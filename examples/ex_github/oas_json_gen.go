// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
)

// Encode implements json.Marshaler.
func (s APIOverview) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"verifiable_password_authentication\"" + ":")
		e.Bool(s.VerifiablePasswordAuthentication)
	}
	{
		if s.SSHKeyFingerprints.Set {
			e.Comma()
		}
		if s.SSHKeyFingerprints.Set {
			e.RawStr("\"ssh_key_fingerprints\"" + ":")
			s.SSHKeyFingerprints.Encode(e)
		}
	}
	{
		if s.Hooks != nil {
			e.Comma()
		}
		if s.Hooks != nil {
			e.RawStr("\"hooks\"" + ":")
			e.ArrStart()
			if len(s.Hooks) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Hooks[0]
					e.Str(elem)
				}
				for _, elem := range s.Hooks[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Web != nil {
			e.Comma()
		}
		if s.Web != nil {
			e.RawStr("\"web\"" + ":")
			e.ArrStart()
			if len(s.Web) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Web[0]
					e.Str(elem)
				}
				for _, elem := range s.Web[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.API != nil {
			e.Comma()
		}
		if s.API != nil {
			e.RawStr("\"api\"" + ":")
			e.ArrStart()
			if len(s.API) >= 1 {
				// Encode first element without comma.
				{
					elem := s.API[0]
					e.Str(elem)
				}
				for _, elem := range s.API[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Git != nil {
			e.Comma()
		}
		if s.Git != nil {
			e.RawStr("\"git\"" + ":")
			e.ArrStart()
			if len(s.Git) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Git[0]
					e.Str(elem)
				}
				for _, elem := range s.Git[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Packages != nil {
			e.Comma()
		}
		if s.Packages != nil {
			e.RawStr("\"packages\"" + ":")
			e.ArrStart()
			if len(s.Packages) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Packages[0]
					e.Str(elem)
				}
				for _, elem := range s.Packages[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Pages != nil {
			e.Comma()
		}
		if s.Pages != nil {
			e.RawStr("\"pages\"" + ":")
			e.ArrStart()
			if len(s.Pages) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Pages[0]
					e.Str(elem)
				}
				for _, elem := range s.Pages[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Importer != nil {
			e.Comma()
		}
		if s.Importer != nil {
			e.RawStr("\"importer\"" + ":")
			e.ArrStart()
			if len(s.Importer) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Importer[0]
					e.Str(elem)
				}
				for _, elem := range s.Importer[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Actions != nil {
			e.Comma()
		}
		if s.Actions != nil {
			e.RawStr("\"actions\"" + ":")
			e.ArrStart()
			if len(s.Actions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Actions[0]
					e.Str(elem)
				}
				for _, elem := range s.Actions[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Dependabot != nil {
			e.Comma()
		}
		if s.Dependabot != nil {
			e.RawStr("\"dependabot\"" + ":")
			e.ArrStart()
			if len(s.Dependabot) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Dependabot[0]
					e.Str(elem)
				}
				for _, elem := range s.Dependabot[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes APIOverview from json.
func (s *APIOverview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode APIOverview to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verifiable_password_authentication":
			v, err := d.Bool()
			s.VerifiablePasswordAuthentication = bool(v)
			if err != nil {
				return err
			}
		case "ssh_key_fingerprints":
			s.SSHKeyFingerprints.Reset()
			if err := s.SSHKeyFingerprints.Decode(d); err != nil {
				return err
			}
		case "hooks":
			s.Hooks = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Hooks = append(s.Hooks, elem)
				return nil
			}); err != nil {
				return err
			}
		case "web":
			s.Web = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Web = append(s.Web, elem)
				return nil
			}); err != nil {
				return err
			}
		case "api":
			s.API = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.API = append(s.API, elem)
				return nil
			}); err != nil {
				return err
			}
		case "git":
			s.Git = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Git = append(s.Git, elem)
				return nil
			}); err != nil {
				return err
			}
		case "packages":
			s.Packages = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Packages = append(s.Packages, elem)
				return nil
			}); err != nil {
				return err
			}
		case "pages":
			s.Pages = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Pages = append(s.Pages, elem)
				return nil
			}); err != nil {
				return err
			}
		case "importer":
			s.Importer = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Importer = append(s.Importer, elem)
				return nil
			}); err != nil {
				return err
			}
		case "actions":
			s.Actions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Actions = append(s.Actions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "dependabot":
			s.Dependabot = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Dependabot = append(s.Dependabot, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s APIOverviewSSHKeyFingerprints) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.SHA256RSA.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SHA256RSA.Set {
			e.RawStr("\"SHA256_RSA\"" + ":")
			s.SHA256RSA.Encode(e)
		}
	}
	{
		if s.SHA256DSA.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SHA256DSA.Set {
			e.RawStr("\"SHA256_DSA\"" + ":")
			s.SHA256DSA.Encode(e)
		}
	}
	{
		if s.SHA256ECDSA.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SHA256ECDSA.Set {
			e.RawStr("\"SHA256_ECDSA\"" + ":")
			s.SHA256ECDSA.Encode(e)
		}
	}
	{
		if s.SHA256ED25519.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SHA256ED25519.Set {
			e.RawStr("\"SHA256_ED25519\"" + ":")
			s.SHA256ED25519.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes APIOverviewSSHKeyFingerprints from json.
func (s *APIOverviewSSHKeyFingerprints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode APIOverviewSSHKeyFingerprints to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "SHA256_RSA":
			s.SHA256RSA.Reset()
			if err := s.SHA256RSA.Decode(d); err != nil {
				return err
			}
		case "SHA256_DSA":
			s.SHA256DSA.Reset()
			if err := s.SHA256DSA.Decode(d); err != nil {
				return err
			}
		case "SHA256_ECDSA":
			s.SHA256ECDSA.Reset()
			if err := s.SHA256ECDSA.Decode(d); err != nil {
				return err
			}
		case "SHA256_ED25519":
			s.SHA256ED25519.Reset()
			if err := s.SHA256ED25519.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Accepted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes Accepted from json.
func (s *Accepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Accepted to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent from json.
func (s *ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsAddSelectedRepoToOrgSecretConflict) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsAddSelectedRepoToOrgSecretConflict from json.
func (s *ActionsAddSelectedRepoToOrgSecretConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsAddSelectedRepoToOrgSecretConflict to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsAddSelectedRepoToOrgSecretNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsAddSelectedRepoToOrgSecretNoContent from json.
func (s *ActionsAddSelectedRepoToOrgSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsAddSelectedRepoToOrgSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsAddSelfHostedRunnerToGroupForOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsAddSelfHostedRunnerToGroupForOrgNoContent from json.
func (s *ActionsAddSelfHostedRunnerToGroupForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsAddSelfHostedRunnerToGroupForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsApproveWorkflowRunApplicationJSONForbidden as json.
func (s ActionsApproveWorkflowRunApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActionsApproveWorkflowRunApplicationJSONForbidden from json.
func (s *ActionsApproveWorkflowRunApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsApproveWorkflowRunApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActionsApproveWorkflowRunApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActionsApproveWorkflowRunApplicationJSONNotFound as json.
func (s ActionsApproveWorkflowRunApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActionsApproveWorkflowRunApplicationJSONNotFound from json.
func (s *ActionsApproveWorkflowRunApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsApproveWorkflowRunApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActionsApproveWorkflowRunApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsBillingUsage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_minutes_used\"" + ":")
		e.Int(s.TotalMinutesUsed)
	}
	{
		e.Comma()

		e.RawStr("\"total_paid_minutes_used\"" + ":")
		e.Int(s.TotalPaidMinutesUsed)
	}
	{
		e.Comma()

		e.RawStr("\"included_minutes\"" + ":")
		e.Int(s.IncludedMinutes)
	}
	{
		e.Comma()

		e.RawStr("\"minutes_used_breakdown\"" + ":")
		s.MinutesUsedBreakdown.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ActionsBillingUsage from json.
func (s *ActionsBillingUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsBillingUsage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_minutes_used":
			v, err := d.Int()
			s.TotalMinutesUsed = int(v)
			if err != nil {
				return err
			}
		case "total_paid_minutes_used":
			v, err := d.Int()
			s.TotalPaidMinutesUsed = int(v)
			if err != nil {
				return err
			}
		case "included_minutes":
			v, err := d.Int()
			s.IncludedMinutes = int(v)
			if err != nil {
				return err
			}
		case "minutes_used_breakdown":
			if err := s.MinutesUsedBreakdown.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsBillingUsageMinutesUsedBreakdown) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.UBUNTU.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UBUNTU.Set {
			e.RawStr("\"UBUNTU\"" + ":")
			s.UBUNTU.Encode(e)
		}
	}
	{
		if s.MACOS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MACOS.Set {
			e.RawStr("\"MACOS\"" + ":")
			s.MACOS.Encode(e)
		}
	}
	{
		if s.WINDOWS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.WINDOWS.Set {
			e.RawStr("\"WINDOWS\"" + ":")
			s.WINDOWS.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ActionsBillingUsageMinutesUsedBreakdown from json.
func (s *ActionsBillingUsageMinutesUsedBreakdown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsBillingUsageMinutesUsedBreakdown to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "UBUNTU":
			s.UBUNTU.Reset()
			if err := s.UBUNTU.Decode(d); err != nil {
				return err
			}
		case "MACOS":
			s.MACOS.Reset()
			if err := s.MACOS.Decode(d); err != nil {
				return err
			}
		case "WINDOWS":
			s.WINDOWS.Reset()
			if err := s.WINDOWS.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCancelWorkflowRunAccepted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsCancelWorkflowRunAccepted from json.
func (s *ActionsCancelWorkflowRunAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCancelWorkflowRunAccepted to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateEnvironmentSecretNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsCreateOrUpdateEnvironmentSecretNoContent from json.
func (s *ActionsCreateOrUpdateEnvironmentSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateEnvironmentSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateEnvironmentSecretReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"encrypted_value\"" + ":")
		e.Str(s.EncryptedValue)
	}
	{
		e.Comma()

		e.RawStr("\"key_id\"" + ":")
		e.Str(s.KeyID)
	}
	e.ObjEnd()
}

// Decode decodes ActionsCreateOrUpdateEnvironmentSecretReq from json.
func (s *ActionsCreateOrUpdateEnvironmentSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateEnvironmentSecretReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encrypted_value":
			v, err := d.Str()
			s.EncryptedValue = string(v)
			if err != nil {
				return err
			}
		case "key_id":
			v, err := d.Str()
			s.KeyID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateOrgSecretNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsCreateOrUpdateOrgSecretNoContent from json.
func (s *ActionsCreateOrUpdateOrgSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateOrgSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateOrgSecretReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.EncryptedValue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EncryptedValue.Set {
			e.RawStr("\"encrypted_value\"" + ":")
			s.EncryptedValue.Encode(e)
		}
	}
	{
		if s.KeyID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.KeyID.Set {
			e.RawStr("\"key_id\"" + ":")
			s.KeyID.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"visibility\"" + ":")
		s.Visibility.Encode(e)
	}
	{
		if s.SelectedRepositoryIds != nil {
			e.Comma()
		}
		if s.SelectedRepositoryIds != nil {
			e.RawStr("\"selected_repository_ids\"" + ":")
			e.ArrStart()
			if len(s.SelectedRepositoryIds) >= 1 {
				// Encode first element without comma.
				{
					elem := s.SelectedRepositoryIds[0]
					e.Str(elem)
				}
				for _, elem := range s.SelectedRepositoryIds[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ActionsCreateOrUpdateOrgSecretReq from json.
func (s *ActionsCreateOrUpdateOrgSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateOrgSecretReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encrypted_value":
			s.EncryptedValue.Reset()
			if err := s.EncryptedValue.Decode(d); err != nil {
				return err
			}
		case "key_id":
			s.KeyID.Reset()
			if err := s.KeyID.Decode(d); err != nil {
				return err
			}
		case "visibility":
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "selected_repository_ids":
			s.SelectedRepositoryIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsCreateOrUpdateOrgSecretReqVisibility as json.
func (s ActionsCreateOrUpdateOrgSecretReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ActionsCreateOrUpdateOrgSecretReqVisibility from json.
func (s *ActionsCreateOrUpdateOrgSecretReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateOrgSecretReqVisibility to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionsCreateOrUpdateOrgSecretReqVisibility(v) {
	case ActionsCreateOrUpdateOrgSecretReqVisibilityAll:
		*s = ActionsCreateOrUpdateOrgSecretReqVisibilityAll
	case ActionsCreateOrUpdateOrgSecretReqVisibilityPrivate:
		*s = ActionsCreateOrUpdateOrgSecretReqVisibilityPrivate
	case ActionsCreateOrUpdateOrgSecretReqVisibilitySelected:
		*s = ActionsCreateOrUpdateOrgSecretReqVisibilitySelected
	default:
		*s = ActionsCreateOrUpdateOrgSecretReqVisibility(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateRepoSecretCreated) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsCreateOrUpdateRepoSecretCreated from json.
func (s *ActionsCreateOrUpdateRepoSecretCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateRepoSecretCreated to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateRepoSecretNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsCreateOrUpdateRepoSecretNoContent from json.
func (s *ActionsCreateOrUpdateRepoSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateRepoSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateRepoSecretReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.EncryptedValue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EncryptedValue.Set {
			e.RawStr("\"encrypted_value\"" + ":")
			s.EncryptedValue.Encode(e)
		}
	}
	{
		if s.KeyID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.KeyID.Set {
			e.RawStr("\"key_id\"" + ":")
			s.KeyID.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ActionsCreateOrUpdateRepoSecretReq from json.
func (s *ActionsCreateOrUpdateRepoSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateRepoSecretReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encrypted_value":
			s.EncryptedValue.Reset()
			if err := s.EncryptedValue.Decode(d); err != nil {
				return err
			}
		case "key_id":
			s.KeyID.Reset()
			if err := s.KeyID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCreateSelfHostedRunnerGroupForOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.SelectedRepositoryIds != nil {
			e.Comma()
		}
		if s.SelectedRepositoryIds != nil {
			e.RawStr("\"selected_repository_ids\"" + ":")
			e.ArrStart()
			if len(s.SelectedRepositoryIds) >= 1 {
				// Encode first element without comma.
				{
					elem := s.SelectedRepositoryIds[0]
					e.Int(elem)
				}
				for _, elem := range s.SelectedRepositoryIds[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Runners != nil {
			e.Comma()
		}
		if s.Runners != nil {
			e.RawStr("\"runners\"" + ":")
			e.ArrStart()
			if len(s.Runners) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Runners[0]
					e.Int(elem)
				}
				for _, elem := range s.Runners[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ActionsCreateSelfHostedRunnerGroupForOrgReq from json.
func (s *ActionsCreateSelfHostedRunnerGroupForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateSelfHostedRunnerGroupForOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "selected_repository_ids":
			s.SelectedRepositoryIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
				return nil
			}); err != nil {
				return err
			}
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (s ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (s *ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility(v) {
	case ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilitySelected:
		*s = ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilitySelected
	case ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilityAll:
		*s = ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilityAll
	case ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilityPrivate:
		*s = ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilityPrivate
	default:
		*s = ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility(v)
	}

	return nil
}

// Encode encodes ActionsCreateWorkflowDispatchWorkflowID as json.
func (s ActionsCreateWorkflowDispatchWorkflowID) Encode(e *jx.Writer) {
	switch s.Type {
	case IntActionsCreateWorkflowDispatchWorkflowID:
		e.Int(s.Int)
	case StringActionsCreateWorkflowDispatchWorkflowID:
		e.Str(s.String)
	}
}

// Decode decodes ActionsCreateWorkflowDispatchWorkflowID from json.
func (s *ActionsCreateWorkflowDispatchWorkflowID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateWorkflowDispatchWorkflowID to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntActionsCreateWorkflowDispatchWorkflowID
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringActionsCreateWorkflowDispatchWorkflowID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsDeleteArtifactNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsDeleteArtifactNoContent from json.
func (s *ActionsDeleteArtifactNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteArtifactNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteEnvironmentSecretNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsDeleteEnvironmentSecretNoContent from json.
func (s *ActionsDeleteEnvironmentSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteEnvironmentSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteOrgSecretNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsDeleteOrgSecretNoContent from json.
func (s *ActionsDeleteOrgSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteOrgSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteRepoSecretNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsDeleteRepoSecretNoContent from json.
func (s *ActionsDeleteRepoSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteRepoSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteSelfHostedRunnerFromOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsDeleteSelfHostedRunnerFromOrgNoContent from json.
func (s *ActionsDeleteSelfHostedRunnerFromOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteSelfHostedRunnerFromOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteSelfHostedRunnerFromRepoNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsDeleteSelfHostedRunnerFromRepoNoContent from json.
func (s *ActionsDeleteSelfHostedRunnerFromRepoNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteSelfHostedRunnerFromRepoNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent from json.
func (s *ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteWorkflowRunLogsNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsDeleteWorkflowRunLogsNoContent from json.
func (s *ActionsDeleteWorkflowRunLogsNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteWorkflowRunLogsNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteWorkflowRunNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsDeleteWorkflowRunNoContent from json.
func (s *ActionsDeleteWorkflowRunNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteWorkflowRunNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent from json.
func (s *ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsDisableWorkflowWorkflowID as json.
func (s ActionsDisableWorkflowWorkflowID) Encode(e *jx.Writer) {
	switch s.Type {
	case IntActionsDisableWorkflowWorkflowID:
		e.Int(s.Int)
	case StringActionsDisableWorkflowWorkflowID:
		e.Str(s.String)
	}
}

// Decode decodes ActionsDisableWorkflowWorkflowID from json.
func (s *ActionsDisableWorkflowWorkflowID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDisableWorkflowWorkflowID to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntActionsDisableWorkflowWorkflowID
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringActionsDisableWorkflowWorkflowID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsDownloadArtifactFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsDownloadArtifactFound from json.
func (s *ActionsDownloadArtifactFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDownloadArtifactFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDownloadJobLogsForWorkflowRunFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsDownloadJobLogsForWorkflowRunFound from json.
func (s *ActionsDownloadJobLogsForWorkflowRunFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDownloadJobLogsForWorkflowRunFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDownloadWorkflowRunLogsFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsDownloadWorkflowRunLogsFound from json.
func (s *ActionsDownloadWorkflowRunLogsFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDownloadWorkflowRunLogsFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent from json.
func (s *ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsEnableWorkflowWorkflowID as json.
func (s ActionsEnableWorkflowWorkflowID) Encode(e *jx.Writer) {
	switch s.Type {
	case IntActionsEnableWorkflowWorkflowID:
		e.Int(s.Int)
	case StringActionsEnableWorkflowWorkflowID:
		e.Str(s.String)
	}
}

// Decode decodes ActionsEnableWorkflowWorkflowID from json.
func (s *ActionsEnableWorkflowWorkflowID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsEnableWorkflowWorkflowID to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntActionsEnableWorkflowWorkflowID
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringActionsEnableWorkflowWorkflowID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode encodes ActionsEnabled as json.
func (s ActionsEnabled) Encode(e *jx.Writer) {
	unwrapped := bool(s)
	e.Bool(unwrapped)
}

// Decode decodes ActionsEnabled from json.
func (s *ActionsEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsEnabled to nil`)
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActionsEnabled(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsEnterprisePermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled_organizations\"" + ":")
		s.EnabledOrganizations.Encode(e)
	}
	{
		if s.SelectedOrganizationsURL.Set {
			e.Comma()
		}
		if s.SelectedOrganizationsURL.Set {
			e.RawStr("\"selected_organizations_url\"" + ":")
			s.SelectedOrganizationsURL.Encode(e)
		}
	}
	{
		if s.AllowedActions.Set {
			e.Comma()
		}
		if s.AllowedActions.Set {
			e.RawStr("\"allowed_actions\"" + ":")
			s.AllowedActions.Encode(e)
		}
	}
	{
		if s.SelectedActionsURL.Set {
			e.Comma()
		}
		if s.SelectedActionsURL.Set {
			e.RawStr("\"selected_actions_url\"" + ":")
			s.SelectedActionsURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ActionsEnterprisePermissions from json.
func (s *ActionsEnterprisePermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsEnterprisePermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_organizations":
			if err := s.EnabledOrganizations.Decode(d); err != nil {
				return err
			}
		case "selected_organizations_url":
			s.SelectedOrganizationsURL.Reset()
			if err := s.SelectedOrganizationsURL.Decode(d); err != nil {
				return err
			}
		case "allowed_actions":
			s.AllowedActions.Reset()
			if err := s.AllowedActions.Decode(d); err != nil {
				return err
			}
		case "selected_actions_url":
			s.SelectedActionsURL.Reset()
			if err := s.SelectedActionsURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsGetWorkflowUsageWorkflowID as json.
func (s ActionsGetWorkflowUsageWorkflowID) Encode(e *jx.Writer) {
	switch s.Type {
	case IntActionsGetWorkflowUsageWorkflowID:
		e.Int(s.Int)
	case StringActionsGetWorkflowUsageWorkflowID:
		e.Str(s.String)
	}
}

// Decode decodes ActionsGetWorkflowUsageWorkflowID from json.
func (s *ActionsGetWorkflowUsageWorkflowID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsGetWorkflowUsageWorkflowID to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntActionsGetWorkflowUsageWorkflowID
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringActionsGetWorkflowUsageWorkflowID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode encodes ActionsGetWorkflowWorkflowID as json.
func (s ActionsGetWorkflowWorkflowID) Encode(e *jx.Writer) {
	switch s.Type {
	case IntActionsGetWorkflowWorkflowID:
		e.Int(s.Int)
	case StringActionsGetWorkflowWorkflowID:
		e.Str(s.String)
	}
}

// Decode decodes ActionsGetWorkflowWorkflowID from json.
func (s *ActionsGetWorkflowWorkflowID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsGetWorkflowWorkflowID to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntActionsGetWorkflowWorkflowID
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringActionsGetWorkflowWorkflowID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListArtifactsForRepoOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"artifacts\"" + ":")
		e.ArrStart()
		if len(s.Artifacts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Artifacts[0]
				elem.Encode(e)
			}
			for _, elem := range s.Artifacts[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsListArtifactsForRepoOK from json.
func (s *ActionsListArtifactsForRepoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListArtifactsForRepoOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "artifacts":
			s.Artifacts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Artifact
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Artifacts = append(s.Artifacts, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListEnvironmentSecretsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"secrets\"" + ":")
		e.ArrStart()
		if len(s.Secrets) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Secrets[0]
				elem.Encode(e)
			}
			for _, elem := range s.Secrets[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsListEnvironmentSecretsOK from json.
func (s *ActionsListEnvironmentSecretsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListEnvironmentSecretsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "secrets":
			s.Secrets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ActionsSecret
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Secrets = append(s.Secrets, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsListJobsForWorkflowRunFilter as json.
func (s ActionsListJobsForWorkflowRunFilter) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ActionsListJobsForWorkflowRunFilter from json.
func (s *ActionsListJobsForWorkflowRunFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListJobsForWorkflowRunFilter to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionsListJobsForWorkflowRunFilter(v) {
	case ActionsListJobsForWorkflowRunFilterLatest:
		*s = ActionsListJobsForWorkflowRunFilterLatest
	case ActionsListJobsForWorkflowRunFilterAll:
		*s = ActionsListJobsForWorkflowRunFilterAll
	default:
		*s = ActionsListJobsForWorkflowRunFilter(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListJobsForWorkflowRunOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"jobs\"" + ":")
		e.ArrStart()
		if len(s.Jobs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Jobs[0]
				elem.Encode(e)
			}
			for _, elem := range s.Jobs[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsListJobsForWorkflowRunOK from json.
func (s *ActionsListJobsForWorkflowRunOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListJobsForWorkflowRunOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "jobs":
			s.Jobs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Job
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Jobs = append(s.Jobs, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListOrgSecretsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"secrets\"" + ":")
		e.ArrStart()
		if len(s.Secrets) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Secrets[0]
				elem.Encode(e)
			}
			for _, elem := range s.Secrets[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsListOrgSecretsOK from json.
func (s *ActionsListOrgSecretsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListOrgSecretsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "secrets":
			s.Secrets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem OrganizationActionsSecret
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Secrets = append(s.Secrets, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				elem.Encode(e)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK from json.
func (s *ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MinimalRepository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListRepoSecretsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"secrets\"" + ":")
		e.ArrStart()
		if len(s.Secrets) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Secrets[0]
				elem.Encode(e)
			}
			for _, elem := range s.Secrets[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsListRepoSecretsOK from json.
func (s *ActionsListRepoSecretsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListRepoSecretsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "secrets":
			s.Secrets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ActionsSecret
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Secrets = append(s.Secrets, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListRepoWorkflowsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"workflows\"" + ":")
		e.ArrStart()
		if len(s.Workflows) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Workflows[0]
				elem.Encode(e)
			}
			for _, elem := range s.Workflows[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsListRepoWorkflowsOK from json.
func (s *ActionsListRepoWorkflowsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListRepoWorkflowsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "workflows":
			s.Workflows = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Workflow
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Workflows = append(s.Workflows, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListSelectedReposForOrgSecretOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				elem.Encode(e)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsListSelectedReposForOrgSecretOK from json.
func (s *ActionsListSelectedReposForOrgSecretOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListSelectedReposForOrgSecretOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MinimalRepository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				elem.Encode(e)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK from json.
func (s *ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Repository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListSelfHostedRunnerGroupsForOrgOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"runner_groups\"" + ":")
		e.ArrStart()
		if len(s.RunnerGroups) >= 1 {
			// Encode first element without comma.
			{
				elem := s.RunnerGroups[0]
				elem.Encode(e)
			}
			for _, elem := range s.RunnerGroups[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsListSelfHostedRunnerGroupsForOrgOK from json.
func (s *ActionsListSelfHostedRunnerGroupsForOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListSelfHostedRunnerGroupsForOrgOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "runner_groups":
			s.RunnerGroups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem RunnerGroupsOrg
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.RunnerGroups = append(s.RunnerGroups, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListSelfHostedRunnersForOrgOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"runners\"" + ":")
		e.ArrStart()
		if len(s.Runners) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Runners[0]
				elem.Encode(e)
			}
			for _, elem := range s.Runners[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsListSelfHostedRunnersForOrgOK from json.
func (s *ActionsListSelfHostedRunnersForOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListSelfHostedRunnersForOrgOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Runner
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListSelfHostedRunnersForRepoOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"runners\"" + ":")
		e.ArrStart()
		if len(s.Runners) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Runners[0]
				elem.Encode(e)
			}
			for _, elem := range s.Runners[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsListSelfHostedRunnersForRepoOK from json.
func (s *ActionsListSelfHostedRunnersForRepoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListSelfHostedRunnersForRepoOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Runner
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListSelfHostedRunnersInGroupForOrgOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"runners\"" + ":")
		e.ArrStart()
		if len(s.Runners) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Runners[0]
				elem.Encode(e)
			}
			for _, elem := range s.Runners[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsListSelfHostedRunnersInGroupForOrgOK from json.
func (s *ActionsListSelfHostedRunnersInGroupForOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListSelfHostedRunnersInGroupForOrgOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Runner
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListWorkflowRunArtifactsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"artifacts\"" + ":")
		e.ArrStart()
		if len(s.Artifacts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Artifacts[0]
				elem.Encode(e)
			}
			for _, elem := range s.Artifacts[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsListWorkflowRunArtifactsOK from json.
func (s *ActionsListWorkflowRunArtifactsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListWorkflowRunArtifactsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "artifacts":
			s.Artifacts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Artifact
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Artifacts = append(s.Artifacts, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListWorkflowRunsForRepoOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"workflow_runs\"" + ":")
		e.ArrStart()
		if len(s.WorkflowRuns) >= 1 {
			// Encode first element without comma.
			{
				elem := s.WorkflowRuns[0]
				elem.Encode(e)
			}
			for _, elem := range s.WorkflowRuns[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsListWorkflowRunsForRepoOK from json.
func (s *ActionsListWorkflowRunsForRepoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListWorkflowRunsForRepoOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "workflow_runs":
			s.WorkflowRuns = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem WorkflowRun
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.WorkflowRuns = append(s.WorkflowRuns, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsListWorkflowRunsForRepoStatus as json.
func (s ActionsListWorkflowRunsForRepoStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ActionsListWorkflowRunsForRepoStatus from json.
func (s *ActionsListWorkflowRunsForRepoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListWorkflowRunsForRepoStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionsListWorkflowRunsForRepoStatus(v) {
	case ActionsListWorkflowRunsForRepoStatusCompleted:
		*s = ActionsListWorkflowRunsForRepoStatusCompleted
	case ActionsListWorkflowRunsForRepoStatusActionRequired:
		*s = ActionsListWorkflowRunsForRepoStatusActionRequired
	case ActionsListWorkflowRunsForRepoStatusCancelled:
		*s = ActionsListWorkflowRunsForRepoStatusCancelled
	case ActionsListWorkflowRunsForRepoStatusFailure:
		*s = ActionsListWorkflowRunsForRepoStatusFailure
	case ActionsListWorkflowRunsForRepoStatusNeutral:
		*s = ActionsListWorkflowRunsForRepoStatusNeutral
	case ActionsListWorkflowRunsForRepoStatusSkipped:
		*s = ActionsListWorkflowRunsForRepoStatusSkipped
	case ActionsListWorkflowRunsForRepoStatusStale:
		*s = ActionsListWorkflowRunsForRepoStatusStale
	case ActionsListWorkflowRunsForRepoStatusSuccess:
		*s = ActionsListWorkflowRunsForRepoStatusSuccess
	case ActionsListWorkflowRunsForRepoStatusTimedOut:
		*s = ActionsListWorkflowRunsForRepoStatusTimedOut
	case ActionsListWorkflowRunsForRepoStatusInProgress:
		*s = ActionsListWorkflowRunsForRepoStatusInProgress
	case ActionsListWorkflowRunsForRepoStatusQueued:
		*s = ActionsListWorkflowRunsForRepoStatusQueued
	case ActionsListWorkflowRunsForRepoStatusRequested:
		*s = ActionsListWorkflowRunsForRepoStatusRequested
	case ActionsListWorkflowRunsForRepoStatusWaiting:
		*s = ActionsListWorkflowRunsForRepoStatusWaiting
	default:
		*s = ActionsListWorkflowRunsForRepoStatus(v)
	}

	return nil
}

// Encode encodes ActionsListWorkflowRunsWorkflowID as json.
func (s ActionsListWorkflowRunsWorkflowID) Encode(e *jx.Writer) {
	switch s.Type {
	case IntActionsListWorkflowRunsWorkflowID:
		e.Int(s.Int)
	case StringActionsListWorkflowRunsWorkflowID:
		e.Str(s.String)
	}
}

// Decode decodes ActionsListWorkflowRunsWorkflowID from json.
func (s *ActionsListWorkflowRunsWorkflowID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListWorkflowRunsWorkflowID to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntActionsListWorkflowRunsWorkflowID
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringActionsListWorkflowRunsWorkflowID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsOrganizationPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled_repositories\"" + ":")
		s.EnabledRepositories.Encode(e)
	}
	{
		if s.SelectedRepositoriesURL.Set {
			e.Comma()
		}
		if s.SelectedRepositoriesURL.Set {
			e.RawStr("\"selected_repositories_url\"" + ":")
			s.SelectedRepositoriesURL.Encode(e)
		}
	}
	{
		if s.AllowedActions.Set {
			e.Comma()
		}
		if s.AllowedActions.Set {
			e.RawStr("\"allowed_actions\"" + ":")
			s.AllowedActions.Encode(e)
		}
	}
	{
		if s.SelectedActionsURL.Set {
			e.Comma()
		}
		if s.SelectedActionsURL.Set {
			e.RawStr("\"selected_actions_url\"" + ":")
			s.SelectedActionsURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ActionsOrganizationPermissions from json.
func (s *ActionsOrganizationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsOrganizationPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_repositories":
			if err := s.EnabledRepositories.Decode(d); err != nil {
				return err
			}
		case "selected_repositories_url":
			s.SelectedRepositoriesURL.Reset()
			if err := s.SelectedRepositoriesURL.Decode(d); err != nil {
				return err
			}
		case "allowed_actions":
			s.AllowedActions.Reset()
			if err := s.AllowedActions.Decode(d); err != nil {
				return err
			}
		case "selected_actions_url":
			s.SelectedActionsURL.Reset()
			if err := s.SelectedActionsURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsPublicKey) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key_id\"" + ":")
		e.Str(s.KeyID)
	}
	{
		e.Comma()

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		if s.ID.Set {
			e.Comma()
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.Comma()
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.Comma()
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.Comma()
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ActionsPublicKey from json.
func (s *ActionsPublicKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsPublicKey to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key_id":
			v, err := d.Str()
			s.KeyID = string(v)
			if err != nil {
				return err
			}
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsReRunWorkflowCreated) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsReRunWorkflowCreated from json.
func (s *ActionsReRunWorkflowCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsReRunWorkflowCreated to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent from json.
func (s *ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsRemoveSelectedRepoFromOrgSecretConflict) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsRemoveSelectedRepoFromOrgSecretConflict from json.
func (s *ActionsRemoveSelectedRepoFromOrgSecretConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsRemoveSelectedRepoFromOrgSecretConflict to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsRemoveSelectedRepoFromOrgSecretNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsRemoveSelectedRepoFromOrgSecretNoContent from json.
func (s *ActionsRemoveSelectedRepoFromOrgSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsRemoveSelectedRepoFromOrgSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent from json.
func (s *ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled\"" + ":")
		s.Enabled.Encode(e)
	}
	{
		if s.AllowedActions.Set {
			e.Comma()
		}
		if s.AllowedActions.Set {
			e.RawStr("\"allowed_actions\"" + ":")
			s.AllowedActions.Encode(e)
		}
	}
	{
		if s.SelectedActionsURL.Set {
			e.Comma()
		}
		if s.SelectedActionsURL.Set {
			e.RawStr("\"selected_actions_url\"" + ":")
			s.SelectedActionsURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ActionsRepositoryPermissions from json.
func (s *ActionsRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			{
				var unwrapped bool
				v, err := d.Bool()
				unwrapped = bool(v)
				if err != nil {
					return err
				}
				s.Enabled = ActionsEnabled(unwrapped)
			}
		case "allowed_actions":
			s.AllowedActions.Reset()
			if err := s.AllowedActions.Decode(d); err != nil {
				return err
			}
		case "selected_actions_url":
			s.SelectedActionsURL.Reset()
			if err := s.SelectedActionsURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsRetryWorkflowCreated) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsRetryWorkflowCreated from json.
func (s *ActionsRetryWorkflowCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsRetryWorkflowCreated to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsReviewPendingDeploymentsForRunReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"environment_ids\"" + ":")
		e.ArrStart()
		if len(s.EnvironmentIds) >= 1 {
			// Encode first element without comma.
			{
				elem := s.EnvironmentIds[0]
				e.Int(elem)
			}
			for _, elem := range s.EnvironmentIds[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comment\"" + ":")
		e.Str(s.Comment)
	}
	e.ObjEnd()
}

// Decode decodes ActionsReviewPendingDeploymentsForRunReq from json.
func (s *ActionsReviewPendingDeploymentsForRunReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsReviewPendingDeploymentsForRunReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "environment_ids":
			s.EnvironmentIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.EnvironmentIds = append(s.EnvironmentIds, elem)
				return nil
			}); err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "comment":
			v, err := d.Str()
			s.Comment = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsReviewPendingDeploymentsForRunReqState as json.
func (s ActionsReviewPendingDeploymentsForRunReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ActionsReviewPendingDeploymentsForRunReqState from json.
func (s *ActionsReviewPendingDeploymentsForRunReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsReviewPendingDeploymentsForRunReqState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionsReviewPendingDeploymentsForRunReqState(v) {
	case ActionsReviewPendingDeploymentsForRunReqStateApproved:
		*s = ActionsReviewPendingDeploymentsForRunReqStateApproved
	case ActionsReviewPendingDeploymentsForRunReqStateRejected:
		*s = ActionsReviewPendingDeploymentsForRunReqStateRejected
	default:
		*s = ActionsReviewPendingDeploymentsForRunReqState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsSecret) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	e.ObjEnd()
}

// Decode decodes ActionsSecret from json.
func (s *ActionsSecret) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSecret to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetAllowedActionsOrganizationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsSetAllowedActionsOrganizationNoContent from json.
func (s *ActionsSetAllowedActionsOrganizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetAllowedActionsOrganizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetAllowedActionsRepositoryNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsSetAllowedActionsRepositoryNoContent from json.
func (s *ActionsSetAllowedActionsRepositoryNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetAllowedActionsRepositoryNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetGithubActionsPermissionsOrganizationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsSetGithubActionsPermissionsOrganizationNoContent from json.
func (s *ActionsSetGithubActionsPermissionsOrganizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetGithubActionsPermissionsOrganizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetGithubActionsPermissionsOrganizationReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled_repositories\"" + ":")
		s.EnabledRepositories.Encode(e)
	}
	{
		if s.AllowedActions.Set {
			e.Comma()
		}
		if s.AllowedActions.Set {
			e.RawStr("\"allowed_actions\"" + ":")
			s.AllowedActions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ActionsSetGithubActionsPermissionsOrganizationReq from json.
func (s *ActionsSetGithubActionsPermissionsOrganizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetGithubActionsPermissionsOrganizationReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_repositories":
			if err := s.EnabledRepositories.Decode(d); err != nil {
				return err
			}
		case "allowed_actions":
			s.AllowedActions.Reset()
			if err := s.AllowedActions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetGithubActionsPermissionsRepositoryNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsSetGithubActionsPermissionsRepositoryNoContent from json.
func (s *ActionsSetGithubActionsPermissionsRepositoryNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetGithubActionsPermissionsRepositoryNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetGithubActionsPermissionsRepositoryReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled\"" + ":")
		s.Enabled.Encode(e)
	}
	{
		if s.AllowedActions.Set {
			e.Comma()
		}
		if s.AllowedActions.Set {
			e.RawStr("\"allowed_actions\"" + ":")
			s.AllowedActions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ActionsSetGithubActionsPermissionsRepositoryReq from json.
func (s *ActionsSetGithubActionsPermissionsRepositoryReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetGithubActionsPermissionsRepositoryReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			{
				var unwrapped bool
				v, err := d.Bool()
				unwrapped = bool(v)
				if err != nil {
					return err
				}
				s.Enabled = ActionsEnabled(unwrapped)
			}
		case "allowed_actions":
			s.AllowedActions.Reset()
			if err := s.AllowedActions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent from json.
func (s *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selected_repository_ids\"" + ":")
		e.ArrStart()
		if len(s.SelectedRepositoryIds) >= 1 {
			// Encode first element without comma.
			{
				elem := s.SelectedRepositoryIds[0]
				e.Int(elem)
			}
			for _, elem := range s.SelectedRepositoryIds[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq from json.
func (s *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_repository_ids":
			s.SelectedRepositoryIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetSelectedReposForOrgSecretNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsSetSelectedReposForOrgSecretNoContent from json.
func (s *ActionsSetSelectedReposForOrgSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetSelectedReposForOrgSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetSelectedReposForOrgSecretReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selected_repository_ids\"" + ":")
		e.ArrStart()
		if len(s.SelectedRepositoryIds) >= 1 {
			// Encode first element without comma.
			{
				elem := s.SelectedRepositoryIds[0]
				e.Int(elem)
			}
			for _, elem := range s.SelectedRepositoryIds[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsSetSelectedReposForOrgSecretReq from json.
func (s *ActionsSetSelectedReposForOrgSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetSelectedReposForOrgSecretReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_repository_ids":
			s.SelectedRepositoryIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent from json.
func (s *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selected_repository_ids\"" + ":")
		e.ArrStart()
		if len(s.SelectedRepositoryIds) >= 1 {
			// Encode first element without comma.
			{
				elem := s.SelectedRepositoryIds[0]
				e.Int(elem)
			}
			for _, elem := range s.SelectedRepositoryIds[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq from json.
func (s *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_repository_ids":
			s.SelectedRepositoryIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetSelfHostedRunnersInGroupForOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActionsSetSelfHostedRunnersInGroupForOrgNoContent from json.
func (s *ActionsSetSelfHostedRunnersInGroupForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetSelfHostedRunnersInGroupForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetSelfHostedRunnersInGroupForOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"runners\"" + ":")
		e.ArrStart()
		if len(s.Runners) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Runners[0]
				e.Int(elem)
			}
			for _, elem := range s.Runners[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsSetSelfHostedRunnersInGroupForOrgReq from json.
func (s *ActionsSetSelfHostedRunnersInGroupForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetSelfHostedRunnersInGroupForOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsUpdateSelfHostedRunnerGroupForOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ActionsUpdateSelfHostedRunnerGroupForOrgReq from json.
func (s *ActionsUpdateSelfHostedRunnerGroupForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsUpdateSelfHostedRunnerGroupForOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (s ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (s *ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility(v) {
	case ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilitySelected:
		*s = ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilitySelected
	case ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilityAll:
		*s = ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilityAll
	case ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilityPrivate:
		*s = ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilityPrivate
	default:
		*s = ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility(v)
	}

	return nil
}

// Encode encodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound as json.
func (s ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound from json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivityCheckRepoIsStarredByAuthenticatedUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActivityCheckRepoIsStarredByAuthenticatedUserNoContent from json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityCheckRepoIsStarredByAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivityDeleteRepoSubscriptionNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActivityDeleteRepoSubscriptionNoContent from json.
func (s *ActivityDeleteRepoSubscriptionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityDeleteRepoSubscriptionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActivityDeleteThreadSubscriptionApplicationJSONForbidden as json.
func (s ActivityDeleteThreadSubscriptionApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityDeleteThreadSubscriptionApplicationJSONForbidden from json.
func (s *ActivityDeleteThreadSubscriptionApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityDeleteThreadSubscriptionApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityDeleteThreadSubscriptionApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized as json.
func (s ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized from json.
func (s *ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivityDeleteThreadSubscriptionNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActivityDeleteThreadSubscriptionNoContent from json.
func (s *ActivityDeleteThreadSubscriptionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityDeleteThreadSubscriptionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivityGetRepoSubscriptionNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActivityGetRepoSubscriptionNotFound from json.
func (s *ActivityGetRepoSubscriptionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityGetRepoSubscriptionNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActivityGetThreadApplicationJSONForbidden as json.
func (s ActivityGetThreadApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadApplicationJSONForbidden from json.
func (s *ActivityGetThreadApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityGetThreadApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityGetThreadApplicationJSONUnauthorized as json.
func (s ActivityGetThreadApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadApplicationJSONUnauthorized from json.
func (s *ActivityGetThreadApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityGetThreadApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityListNotificationsForAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityListNotificationsForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListNotificationsForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityListNotificationsForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListNotificationsForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListNotificationsForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityListNotificationsForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityListNotificationsForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListNotificationsForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityListNotificationsForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListNotificationsForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListNotificationsForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityListNotificationsForAuthenticatedUserOKApplicationJSON as json.
func (s ActivityListNotificationsForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Thread(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ActivityListNotificationsForAuthenticatedUserOKApplicationJSON from json.
func (s *ActivityListNotificationsForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListNotificationsForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []Thread
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Thread
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListNotificationsForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden as json.
func (s ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden from json.
func (s *ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently as json.
func (s ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently from json.
func (s *ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently(unwrapped)
	return nil
}

// Encode encodes ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound as json.
func (s ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound from json.
func (s *ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ActivityListPublicEventsForRepoNetworkOKApplicationJSON as json.
func (s ActivityListPublicEventsForRepoNetworkOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Event(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ActivityListPublicEventsForRepoNetworkOKApplicationJSON from json.
func (s *ActivityListPublicEventsForRepoNetworkOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListPublicEventsForRepoNetworkOKApplicationJSON to nil`)
	}
	var unwrapped []Event
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Event
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ActivityListPublicEventsOKApplicationJSON as json.
func (s ActivityListPublicEventsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Event(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ActivityListPublicEventsOKApplicationJSON from json.
func (s *ActivityListPublicEventsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListPublicEventsOKApplicationJSON to nil`)
	}
	var unwrapped []Event
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Event
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserDirection as json.
func (s ActivityListReposStarredByAuthenticatedUserDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserDirection from json.
func (s *ActivityListReposStarredByAuthenticatedUserDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListReposStarredByAuthenticatedUserDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActivityListReposStarredByAuthenticatedUserDirection(v) {
	case ActivityListReposStarredByAuthenticatedUserDirectionAsc:
		*s = ActivityListReposStarredByAuthenticatedUserDirectionAsc
	case ActivityListReposStarredByAuthenticatedUserDirectionDesc:
		*s = ActivityListReposStarredByAuthenticatedUserDirectionDesc
	default:
		*s = ActivityListReposStarredByAuthenticatedUserDirection(v)
	}

	return nil
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserOKApplicationJSON as json.
func (s ActivityListReposStarredByAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Repository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserOKApplicationJSON from json.
func (s *ActivityListReposStarredByAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListReposStarredByAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []Repository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Repository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListReposStarredByAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserSort as json.
func (s ActivityListReposStarredByAuthenticatedUserSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserSort from json.
func (s *ActivityListReposStarredByAuthenticatedUserSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListReposStarredByAuthenticatedUserSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActivityListReposStarredByAuthenticatedUserSort(v) {
	case ActivityListReposStarredByAuthenticatedUserSortCreated:
		*s = ActivityListReposStarredByAuthenticatedUserSortCreated
	case ActivityListReposStarredByAuthenticatedUserSortUpdated:
		*s = ActivityListReposStarredByAuthenticatedUserSortUpdated
	default:
		*s = ActivityListReposStarredByAuthenticatedUserSort(v)
	}

	return nil
}

// Encode encodes ActivityListReposStarredByUserDirection as json.
func (s ActivityListReposStarredByUserDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ActivityListReposStarredByUserDirection from json.
func (s *ActivityListReposStarredByUserDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListReposStarredByUserDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActivityListReposStarredByUserDirection(v) {
	case ActivityListReposStarredByUserDirectionAsc:
		*s = ActivityListReposStarredByUserDirectionAsc
	case ActivityListReposStarredByUserDirectionDesc:
		*s = ActivityListReposStarredByUserDirectionDesc
	default:
		*s = ActivityListReposStarredByUserDirection(v)
	}

	return nil
}

// Encode encodes ActivityListReposStarredByUserSort as json.
func (s ActivityListReposStarredByUserSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ActivityListReposStarredByUserSort from json.
func (s *ActivityListReposStarredByUserSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListReposStarredByUserSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActivityListReposStarredByUserSort(v) {
	case ActivityListReposStarredByUserSortCreated:
		*s = ActivityListReposStarredByUserSortCreated
	case ActivityListReposStarredByUserSortUpdated:
		*s = ActivityListReposStarredByUserSortUpdated
	default:
		*s = ActivityListReposStarredByUserSort(v)
	}

	return nil
}

// Encode encodes ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON as json.
func (s ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON from json.
func (s *ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivityMarkNotificationsAsReadAccepted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ActivityMarkNotificationsAsReadAccepted from json.
func (s *ActivityMarkNotificationsAsReadAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkNotificationsAsReadAccepted to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActivityMarkNotificationsAsReadApplicationJSONForbidden as json.
func (s ActivityMarkNotificationsAsReadApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityMarkNotificationsAsReadApplicationJSONForbidden from json.
func (s *ActivityMarkNotificationsAsReadApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkNotificationsAsReadApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityMarkNotificationsAsReadApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityMarkNotificationsAsReadApplicationJSONUnauthorized as json.
func (s ActivityMarkNotificationsAsReadApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityMarkNotificationsAsReadApplicationJSONUnauthorized from json.
func (s *ActivityMarkNotificationsAsReadApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkNotificationsAsReadApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityMarkNotificationsAsReadApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivityMarkNotificationsAsReadReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastReadAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastReadAt.Set {
			e.RawStr("\"last_read_at\"" + ":")
			s.LastReadAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Read.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Read.Set {
			e.RawStr("\"read\"" + ":")
			s.Read.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ActivityMarkNotificationsAsReadReq from json.
func (s *ActivityMarkNotificationsAsReadReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkNotificationsAsReadReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "last_read_at":
			s.LastReadAt.Reset()
			if err := s.LastReadAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "read":
			s.Read.Reset()
			if err := s.Read.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivityMarkNotificationsAsReadResetContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActivityMarkNotificationsAsReadResetContent from json.
func (s *ActivityMarkNotificationsAsReadResetContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkNotificationsAsReadResetContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivityMarkRepoNotificationsAsReadAccepted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ActivityMarkRepoNotificationsAsReadAccepted from json.
func (s *ActivityMarkRepoNotificationsAsReadAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkRepoNotificationsAsReadAccepted to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivityMarkRepoNotificationsAsReadReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastReadAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastReadAt.Set {
			e.RawStr("\"last_read_at\"" + ":")
			s.LastReadAt.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

// Decode decodes ActivityMarkRepoNotificationsAsReadReq from json.
func (s *ActivityMarkRepoNotificationsAsReadReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkRepoNotificationsAsReadReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "last_read_at":
			s.LastReadAt.Reset()
			if err := s.LastReadAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivityMarkRepoNotificationsAsReadResetContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActivityMarkRepoNotificationsAsReadResetContent from json.
func (s *ActivityMarkRepoNotificationsAsReadResetContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkRepoNotificationsAsReadResetContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivityMarkThreadAsReadResetContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActivityMarkThreadAsReadResetContent from json.
func (s *ActivityMarkThreadAsReadResetContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkThreadAsReadResetContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivitySetRepoSubscriptionReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Subscribed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Subscribed.Set {
			e.RawStr("\"subscribed\"" + ":")
			s.Subscribed.Encode(e)
		}
	}
	{
		if s.Ignored.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ignored.Set {
			e.RawStr("\"ignored\"" + ":")
			s.Ignored.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ActivitySetRepoSubscriptionReq from json.
func (s *ActivitySetRepoSubscriptionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivitySetRepoSubscriptionReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscribed":
			s.Subscribed.Reset()
			if err := s.Subscribed.Decode(d); err != nil {
				return err
			}
		case "ignored":
			s.Ignored.Reset()
			if err := s.Ignored.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActivitySetThreadSubscriptionApplicationJSONForbidden as json.
func (s ActivitySetThreadSubscriptionApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivitySetThreadSubscriptionApplicationJSONForbidden from json.
func (s *ActivitySetThreadSubscriptionApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivitySetThreadSubscriptionApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivitySetThreadSubscriptionApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivitySetThreadSubscriptionApplicationJSONUnauthorized as json.
func (s ActivitySetThreadSubscriptionApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivitySetThreadSubscriptionApplicationJSONUnauthorized from json.
func (s *ActivitySetThreadSubscriptionApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivitySetThreadSubscriptionApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivitySetThreadSubscriptionApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivitySetThreadSubscriptionReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ignored.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ignored.Set {
			e.RawStr("\"ignored\"" + ":")
			s.Ignored.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ActivitySetThreadSubscriptionReq from json.
func (s *ActivitySetThreadSubscriptionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivitySetThreadSubscriptionReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ignored":
			s.Ignored.Reset()
			if err := s.Ignored.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound as json.
func (s ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound from json.
func (s *ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivityStarRepoForAuthenticatedUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActivityStarRepoForAuthenticatedUserNoContent from json.
func (s *ActivityStarRepoForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityStarRepoForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound as json.
func (s ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound from json.
func (s *ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivityUnstarRepoForAuthenticatedUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ActivityUnstarRepoForAuthenticatedUserNoContent from json.
func (s *ActivityUnstarRepoForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityUnstarRepoForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Actor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		if s.DisplayLogin.Set {
			e.Comma()
		}
		if s.DisplayLogin.Set {
			e.RawStr("\"display_login\"" + ":")
			s.DisplayLogin.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	e.ObjEnd()
}

// Decode decodes Actor from json.
func (s *Actor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Actor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "display_login":
			s.DisplayLogin.Reset()
			if err := s.DisplayLogin.Decode(d); err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AlertCreatedAt as json.
func (s AlertCreatedAt) Encode(e *jx.Writer) {
	unwrapped := time.Time(s)
	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes AlertCreatedAt from json.
func (s *AlertCreatedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AlertCreatedAt to nil`)
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertCreatedAt(unwrapped)
	return nil
}

// Encode encodes AlertHTMLURL as json.
func (s AlertHTMLURL) Encode(e *jx.Writer) {
	unwrapped := url.URL(s)
	json.EncodeURI(e, unwrapped)
}

// Decode decodes AlertHTMLURL from json.
func (s *AlertHTMLURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AlertHTMLURL to nil`)
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertHTMLURL(unwrapped)
	return nil
}

// Encode encodes AlertInstancesURL as json.
func (s AlertInstancesURL) Encode(e *jx.Writer) {
	unwrapped := url.URL(s)
	json.EncodeURI(e, unwrapped)
}

// Decode decodes AlertInstancesURL from json.
func (s *AlertInstancesURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AlertInstancesURL to nil`)
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertInstancesURL(unwrapped)
	return nil
}

// Encode encodes AlertNumber as json.
func (s AlertNumber) Encode(e *jx.Writer) {
	unwrapped := int(s)
	e.Int(unwrapped)
}

// Decode decodes AlertNumber from json.
func (s *AlertNumber) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AlertNumber to nil`)
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertNumber(unwrapped)
	return nil
}

// Encode encodes AlertURL as json.
func (s AlertURL) Encode(e *jx.Writer) {
	unwrapped := url.URL(s)
	json.EncodeURI(e, unwrapped)
}

// Decode decodes AlertURL from json.
func (s *AlertURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AlertURL to nil`)
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertURL(unwrapped)
	return nil
}

// Encode encodes AllowedActions as json.
func (s AllowedActions) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AllowedActions from json.
func (s *AllowedActions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AllowedActions to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AllowedActions(v) {
	case AllowedActionsAll:
		*s = AllowedActionsAll
	case AllowedActionsLocalOnly:
		*s = AllowedActionsLocalOnly
	case AllowedActionsSelected:
		*s = AllowedActionsSelected
	default:
		*s = AllowedActions(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AppPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Actions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Actions.Set {
			e.RawStr("\"actions\"" + ":")
			s.Actions.Encode(e)
		}
	}
	{
		if s.Administration.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Administration.Set {
			e.RawStr("\"administration\"" + ":")
			s.Administration.Encode(e)
		}
	}
	{
		if s.Checks.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Checks.Set {
			e.RawStr("\"checks\"" + ":")
			s.Checks.Encode(e)
		}
	}
	{
		if s.ContentReferences.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentReferences.Set {
			e.RawStr("\"content_references\"" + ":")
			s.ContentReferences.Encode(e)
		}
	}
	{
		if s.Contents.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Contents.Set {
			e.RawStr("\"contents\"" + ":")
			s.Contents.Encode(e)
		}
	}
	{
		if s.Deployments.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Deployments.Set {
			e.RawStr("\"deployments\"" + ":")
			s.Deployments.Encode(e)
		}
	}
	{
		if s.Environments.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Environments.Set {
			e.RawStr("\"environments\"" + ":")
			s.Environments.Encode(e)
		}
	}
	{
		if s.Issues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Issues.Set {
			e.RawStr("\"issues\"" + ":")
			s.Issues.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Packages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Packages.Set {
			e.RawStr("\"packages\"" + ":")
			s.Packages.Encode(e)
		}
	}
	{
		if s.Pages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pages.Set {
			e.RawStr("\"pages\"" + ":")
			s.Pages.Encode(e)
		}
	}
	{
		if s.PullRequests.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PullRequests.Set {
			e.RawStr("\"pull_requests\"" + ":")
			s.PullRequests.Encode(e)
		}
	}
	{
		if s.RepositoryHooks.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RepositoryHooks.Set {
			e.RawStr("\"repository_hooks\"" + ":")
			s.RepositoryHooks.Encode(e)
		}
	}
	{
		if s.RepositoryProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RepositoryProjects.Set {
			e.RawStr("\"repository_projects\"" + ":")
			s.RepositoryProjects.Encode(e)
		}
	}
	{
		if s.SecretScanningAlerts.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretScanningAlerts.Set {
			e.RawStr("\"secret_scanning_alerts\"" + ":")
			s.SecretScanningAlerts.Encode(e)
		}
	}
	{
		if s.Secrets.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secrets.Set {
			e.RawStr("\"secrets\"" + ":")
			s.Secrets.Encode(e)
		}
	}
	{
		if s.SecurityEvents.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecurityEvents.Set {
			e.RawStr("\"security_events\"" + ":")
			s.SecurityEvents.Encode(e)
		}
	}
	{
		if s.SingleFile.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SingleFile.Set {
			e.RawStr("\"single_file\"" + ":")
			s.SingleFile.Encode(e)
		}
	}
	{
		if s.Statuses.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Statuses.Set {
			e.RawStr("\"statuses\"" + ":")
			s.Statuses.Encode(e)
		}
	}
	{
		if s.VulnerabilityAlerts.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VulnerabilityAlerts.Set {
			e.RawStr("\"vulnerability_alerts\"" + ":")
			s.VulnerabilityAlerts.Encode(e)
		}
	}
	{
		if s.Workflows.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Workflows.Set {
			e.RawStr("\"workflows\"" + ":")
			s.Workflows.Encode(e)
		}
	}
	{
		if s.Members.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Members.Set {
			e.RawStr("\"members\"" + ":")
			s.Members.Encode(e)
		}
	}
	{
		if s.OrganizationAdministration.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationAdministration.Set {
			e.RawStr("\"organization_administration\"" + ":")
			s.OrganizationAdministration.Encode(e)
		}
	}
	{
		if s.OrganizationHooks.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationHooks.Set {
			e.RawStr("\"organization_hooks\"" + ":")
			s.OrganizationHooks.Encode(e)
		}
	}
	{
		if s.OrganizationPlan.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationPlan.Set {
			e.RawStr("\"organization_plan\"" + ":")
			s.OrganizationPlan.Encode(e)
		}
	}
	{
		if s.OrganizationProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationProjects.Set {
			e.RawStr("\"organization_projects\"" + ":")
			s.OrganizationProjects.Encode(e)
		}
	}
	{
		if s.OrganizationPackages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationPackages.Set {
			e.RawStr("\"organization_packages\"" + ":")
			s.OrganizationPackages.Encode(e)
		}
	}
	{
		if s.OrganizationSecrets.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationSecrets.Set {
			e.RawStr("\"organization_secrets\"" + ":")
			s.OrganizationSecrets.Encode(e)
		}
	}
	{
		if s.OrganizationSelfHostedRunners.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationSelfHostedRunners.Set {
			e.RawStr("\"organization_self_hosted_runners\"" + ":")
			s.OrganizationSelfHostedRunners.Encode(e)
		}
	}
	{
		if s.OrganizationUserBlocking.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationUserBlocking.Set {
			e.RawStr("\"organization_user_blocking\"" + ":")
			s.OrganizationUserBlocking.Encode(e)
		}
	}
	{
		if s.TeamDiscussions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TeamDiscussions.Set {
			e.RawStr("\"team_discussions\"" + ":")
			s.TeamDiscussions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes AppPermissions from json.
func (s *AppPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "actions":
			s.Actions.Reset()
			if err := s.Actions.Decode(d); err != nil {
				return err
			}
		case "administration":
			s.Administration.Reset()
			if err := s.Administration.Decode(d); err != nil {
				return err
			}
		case "checks":
			s.Checks.Reset()
			if err := s.Checks.Decode(d); err != nil {
				return err
			}
		case "content_references":
			s.ContentReferences.Reset()
			if err := s.ContentReferences.Decode(d); err != nil {
				return err
			}
		case "contents":
			s.Contents.Reset()
			if err := s.Contents.Decode(d); err != nil {
				return err
			}
		case "deployments":
			s.Deployments.Reset()
			if err := s.Deployments.Decode(d); err != nil {
				return err
			}
		case "environments":
			s.Environments.Reset()
			if err := s.Environments.Decode(d); err != nil {
				return err
			}
		case "issues":
			s.Issues.Reset()
			if err := s.Issues.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "packages":
			s.Packages.Reset()
			if err := s.Packages.Decode(d); err != nil {
				return err
			}
		case "pages":
			s.Pages.Reset()
			if err := s.Pages.Decode(d); err != nil {
				return err
			}
		case "pull_requests":
			s.PullRequests.Reset()
			if err := s.PullRequests.Decode(d); err != nil {
				return err
			}
		case "repository_hooks":
			s.RepositoryHooks.Reset()
			if err := s.RepositoryHooks.Decode(d); err != nil {
				return err
			}
		case "repository_projects":
			s.RepositoryProjects.Reset()
			if err := s.RepositoryProjects.Decode(d); err != nil {
				return err
			}
		case "secret_scanning_alerts":
			s.SecretScanningAlerts.Reset()
			if err := s.SecretScanningAlerts.Decode(d); err != nil {
				return err
			}
		case "secrets":
			s.Secrets.Reset()
			if err := s.Secrets.Decode(d); err != nil {
				return err
			}
		case "security_events":
			s.SecurityEvents.Reset()
			if err := s.SecurityEvents.Decode(d); err != nil {
				return err
			}
		case "single_file":
			s.SingleFile.Reset()
			if err := s.SingleFile.Decode(d); err != nil {
				return err
			}
		case "statuses":
			s.Statuses.Reset()
			if err := s.Statuses.Decode(d); err != nil {
				return err
			}
		case "vulnerability_alerts":
			s.VulnerabilityAlerts.Reset()
			if err := s.VulnerabilityAlerts.Decode(d); err != nil {
				return err
			}
		case "workflows":
			s.Workflows.Reset()
			if err := s.Workflows.Decode(d); err != nil {
				return err
			}
		case "members":
			s.Members.Reset()
			if err := s.Members.Decode(d); err != nil {
				return err
			}
		case "organization_administration":
			s.OrganizationAdministration.Reset()
			if err := s.OrganizationAdministration.Decode(d); err != nil {
				return err
			}
		case "organization_hooks":
			s.OrganizationHooks.Reset()
			if err := s.OrganizationHooks.Decode(d); err != nil {
				return err
			}
		case "organization_plan":
			s.OrganizationPlan.Reset()
			if err := s.OrganizationPlan.Decode(d); err != nil {
				return err
			}
		case "organization_projects":
			s.OrganizationProjects.Reset()
			if err := s.OrganizationProjects.Decode(d); err != nil {
				return err
			}
		case "organization_packages":
			s.OrganizationPackages.Reset()
			if err := s.OrganizationPackages.Decode(d); err != nil {
				return err
			}
		case "organization_secrets":
			s.OrganizationSecrets.Reset()
			if err := s.OrganizationSecrets.Decode(d); err != nil {
				return err
			}
		case "organization_self_hosted_runners":
			s.OrganizationSelfHostedRunners.Reset()
			if err := s.OrganizationSelfHostedRunners.Decode(d); err != nil {
				return err
			}
		case "organization_user_blocking":
			s.OrganizationUserBlocking.Reset()
			if err := s.OrganizationUserBlocking.Decode(d); err != nil {
				return err
			}
		case "team_discussions":
			s.TeamDiscussions.Reset()
			if err := s.TeamDiscussions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AppPermissionsActions as json.
func (s AppPermissionsActions) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsActions from json.
func (s *AppPermissionsActions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsActions to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsActions(v) {
	case AppPermissionsActionsRead:
		*s = AppPermissionsActionsRead
	case AppPermissionsActionsWrite:
		*s = AppPermissionsActionsWrite
	default:
		*s = AppPermissionsActions(v)
	}

	return nil
}

// Encode encodes AppPermissionsAdministration as json.
func (s AppPermissionsAdministration) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsAdministration from json.
func (s *AppPermissionsAdministration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsAdministration to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsAdministration(v) {
	case AppPermissionsAdministrationRead:
		*s = AppPermissionsAdministrationRead
	case AppPermissionsAdministrationWrite:
		*s = AppPermissionsAdministrationWrite
	default:
		*s = AppPermissionsAdministration(v)
	}

	return nil
}

// Encode encodes AppPermissionsChecks as json.
func (s AppPermissionsChecks) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsChecks from json.
func (s *AppPermissionsChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsChecks to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsChecks(v) {
	case AppPermissionsChecksRead:
		*s = AppPermissionsChecksRead
	case AppPermissionsChecksWrite:
		*s = AppPermissionsChecksWrite
	default:
		*s = AppPermissionsChecks(v)
	}

	return nil
}

// Encode encodes AppPermissionsContentReferences as json.
func (s AppPermissionsContentReferences) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsContentReferences from json.
func (s *AppPermissionsContentReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsContentReferences to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsContentReferences(v) {
	case AppPermissionsContentReferencesRead:
		*s = AppPermissionsContentReferencesRead
	case AppPermissionsContentReferencesWrite:
		*s = AppPermissionsContentReferencesWrite
	default:
		*s = AppPermissionsContentReferences(v)
	}

	return nil
}

// Encode encodes AppPermissionsContents as json.
func (s AppPermissionsContents) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsContents from json.
func (s *AppPermissionsContents) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsContents to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsContents(v) {
	case AppPermissionsContentsRead:
		*s = AppPermissionsContentsRead
	case AppPermissionsContentsWrite:
		*s = AppPermissionsContentsWrite
	default:
		*s = AppPermissionsContents(v)
	}

	return nil
}

// Encode encodes AppPermissionsDeployments as json.
func (s AppPermissionsDeployments) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsDeployments from json.
func (s *AppPermissionsDeployments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsDeployments to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsDeployments(v) {
	case AppPermissionsDeploymentsRead:
		*s = AppPermissionsDeploymentsRead
	case AppPermissionsDeploymentsWrite:
		*s = AppPermissionsDeploymentsWrite
	default:
		*s = AppPermissionsDeployments(v)
	}

	return nil
}

// Encode encodes AppPermissionsEnvironments as json.
func (s AppPermissionsEnvironments) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsEnvironments from json.
func (s *AppPermissionsEnvironments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsEnvironments to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsEnvironments(v) {
	case AppPermissionsEnvironmentsRead:
		*s = AppPermissionsEnvironmentsRead
	case AppPermissionsEnvironmentsWrite:
		*s = AppPermissionsEnvironmentsWrite
	default:
		*s = AppPermissionsEnvironments(v)
	}

	return nil
}

// Encode encodes AppPermissionsIssues as json.
func (s AppPermissionsIssues) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsIssues from json.
func (s *AppPermissionsIssues) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsIssues to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsIssues(v) {
	case AppPermissionsIssuesRead:
		*s = AppPermissionsIssuesRead
	case AppPermissionsIssuesWrite:
		*s = AppPermissionsIssuesWrite
	default:
		*s = AppPermissionsIssues(v)
	}

	return nil
}

// Encode encodes AppPermissionsMembers as json.
func (s AppPermissionsMembers) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsMembers from json.
func (s *AppPermissionsMembers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsMembers to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsMembers(v) {
	case AppPermissionsMembersRead:
		*s = AppPermissionsMembersRead
	case AppPermissionsMembersWrite:
		*s = AppPermissionsMembersWrite
	default:
		*s = AppPermissionsMembers(v)
	}

	return nil
}

// Encode encodes AppPermissionsMetadata as json.
func (s AppPermissionsMetadata) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsMetadata from json.
func (s *AppPermissionsMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsMetadata to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsMetadata(v) {
	case AppPermissionsMetadataRead:
		*s = AppPermissionsMetadataRead
	case AppPermissionsMetadataWrite:
		*s = AppPermissionsMetadataWrite
	default:
		*s = AppPermissionsMetadata(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationAdministration as json.
func (s AppPermissionsOrganizationAdministration) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationAdministration from json.
func (s *AppPermissionsOrganizationAdministration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationAdministration to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationAdministration(v) {
	case AppPermissionsOrganizationAdministrationRead:
		*s = AppPermissionsOrganizationAdministrationRead
	case AppPermissionsOrganizationAdministrationWrite:
		*s = AppPermissionsOrganizationAdministrationWrite
	default:
		*s = AppPermissionsOrganizationAdministration(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationHooks as json.
func (s AppPermissionsOrganizationHooks) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationHooks from json.
func (s *AppPermissionsOrganizationHooks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationHooks to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationHooks(v) {
	case AppPermissionsOrganizationHooksRead:
		*s = AppPermissionsOrganizationHooksRead
	case AppPermissionsOrganizationHooksWrite:
		*s = AppPermissionsOrganizationHooksWrite
	default:
		*s = AppPermissionsOrganizationHooks(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationPackages as json.
func (s AppPermissionsOrganizationPackages) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationPackages from json.
func (s *AppPermissionsOrganizationPackages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationPackages to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationPackages(v) {
	case AppPermissionsOrganizationPackagesRead:
		*s = AppPermissionsOrganizationPackagesRead
	case AppPermissionsOrganizationPackagesWrite:
		*s = AppPermissionsOrganizationPackagesWrite
	default:
		*s = AppPermissionsOrganizationPackages(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationPlan as json.
func (s AppPermissionsOrganizationPlan) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationPlan from json.
func (s *AppPermissionsOrganizationPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationPlan to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationPlan(v) {
	case AppPermissionsOrganizationPlanRead:
		*s = AppPermissionsOrganizationPlanRead
	default:
		*s = AppPermissionsOrganizationPlan(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationProjects as json.
func (s AppPermissionsOrganizationProjects) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationProjects from json.
func (s *AppPermissionsOrganizationProjects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationProjects to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationProjects(v) {
	case AppPermissionsOrganizationProjectsRead:
		*s = AppPermissionsOrganizationProjectsRead
	case AppPermissionsOrganizationProjectsWrite:
		*s = AppPermissionsOrganizationProjectsWrite
	case AppPermissionsOrganizationProjectsAdmin:
		*s = AppPermissionsOrganizationProjectsAdmin
	default:
		*s = AppPermissionsOrganizationProjects(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationSecrets as json.
func (s AppPermissionsOrganizationSecrets) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationSecrets from json.
func (s *AppPermissionsOrganizationSecrets) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationSecrets to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationSecrets(v) {
	case AppPermissionsOrganizationSecretsRead:
		*s = AppPermissionsOrganizationSecretsRead
	case AppPermissionsOrganizationSecretsWrite:
		*s = AppPermissionsOrganizationSecretsWrite
	default:
		*s = AppPermissionsOrganizationSecrets(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationSelfHostedRunners as json.
func (s AppPermissionsOrganizationSelfHostedRunners) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationSelfHostedRunners from json.
func (s *AppPermissionsOrganizationSelfHostedRunners) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationSelfHostedRunners to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationSelfHostedRunners(v) {
	case AppPermissionsOrganizationSelfHostedRunnersRead:
		*s = AppPermissionsOrganizationSelfHostedRunnersRead
	case AppPermissionsOrganizationSelfHostedRunnersWrite:
		*s = AppPermissionsOrganizationSelfHostedRunnersWrite
	default:
		*s = AppPermissionsOrganizationSelfHostedRunners(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationUserBlocking as json.
func (s AppPermissionsOrganizationUserBlocking) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationUserBlocking from json.
func (s *AppPermissionsOrganizationUserBlocking) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationUserBlocking to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationUserBlocking(v) {
	case AppPermissionsOrganizationUserBlockingRead:
		*s = AppPermissionsOrganizationUserBlockingRead
	case AppPermissionsOrganizationUserBlockingWrite:
		*s = AppPermissionsOrganizationUserBlockingWrite
	default:
		*s = AppPermissionsOrganizationUserBlocking(v)
	}

	return nil
}

// Encode encodes AppPermissionsPackages as json.
func (s AppPermissionsPackages) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsPackages from json.
func (s *AppPermissionsPackages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsPackages to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsPackages(v) {
	case AppPermissionsPackagesRead:
		*s = AppPermissionsPackagesRead
	case AppPermissionsPackagesWrite:
		*s = AppPermissionsPackagesWrite
	default:
		*s = AppPermissionsPackages(v)
	}

	return nil
}

// Encode encodes AppPermissionsPages as json.
func (s AppPermissionsPages) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsPages from json.
func (s *AppPermissionsPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsPages to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsPages(v) {
	case AppPermissionsPagesRead:
		*s = AppPermissionsPagesRead
	case AppPermissionsPagesWrite:
		*s = AppPermissionsPagesWrite
	default:
		*s = AppPermissionsPages(v)
	}

	return nil
}

// Encode encodes AppPermissionsPullRequests as json.
func (s AppPermissionsPullRequests) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsPullRequests from json.
func (s *AppPermissionsPullRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsPullRequests to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsPullRequests(v) {
	case AppPermissionsPullRequestsRead:
		*s = AppPermissionsPullRequestsRead
	case AppPermissionsPullRequestsWrite:
		*s = AppPermissionsPullRequestsWrite
	default:
		*s = AppPermissionsPullRequests(v)
	}

	return nil
}

// Encode encodes AppPermissionsRepositoryHooks as json.
func (s AppPermissionsRepositoryHooks) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsRepositoryHooks from json.
func (s *AppPermissionsRepositoryHooks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsRepositoryHooks to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsRepositoryHooks(v) {
	case AppPermissionsRepositoryHooksRead:
		*s = AppPermissionsRepositoryHooksRead
	case AppPermissionsRepositoryHooksWrite:
		*s = AppPermissionsRepositoryHooksWrite
	default:
		*s = AppPermissionsRepositoryHooks(v)
	}

	return nil
}

// Encode encodes AppPermissionsRepositoryProjects as json.
func (s AppPermissionsRepositoryProjects) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsRepositoryProjects from json.
func (s *AppPermissionsRepositoryProjects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsRepositoryProjects to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsRepositoryProjects(v) {
	case AppPermissionsRepositoryProjectsRead:
		*s = AppPermissionsRepositoryProjectsRead
	case AppPermissionsRepositoryProjectsWrite:
		*s = AppPermissionsRepositoryProjectsWrite
	case AppPermissionsRepositoryProjectsAdmin:
		*s = AppPermissionsRepositoryProjectsAdmin
	default:
		*s = AppPermissionsRepositoryProjects(v)
	}

	return nil
}

// Encode encodes AppPermissionsSecretScanningAlerts as json.
func (s AppPermissionsSecretScanningAlerts) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSecretScanningAlerts from json.
func (s *AppPermissionsSecretScanningAlerts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsSecretScanningAlerts to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsSecretScanningAlerts(v) {
	case AppPermissionsSecretScanningAlertsRead:
		*s = AppPermissionsSecretScanningAlertsRead
	case AppPermissionsSecretScanningAlertsWrite:
		*s = AppPermissionsSecretScanningAlertsWrite
	default:
		*s = AppPermissionsSecretScanningAlerts(v)
	}

	return nil
}

// Encode encodes AppPermissionsSecrets as json.
func (s AppPermissionsSecrets) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSecrets from json.
func (s *AppPermissionsSecrets) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsSecrets to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsSecrets(v) {
	case AppPermissionsSecretsRead:
		*s = AppPermissionsSecretsRead
	case AppPermissionsSecretsWrite:
		*s = AppPermissionsSecretsWrite
	default:
		*s = AppPermissionsSecrets(v)
	}

	return nil
}

// Encode encodes AppPermissionsSecurityEvents as json.
func (s AppPermissionsSecurityEvents) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSecurityEvents from json.
func (s *AppPermissionsSecurityEvents) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsSecurityEvents to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsSecurityEvents(v) {
	case AppPermissionsSecurityEventsRead:
		*s = AppPermissionsSecurityEventsRead
	case AppPermissionsSecurityEventsWrite:
		*s = AppPermissionsSecurityEventsWrite
	default:
		*s = AppPermissionsSecurityEvents(v)
	}

	return nil
}

// Encode encodes AppPermissionsSingleFile as json.
func (s AppPermissionsSingleFile) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSingleFile from json.
func (s *AppPermissionsSingleFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsSingleFile to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsSingleFile(v) {
	case AppPermissionsSingleFileRead:
		*s = AppPermissionsSingleFileRead
	case AppPermissionsSingleFileWrite:
		*s = AppPermissionsSingleFileWrite
	default:
		*s = AppPermissionsSingleFile(v)
	}

	return nil
}

// Encode encodes AppPermissionsStatuses as json.
func (s AppPermissionsStatuses) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsStatuses from json.
func (s *AppPermissionsStatuses) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsStatuses to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsStatuses(v) {
	case AppPermissionsStatusesRead:
		*s = AppPermissionsStatusesRead
	case AppPermissionsStatusesWrite:
		*s = AppPermissionsStatusesWrite
	default:
		*s = AppPermissionsStatuses(v)
	}

	return nil
}

// Encode encodes AppPermissionsTeamDiscussions as json.
func (s AppPermissionsTeamDiscussions) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsTeamDiscussions from json.
func (s *AppPermissionsTeamDiscussions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsTeamDiscussions to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsTeamDiscussions(v) {
	case AppPermissionsTeamDiscussionsRead:
		*s = AppPermissionsTeamDiscussionsRead
	case AppPermissionsTeamDiscussionsWrite:
		*s = AppPermissionsTeamDiscussionsWrite
	default:
		*s = AppPermissionsTeamDiscussions(v)
	}

	return nil
}

// Encode encodes AppPermissionsVulnerabilityAlerts as json.
func (s AppPermissionsVulnerabilityAlerts) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsVulnerabilityAlerts from json.
func (s *AppPermissionsVulnerabilityAlerts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsVulnerabilityAlerts to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsVulnerabilityAlerts(v) {
	case AppPermissionsVulnerabilityAlertsRead:
		*s = AppPermissionsVulnerabilityAlertsRead
	default:
		*s = AppPermissionsVulnerabilityAlerts(v)
	}

	return nil
}

// Encode encodes AppPermissionsWorkflows as json.
func (s AppPermissionsWorkflows) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsWorkflows from json.
func (s *AppPermissionsWorkflows) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsWorkflows to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsWorkflows(v) {
	case AppPermissionsWorkflowsWrite:
		*s = AppPermissionsWorkflowsWrite
	default:
		*s = AppPermissionsWorkflows(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ApplicationGrant) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"app\"" + ":")
		s.App.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"scopes\"" + ":")
		e.ArrStart()
		if len(s.Scopes) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Scopes[0]
				e.Str(elem)
			}
			for _, elem := range s.Scopes[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ApplicationGrant from json.
func (s *ApplicationGrant) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ApplicationGrant to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "app":
			if err := s.App.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "scopes":
			s.Scopes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Scopes = append(s.Scopes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ApplicationGrantApp) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"client_id\"" + ":")
		e.Str(s.ClientID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

// Decode decodes ApplicationGrantApp from json.
func (s *ApplicationGrantApp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ApplicationGrantApp to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_id":
			v, err := d.Str()
			s.ClientID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AppsAddRepoToInstallationApplicationJSONForbidden as json.
func (s AppsAddRepoToInstallationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsAddRepoToInstallationApplicationJSONForbidden from json.
func (s *AppsAddRepoToInstallationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsAddRepoToInstallationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsAddRepoToInstallationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsAddRepoToInstallationApplicationJSONNotFound as json.
func (s AppsAddRepoToInstallationApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsAddRepoToInstallationApplicationJSONNotFound from json.
func (s *AppsAddRepoToInstallationApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsAddRepoToInstallationApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsAddRepoToInstallationApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsAddRepoToInstallationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes AppsAddRepoToInstallationNoContent from json.
func (s *AppsAddRepoToInstallationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsAddRepoToInstallationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsCheckTokenReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"access_token\"" + ":")
		e.Str(s.AccessToken)
	}
	e.ObjEnd()
}

// Decode decodes AppsCheckTokenReq from json.
func (s *AppsCheckTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsCheckTokenReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			v, err := d.Str()
			s.AccessToken = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AppsCreateContentAttachmentApplicationJSONForbidden as json.
func (s AppsCreateContentAttachmentApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsCreateContentAttachmentApplicationJSONForbidden from json.
func (s *AppsCreateContentAttachmentApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsCreateContentAttachmentApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateContentAttachmentApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsCreateContentAttachmentApplicationJSONGone as json.
func (s AppsCreateContentAttachmentApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsCreateContentAttachmentApplicationJSONGone from json.
func (s *AppsCreateContentAttachmentApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsCreateContentAttachmentApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateContentAttachmentApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes AppsCreateContentAttachmentApplicationJSONNotFound as json.
func (s AppsCreateContentAttachmentApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsCreateContentAttachmentApplicationJSONNotFound from json.
func (s *AppsCreateContentAttachmentApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsCreateContentAttachmentApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateContentAttachmentApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsCreateContentAttachmentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

// Decode decodes AppsCreateContentAttachmentReq from json.
func (s *AppsCreateContentAttachmentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsCreateContentAttachmentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsCreateFromManifestReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes AppsCreateFromManifestReq from json.
func (s *AppsCreateFromManifestReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsCreateFromManifestReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AppsCreateInstallationAccessTokenApplicationJSONForbidden as json.
func (s AppsCreateInstallationAccessTokenApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsCreateInstallationAccessTokenApplicationJSONForbidden from json.
func (s *AppsCreateInstallationAccessTokenApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsCreateInstallationAccessTokenApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateInstallationAccessTokenApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsCreateInstallationAccessTokenApplicationJSONNotFound as json.
func (s AppsCreateInstallationAccessTokenApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsCreateInstallationAccessTokenApplicationJSONNotFound from json.
func (s *AppsCreateInstallationAccessTokenApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsCreateInstallationAccessTokenApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateInstallationAccessTokenApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsCreateInstallationAccessTokenApplicationJSONUnauthorized as json.
func (s AppsCreateInstallationAccessTokenApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsCreateInstallationAccessTokenApplicationJSONUnauthorized from json.
func (s *AppsCreateInstallationAccessTokenApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsCreateInstallationAccessTokenApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateInstallationAccessTokenApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsCreateInstallationAccessTokenReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Repositories != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Repositories != nil {
			e.RawStr("\"repositories\"" + ":")
			e.ArrStart()
			if len(s.Repositories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Repositories[0]
					e.Str(elem)
				}
				for _, elem := range s.Repositories[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RepositoryIds != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RepositoryIds != nil {
			e.RawStr("\"repository_ids\"" + ":")
			e.ArrStart()
			if len(s.RepositoryIds) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RepositoryIds[0]
					e.Int(elem)
				}
				for _, elem := range s.RepositoryIds[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Permissions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes AppsCreateInstallationAccessTokenReq from json.
func (s *AppsCreateInstallationAccessTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsCreateInstallationAccessTokenReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "repository_ids":
			s.RepositoryIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.RepositoryIds = append(s.RepositoryIds, elem)
				return nil
			}); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsDeleteAuthorizationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes AppsDeleteAuthorizationNoContent from json.
func (s *AppsDeleteAuthorizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsDeleteAuthorizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsDeleteAuthorizationReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"access_token\"" + ":")
		e.Str(s.AccessToken)
	}
	e.ObjEnd()
}

// Decode decodes AppsDeleteAuthorizationReq from json.
func (s *AppsDeleteAuthorizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsDeleteAuthorizationReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			v, err := d.Str()
			s.AccessToken = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsDeleteInstallationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes AppsDeleteInstallationNoContent from json.
func (s *AppsDeleteInstallationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsDeleteInstallationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsDeleteTokenNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes AppsDeleteTokenNoContent from json.
func (s *AppsDeleteTokenNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsDeleteTokenNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsDeleteTokenReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"access_token\"" + ":")
		e.Str(s.AccessToken)
	}
	e.ObjEnd()
}

// Decode decodes AppsDeleteTokenReq from json.
func (s *AppsDeleteTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsDeleteTokenReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			v, err := d.Str()
			s.AccessToken = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AppsGetBySlugApplicationJSONForbidden as json.
func (s AppsGetBySlugApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsGetBySlugApplicationJSONForbidden from json.
func (s *AppsGetBySlugApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsGetBySlugApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetBySlugApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsGetBySlugApplicationJSONNotFound as json.
func (s AppsGetBySlugApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsGetBySlugApplicationJSONNotFound from json.
func (s *AppsGetBySlugApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsGetBySlugApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetBySlugApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsGetSubscriptionPlanForAccountApplicationJSONNotFound as json.
func (s AppsGetSubscriptionPlanForAccountApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsGetSubscriptionPlanForAccountApplicationJSONNotFound from json.
func (s *AppsGetSubscriptionPlanForAccountApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsGetSubscriptionPlanForAccountApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetSubscriptionPlanForAccountApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized as json.
func (s AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized from json.
func (s *AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsGetSubscriptionPlanForAccountStubbedNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes AppsGetSubscriptionPlanForAccountStubbedNotFound from json.
func (s *AppsGetSubscriptionPlanForAccountStubbedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsGetSubscriptionPlanForAccountStubbedNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AppsListAccountsForPlanApplicationJSONNotFound as json.
func (s AppsListAccountsForPlanApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListAccountsForPlanApplicationJSONNotFound from json.
func (s *AppsListAccountsForPlanApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListAccountsForPlanApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListAccountsForPlanApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsListAccountsForPlanApplicationJSONUnauthorized as json.
func (s AppsListAccountsForPlanApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListAccountsForPlanApplicationJSONUnauthorized from json.
func (s *AppsListAccountsForPlanApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListAccountsForPlanApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListAccountsForPlanApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes AppsListAccountsForPlanDirection as json.
func (s AppsListAccountsForPlanDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppsListAccountsForPlanDirection from json.
func (s *AppsListAccountsForPlanDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListAccountsForPlanDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppsListAccountsForPlanDirection(v) {
	case AppsListAccountsForPlanDirectionAsc:
		*s = AppsListAccountsForPlanDirectionAsc
	case AppsListAccountsForPlanDirectionDesc:
		*s = AppsListAccountsForPlanDirectionDesc
	default:
		*s = AppsListAccountsForPlanDirection(v)
	}

	return nil
}

// Encode encodes AppsListAccountsForPlanOKApplicationJSON as json.
func (s AppsListAccountsForPlanOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MarketplacePurchase(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes AppsListAccountsForPlanOKApplicationJSON from json.
func (s *AppsListAccountsForPlanOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListAccountsForPlanOKApplicationJSON to nil`)
	}
	var unwrapped []MarketplacePurchase
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MarketplacePurchase
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListAccountsForPlanOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListAccountsForPlanSort as json.
func (s AppsListAccountsForPlanSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppsListAccountsForPlanSort from json.
func (s *AppsListAccountsForPlanSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListAccountsForPlanSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppsListAccountsForPlanSort(v) {
	case AppsListAccountsForPlanSortCreated:
		*s = AppsListAccountsForPlanSortCreated
	case AppsListAccountsForPlanSortUpdated:
		*s = AppsListAccountsForPlanSortUpdated
	default:
		*s = AppsListAccountsForPlanSort(v)
	}

	return nil
}

// Encode encodes AppsListAccountsForPlanStubbedDirection as json.
func (s AppsListAccountsForPlanStubbedDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppsListAccountsForPlanStubbedDirection from json.
func (s *AppsListAccountsForPlanStubbedDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListAccountsForPlanStubbedDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppsListAccountsForPlanStubbedDirection(v) {
	case AppsListAccountsForPlanStubbedDirectionAsc:
		*s = AppsListAccountsForPlanStubbedDirectionAsc
	case AppsListAccountsForPlanStubbedDirectionDesc:
		*s = AppsListAccountsForPlanStubbedDirectionDesc
	default:
		*s = AppsListAccountsForPlanStubbedDirection(v)
	}

	return nil
}

// Encode encodes AppsListAccountsForPlanStubbedOKApplicationJSON as json.
func (s AppsListAccountsForPlanStubbedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MarketplacePurchase(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes AppsListAccountsForPlanStubbedOKApplicationJSON from json.
func (s *AppsListAccountsForPlanStubbedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListAccountsForPlanStubbedOKApplicationJSON to nil`)
	}
	var unwrapped []MarketplacePurchase
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MarketplacePurchase
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListAccountsForPlanStubbedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListAccountsForPlanStubbedSort as json.
func (s AppsListAccountsForPlanStubbedSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppsListAccountsForPlanStubbedSort from json.
func (s *AppsListAccountsForPlanStubbedSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListAccountsForPlanStubbedSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppsListAccountsForPlanStubbedSort(v) {
	case AppsListAccountsForPlanStubbedSortCreated:
		*s = AppsListAccountsForPlanStubbedSortCreated
	case AppsListAccountsForPlanStubbedSortUpdated:
		*s = AppsListAccountsForPlanStubbedSortUpdated
	default:
		*s = AppsListAccountsForPlanStubbedSort(v)
	}

	return nil
}

// Encode encodes AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden as json.
func (s AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden from json.
func (s *AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound as json.
func (s AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound from json.
func (s *AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsListInstallationReposForAuthenticatedUserOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		if s.RepositorySelection.Set {
			e.Comma()
		}
		if s.RepositorySelection.Set {
			e.RawStr("\"repository_selection\"" + ":")
			s.RepositorySelection.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				elem.Encode(e)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes AppsListInstallationReposForAuthenticatedUserOK from json.
func (s *AppsListInstallationReposForAuthenticatedUserOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListInstallationReposForAuthenticatedUserOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "repository_selection":
			s.RepositorySelection.Reset()
			if err := s.RepositorySelection.Decode(d); err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Repository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AppsListPlansApplicationJSONNotFound as json.
func (s AppsListPlansApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListPlansApplicationJSONNotFound from json.
func (s *AppsListPlansApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListPlansApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListPlansApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsListPlansApplicationJSONUnauthorized as json.
func (s AppsListPlansApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListPlansApplicationJSONUnauthorized from json.
func (s *AppsListPlansApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListPlansApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListPlansApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes AppsListPlansOKApplicationJSON as json.
func (s AppsListPlansOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MarketplaceListingPlan(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes AppsListPlansOKApplicationJSON from json.
func (s *AppsListPlansOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListPlansOKApplicationJSON to nil`)
	}
	var unwrapped []MarketplaceListingPlan
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MarketplaceListingPlan
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListPlansOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListPlansStubbedOKApplicationJSON as json.
func (s AppsListPlansStubbedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MarketplaceListingPlan(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes AppsListPlansStubbedOKApplicationJSON from json.
func (s *AppsListPlansStubbedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListPlansStubbedOKApplicationJSON to nil`)
	}
	var unwrapped []MarketplaceListingPlan
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MarketplaceListingPlan
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListPlansStubbedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListReposAccessibleToInstallationApplicationJSONForbidden as json.
func (s AppsListReposAccessibleToInstallationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListReposAccessibleToInstallationApplicationJSONForbidden from json.
func (s *AppsListReposAccessibleToInstallationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListReposAccessibleToInstallationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListReposAccessibleToInstallationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsListReposAccessibleToInstallationApplicationJSONUnauthorized as json.
func (s AppsListReposAccessibleToInstallationApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListReposAccessibleToInstallationApplicationJSONUnauthorized from json.
func (s *AppsListReposAccessibleToInstallationApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListReposAccessibleToInstallationApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListReposAccessibleToInstallationApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsListReposAccessibleToInstallationOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				elem.Encode(e)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.RepositorySelection.Set {
			e.Comma()
		}
		if s.RepositorySelection.Set {
			e.RawStr("\"repository_selection\"" + ":")
			s.RepositorySelection.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes AppsListReposAccessibleToInstallationOK from json.
func (s *AppsListReposAccessibleToInstallationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListReposAccessibleToInstallationOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Repository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "repository_selection":
			s.RepositorySelection.Reset()
			if err := s.RepositorySelection.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound as json.
func (s AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound from json.
func (s *AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON as json.
func (s AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []UserMarketplacePurchase(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON from json.
func (s *AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []UserMarketplacePurchase
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserMarketplacePurchase
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON as json.
func (s AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []UserMarketplacePurchase(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON from json.
func (s *AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON to nil`)
	}
	var unwrapped []UserMarketplacePurchase
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserMarketplacePurchase
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListWebhookDeliveriesOKApplicationJSON as json.
func (s AppsListWebhookDeliveriesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []HookDeliveryItem(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes AppsListWebhookDeliveriesOKApplicationJSON from json.
func (s *AppsListWebhookDeliveriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListWebhookDeliveriesOKApplicationJSON to nil`)
	}
	var unwrapped []HookDeliveryItem
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HookDeliveryItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListWebhookDeliveriesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsRemoveRepoFromInstallationApplicationJSONForbidden as json.
func (s AppsRemoveRepoFromInstallationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsRemoveRepoFromInstallationApplicationJSONForbidden from json.
func (s *AppsRemoveRepoFromInstallationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsRemoveRepoFromInstallationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsRemoveRepoFromInstallationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsRemoveRepoFromInstallationApplicationJSONNotFound as json.
func (s AppsRemoveRepoFromInstallationApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsRemoveRepoFromInstallationApplicationJSONNotFound from json.
func (s *AppsRemoveRepoFromInstallationApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsRemoveRepoFromInstallationApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsRemoveRepoFromInstallationApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsRemoveRepoFromInstallationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes AppsRemoveRepoFromInstallationNoContent from json.
func (s *AppsRemoveRepoFromInstallationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsRemoveRepoFromInstallationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsResetTokenReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"access_token\"" + ":")
		e.Str(s.AccessToken)
	}
	e.ObjEnd()
}

// Decode decodes AppsResetTokenReq from json.
func (s *AppsResetTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsResetTokenReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			v, err := d.Str()
			s.AccessToken = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsRevokeInstallationAccessTokenNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes AppsRevokeInstallationAccessTokenNoContent from json.
func (s *AppsRevokeInstallationAccessTokenNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsRevokeInstallationAccessTokenNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AppsScopeTokenApplicationJSONForbidden as json.
func (s AppsScopeTokenApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsScopeTokenApplicationJSONForbidden from json.
func (s *AppsScopeTokenApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsScopeTokenApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsScopeTokenApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsScopeTokenApplicationJSONNotFound as json.
func (s AppsScopeTokenApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsScopeTokenApplicationJSONNotFound from json.
func (s *AppsScopeTokenApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsScopeTokenApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsScopeTokenApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsScopeTokenApplicationJSONUnauthorized as json.
func (s AppsScopeTokenApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsScopeTokenApplicationJSONUnauthorized from json.
func (s *AppsScopeTokenApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsScopeTokenApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsScopeTokenApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsScopeTokenReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"access_token\"" + ":")
		e.Str(s.AccessToken)
	}
	{
		if s.Target.Set {
			e.Comma()
		}
		if s.Target.Set {
			e.RawStr("\"target\"" + ":")
			s.Target.Encode(e)
		}
	}
	{
		if s.TargetID.Set {
			e.Comma()
		}
		if s.TargetID.Set {
			e.RawStr("\"target_id\"" + ":")
			s.TargetID.Encode(e)
		}
	}
	{
		if s.Repositories != nil {
			e.Comma()
		}
		if s.Repositories != nil {
			e.RawStr("\"repositories\"" + ":")
			e.ArrStart()
			if len(s.Repositories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Repositories[0]
					e.Str(elem)
				}
				for _, elem := range s.Repositories[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RepositoryIds != nil {
			e.Comma()
		}
		if s.RepositoryIds != nil {
			e.RawStr("\"repository_ids\"" + ":")
			e.ArrStart()
			if len(s.RepositoryIds) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RepositoryIds[0]
					e.Int(elem)
				}
				for _, elem := range s.RepositoryIds[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes AppsScopeTokenReq from json.
func (s *AppsScopeTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsScopeTokenReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			v, err := d.Str()
			s.AccessToken = string(v)
			if err != nil {
				return err
			}
		case "target":
			s.Target.Reset()
			if err := s.Target.Decode(d); err != nil {
				return err
			}
		case "target_id":
			s.TargetID.Reset()
			if err := s.TargetID.Decode(d); err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "repository_ids":
			s.RepositoryIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.RepositoryIds = append(s.RepositoryIds, elem)
				return nil
			}); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsSuspendInstallationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes AppsSuspendInstallationNoContent from json.
func (s *AppsSuspendInstallationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsSuspendInstallationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsUnsuspendInstallationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes AppsUnsuspendInstallationNoContent from json.
func (s *AppsUnsuspendInstallationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsUnsuspendInstallationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsUpdateWebhookConfigForAppReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes AppsUpdateWebhookConfigForAppReq from json.
func (s *AppsUpdateWebhookConfigForAppReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsUpdateWebhookConfigForAppReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl.Reset()
			if err := s.InsecureSsl.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Artifact) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"size_in_bytes\"" + ":")
		e.Int(s.SizeInBytes)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_download_url\"" + ":")
		e.Str(s.ArchiveDownloadURL)
	}
	{
		e.Comma()

		e.RawStr("\"expired\"" + ":")
		e.Bool(s.Expired)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"expires_at\"" + ":")
		s.ExpiresAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes Artifact from json.
func (s *Artifact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Artifact to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "size_in_bytes":
			v, err := d.Int()
			s.SizeInBytes = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "archive_download_url":
			v, err := d.Str()
			s.ArchiveDownloadURL = string(v)
			if err != nil {
				return err
			}
		case "expired":
			v, err := d.Bool()
			s.Expired = bool(v)
			if err != nil {
				return err
			}
		case "created_at":
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "expires_at":
			if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AuditLogEvent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Timestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Timestamp.Set {
			e.RawStr("\"@timestamp\"" + ":")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Action.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Action.Set {
			e.RawStr("\"action\"" + ":")
			s.Action.Encode(e)
		}
	}
	{
		if s.Active.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if s.ActiveWas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ActiveWas.Set {
			e.RawStr("\"active_was\"" + ":")
			s.ActiveWas.Encode(e)
		}
	}
	{
		if s.Actor.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Actor.Set {
			e.RawStr("\"actor\"" + ":")
			s.Actor.Encode(e)
		}
	}
	{
		if s.ActorID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ActorID.Set {
			e.RawStr("\"actor_id\"" + ":")
			s.ActorID.Encode(e)
		}
	}
	{
		if s.ActorLocation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ActorLocation.Set {
			e.RawStr("\"actor_location\"" + ":")
			s.ActorLocation.Encode(e)
		}
	}
	{
		if s.Data != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Data != nil {
			e.RawStr("\"data\"" + ":")
			s.Data.Encode(e)
		}
	}
	{
		if s.OrgID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrgID.Set {
			e.RawStr("\"org_id\"" + ":")
			s.OrgID.Encode(e)
		}
	}
	{
		if s.BlockedUser.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BlockedUser.Set {
			e.RawStr("\"blocked_user\"" + ":")
			s.BlockedUser.Encode(e)
		}
	}
	{
		if s.Business.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Business.Set {
			e.RawStr("\"business\"" + ":")
			s.Business.Encode(e)
		}
	}
	{
		if s.Config != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Config != nil {
			e.RawStr("\"config\"" + ":")
			e.ArrStart()
			if len(s.Config) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Config[0]
					e.Str(elem)
				}
				for _, elem := range s.Config[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ConfigWas != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConfigWas != nil {
			e.RawStr("\"config_was\"" + ":")
			e.ArrStart()
			if len(s.ConfigWas) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ConfigWas[0]
					e.Str(elem)
				}
				for _, elem := range s.ConfigWas[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ContentType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.DeployKeyFingerprint.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeployKeyFingerprint.Set {
			e.RawStr("\"deploy_key_fingerprint\"" + ":")
			s.DeployKeyFingerprint.Encode(e)
		}
	}
	{
		if s.DocumentID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentID.Set {
			e.RawStr("\"_document_id\"" + ":")
			s.DocumentID.Encode(e)
		}
	}
	{
		if s.Emoji.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Emoji.Set {
			e.RawStr("\"emoji\"" + ":")
			s.Emoji.Encode(e)
		}
	}
	{
		if s.Events != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Events != nil {
			e.RawStr("\"events\"" + ":")
			e.ArrStart()
			if len(s.Events) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Events[0]
					e.Str(elem)
				}
				for _, elem := range s.Events[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.EventsWere != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsWere != nil {
			e.RawStr("\"events_were\"" + ":")
			e.ArrStart()
			if len(s.EventsWere) >= 1 {
				// Encode first element without comma.
				{
					elem := s.EventsWere[0]
					e.Str(elem)
				}
				for _, elem := range s.EventsWere[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Explanation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Explanation.Set {
			e.RawStr("\"explanation\"" + ":")
			s.Explanation.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fingerprint.Set {
			e.RawStr("\"fingerprint\"" + ":")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.HookID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HookID.Set {
			e.RawStr("\"hook_id\"" + ":")
			s.HookID.Encode(e)
		}
	}
	{
		if s.LimitedAvailability.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LimitedAvailability.Set {
			e.RawStr("\"limited_availability\"" + ":")
			s.LimitedAvailability.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.OldUser.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OldUser.Set {
			e.RawStr("\"old_user\"" + ":")
			s.OldUser.Encode(e)
		}
	}
	{
		if s.OpensshPublicKey.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OpensshPublicKey.Set {
			e.RawStr("\"openssh_public_key\"" + ":")
			s.OpensshPublicKey.Encode(e)
		}
	}
	{
		if s.Org.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Org.Set {
			e.RawStr("\"org\"" + ":")
			s.Org.Encode(e)
		}
	}
	{
		if s.PreviousVisibility.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PreviousVisibility.Set {
			e.RawStr("\"previous_visibility\"" + ":")
			s.PreviousVisibility.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"read_only\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.Repo.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Repo.Set {
			e.RawStr("\"repo\"" + ":")
			s.Repo.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Repository.Set {
			e.RawStr("\"repository\"" + ":")
			s.Repository.Encode(e)
		}
	}
	{
		if s.RepositoryPublic.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RepositoryPublic.Set {
			e.RawStr("\"repository_public\"" + ":")
			s.RepositoryPublic.Encode(e)
		}
	}
	{
		if s.TargetLogin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TargetLogin.Set {
			e.RawStr("\"target_login\"" + ":")
			s.TargetLogin.Encode(e)
		}
	}
	{
		if s.Team.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Team.Set {
			e.RawStr("\"team\"" + ":")
			s.Team.Encode(e)
		}
	}
	{
		if s.TransportProtocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TransportProtocol.Set {
			e.RawStr("\"transport_protocol\"" + ":")
			s.TransportProtocol.Encode(e)
		}
	}
	{
		if s.TransportProtocolName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TransportProtocolName.Set {
			e.RawStr("\"transport_protocol_name\"" + ":")
			s.TransportProtocolName.Encode(e)
		}
	}
	{
		if s.User.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes AuditLogEvent from json.
func (s *AuditLogEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuditLogEvent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "@timestamp":
			s.Timestamp.Reset()
			if err := s.Timestamp.Decode(d); err != nil {
				return err
			}
		case "action":
			s.Action.Reset()
			if err := s.Action.Decode(d); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		case "active_was":
			s.ActiveWas.Reset()
			if err := s.ActiveWas.Decode(d); err != nil {
				return err
			}
		case "actor":
			s.Actor.Reset()
			if err := s.Actor.Decode(d); err != nil {
				return err
			}
		case "actor_id":
			s.ActorID.Reset()
			if err := s.ActorID.Decode(d); err != nil {
				return err
			}
		case "actor_location":
			s.ActorLocation.Reset()
			if err := s.ActorLocation.Decode(d); err != nil {
				return err
			}
		case "data":
			s.Data = nil
			var elem AuditLogEventData
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Data = &elem
		case "org_id":
			s.OrgID.Reset()
			if err := s.OrgID.Decode(d); err != nil {
				return err
			}
		case "blocked_user":
			s.BlockedUser.Reset()
			if err := s.BlockedUser.Decode(d); err != nil {
				return err
			}
		case "business":
			s.Business.Reset()
			if err := s.Business.Decode(d); err != nil {
				return err
			}
		case "config":
			s.Config = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Config = append(s.Config, elem)
				return nil
			}); err != nil {
				return err
			}
		case "config_was":
			s.ConfigWas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.ConfigWas = append(s.ConfigWas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "deploy_key_fingerprint":
			s.DeployKeyFingerprint.Reset()
			if err := s.DeployKeyFingerprint.Decode(d); err != nil {
				return err
			}
		case "_document_id":
			s.DocumentID.Reset()
			if err := s.DocumentID.Decode(d); err != nil {
				return err
			}
		case "emoji":
			s.Emoji.Reset()
			if err := s.Emoji.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "events_were":
			s.EventsWere = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.EventsWere = append(s.EventsWere, elem)
				return nil
			}); err != nil {
				return err
			}
		case "explanation":
			s.Explanation.Reset()
			if err := s.Explanation.Decode(d); err != nil {
				return err
			}
		case "fingerprint":
			s.Fingerprint.Reset()
			if err := s.Fingerprint.Decode(d); err != nil {
				return err
			}
		case "hook_id":
			s.HookID.Reset()
			if err := s.HookID.Decode(d); err != nil {
				return err
			}
		case "limited_availability":
			s.LimitedAvailability.Reset()
			if err := s.LimitedAvailability.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "old_user":
			s.OldUser.Reset()
			if err := s.OldUser.Decode(d); err != nil {
				return err
			}
		case "openssh_public_key":
			s.OpensshPublicKey.Reset()
			if err := s.OpensshPublicKey.Decode(d); err != nil {
				return err
			}
		case "org":
			s.Org.Reset()
			if err := s.Org.Decode(d); err != nil {
				return err
			}
		case "previous_visibility":
			s.PreviousVisibility.Reset()
			if err := s.PreviousVisibility.Decode(d); err != nil {
				return err
			}
		case "read_only":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "repo":
			s.Repo.Reset()
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		case "repository":
			s.Repository.Reset()
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "repository_public":
			s.RepositoryPublic.Reset()
			if err := s.RepositoryPublic.Decode(d); err != nil {
				return err
			}
		case "target_login":
			s.TargetLogin.Reset()
			if err := s.TargetLogin.Decode(d); err != nil {
				return err
			}
		case "team":
			s.Team.Reset()
			if err := s.Team.Decode(d); err != nil {
				return err
			}
		case "transport_protocol":
			s.TransportProtocol.Reset()
			if err := s.TransportProtocol.Decode(d); err != nil {
				return err
			}
		case "transport_protocol_name":
			s.TransportProtocolName.Reset()
			if err := s.TransportProtocolName.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AuditLogEventActorLocation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CountryName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CountryName.Set {
			e.RawStr("\"country_name\"" + ":")
			s.CountryName.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes AuditLogEventActorLocation from json.
func (s *AuditLogEventActorLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuditLogEventActorLocation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "country_name":
			s.CountryName.Reset()
			if err := s.CountryName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AuditLogEventData) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes AuditLogEventData from json.
func (s *AuditLogEventData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuditLogEventData to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AuthenticationToken) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"token\"" + ":")
		e.Str(s.Token)
	}
	{
		e.Comma()

		e.RawStr("\"expires_at\"" + ":")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		if s.Permissions != nil {
			e.Comma()
		}
		if s.Permissions != nil {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.Repositories != nil {
			e.Comma()
		}
		if s.Repositories != nil {
			e.RawStr("\"repositories\"" + ":")
			e.ArrStart()
			if len(s.Repositories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Repositories[0]
					elem.Encode(e)
				}
				for _, elem := range s.Repositories[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.SingleFile.Set {
			e.Comma()
		}
		if s.SingleFile.Set {
			e.RawStr("\"single_file\"" + ":")
			s.SingleFile.Encode(e)
		}
	}
	{
		if s.RepositorySelection.Set {
			e.Comma()
		}
		if s.RepositorySelection.Set {
			e.RawStr("\"repository_selection\"" + ":")
			s.RepositorySelection.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes AuthenticationToken from json.
func (s *AuthenticationToken) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuthenticationToken to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			v, err := d.Str()
			s.Token = string(v)
			if err != nil {
				return err
			}
		case "expires_at":
			v, err := json.DecodeDateTime(d)
			s.ExpiresAt = v
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions = nil
			var elem AuthenticationTokenPermissions
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Permissions = &elem
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Repository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "single_file":
			s.SingleFile.Reset()
			if err := s.SingleFile.Decode(d); err != nil {
				return err
			}
		case "repository_selection":
			s.RepositorySelection.Reset()
			if err := s.RepositorySelection.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AuthenticationTokenPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes AuthenticationTokenPermissions from json.
func (s *AuthenticationTokenPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuthenticationTokenPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AuthenticationTokenRepositorySelection as json.
func (s AuthenticationTokenRepositorySelection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AuthenticationTokenRepositorySelection from json.
func (s *AuthenticationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuthenticationTokenRepositorySelection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuthenticationTokenRepositorySelection(v) {
	case AuthenticationTokenRepositorySelectionAll:
		*s = AuthenticationTokenRepositorySelectionAll
	case AuthenticationTokenRepositorySelectionSelected:
		*s = AuthenticationTokenRepositorySelectionSelected
	default:
		*s = AuthenticationTokenRepositorySelection(v)
	}

	return nil
}

// Encode encodes AuthorAssociation as json.
func (s AuthorAssociation) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AuthorAssociation from json.
func (s *AuthorAssociation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuthorAssociation to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuthorAssociation(v) {
	case AuthorAssociationCOLLABORATOR:
		*s = AuthorAssociationCOLLABORATOR
	case AuthorAssociationCONTRIBUTOR:
		*s = AuthorAssociationCONTRIBUTOR
	case AuthorAssociationFIRSTTIMER:
		*s = AuthorAssociationFIRSTTIMER
	case AuthorAssociationFIRSTTIMECONTRIBUTOR:
		*s = AuthorAssociationFIRSTTIMECONTRIBUTOR
	case AuthorAssociationMANNEQUIN:
		*s = AuthorAssociationMANNEQUIN
	case AuthorAssociationMEMBER:
		*s = AuthorAssociationMEMBER
	case AuthorAssociationNONE:
		*s = AuthorAssociationNONE
	case AuthorAssociationOWNER:
		*s = AuthorAssociationOWNER
	default:
		*s = AuthorAssociation(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Authorization) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"scopes\"" + ":")
		if s.Scopes == nil {
			e.Null()
		} else {
			e.ArrStart()
			if len(s.Scopes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Scopes[0]
					e.Str(elem)
				}
				for _, elem := range s.Scopes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"token\"" + ":")
		e.Str(s.Token)
	}
	{
		e.Comma()

		e.RawStr("\"token_last_eight\"" + ":")
		s.TokenLastEight.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"hashed_token\"" + ":")
		s.HashedToken.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"app\"" + ":")
		s.App.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"note\"" + ":")
		s.Note.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"note_url\"" + ":")
		s.NoteURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"fingerprint\"" + ":")
		s.Fingerprint.Encode(e)
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	{
		if s.Installation.Set {
			e.Comma()
		}
		if s.Installation.Set {
			e.RawStr("\"installation\"" + ":")
			s.Installation.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"expires_at\"" + ":")
		s.ExpiresAt.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes Authorization from json.
func (s *Authorization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Authorization to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "scopes":
			s.Scopes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Scopes = append(s.Scopes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "token":
			v, err := d.Str()
			s.Token = string(v)
			if err != nil {
				return err
			}
		case "token_last_eight":
			if err := s.TokenLastEight.Decode(d); err != nil {
				return err
			}
		case "hashed_token":
			if err := s.HashedToken.Decode(d); err != nil {
				return err
			}
		case "app":
			if err := s.App.Decode(d); err != nil {
				return err
			}
		case "note":
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "note_url":
			if err := s.NoteURL.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "fingerprint":
			if err := s.Fingerprint.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "installation":
			s.Installation.Reset()
			if err := s.Installation.Decode(d); err != nil {
				return err
			}
		case "expires_at":
			if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AuthorizationApp) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"client_id\"" + ":")
		e.Str(s.ClientID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

// Decode decodes AuthorizationApp from json.
func (s *AuthorizationApp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuthorizationApp to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_id":
			v, err := d.Str()
			s.ClientID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AutoMerge) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled_by\"" + ":")
		s.EnabledBy.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"merge_method\"" + ":")
		s.MergeMethod.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commit_title\"" + ":")
		e.Str(s.CommitTitle)
	}
	{
		e.Comma()

		e.RawStr("\"commit_message\"" + ":")
		e.Str(s.CommitMessage)
	}
	e.ObjEnd()
}

// Decode decodes AutoMerge from json.
func (s *AutoMerge) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AutoMerge to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_by":
			if err := s.EnabledBy.Decode(d); err != nil {
				return err
			}
		case "merge_method":
			if err := s.MergeMethod.Decode(d); err != nil {
				return err
			}
		case "commit_title":
			v, err := d.Str()
			s.CommitTitle = string(v)
			if err != nil {
				return err
			}
		case "commit_message":
			v, err := d.Str()
			s.CommitMessage = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AutoMergeMergeMethod as json.
func (s AutoMergeMergeMethod) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AutoMergeMergeMethod from json.
func (s *AutoMergeMergeMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AutoMergeMergeMethod to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AutoMergeMergeMethod(v) {
	case AutoMergeMergeMethodMerge:
		*s = AutoMergeMergeMethodMerge
	case AutoMergeMergeMethodSquash:
		*s = AutoMergeMergeMethodSquash
	case AutoMergeMergeMethodRebase:
		*s = AutoMergeMergeMethodRebase
	default:
		*s = AutoMergeMergeMethod(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Autolink) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"key_prefix\"" + ":")
		e.Str(s.KeyPrefix)
	}
	{
		e.Comma()

		e.RawStr("\"url_template\"" + ":")
		e.Str(s.URLTemplate)
	}
	e.ObjEnd()
}

// Decode decodes Autolink from json.
func (s *Autolink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Autolink to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "key_prefix":
			v, err := d.Str()
			s.KeyPrefix = string(v)
			if err != nil {
				return err
			}
		case "url_template":
			v, err := d.Str()
			s.URLTemplate = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BaseGist) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		json.EncodeURI(e, s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"git_pull_url\"" + ":")
		json.EncodeURI(e, s.GitPullURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_push_url\"" + ":")
		json.EncodeURI(e, s.GitPushURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"files\"" + ":")
		s.Files.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"public\"" + ":")
		e.Bool(s.Public)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comments\"" + ":")
		e.Int(s.Comments)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		if s.Owner.Set {
			e.Comma()
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Truncated.Set {
			e.Comma()
		}
		if s.Truncated.Set {
			e.RawStr("\"truncated\"" + ":")
			s.Truncated.Encode(e)
		}
	}
	{
		if s.Forks != nil {
			e.Comma()
		}
		if s.Forks != nil {
			e.RawStr("\"forks\"" + ":")
			e.ArrStart()
			if len(s.Forks) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Forks[0]
					e.Str(elem)
				}
				for _, elem := range s.Forks[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.History != nil {
			e.Comma()
		}
		if s.History != nil {
			e.RawStr("\"history\"" + ":")
			e.ArrStart()
			if len(s.History) >= 1 {
				// Encode first element without comma.
				{
					elem := s.History[0]
					e.Str(elem)
				}
				for _, elem := range s.History[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes BaseGist from json.
func (s *BaseGist) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BaseGist to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := json.DecodeURI(d)
			s.CommitsURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "git_pull_url":
			v, err := json.DecodeURI(d)
			s.GitPullURL = v
			if err != nil {
				return err
			}
		case "git_push_url":
			v, err := json.DecodeURI(d)
			s.GitPushURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "files":
			if err := s.Files.Decode(d); err != nil {
				return err
			}
		case "public":
			v, err := d.Bool()
			s.Public = bool(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "comments":
			v, err := d.Int()
			s.Comments = int(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "truncated":
			s.Truncated.Reset()
			if err := s.Truncated.Decode(d); err != nil {
				return err
			}
		case "forks":
			s.Forks = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Forks = append(s.Forks, elem)
				return nil
			}); err != nil {
				return err
			}
		case "history":
			s.History = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.History = append(s.History, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BaseGistFiles) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes BaseGistFiles from json.
func (s *BaseGistFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BaseGistFiles to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BasicError) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes BasicError from json.
func (s *BasicError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BasicError to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Blob) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		e.Str(s.Content)
	}
	{
		e.Comma()

		e.RawStr("\"encoding\"" + ":")
		e.Str(s.Encoding)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		s.Size.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		if s.HighlightedContent.Set {
			e.Comma()
		}
		if s.HighlightedContent.Set {
			e.RawStr("\"highlighted_content\"" + ":")
			s.HighlightedContent.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes Blob from json.
func (s *Blob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Blob to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			v, err := d.Str()
			s.Content = string(v)
			if err != nil {
				return err
			}
		case "encoding":
			v, err := d.Str()
			s.Encoding = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "size":
			if err := s.Size.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "highlighted_content":
			s.HighlightedContent.Reset()
			if err := s.HighlightedContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchProtection) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Enabled.Set {
			e.RawStr("\"enabled\"" + ":")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.RequiredStatusChecks.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredStatusChecks.Set {
			e.RawStr("\"required_status_checks\"" + ":")
			s.RequiredStatusChecks.Encode(e)
		}
	}
	{
		if s.EnforceAdmins.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EnforceAdmins.Set {
			e.RawStr("\"enforce_admins\"" + ":")
			s.EnforceAdmins.Encode(e)
		}
	}
	{
		if s.RequiredPullRequestReviews.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredPullRequestReviews.Set {
			e.RawStr("\"required_pull_request_reviews\"" + ":")
			s.RequiredPullRequestReviews.Encode(e)
		}
	}
	{
		if s.Restrictions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Restrictions.Set {
			e.RawStr("\"restrictions\"" + ":")
			s.Restrictions.Encode(e)
		}
	}
	{
		if s.RequiredLinearHistory.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredLinearHistory.Set {
			e.RawStr("\"required_linear_history\"" + ":")
			s.RequiredLinearHistory.Encode(e)
		}
	}
	{
		if s.AllowForcePushes.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowForcePushes.Set {
			e.RawStr("\"allow_force_pushes\"" + ":")
			s.AllowForcePushes.Encode(e)
		}
	}
	{
		if s.AllowDeletions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowDeletions.Set {
			e.RawStr("\"allow_deletions\"" + ":")
			s.AllowDeletions.Encode(e)
		}
	}
	{
		if s.RequiredConversationResolution.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredConversationResolution.Set {
			e.RawStr("\"required_conversation_resolution\"" + ":")
			s.RequiredConversationResolution.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.ProtectionURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ProtectionURL.Set {
			e.RawStr("\"protection_url\"" + ":")
			s.ProtectionURL.Encode(e)
		}
	}
	{
		if s.RequiredSignatures.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredSignatures.Set {
			e.RawStr("\"required_signatures\"" + ":")
			s.RequiredSignatures.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes BranchProtection from json.
func (s *BranchProtection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchProtection to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "enabled":
			s.Enabled.Reset()
			if err := s.Enabled.Decode(d); err != nil {
				return err
			}
		case "required_status_checks":
			s.RequiredStatusChecks.Reset()
			if err := s.RequiredStatusChecks.Decode(d); err != nil {
				return err
			}
		case "enforce_admins":
			s.EnforceAdmins.Reset()
			if err := s.EnforceAdmins.Decode(d); err != nil {
				return err
			}
		case "required_pull_request_reviews":
			s.RequiredPullRequestReviews.Reset()
			if err := s.RequiredPullRequestReviews.Decode(d); err != nil {
				return err
			}
		case "restrictions":
			s.Restrictions.Reset()
			if err := s.Restrictions.Decode(d); err != nil {
				return err
			}
		case "required_linear_history":
			s.RequiredLinearHistory.Reset()
			if err := s.RequiredLinearHistory.Decode(d); err != nil {
				return err
			}
		case "allow_force_pushes":
			s.AllowForcePushes.Reset()
			if err := s.AllowForcePushes.Decode(d); err != nil {
				return err
			}
		case "allow_deletions":
			s.AllowDeletions.Reset()
			if err := s.AllowDeletions.Decode(d); err != nil {
				return err
			}
		case "required_conversation_resolution":
			s.RequiredConversationResolution.Reset()
			if err := s.RequiredConversationResolution.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "protection_url":
			s.ProtectionURL.Reset()
			if err := s.ProtectionURL.Decode(d); err != nil {
				return err
			}
		case "required_signatures":
			s.RequiredSignatures.Reset()
			if err := s.RequiredSignatures.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchProtectionAllowDeletions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Enabled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Enabled.Set {
			e.RawStr("\"enabled\"" + ":")
			s.Enabled.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes BranchProtectionAllowDeletions from json.
func (s *BranchProtectionAllowDeletions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchProtectionAllowDeletions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			s.Enabled.Reset()
			if err := s.Enabled.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchProtectionAllowForcePushes) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Enabled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Enabled.Set {
			e.RawStr("\"enabled\"" + ":")
			s.Enabled.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes BranchProtectionAllowForcePushes from json.
func (s *BranchProtectionAllowForcePushes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchProtectionAllowForcePushes to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			s.Enabled.Reset()
			if err := s.Enabled.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchProtectionRequiredConversationResolution) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Enabled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Enabled.Set {
			e.RawStr("\"enabled\"" + ":")
			s.Enabled.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes BranchProtectionRequiredConversationResolution from json.
func (s *BranchProtectionRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchProtectionRequiredConversationResolution to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			s.Enabled.Reset()
			if err := s.Enabled.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchProtectionRequiredLinearHistory) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Enabled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Enabled.Set {
			e.RawStr("\"enabled\"" + ":")
			s.Enabled.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes BranchProtectionRequiredLinearHistory from json.
func (s *BranchProtectionRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchProtectionRequiredLinearHistory to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			s.Enabled.Reset()
			if err := s.Enabled.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchProtectionRequiredSignatures) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"enabled\"" + ":")
		e.Bool(s.Enabled)
	}
	e.ObjEnd()
}

// Decode decodes BranchProtectionRequiredSignatures from json.
func (s *BranchProtectionRequiredSignatures) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchProtectionRequiredSignatures to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "enabled":
			v, err := d.Bool()
			s.Enabled = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchProtectionRequiredStatusChecks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.EnforcementLevel.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EnforcementLevel.Set {
			e.RawStr("\"enforcement_level\"" + ":")
			s.EnforcementLevel.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"contexts\"" + ":")
		e.ArrStart()
		if len(s.Contexts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Contexts[0]
				e.Str(elem)
			}
			for _, elem := range s.Contexts[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.ContextsURL.Set {
			e.Comma()
		}
		if s.ContextsURL.Set {
			e.RawStr("\"contexts_url\"" + ":")
			s.ContextsURL.Encode(e)
		}
	}
	{
		if s.Strict.Set {
			e.Comma()
		}
		if s.Strict.Set {
			e.RawStr("\"strict\"" + ":")
			s.Strict.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes BranchProtectionRequiredStatusChecks from json.
func (s *BranchProtectionRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchProtectionRequiredStatusChecks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "enforcement_level":
			s.EnforcementLevel.Reset()
			if err := s.EnforcementLevel.Decode(d); err != nil {
				return err
			}
		case "contexts":
			s.Contexts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Contexts = append(s.Contexts, elem)
				return nil
			}); err != nil {
				return err
			}
		case "contexts_url":
			s.ContextsURL.Reset()
			if err := s.ContextsURL.Decode(d); err != nil {
				return err
			}
		case "strict":
			s.Strict.Reset()
			if err := s.Strict.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"users_url\"" + ":")
		json.EncodeURI(e, s.UsersURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"apps_url\"" + ":")
		json.EncodeURI(e, s.AppsURL)
	}
	{
		e.Comma()

		e.RawStr("\"users\"" + ":")
		e.ArrStart()
		if len(s.Users) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Users[0]
				elem.Encode(e)
			}
			for _, elem := range s.Users[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"teams\"" + ":")
		e.ArrStart()
		if len(s.Teams) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Teams[0]
				elem.Encode(e)
			}
			for _, elem := range s.Teams[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"apps\"" + ":")
		e.ArrStart()
		if len(s.Apps) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Apps[0]
				elem.Encode(e)
			}
			for _, elem := range s.Apps[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes BranchRestrictionPolicy from json.
func (s *BranchRestrictionPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchRestrictionPolicy to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "users_url":
			v, err := json.DecodeURI(d)
			s.UsersURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "apps_url":
			v, err := json.DecodeURI(d)
			s.AppsURL = v
			if err != nil {
				return err
			}
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem BranchRestrictionPolicyUsersItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem BranchRestrictionPolicyTeamsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		case "apps":
			s.Apps = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem BranchRestrictionPolicyAppsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Apps = append(s.Apps, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicyAppsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Slug.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Slug.Set {
			e.RawStr("\"slug\"" + ":")
			s.Slug.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.Owner.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.ExternalURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalURL.Set {
			e.RawStr("\"external_url\"" + ":")
			s.ExternalURL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.Permissions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.Events != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Events != nil {
			e.RawStr("\"events\"" + ":")
			e.ArrStart()
			if len(s.Events) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Events[0]
					e.Str(elem)
				}
				for _, elem := range s.Events[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes BranchRestrictionPolicyAppsItem from json.
func (s *BranchRestrictionPolicyAppsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchRestrictionPolicyAppsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "slug":
			s.Slug.Reset()
			if err := s.Slug.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "external_url":
			s.ExternalURL.Reset()
			if err := s.ExternalURL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicyAppsItemOwner) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Login.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Login.Set {
			e.RawStr("\"login\"" + ":")
			s.Login.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ReposURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReposURL.Set {
			e.RawStr("\"repos_url\"" + ":")
			s.ReposURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsURL.Set {
			e.RawStr("\"events_url\"" + ":")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.HooksURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HooksURL.Set {
			e.RawStr("\"hooks_url\"" + ":")
			s.HooksURL.Encode(e)
		}
	}
	{
		if s.IssuesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IssuesURL.Set {
			e.RawStr("\"issues_url\"" + ":")
			s.IssuesURL.Encode(e)
		}
	}
	{
		if s.MembersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersURL.Set {
			e.RawStr("\"members_url\"" + ":")
			s.MembersURL.Encode(e)
		}
	}
	{
		if s.PublicMembersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PublicMembersURL.Set {
			e.RawStr("\"public_members_url\"" + ":")
			s.PublicMembersURL.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvatarURL.Set {
			e.RawStr("\"avatar_url\"" + ":")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.GravatarID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GravatarID.Set {
			e.RawStr("\"gravatar_id\"" + ":")
			s.GravatarID.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.FollowersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowersURL.Set {
			e.RawStr("\"followers_url\"" + ":")
			s.FollowersURL.Encode(e)
		}
	}
	{
		if s.FollowingURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowingURL.Set {
			e.RawStr("\"following_url\"" + ":")
			s.FollowingURL.Encode(e)
		}
	}
	{
		if s.GistsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GistsURL.Set {
			e.RawStr("\"gists_url\"" + ":")
			s.GistsURL.Encode(e)
		}
	}
	{
		if s.StarredURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StarredURL.Set {
			e.RawStr("\"starred_url\"" + ":")
			s.StarredURL.Encode(e)
		}
	}
	{
		if s.SubscriptionsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscriptionsURL.Set {
			e.RawStr("\"subscriptions_url\"" + ":")
			s.SubscriptionsURL.Encode(e)
		}
	}
	{
		if s.OrganizationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationsURL.Set {
			e.RawStr("\"organizations_url\"" + ":")
			s.OrganizationsURL.Encode(e)
		}
	}
	{
		if s.ReceivedEventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReceivedEventsURL.Set {
			e.RawStr("\"received_events_url\"" + ":")
			s.ReceivedEventsURL.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.SiteAdmin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SiteAdmin.Set {
			e.RawStr("\"site_admin\"" + ":")
			s.SiteAdmin.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes BranchRestrictionPolicyAppsItemOwner from json.
func (s *BranchRestrictionPolicyAppsItemOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchRestrictionPolicyAppsItemOwner to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			s.Login.Reset()
			if err := s.Login.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "repos_url":
			s.ReposURL.Reset()
			if err := s.ReposURL.Decode(d); err != nil {
				return err
			}
		case "events_url":
			s.EventsURL.Reset()
			if err := s.EventsURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			s.HooksURL.Reset()
			if err := s.HooksURL.Decode(d); err != nil {
				return err
			}
		case "issues_url":
			s.IssuesURL.Reset()
			if err := s.IssuesURL.Decode(d); err != nil {
				return err
			}
		case "members_url":
			s.MembersURL.Reset()
			if err := s.MembersURL.Decode(d); err != nil {
				return err
			}
		case "public_members_url":
			s.PublicMembersURL.Reset()
			if err := s.PublicMembersURL.Decode(d); err != nil {
				return err
			}
		case "avatar_url":
			s.AvatarURL.Reset()
			if err := s.AvatarURL.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "gravatar_id":
			s.GravatarID.Reset()
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "followers_url":
			s.FollowersURL.Reset()
			if err := s.FollowersURL.Decode(d); err != nil {
				return err
			}
		case "following_url":
			s.FollowingURL.Reset()
			if err := s.FollowingURL.Decode(d); err != nil {
				return err
			}
		case "gists_url":
			s.GistsURL.Reset()
			if err := s.GistsURL.Decode(d); err != nil {
				return err
			}
		case "starred_url":
			s.StarredURL.Reset()
			if err := s.StarredURL.Decode(d); err != nil {
				return err
			}
		case "subscriptions_url":
			s.SubscriptionsURL.Reset()
			if err := s.SubscriptionsURL.Decode(d); err != nil {
				return err
			}
		case "organizations_url":
			s.OrganizationsURL.Reset()
			if err := s.OrganizationsURL.Decode(d); err != nil {
				return err
			}
		case "received_events_url":
			s.ReceivedEventsURL.Reset()
			if err := s.ReceivedEventsURL.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "site_admin":
			s.SiteAdmin.Reset()
			if err := s.SiteAdmin.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicyAppsItemPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Contents.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Contents.Set {
			e.RawStr("\"contents\"" + ":")
			s.Contents.Encode(e)
		}
	}
	{
		if s.Issues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Issues.Set {
			e.RawStr("\"issues\"" + ":")
			s.Issues.Encode(e)
		}
	}
	{
		if s.SingleFile.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SingleFile.Set {
			e.RawStr("\"single_file\"" + ":")
			s.SingleFile.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes BranchRestrictionPolicyAppsItemPermissions from json.
func (s *BranchRestrictionPolicyAppsItemPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchRestrictionPolicyAppsItemPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "contents":
			s.Contents.Reset()
			if err := s.Contents.Decode(d); err != nil {
				return err
			}
		case "issues":
			s.Issues.Reset()
			if err := s.Issues.Decode(d); err != nil {
				return err
			}
		case "single_file":
			s.SingleFile.Reset()
			if err := s.SingleFile.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicyTeamsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Slug.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Slug.Set {
			e.RawStr("\"slug\"" + ":")
			s.Slug.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Privacy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	{
		if s.MembersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersURL.Set {
			e.RawStr("\"members_url\"" + ":")
			s.MembersURL.Encode(e)
		}
	}
	{
		if s.RepositoriesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RepositoriesURL.Set {
			e.RawStr("\"repositories_url\"" + ":")
			s.RepositoriesURL.Encode(e)
		}
	}
	{
		if s.Parent.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Parent.Set {
			e.RawStr("\"parent\"" + ":")
			s.Parent.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes BranchRestrictionPolicyTeamsItem from json.
func (s *BranchRestrictionPolicyTeamsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchRestrictionPolicyTeamsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "slug":
			s.Slug.Reset()
			if err := s.Slug.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		case "members_url":
			s.MembersURL.Reset()
			if err := s.MembersURL.Decode(d); err != nil {
				return err
			}
		case "repositories_url":
			s.RepositoriesURL.Reset()
			if err := s.RepositoriesURL.Decode(d); err != nil {
				return err
			}
		case "parent":
			s.Parent.Reset()
			if err := s.Parent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicyUsersItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Login.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Login.Set {
			e.RawStr("\"login\"" + ":")
			s.Login.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvatarURL.Set {
			e.RawStr("\"avatar_url\"" + ":")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.GravatarID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GravatarID.Set {
			e.RawStr("\"gravatar_id\"" + ":")
			s.GravatarID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.FollowersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowersURL.Set {
			e.RawStr("\"followers_url\"" + ":")
			s.FollowersURL.Encode(e)
		}
	}
	{
		if s.FollowingURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowingURL.Set {
			e.RawStr("\"following_url\"" + ":")
			s.FollowingURL.Encode(e)
		}
	}
	{
		if s.GistsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GistsURL.Set {
			e.RawStr("\"gists_url\"" + ":")
			s.GistsURL.Encode(e)
		}
	}
	{
		if s.StarredURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StarredURL.Set {
			e.RawStr("\"starred_url\"" + ":")
			s.StarredURL.Encode(e)
		}
	}
	{
		if s.SubscriptionsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscriptionsURL.Set {
			e.RawStr("\"subscriptions_url\"" + ":")
			s.SubscriptionsURL.Encode(e)
		}
	}
	{
		if s.OrganizationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationsURL.Set {
			e.RawStr("\"organizations_url\"" + ":")
			s.OrganizationsURL.Encode(e)
		}
	}
	{
		if s.ReposURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReposURL.Set {
			e.RawStr("\"repos_url\"" + ":")
			s.ReposURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsURL.Set {
			e.RawStr("\"events_url\"" + ":")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ReceivedEventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReceivedEventsURL.Set {
			e.RawStr("\"received_events_url\"" + ":")
			s.ReceivedEventsURL.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.SiteAdmin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SiteAdmin.Set {
			e.RawStr("\"site_admin\"" + ":")
			s.SiteAdmin.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes BranchRestrictionPolicyUsersItem from json.
func (s *BranchRestrictionPolicyUsersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchRestrictionPolicyUsersItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			s.Login.Reset()
			if err := s.Login.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "avatar_url":
			s.AvatarURL.Reset()
			if err := s.AvatarURL.Decode(d); err != nil {
				return err
			}
		case "gravatar_id":
			s.GravatarID.Reset()
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "followers_url":
			s.FollowersURL.Reset()
			if err := s.FollowersURL.Decode(d); err != nil {
				return err
			}
		case "following_url":
			s.FollowingURL.Reset()
			if err := s.FollowingURL.Decode(d); err != nil {
				return err
			}
		case "gists_url":
			s.GistsURL.Reset()
			if err := s.GistsURL.Decode(d); err != nil {
				return err
			}
		case "starred_url":
			s.StarredURL.Reset()
			if err := s.StarredURL.Decode(d); err != nil {
				return err
			}
		case "subscriptions_url":
			s.SubscriptionsURL.Reset()
			if err := s.SubscriptionsURL.Decode(d); err != nil {
				return err
			}
		case "organizations_url":
			s.OrganizationsURL.Reset()
			if err := s.OrganizationsURL.Decode(d); err != nil {
				return err
			}
		case "repos_url":
			s.ReposURL.Reset()
			if err := s.ReposURL.Decode(d); err != nil {
				return err
			}
		case "events_url":
			s.EventsURL.Reset()
			if err := s.EventsURL.Decode(d); err != nil {
				return err
			}
		case "received_events_url":
			s.ReceivedEventsURL.Reset()
			if err := s.ReceivedEventsURL.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "site_admin":
			s.SiteAdmin.Reset()
			if err := s.SiteAdmin.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchShort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		s.Commit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"protected\"" + ":")
		e.Bool(s.Protected)
	}
	e.ObjEnd()
}

// Decode decodes BranchShort from json.
func (s *BranchShort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchShort to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "commit":
			if err := s.Commit.Decode(d); err != nil {
				return err
			}
		case "protected":
			v, err := d.Bool()
			s.Protected = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchShortCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	e.ObjEnd()
}

// Decode decodes BranchShortCommit from json.
func (s *BranchShortCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchShortCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchWithProtection) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		s.Commit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"protected\"" + ":")
		e.Bool(s.Protected)
	}
	{
		e.Comma()

		e.RawStr("\"protection\"" + ":")
		s.Protection.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"protection_url\"" + ":")
		json.EncodeURI(e, s.ProtectionURL)
	}
	{
		if s.Pattern.Set {
			e.Comma()
		}
		if s.Pattern.Set {
			e.RawStr("\"pattern\"" + ":")
			s.Pattern.Encode(e)
		}
	}
	{
		if s.RequiredApprovingReviewCount.Set {
			e.Comma()
		}
		if s.RequiredApprovingReviewCount.Set {
			e.RawStr("\"required_approving_review_count\"" + ":")
			s.RequiredApprovingReviewCount.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes BranchWithProtection from json.
func (s *BranchWithProtection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchWithProtection to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "commit":
			if err := s.Commit.Decode(d); err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "protected":
			v, err := d.Bool()
			s.Protected = bool(v)
			if err != nil {
				return err
			}
		case "protection":
			if err := s.Protection.Decode(d); err != nil {
				return err
			}
		case "protection_url":
			v, err := json.DecodeURI(d)
			s.ProtectionURL = v
			if err != nil {
				return err
			}
		case "pattern":
			s.Pattern.Reset()
			if err := s.Pattern.Decode(d); err != nil {
				return err
			}
		case "required_approving_review_count":
			s.RequiredApprovingReviewCount.Reset()
			if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchWithProtectionLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"html\"" + ":")
		e.Str(s.HTML)
	}
	{
		e.Comma()

		e.RawStr("\"self\"" + ":")
		json.EncodeURI(e, s.Self)
	}
	e.ObjEnd()
}

// Decode decodes BranchWithProtectionLinks from json.
func (s *BranchWithProtectionLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchWithProtectionLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "html":
			v, err := d.Str()
			s.HTML = string(v)
			if err != nil {
				return err
			}
		case "self":
			v, err := json.DecodeURI(d)
			s.Self = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CheckAnnotation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"start_line\"" + ":")
		e.Int(s.StartLine)
	}
	{
		e.Comma()

		e.RawStr("\"end_line\"" + ":")
		e.Int(s.EndLine)
	}
	{
		e.Comma()

		e.RawStr("\"start_column\"" + ":")
		s.StartColumn.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"end_column\"" + ":")
		s.EndColumn.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"annotation_level\"" + ":")
		s.AnnotationLevel.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		s.Title.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		s.Message.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"raw_details\"" + ":")
		s.RawDetails.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"blob_href\"" + ":")
		e.Str(s.BlobHref)
	}
	e.ObjEnd()
}

// Decode decodes CheckAnnotation from json.
func (s *CheckAnnotation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckAnnotation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "start_line":
			v, err := d.Int()
			s.StartLine = int(v)
			if err != nil {
				return err
			}
		case "end_line":
			v, err := d.Int()
			s.EndLine = int(v)
			if err != nil {
				return err
			}
		case "start_column":
			if err := s.StartColumn.Decode(d); err != nil {
				return err
			}
		case "end_column":
			if err := s.EndColumn.Decode(d); err != nil {
				return err
			}
		case "annotation_level":
			if err := s.AnnotationLevel.Decode(d); err != nil {
				return err
			}
		case "title":
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "message":
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "raw_details":
			if err := s.RawDetails.Decode(d); err != nil {
				return err
			}
		case "blob_href":
			v, err := d.Str()
			s.BlobHref = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CheckRun) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"head_sha\"" + ":")
		e.Str(s.HeadSha)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"external_id\"" + ":")
		s.ExternalID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"details_url\"" + ":")
		s.DetailsURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"conclusion\"" + ":")
		s.Conclusion.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"started_at\"" + ":")
		s.StartedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"completed_at\"" + ":")
		s.CompletedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"output\"" + ":")
		s.Output.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"check_suite\"" + ":")
		s.CheckSuite.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"app\"" + ":")
		s.App.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pull_requests\"" + ":")
		e.Str(s.PullRequests)
	}
	{
		if s.Deployment.Set {
			e.Comma()
		}
		if s.Deployment.Set {
			e.RawStr("\"deployment\"" + ":")
			s.Deployment.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CheckRun from json.
func (s *CheckRun) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckRun to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "head_sha":
			v, err := d.Str()
			s.HeadSha = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "external_id":
			if err := s.ExternalID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "details_url":
			if err := s.DetailsURL.Decode(d); err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "conclusion":
			if err := s.Conclusion.Decode(d); err != nil {
				return err
			}
		case "started_at":
			if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "completed_at":
			if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "output":
			if err := s.Output.Decode(d); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "check_suite":
			if err := s.CheckSuite.Decode(d); err != nil {
				return err
			}
		case "app":
			if err := s.App.Decode(d); err != nil {
				return err
			}
		case "pull_requests":
			v, err := d.Str()
			s.PullRequests = string(v)
			if err != nil {
				return err
			}
		case "deployment":
			s.Deployment.Reset()
			if err := s.Deployment.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CheckRunCheckSuite) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	e.ObjEnd()
}

// Decode decodes CheckRunCheckSuite from json.
func (s *CheckRunCheckSuite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckRunCheckSuite to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CheckRunConclusion as json.
func (s CheckRunConclusion) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CheckRunConclusion from json.
func (s *CheckRunConclusion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckRunConclusion to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CheckRunConclusion(v) {
	case CheckRunConclusionSuccess:
		*s = CheckRunConclusionSuccess
	case CheckRunConclusionFailure:
		*s = CheckRunConclusionFailure
	case CheckRunConclusionNeutral:
		*s = CheckRunConclusionNeutral
	case CheckRunConclusionCancelled:
		*s = CheckRunConclusionCancelled
	case CheckRunConclusionSkipped:
		*s = CheckRunConclusionSkipped
	case CheckRunConclusionTimedOut:
		*s = CheckRunConclusionTimedOut
	case CheckRunConclusionActionRequired:
		*s = CheckRunConclusionActionRequired
	default:
		*s = CheckRunConclusion(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CheckRunOutput) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		s.Title.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"summary\"" + ":")
		s.Summary.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"text\"" + ":")
		s.Text.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"annotations_count\"" + ":")
		e.Int(s.AnnotationsCount)
	}
	{
		e.Comma()

		e.RawStr("\"annotations_url\"" + ":")
		json.EncodeURI(e, s.AnnotationsURL)
	}
	e.ObjEnd()
}

// Decode decodes CheckRunOutput from json.
func (s *CheckRunOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckRunOutput to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "summary":
			if err := s.Summary.Decode(d); err != nil {
				return err
			}
		case "text":
			if err := s.Text.Decode(d); err != nil {
				return err
			}
		case "annotations_count":
			v, err := d.Int()
			s.AnnotationsCount = int(v)
			if err != nil {
				return err
			}
		case "annotations_url":
			v, err := json.DecodeURI(d)
			s.AnnotationsURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CheckRunStatus as json.
func (s CheckRunStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CheckRunStatus from json.
func (s *CheckRunStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckRunStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CheckRunStatus(v) {
	case CheckRunStatusQueued:
		*s = CheckRunStatusQueued
	case CheckRunStatusInProgress:
		*s = CheckRunStatusInProgress
	case CheckRunStatusCompleted:
		*s = CheckRunStatusCompleted
	default:
		*s = CheckRunStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CheckSuite) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"head_branch\"" + ":")
		s.HeadBranch.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"head_sha\"" + ":")
		e.Str(s.HeadSha)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"conclusion\"" + ":")
		s.Conclusion.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"before\"" + ":")
		s.Before.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"after\"" + ":")
		s.After.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pull_requests\"" + ":")
		if s.PullRequests == nil {
			e.Null()
		} else {
			e.ArrStart()
			if len(s.PullRequests) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PullRequests[0]
					elem.Encode(e)
				}
				for _, elem := range s.PullRequests[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"app\"" + ":")
		s.App.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"head_commit\"" + ":")
		s.HeadCommit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"latest_check_runs_count\"" + ":")
		e.Int(s.LatestCheckRunsCount)
	}
	{
		e.Comma()

		e.RawStr("\"check_runs_url\"" + ":")
		e.Str(s.CheckRunsURL)
	}
	e.ObjEnd()
}

// Decode decodes CheckSuite from json.
func (s *CheckSuite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckSuite to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "head_branch":
			if err := s.HeadBranch.Decode(d); err != nil {
				return err
			}
		case "head_sha":
			v, err := d.Str()
			s.HeadSha = string(v)
			if err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "conclusion":
			if err := s.Conclusion.Decode(d); err != nil {
				return err
			}
		case "url":
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "before":
			if err := s.Before.Decode(d); err != nil {
				return err
			}
		case "after":
			if err := s.After.Decode(d); err != nil {
				return err
			}
		case "pull_requests":
			s.PullRequests = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PullRequestMinimal
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PullRequests = append(s.PullRequests, elem)
				return nil
			}); err != nil {
				return err
			}
		case "app":
			if err := s.App.Decode(d); err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "created_at":
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "head_commit":
			if err := s.HeadCommit.Decode(d); err != nil {
				return err
			}
		case "latest_check_runs_count":
			v, err := d.Int()
			s.LatestCheckRunsCount = int(v)
			if err != nil {
				return err
			}
		case "check_runs_url":
			v, err := d.Str()
			s.CheckRunsURL = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CheckSuiteConclusion as json.
func (s CheckSuiteConclusion) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CheckSuiteConclusion from json.
func (s *CheckSuiteConclusion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckSuiteConclusion to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CheckSuiteConclusion(v) {
	case CheckSuiteConclusionSuccess:
		*s = CheckSuiteConclusionSuccess
	case CheckSuiteConclusionFailure:
		*s = CheckSuiteConclusionFailure
	case CheckSuiteConclusionNeutral:
		*s = CheckSuiteConclusionNeutral
	case CheckSuiteConclusionCancelled:
		*s = CheckSuiteConclusionCancelled
	case CheckSuiteConclusionSkipped:
		*s = CheckSuiteConclusionSkipped
	case CheckSuiteConclusionTimedOut:
		*s = CheckSuiteConclusionTimedOut
	case CheckSuiteConclusionActionRequired:
		*s = CheckSuiteConclusionActionRequired
	default:
		*s = CheckSuiteConclusion(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CheckSuitePreference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"preferences\"" + ":")
		s.Preferences.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CheckSuitePreference from json.
func (s *CheckSuitePreference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckSuitePreference to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferences":
			if err := s.Preferences.Decode(d); err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CheckSuitePreferencePreferences) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AutoTriggerChecks != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AutoTriggerChecks != nil {
			e.RawStr("\"auto_trigger_checks\"" + ":")
			e.ArrStart()
			if len(s.AutoTriggerChecks) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AutoTriggerChecks[0]
					elem.Encode(e)
				}
				for _, elem := range s.AutoTriggerChecks[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes CheckSuitePreferencePreferences from json.
func (s *CheckSuitePreferencePreferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckSuitePreferencePreferences to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auto_trigger_checks":
			s.AutoTriggerChecks = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CheckSuitePreferencePreferencesAutoTriggerChecksItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AutoTriggerChecks = append(s.AutoTriggerChecks, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CheckSuitePreferencePreferencesAutoTriggerChecksItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"app_id\"" + ":")
		e.Int(s.AppID)
	}
	{
		e.Comma()

		e.RawStr("\"setting\"" + ":")
		e.Bool(s.Setting)
	}
	e.ObjEnd()
}

// Decode decodes CheckSuitePreferencePreferencesAutoTriggerChecksItem from json.
func (s *CheckSuitePreferencePreferencesAutoTriggerChecksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckSuitePreferencePreferencesAutoTriggerChecksItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "app_id":
			v, err := d.Int()
			s.AppID = int(v)
			if err != nil {
				return err
			}
		case "setting":
			v, err := d.Bool()
			s.Setting = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CheckSuiteStatus as json.
func (s CheckSuiteStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CheckSuiteStatus from json.
func (s *CheckSuiteStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckSuiteStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CheckSuiteStatus(v) {
	case CheckSuiteStatusQueued:
		*s = CheckSuiteStatusQueued
	case CheckSuiteStatusInProgress:
		*s = CheckSuiteStatusInProgress
	case CheckSuiteStatusCompleted:
		*s = CheckSuiteStatusCompleted
	default:
		*s = CheckSuiteStatus(v)
	}

	return nil
}

// Encode encodes ChecksCreateSuiteApplicationJSONCreated as json.
func (s ChecksCreateSuiteApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := CheckSuite(s)
	unwrapped.Encode(e)
}

// Decode decodes ChecksCreateSuiteApplicationJSONCreated from json.
func (s *ChecksCreateSuiteApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksCreateSuiteApplicationJSONCreated to nil`)
	}
	var unwrapped CheckSuite
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ChecksCreateSuiteApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ChecksCreateSuiteApplicationJSONOK as json.
func (s ChecksCreateSuiteApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := CheckSuite(s)
	unwrapped.Encode(e)
}

// Decode decodes ChecksCreateSuiteApplicationJSONOK from json.
func (s *ChecksCreateSuiteApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksCreateSuiteApplicationJSONOK to nil`)
	}
	var unwrapped CheckSuite
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ChecksCreateSuiteApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ChecksCreateSuiteReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"head_sha\"" + ":")
		e.Str(s.HeadSha)
	}
	e.ObjEnd()
}

// Decode decodes ChecksCreateSuiteReq from json.
func (s *ChecksCreateSuiteReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksCreateSuiteReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "head_sha":
			v, err := d.Str()
			s.HeadSha = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ChecksListForRefFilter as json.
func (s ChecksListForRefFilter) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ChecksListForRefFilter from json.
func (s *ChecksListForRefFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksListForRefFilter to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChecksListForRefFilter(v) {
	case ChecksListForRefFilterLatest:
		*s = ChecksListForRefFilterLatest
	case ChecksListForRefFilterAll:
		*s = ChecksListForRefFilterAll
	default:
		*s = ChecksListForRefFilter(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChecksListForRefOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"check_runs\"" + ":")
		e.ArrStart()
		if len(s.CheckRuns) >= 1 {
			// Encode first element without comma.
			{
				elem := s.CheckRuns[0]
				elem.Encode(e)
			}
			for _, elem := range s.CheckRuns[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ChecksListForRefOK from json.
func (s *ChecksListForRefOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksListForRefOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "check_runs":
			s.CheckRuns = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CheckRun
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CheckRuns = append(s.CheckRuns, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ChecksListForRefStatus as json.
func (s ChecksListForRefStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ChecksListForRefStatus from json.
func (s *ChecksListForRefStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksListForRefStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChecksListForRefStatus(v) {
	case ChecksListForRefStatusQueued:
		*s = ChecksListForRefStatusQueued
	case ChecksListForRefStatusInProgress:
		*s = ChecksListForRefStatusInProgress
	case ChecksListForRefStatusCompleted:
		*s = ChecksListForRefStatusCompleted
	default:
		*s = ChecksListForRefStatus(v)
	}

	return nil
}

// Encode encodes ChecksListForSuiteFilter as json.
func (s ChecksListForSuiteFilter) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ChecksListForSuiteFilter from json.
func (s *ChecksListForSuiteFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksListForSuiteFilter to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChecksListForSuiteFilter(v) {
	case ChecksListForSuiteFilterLatest:
		*s = ChecksListForSuiteFilterLatest
	case ChecksListForSuiteFilterAll:
		*s = ChecksListForSuiteFilterAll
	default:
		*s = ChecksListForSuiteFilter(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChecksListForSuiteOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"check_runs\"" + ":")
		e.ArrStart()
		if len(s.CheckRuns) >= 1 {
			// Encode first element without comma.
			{
				elem := s.CheckRuns[0]
				elem.Encode(e)
			}
			for _, elem := range s.CheckRuns[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ChecksListForSuiteOK from json.
func (s *ChecksListForSuiteOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksListForSuiteOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "check_runs":
			s.CheckRuns = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CheckRun
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CheckRuns = append(s.CheckRuns, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ChecksListForSuiteStatus as json.
func (s ChecksListForSuiteStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ChecksListForSuiteStatus from json.
func (s *ChecksListForSuiteStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksListForSuiteStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChecksListForSuiteStatus(v) {
	case ChecksListForSuiteStatusQueued:
		*s = ChecksListForSuiteStatusQueued
	case ChecksListForSuiteStatusInProgress:
		*s = ChecksListForSuiteStatusInProgress
	case ChecksListForSuiteStatusCompleted:
		*s = ChecksListForSuiteStatusCompleted
	default:
		*s = ChecksListForSuiteStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChecksListSuitesForRefOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"check_suites\"" + ":")
		e.ArrStart()
		if len(s.CheckSuites) >= 1 {
			// Encode first element without comma.
			{
				elem := s.CheckSuites[0]
				elem.Encode(e)
			}
			for _, elem := range s.CheckSuites[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ChecksListSuitesForRefOK from json.
func (s *ChecksListSuitesForRefOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksListSuitesForRefOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "check_suites":
			s.CheckSuites = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CheckSuite
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CheckSuites = append(s.CheckSuites, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ChecksRerequestSuiteCreated) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ChecksRerequestSuiteCreated from json.
func (s *ChecksRerequestSuiteCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksRerequestSuiteCreated to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ChecksSetSuitesPreferencesReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AutoTriggerChecks != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AutoTriggerChecks != nil {
			e.RawStr("\"auto_trigger_checks\"" + ":")
			e.ArrStart()
			if len(s.AutoTriggerChecks) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AutoTriggerChecks[0]
					elem.Encode(e)
				}
				for _, elem := range s.AutoTriggerChecks[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ChecksSetSuitesPreferencesReq from json.
func (s *ChecksSetSuitesPreferencesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksSetSuitesPreferencesReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auto_trigger_checks":
			s.AutoTriggerChecks = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ChecksSetSuitesPreferencesReqAutoTriggerChecksItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AutoTriggerChecks = append(s.AutoTriggerChecks, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ChecksSetSuitesPreferencesReqAutoTriggerChecksItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"app_id\"" + ":")
		e.Int(s.AppID)
	}
	{
		e.Comma()

		e.RawStr("\"setting\"" + ":")
		e.Bool(s.Setting)
	}
	e.ObjEnd()
}

// Decode decodes ChecksSetSuitesPreferencesReqAutoTriggerChecksItem from json.
func (s *ChecksSetSuitesPreferencesReqAutoTriggerChecksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksSetSuitesPreferencesReqAutoTriggerChecksItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "app_id":
			v, err := d.Int()
			s.AppID = int(v)
			if err != nil {
				return err
			}
		case "setting":
			v, err := d.Bool()
			s.Setting = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CloneTraffic) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"count\"" + ":")
		e.Int(s.Count)
	}
	{
		e.Comma()

		e.RawStr("\"uniques\"" + ":")
		e.Int(s.Uniques)
	}
	{
		e.Comma()

		e.RawStr("\"clones\"" + ":")
		e.ArrStart()
		if len(s.Clones) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Clones[0]
				elem.Encode(e)
			}
			for _, elem := range s.Clones[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes CloneTraffic from json.
func (s *CloneTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CloneTraffic to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			v, err := d.Int()
			s.Count = int(v)
			if err != nil {
				return err
			}
		case "uniques":
			v, err := d.Int()
			s.Uniques = int(v)
			if err != nil {
				return err
			}
		case "clones":
			s.Clones = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Traffic
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Clones = append(s.Clones, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeFrequencyStat as json.
func (s CodeFrequencyStat) Encode(e *jx.Writer) {
	unwrapped := []int(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			e.Int(elem)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			e.Int(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes CodeFrequencyStat from json.
func (s *CodeFrequencyStat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeFrequencyStat to nil`)
	}
	var unwrapped []int
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem int
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeFrequencyStat(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeOfConduct) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeOfConduct from json.
func (s *CodeOfConduct) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeOfConduct to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeOfConductSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeOfConductSimple from json.
func (s *CodeOfConductSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeOfConductSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningAlert) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"number\"" + ":")
		s.Number.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		if s.Instances.Set {
			e.Comma()
		}
		if s.Instances.Set {
			e.RawStr("\"instances\"" + ":")
			s.Instances.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"instances_url\"" + ":")
		s.InstancesURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"dismissed_by\"" + ":")
		s.DismissedBy.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"dismissed_at\"" + ":")
		s.DismissedAt.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"dismissed_reason\"" + ":")
		s.DismissedReason.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"rule\"" + ":")
		s.Rule.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"tool\"" + ":")
		s.Tool.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"most_recent_instance\"" + ":")
		s.MostRecentInstance.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAlert from json.
func (s *CodeScanningAlert) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlert to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			{
				var unwrapped int
				v, err := d.Int()
				unwrapped = int(v)
				if err != nil {
					return err
				}
				s.Number = AlertNumber(unwrapped)
			}
		case "created_at":
			{
				var unwrapped time.Time
				v, err := json.DecodeDateTime(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.CreatedAt = AlertCreatedAt(unwrapped)
			}
		case "url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.URL = AlertURL(unwrapped)
			}
		case "html_url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.HTMLURL = AlertHTMLURL(unwrapped)
			}
		case "instances":
			s.Instances.Reset()
			if err := s.Instances.Decode(d); err != nil {
				return err
			}
		case "instances_url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.InstancesURL = AlertInstancesURL(unwrapped)
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "dismissed_by":
			if err := s.DismissedBy.Decode(d); err != nil {
				return err
			}
		case "dismissed_at":
			if err := s.DismissedAt.Decode(d); err != nil {
				return err
			}
		case "dismissed_reason":
			if err := s.DismissedReason.Decode(d); err != nil {
				return err
			}
		case "rule":
			if err := s.Rule.Decode(d); err != nil {
				return err
			}
		case "tool":
			if err := s.Tool.Decode(d); err != nil {
				return err
			}
		case "most_recent_instance":
			if err := s.MostRecentInstance.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningAlertClassification as json.
func (s CodeScanningAlertClassification) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertClassification from json.
func (s *CodeScanningAlertClassification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertClassification to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertClassification(v) {
	case CodeScanningAlertClassificationSource:
		*s = CodeScanningAlertClassificationSource
	case CodeScanningAlertClassificationGenerated:
		*s = CodeScanningAlertClassificationGenerated
	case CodeScanningAlertClassificationTest:
		*s = CodeScanningAlertClassificationTest
	case CodeScanningAlertClassificationLibrary:
		*s = CodeScanningAlertClassificationLibrary
	default:
		*s = CodeScanningAlertClassification(v)
	}

	return nil
}

// Encode encodes CodeScanningAlertDismissedAt as json.
func (s CodeScanningAlertDismissedAt) Encode(e *jx.Writer) {
	unwrapped := time.Time(s)
	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes CodeScanningAlertDismissedAt from json.
func (s *CodeScanningAlertDismissedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertDismissedAt to nil`)
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAlertDismissedAt(unwrapped)
	return nil
}

// Encode encodes CodeScanningAlertDismissedReason as json.
func (s CodeScanningAlertDismissedReason) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertDismissedReason from json.
func (s *CodeScanningAlertDismissedReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertDismissedReason to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertDismissedReason(v) {
	case CodeScanningAlertDismissedReasonFalsePositive:
		*s = CodeScanningAlertDismissedReasonFalsePositive
	case CodeScanningAlertDismissedReasonWonTFix:
		*s = CodeScanningAlertDismissedReasonWonTFix
	case CodeScanningAlertDismissedReasonUsedInTests:
		*s = CodeScanningAlertDismissedReasonUsedInTests
	default:
		*s = CodeScanningAlertDismissedReason(v)
	}

	return nil
}

// Encode encodes CodeScanningAlertEnvironment as json.
func (s CodeScanningAlertEnvironment) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAlertEnvironment from json.
func (s *CodeScanningAlertEnvironment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertEnvironment to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAlertEnvironment(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertInstance) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ref.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ref.Set {
			e.RawStr("\"ref\"" + ":")
			s.Ref.Encode(e)
		}
	}
	{
		if s.AnalysisKey.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AnalysisKey.Set {
			e.RawStr("\"analysis_key\"" + ":")
			s.AnalysisKey.Encode(e)
		}
	}
	{
		if s.Environment.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Environment.Set {
			e.RawStr("\"environment\"" + ":")
			s.Environment.Encode(e)
		}
	}
	{
		if s.Category.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Category.Set {
			e.RawStr("\"category\"" + ":")
			s.Category.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.CommitSha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommitSha.Set {
			e.RawStr("\"commit_sha\"" + ":")
			s.CommitSha.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Location.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Classifications != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Classifications != nil {
			e.RawStr("\"classifications\"" + ":")
			e.ArrStart()
			if len(s.Classifications) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Classifications[0]
					elem.Encode(e)
				}
				for _, elem := range s.Classifications[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAlertInstance from json.
func (s *CodeScanningAlertInstance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertInstance to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			s.Ref.Reset()
			if err := s.Ref.Decode(d); err != nil {
				return err
			}
		case "analysis_key":
			s.AnalysisKey.Reset()
			if err := s.AnalysisKey.Decode(d); err != nil {
				return err
			}
		case "environment":
			s.Environment.Reset()
			if err := s.Environment.Decode(d); err != nil {
				return err
			}
		case "category":
			s.Category.Reset()
			if err := s.Category.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "commit_sha":
			s.CommitSha.Reset()
			if err := s.CommitSha.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "classifications":
			s.Classifications = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CodeScanningAlertClassification
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Classifications = append(s.Classifications, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertInstanceMessage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Text.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Text.Set {
			e.RawStr("\"text\"" + ":")
			s.Text.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAlertInstanceMessage from json.
func (s *CodeScanningAlertInstanceMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertInstanceMessage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			s.Text.Reset()
			if err := s.Text.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertItems) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"number\"" + ":")
		s.Number.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"instances_url\"" + ":")
		s.InstancesURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"dismissed_by\"" + ":")
		s.DismissedBy.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"dismissed_at\"" + ":")
		s.DismissedAt.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"dismissed_reason\"" + ":")
		s.DismissedReason.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"rule\"" + ":")
		s.Rule.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"tool\"" + ":")
		s.Tool.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"most_recent_instance\"" + ":")
		s.MostRecentInstance.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAlertItems from json.
func (s *CodeScanningAlertItems) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertItems to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			{
				var unwrapped int
				v, err := d.Int()
				unwrapped = int(v)
				if err != nil {
					return err
				}
				s.Number = AlertNumber(unwrapped)
			}
		case "created_at":
			{
				var unwrapped time.Time
				v, err := json.DecodeDateTime(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.CreatedAt = AlertCreatedAt(unwrapped)
			}
		case "url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.URL = AlertURL(unwrapped)
			}
		case "html_url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.HTMLURL = AlertHTMLURL(unwrapped)
			}
		case "instances_url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.InstancesURL = AlertInstancesURL(unwrapped)
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "dismissed_by":
			if err := s.DismissedBy.Decode(d); err != nil {
				return err
			}
		case "dismissed_at":
			if err := s.DismissedAt.Decode(d); err != nil {
				return err
			}
		case "dismissed_reason":
			if err := s.DismissedReason.Decode(d); err != nil {
				return err
			}
		case "rule":
			if err := s.Rule.Decode(d); err != nil {
				return err
			}
		case "tool":
			if err := s.Tool.Decode(d); err != nil {
				return err
			}
		case "most_recent_instance":
			if err := s.MostRecentInstance.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertLocation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Path.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.StartLine.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StartLine.Set {
			e.RawStr("\"start_line\"" + ":")
			s.StartLine.Encode(e)
		}
	}
	{
		if s.EndLine.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EndLine.Set {
			e.RawStr("\"end_line\"" + ":")
			s.EndLine.Encode(e)
		}
	}
	{
		if s.StartColumn.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StartColumn.Set {
			e.RawStr("\"start_column\"" + ":")
			s.StartColumn.Encode(e)
		}
	}
	{
		if s.EndColumn.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EndColumn.Set {
			e.RawStr("\"end_column\"" + ":")
			s.EndColumn.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAlertLocation from json.
func (s *CodeScanningAlertLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertLocation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "start_line":
			s.StartLine.Reset()
			if err := s.StartLine.Decode(d); err != nil {
				return err
			}
		case "end_line":
			s.EndLine.Reset()
			if err := s.EndLine.Decode(d); err != nil {
				return err
			}
		case "start_column":
			s.StartColumn.Reset()
			if err := s.StartColumn.Decode(d); err != nil {
				return err
			}
		case "end_column":
			s.EndColumn.Reset()
			if err := s.EndColumn.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Severity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Severity.Set {
			e.RawStr("\"severity\"" + ":")
			s.Severity.Encode(e)
		}
	}
	{
		if s.SecuritySeverityLevel.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecuritySeverityLevel.Set {
			e.RawStr("\"security_severity_level\"" + ":")
			s.SecuritySeverityLevel.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.FullDescription.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FullDescription.Set {
			e.RawStr("\"full_description\"" + ":")
			s.FullDescription.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Tags.Set {
			e.RawStr("\"tags\"" + ":")
			s.Tags.Encode(e)
		}
	}
	{
		if s.Help.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Help.Set {
			e.RawStr("\"help\"" + ":")
			s.Help.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAlertRule from json.
func (s *CodeScanningAlertRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertRule to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "severity":
			s.Severity.Reset()
			if err := s.Severity.Decode(d); err != nil {
				return err
			}
		case "security_severity_level":
			s.SecuritySeverityLevel.Reset()
			if err := s.SecuritySeverityLevel.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "full_description":
			s.FullDescription.Reset()
			if err := s.FullDescription.Decode(d); err != nil {
				return err
			}
		case "tags":
			s.Tags.Reset()
			if err := s.Tags.Decode(d); err != nil {
				return err
			}
		case "help":
			s.Help.Reset()
			if err := s.Help.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningAlertRuleSecuritySeverityLevel as json.
func (s CodeScanningAlertRuleSecuritySeverityLevel) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertRuleSecuritySeverityLevel from json.
func (s *CodeScanningAlertRuleSecuritySeverityLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertRuleSecuritySeverityLevel to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertRuleSecuritySeverityLevel(v) {
	case CodeScanningAlertRuleSecuritySeverityLevelLow:
		*s = CodeScanningAlertRuleSecuritySeverityLevelLow
	case CodeScanningAlertRuleSecuritySeverityLevelMedium:
		*s = CodeScanningAlertRuleSecuritySeverityLevelMedium
	case CodeScanningAlertRuleSecuritySeverityLevelHigh:
		*s = CodeScanningAlertRuleSecuritySeverityLevelHigh
	case CodeScanningAlertRuleSecuritySeverityLevelCritical:
		*s = CodeScanningAlertRuleSecuritySeverityLevelCritical
	default:
		*s = CodeScanningAlertRuleSecuritySeverityLevel(v)
	}

	return nil
}

// Encode encodes CodeScanningAlertRuleSeverity as json.
func (s CodeScanningAlertRuleSeverity) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertRuleSeverity from json.
func (s *CodeScanningAlertRuleSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertRuleSeverity to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertRuleSeverity(v) {
	case CodeScanningAlertRuleSeverityNone:
		*s = CodeScanningAlertRuleSeverityNone
	case CodeScanningAlertRuleSeverityNote:
		*s = CodeScanningAlertRuleSeverityNote
	case CodeScanningAlertRuleSeverityWarning:
		*s = CodeScanningAlertRuleSeverityWarning
	case CodeScanningAlertRuleSeverityError:
		*s = CodeScanningAlertRuleSeverityError
	default:
		*s = CodeScanningAlertRuleSeverity(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertRuleSummary) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Severity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Severity.Set {
			e.RawStr("\"severity\"" + ":")
			s.Severity.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAlertRuleSummary from json.
func (s *CodeScanningAlertRuleSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertRuleSummary to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "severity":
			s.Severity.Reset()
			if err := s.Severity.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningAlertRuleSummarySeverity as json.
func (s CodeScanningAlertRuleSummarySeverity) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertRuleSummarySeverity from json.
func (s *CodeScanningAlertRuleSummarySeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertRuleSummarySeverity to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertRuleSummarySeverity(v) {
	case CodeScanningAlertRuleSummarySeverityNone:
		*s = CodeScanningAlertRuleSummarySeverityNone
	case CodeScanningAlertRuleSummarySeverityNote:
		*s = CodeScanningAlertRuleSummarySeverityNote
	case CodeScanningAlertRuleSummarySeverityWarning:
		*s = CodeScanningAlertRuleSummarySeverityWarning
	case CodeScanningAlertRuleSummarySeverityError:
		*s = CodeScanningAlertRuleSummarySeverityError
	default:
		*s = CodeScanningAlertRuleSummarySeverity(v)
	}

	return nil
}

// Encode encodes CodeScanningAlertSetState as json.
func (s CodeScanningAlertSetState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertSetState from json.
func (s *CodeScanningAlertSetState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertSetState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertSetState(v) {
	case CodeScanningAlertSetStateOpen:
		*s = CodeScanningAlertSetStateOpen
	case CodeScanningAlertSetStateDismissed:
		*s = CodeScanningAlertSetStateDismissed
	default:
		*s = CodeScanningAlertSetState(v)
	}

	return nil
}

// Encode encodes CodeScanningAlertState as json.
func (s CodeScanningAlertState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertState from json.
func (s *CodeScanningAlertState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertState(v) {
	case CodeScanningAlertStateOpen:
		*s = CodeScanningAlertStateOpen
	case CodeScanningAlertStateClosed:
		*s = CodeScanningAlertStateClosed
	case CodeScanningAlertStateDismissed:
		*s = CodeScanningAlertStateDismissed
	case CodeScanningAlertStateFixed:
		*s = CodeScanningAlertStateFixed
	default:
		*s = CodeScanningAlertState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAnalysis) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ref\"" + ":")
		s.Ref.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commit_sha\"" + ":")
		s.CommitSha.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"analysis_key\"" + ":")
		s.AnalysisKey.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"environment\"" + ":")
		s.Environment.Encode(e)
	}
	{
		if s.Category.Set {
			e.Comma()
		}
		if s.Category.Set {
			e.RawStr("\"category\"" + ":")
			s.Category.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"error\"" + ":")
		e.Str(s.Error)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"results_count\"" + ":")
		e.Int(s.ResultsCount)
	}
	{
		e.Comma()

		e.RawStr("\"rules_count\"" + ":")
		e.Int(s.RulesCount)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sarif_id\"" + ":")
		s.SarifID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"tool\"" + ":")
		s.Tool.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"deletable\"" + ":")
		e.Bool(s.Deletable)
	}
	{
		e.Comma()

		e.RawStr("\"warning\"" + ":")
		e.Str(s.Warning)
	}
	{
		if s.ToolName.Set {
			e.Comma()
		}
		if s.ToolName.Set {
			e.RawStr("\"tool_name\"" + ":")
			s.ToolName.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAnalysis from json.
func (s *CodeScanningAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysis to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.Ref = CodeScanningRef(unwrapped)
			}
		case "commit_sha":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.CommitSha = CodeScanningAnalysisCommitSha(unwrapped)
			}
		case "analysis_key":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.AnalysisKey = CodeScanningAnalysisAnalysisKey(unwrapped)
			}
		case "environment":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.Environment = CodeScanningAnalysisEnvironment(unwrapped)
			}
		case "category":
			s.Category.Reset()
			if err := s.Category.Decode(d); err != nil {
				return err
			}
		case "error":
			v, err := d.Str()
			s.Error = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			{
				var unwrapped time.Time
				v, err := json.DecodeDateTime(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.CreatedAt = CodeScanningAnalysisCreatedAt(unwrapped)
			}
		case "results_count":
			v, err := d.Int()
			s.ResultsCount = int(v)
			if err != nil {
				return err
			}
		case "rules_count":
			v, err := d.Int()
			s.RulesCount = int(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.URL = CodeScanningAnalysisURL(unwrapped)
			}
		case "sarif_id":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.SarifID = CodeScanningAnalysisSarifID(unwrapped)
			}
		case "tool":
			if err := s.Tool.Decode(d); err != nil {
				return err
			}
		case "deletable":
			v, err := d.Bool()
			s.Deletable = bool(v)
			if err != nil {
				return err
			}
		case "warning":
			v, err := d.Str()
			s.Warning = string(v)
			if err != nil {
				return err
			}
		case "tool_name":
			s.ToolName.Reset()
			if err := s.ToolName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningAnalysisAnalysisKey as json.
func (s CodeScanningAnalysisAnalysisKey) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisAnalysisKey from json.
func (s *CodeScanningAnalysisAnalysisKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisAnalysisKey to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisAnalysisKey(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisCategory as json.
func (s CodeScanningAnalysisCategory) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisCategory from json.
func (s *CodeScanningAnalysisCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisCategory to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisCategory(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisCommitSha as json.
func (s CodeScanningAnalysisCommitSha) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisCommitSha from json.
func (s *CodeScanningAnalysisCommitSha) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisCommitSha to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisCommitSha(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisCreatedAt as json.
func (s CodeScanningAnalysisCreatedAt) Encode(e *jx.Writer) {
	unwrapped := time.Time(s)
	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes CodeScanningAnalysisCreatedAt from json.
func (s *CodeScanningAnalysisCreatedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisCreatedAt to nil`)
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisCreatedAt(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAnalysisDeletion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"next_analysis_url\"" + ":")
		s.NextAnalysisURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"confirm_delete_url\"" + ":")
		s.ConfirmDeleteURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAnalysisDeletion from json.
func (s *CodeScanningAnalysisDeletion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisDeletion to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "next_analysis_url":
			if err := s.NextAnalysisURL.Decode(d); err != nil {
				return err
			}
		case "confirm_delete_url":
			if err := s.ConfirmDeleteURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningAnalysisEnvironment as json.
func (s CodeScanningAnalysisEnvironment) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisEnvironment from json.
func (s *CodeScanningAnalysisEnvironment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisEnvironment to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisEnvironment(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisSarifFile as json.
func (s CodeScanningAnalysisSarifFile) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisSarifFile from json.
func (s *CodeScanningAnalysisSarifFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisSarifFile to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisSarifFile(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisSarifID as json.
func (s CodeScanningAnalysisSarifID) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisSarifID from json.
func (s *CodeScanningAnalysisSarifID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisSarifID to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisSarifID(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAnalysisTool) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Version.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Version.Set {
			e.RawStr("\"version\"" + ":")
			s.Version.Encode(e)
		}
	}
	{
		if s.GUID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GUID.Set {
			e.RawStr("\"guid\"" + ":")
			s.GUID.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAnalysisTool from json.
func (s *CodeScanningAnalysisTool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisTool to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "version":
			s.Version.Reset()
			if err := s.Version.Decode(d); err != nil {
				return err
			}
		case "guid":
			s.GUID.Reset()
			if err := s.GUID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningAnalysisToolGUID as json.
func (s CodeScanningAnalysisToolGUID) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisToolGUID from json.
func (s *CodeScanningAnalysisToolGUID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisToolGUID to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisToolGUID(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisToolName as json.
func (s CodeScanningAnalysisToolName) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisToolName from json.
func (s *CodeScanningAnalysisToolName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisToolName to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisToolName(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisToolVersion as json.
func (s CodeScanningAnalysisToolVersion) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisToolVersion from json.
func (s *CodeScanningAnalysisToolVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisToolVersion to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisToolVersion(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisURL as json.
func (s CodeScanningAnalysisURL) Encode(e *jx.Writer) {
	unwrapped := url.URL(s)
	json.EncodeURI(e, unwrapped)
}

// Decode decodes CodeScanningAnalysisURL from json.
func (s *CodeScanningAnalysisURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisURL to nil`)
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisURL(unwrapped)
	return nil
}

// Encode encodes CodeScanningDeleteAnalysisApplicationJSONBadRequest as json.
func (s CodeScanningDeleteAnalysisApplicationJSONBadRequest) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningDeleteAnalysisApplicationJSONBadRequest from json.
func (s *CodeScanningDeleteAnalysisApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningDeleteAnalysisApplicationJSONBadRequest to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningDeleteAnalysisApplicationJSONBadRequest(unwrapped)
	return nil
}

// Encode encodes CodeScanningDeleteAnalysisApplicationJSONForbidden as json.
func (s CodeScanningDeleteAnalysisApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningDeleteAnalysisApplicationJSONForbidden from json.
func (s *CodeScanningDeleteAnalysisApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningDeleteAnalysisApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningDeleteAnalysisApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningDeleteAnalysisApplicationJSONNotFound as json.
func (s CodeScanningDeleteAnalysisApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningDeleteAnalysisApplicationJSONNotFound from json.
func (s *CodeScanningDeleteAnalysisApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningDeleteAnalysisApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningDeleteAnalysisApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningGetAlertApplicationJSONForbidden as json.
func (s CodeScanningGetAlertApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAlertApplicationJSONForbidden from json.
func (s *CodeScanningGetAlertApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningGetAlertApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAlertApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningGetAlertApplicationJSONNotFound as json.
func (s CodeScanningGetAlertApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAlertApplicationJSONNotFound from json.
func (s *CodeScanningGetAlertApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningGetAlertApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAlertApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningGetAnalysisApplicationJSONForbidden as json.
func (s CodeScanningGetAnalysisApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAnalysisApplicationJSONForbidden from json.
func (s *CodeScanningGetAnalysisApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningGetAnalysisApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAnalysisApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningGetAnalysisApplicationJSONNotFound as json.
func (s CodeScanningGetAnalysisApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAnalysisApplicationJSONNotFound from json.
func (s *CodeScanningGetAnalysisApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningGetAnalysisApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAnalysisApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningGetSarifNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes CodeScanningGetSarifNotFound from json.
func (s *CodeScanningGetSarifNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningGetSarifNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningListAlertInstancesApplicationJSONForbidden as json.
func (s CodeScanningListAlertInstancesApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertInstancesApplicationJSONForbidden from json.
func (s *CodeScanningListAlertInstancesApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListAlertInstancesApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertInstancesApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertInstancesApplicationJSONNotFound as json.
func (s CodeScanningListAlertInstancesApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertInstancesApplicationJSONNotFound from json.
func (s *CodeScanningListAlertInstancesApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListAlertInstancesApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertInstancesApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertInstancesOKApplicationJSON as json.
func (s CodeScanningListAlertInstancesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CodeScanningAlertInstance(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes CodeScanningListAlertInstancesOKApplicationJSON from json.
func (s *CodeScanningListAlertInstancesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListAlertInstancesOKApplicationJSON to nil`)
	}
	var unwrapped []CodeScanningAlertInstance
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeScanningAlertInstance
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertInstancesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertsForRepoApplicationJSONForbidden as json.
func (s CodeScanningListAlertsForRepoApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertsForRepoApplicationJSONForbidden from json.
func (s *CodeScanningListAlertsForRepoApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListAlertsForRepoApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertsForRepoApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertsForRepoApplicationJSONNotFound as json.
func (s CodeScanningListAlertsForRepoApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertsForRepoApplicationJSONNotFound from json.
func (s *CodeScanningListAlertsForRepoApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListAlertsForRepoApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertsForRepoApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertsForRepoOKApplicationJSON as json.
func (s CodeScanningListAlertsForRepoOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CodeScanningAlertItems(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes CodeScanningListAlertsForRepoOKApplicationJSON from json.
func (s *CodeScanningListAlertsForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListAlertsForRepoOKApplicationJSON to nil`)
	}
	var unwrapped []CodeScanningAlertItems
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeScanningAlertItems
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertsForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes CodeScanningListRecentAnalysesApplicationJSONForbidden as json.
func (s CodeScanningListRecentAnalysesApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListRecentAnalysesApplicationJSONForbidden from json.
func (s *CodeScanningListRecentAnalysesApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListRecentAnalysesApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListRecentAnalysesApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningListRecentAnalysesApplicationJSONNotFound as json.
func (s CodeScanningListRecentAnalysesApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListRecentAnalysesApplicationJSONNotFound from json.
func (s *CodeScanningListRecentAnalysesApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListRecentAnalysesApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListRecentAnalysesApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningListRecentAnalysesOKApplicationJSON as json.
func (s CodeScanningListRecentAnalysesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CodeScanningAnalysis(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes CodeScanningListRecentAnalysesOKApplicationJSON from json.
func (s *CodeScanningListRecentAnalysesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListRecentAnalysesOKApplicationJSON to nil`)
	}
	var unwrapped []CodeScanningAnalysis
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeScanningAnalysis
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListRecentAnalysesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes CodeScanningRef as json.
func (s CodeScanningRef) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningRef from json.
func (s *CodeScanningRef) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningRef to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningRef(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningSarifsReceipt) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningSarifsReceipt from json.
func (s *CodeScanningSarifsReceipt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningSarifsReceipt to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningSarifsStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ProcessingStatus.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ProcessingStatus.Set {
			e.RawStr("\"processing_status\"" + ":")
			s.ProcessingStatus.Encode(e)
		}
	}
	{
		if s.AnalysesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AnalysesURL.Set {
			e.RawStr("\"analyses_url\"" + ":")
			s.AnalysesURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningSarifsStatus from json.
func (s *CodeScanningSarifsStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningSarifsStatus to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "processing_status":
			s.ProcessingStatus.Reset()
			if err := s.ProcessingStatus.Decode(d); err != nil {
				return err
			}
		case "analyses_url":
			s.AnalysesURL.Reset()
			if err := s.AnalysesURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningSarifsStatusProcessingStatus as json.
func (s CodeScanningSarifsStatusProcessingStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningSarifsStatusProcessingStatus from json.
func (s *CodeScanningSarifsStatusProcessingStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningSarifsStatusProcessingStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningSarifsStatusProcessingStatus(v) {
	case CodeScanningSarifsStatusProcessingStatusPending:
		*s = CodeScanningSarifsStatusProcessingStatusPending
	case CodeScanningSarifsStatusProcessingStatusComplete:
		*s = CodeScanningSarifsStatusProcessingStatusComplete
	default:
		*s = CodeScanningSarifsStatusProcessingStatus(v)
	}

	return nil
}

// Encode encodes CodeScanningUpdateAlertApplicationJSONForbidden as json.
func (s CodeScanningUpdateAlertApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUpdateAlertApplicationJSONForbidden from json.
func (s *CodeScanningUpdateAlertApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUpdateAlertApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUpdateAlertApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningUpdateAlertApplicationJSONNotFound as json.
func (s CodeScanningUpdateAlertApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUpdateAlertApplicationJSONNotFound from json.
func (s *CodeScanningUpdateAlertApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUpdateAlertApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUpdateAlertApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningUpdateAlertReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		if s.DismissedReason.Set {
			e.Comma()
		}
		if s.DismissedReason.Set {
			e.RawStr("\"dismissed_reason\"" + ":")
			s.DismissedReason.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningUpdateAlertReq from json.
func (s *CodeScanningUpdateAlertReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUpdateAlertReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "dismissed_reason":
			s.DismissedReason.Reset()
			if err := s.DismissedReason.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningUploadSarifApplicationJSONForbidden as json.
func (s CodeScanningUploadSarifApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUploadSarifApplicationJSONForbidden from json.
func (s *CodeScanningUploadSarifApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUploadSarifApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUploadSarifApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningUploadSarifApplicationJSONNotFound as json.
func (s CodeScanningUploadSarifApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUploadSarifApplicationJSONNotFound from json.
func (s *CodeScanningUploadSarifApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUploadSarifApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUploadSarifApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningUploadSarifBadRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes CodeScanningUploadSarifBadRequest from json.
func (s *CodeScanningUploadSarifBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUploadSarifBadRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningUploadSarifReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"commit_sha\"" + ":")
		s.CommitSha.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"ref\"" + ":")
		s.Ref.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sarif\"" + ":")
		s.Sarif.Encode(e)
	}
	{
		if s.CheckoutURI.Set {
			e.Comma()
		}
		if s.CheckoutURI.Set {
			e.RawStr("\"checkout_uri\"" + ":")
			s.CheckoutURI.Encode(e)
		}
	}
	{
		if s.StartedAt.Set {
			e.Comma()
		}
		if s.StartedAt.Set {
			e.RawStr("\"started_at\"" + ":")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ToolName.Set {
			e.Comma()
		}
		if s.ToolName.Set {
			e.RawStr("\"tool_name\"" + ":")
			s.ToolName.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningUploadSarifReq from json.
func (s *CodeScanningUploadSarifReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUploadSarifReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commit_sha":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.CommitSha = CodeScanningAnalysisCommitSha(unwrapped)
			}
		case "ref":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.Ref = CodeScanningRef(unwrapped)
			}
		case "sarif":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.Sarif = CodeScanningAnalysisSarifFile(unwrapped)
			}
		case "checkout_uri":
			s.CheckoutURI.Reset()
			if err := s.CheckoutURI.Decode(d); err != nil {
				return err
			}
		case "started_at":
			s.StartedAt.Reset()
			if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "tool_name":
			s.ToolName.Reset()
			if err := s.ToolName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningUploadSarifRequestEntityTooLarge) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes CodeScanningUploadSarifRequestEntityTooLarge from json.
func (s *CodeScanningUploadSarifRequestEntityTooLarge) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUploadSarifRequestEntityTooLarge to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeSearchResultItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		json.EncodeURI(e, s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Float64(s.Score)
	}
	{
		if s.FileSize.Set {
			e.Comma()
		}
		if s.FileSize.Set {
			e.RawStr("\"file_size\"" + ":")
			s.FileSize.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.Comma()
		}
		if s.Language.Set {
			e.RawStr("\"language\"" + ":")
			s.Language.Encode(e)
		}
	}
	{
		if s.LastModifiedAt.Set {
			e.Comma()
		}
		if s.LastModifiedAt.Set {
			e.RawStr("\"last_modified_at\"" + ":")
			s.LastModifiedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LineNumbers != nil {
			e.Comma()
		}
		if s.LineNumbers != nil {
			e.RawStr("\"line_numbers\"" + ":")
			e.ArrStart()
			if len(s.LineNumbers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.LineNumbers[0]
					e.Str(elem)
				}
				for _, elem := range s.LineNumbers[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.TextMatches != nil {
			e.Comma()
		}
		if s.TextMatches != nil {
			e.RawStr("\"text_matches\"" + ":")
			s.TextMatches.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CodeSearchResultItem from json.
func (s *CodeSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeSearchResultItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "git_url":
			v, err := json.DecodeURI(d)
			s.GitURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "score":
			v, err := d.Float64()
			s.Score = float64(v)
			if err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		case "language":
			s.Language.Reset()
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "last_modified_at":
			s.LastModifiedAt.Reset()
			if err := s.LastModifiedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "line_numbers":
			s.LineNumbers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.LineNumbers = append(s.LineNumbers, elem)
				return nil
			}); err != nil {
				return err
			}
		case "text_matches":
			s.TextMatches = nil
			var elem SearchResultTextMatches
			{
				var unwrapped []SearchResultTextMatchesItem
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = SearchResultTextMatches(unwrapped)
			}
			s.TextMatches = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodesOfConductGetAllCodesOfConductOKApplicationJSON as json.
func (s CodesOfConductGetAllCodesOfConductOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CodeOfConduct(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes CodesOfConductGetAllCodesOfConductOKApplicationJSON from json.
func (s *CodesOfConductGetAllCodesOfConductOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodesOfConductGetAllCodesOfConductOKApplicationJSON to nil`)
	}
	var unwrapped []CodeOfConduct
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeOfConduct
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodesOfConductGetAllCodesOfConductOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s Collaborator) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		if s.Email.Set {
			e.Comma()
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes Collaborator from json.
func (s *Collaborator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Collaborator to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CollaboratorPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	e.ObjEnd()
}

// Decode decodes CollaboratorPermissions from json.
func (s *CollaboratorPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CollaboratorPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CombinedBillingUsage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"days_left_in_billing_cycle\"" + ":")
		e.Int(s.DaysLeftInBillingCycle)
	}
	{
		e.Comma()

		e.RawStr("\"estimated_paid_storage_for_month\"" + ":")
		e.Int(s.EstimatedPaidStorageForMonth)
	}
	{
		e.Comma()

		e.RawStr("\"estimated_storage_for_month\"" + ":")
		e.Int(s.EstimatedStorageForMonth)
	}
	e.ObjEnd()
}

// Decode decodes CombinedBillingUsage from json.
func (s *CombinedBillingUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CombinedBillingUsage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "days_left_in_billing_cycle":
			v, err := d.Int()
			s.DaysLeftInBillingCycle = int(v)
			if err != nil {
				return err
			}
		case "estimated_paid_storage_for_month":
			v, err := d.Int()
			s.EstimatedPaidStorageForMonth = int(v)
			if err != nil {
				return err
			}
		case "estimated_storage_for_month":
			v, err := d.Int()
			s.EstimatedStorageForMonth = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CombinedCommitStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"statuses\"" + ":")
		e.ArrStart()
		if len(s.Statuses) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Statuses[0]
				elem.Encode(e)
			}
			for _, elem := range s.Statuses[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commit_url\"" + ":")
		json.EncodeURI(e, s.CommitURL)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

// Decode decodes CombinedCommitStatus from json.
func (s *CombinedCommitStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CombinedCommitStatus to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "statuses":
			s.Statuses = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem SimpleCommitStatus
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Statuses = append(s.Statuses, elem)
				return nil
			}); err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "commit_url":
			v, err := json.DecodeURI(d)
			s.CommitURL = v
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Commit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		s.Commit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committer\"" + ":")
		s.Committer.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"parents\"" + ":")
		e.ArrStart()
		if len(s.Parents) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Parents[0]
				elem.Encode(e)
			}
			for _, elem := range s.Parents[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Stats.Set {
			e.Comma()
		}
		if s.Stats.Set {
			e.RawStr("\"stats\"" + ":")
			s.Stats.Encode(e)
		}
	}
	{
		if s.Files != nil {
			e.Comma()
		}
		if s.Files != nil {
			e.RawStr("\"files\"" + ":")
			e.ArrStart()
			if len(s.Files) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Files[0]
					elem.Encode(e)
				}
				for _, elem := range s.Files[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes Commit from json.
func (s *Commit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Commit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "commit":
			if err := s.Commit.Decode(d); err != nil {
				return err
			}
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "parents":
			s.Parents = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CommitParentsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Parents = append(s.Parents, elem)
				return nil
			}); err != nil {
				return err
			}
		case "stats":
			s.Stats.Reset()
			if err := s.Stats.Decode(d); err != nil {
				return err
			}
		case "files":
			s.Files = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CommitFilesItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Files = append(s.Files, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitActivity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"days\"" + ":")
		e.ArrStart()
		if len(s.Days) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Days[0]
				e.Int(elem)
			}
			for _, elem := range s.Days[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"total\"" + ":")
		e.Int(s.Total)
	}
	{
		e.Comma()

		e.RawStr("\"week\"" + ":")
		e.Int(s.Week)
	}
	e.ObjEnd()
}

// Decode decodes CommitActivity from json.
func (s *CommitActivity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitActivity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "days":
			s.Days = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Days = append(s.Days, elem)
				return nil
			}); err != nil {
				return err
			}
		case "total":
			v, err := d.Int()
			s.Total = int(v)
			if err != nil {
				return err
			}
		case "week":
			v, err := d.Int()
			s.Week = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitComment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		s.Path.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"position\"" + ":")
		s.Position.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"line\"" + ":")
		s.Line.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commit_id\"" + ":")
		e.Str(s.CommitID)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CommitComment from json.
func (s *CommitComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitComment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "path":
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "position":
			if err := s.Position.Decode(d); err != nil {
				return err
			}
		case "line":
			if err := s.Line.Decode(d); err != nil {
				return err
			}
		case "commit_id":
			v, err := d.Str()
			s.CommitID = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "reactions":
			s.Reactions.Reset()
			if err := s.Reactions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committer\"" + ":")
		s.Committer.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"comment_count\"" + ":")
		e.Int(s.CommentCount)
	}
	{
		e.Comma()

		e.RawStr("\"tree\"" + ":")
		s.Tree.Encode(e)
	}
	{
		if s.Verification.Set {
			e.Comma()
		}
		if s.Verification.Set {
			e.RawStr("\"verification\"" + ":")
			s.Verification.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CommitCommit from json.
func (s *CommitCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "comment_count":
			v, err := d.Int()
			s.CommentCount = int(v)
			if err != nil {
				return err
			}
		case "tree":
			if err := s.Tree.Decode(d); err != nil {
				return err
			}
		case "verification":
			s.Verification.Reset()
			if err := s.Verification.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitCommitTree) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

// Decode decodes CommitCommitTree from json.
func (s *CommitCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitCommitTree to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitComparison) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"permalink_url\"" + ":")
		json.EncodeURI(e, s.PermalinkURL)
	}
	{
		e.Comma()

		e.RawStr("\"diff_url\"" + ":")
		json.EncodeURI(e, s.DiffURL)
	}
	{
		e.Comma()

		e.RawStr("\"patch_url\"" + ":")
		json.EncodeURI(e, s.PatchURL)
	}
	{
		e.Comma()

		e.RawStr("\"base_commit\"" + ":")
		s.BaseCommit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"merge_base_commit\"" + ":")
		s.MergeBaseCommit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"ahead_by\"" + ":")
		e.Int(s.AheadBy)
	}
	{
		e.Comma()

		e.RawStr("\"behind_by\"" + ":")
		e.Int(s.BehindBy)
	}
	{
		e.Comma()

		e.RawStr("\"total_commits\"" + ":")
		e.Int(s.TotalCommits)
	}
	{
		e.Comma()

		e.RawStr("\"commits\"" + ":")
		e.ArrStart()
		if len(s.Commits) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Commits[0]
				elem.Encode(e)
			}
			for _, elem := range s.Commits[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Files != nil {
			e.Comma()
		}
		if s.Files != nil {
			e.RawStr("\"files\"" + ":")
			e.ArrStart()
			if len(s.Files) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Files[0]
					elem.Encode(e)
				}
				for _, elem := range s.Files[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes CommitComparison from json.
func (s *CommitComparison) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitComparison to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "permalink_url":
			v, err := json.DecodeURI(d)
			s.PermalinkURL = v
			if err != nil {
				return err
			}
		case "diff_url":
			v, err := json.DecodeURI(d)
			s.DiffURL = v
			if err != nil {
				return err
			}
		case "patch_url":
			v, err := json.DecodeURI(d)
			s.PatchURL = v
			if err != nil {
				return err
			}
		case "base_commit":
			if err := s.BaseCommit.Decode(d); err != nil {
				return err
			}
		case "merge_base_commit":
			if err := s.MergeBaseCommit.Decode(d); err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "ahead_by":
			v, err := d.Int()
			s.AheadBy = int(v)
			if err != nil {
				return err
			}
		case "behind_by":
			v, err := d.Int()
			s.BehindBy = int(v)
			if err != nil {
				return err
			}
		case "total_commits":
			v, err := d.Int()
			s.TotalCommits = int(v)
			if err != nil {
				return err
			}
		case "commits":
			s.Commits = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Commit
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Commits = append(s.Commits, elem)
				return nil
			}); err != nil {
				return err
			}
		case "files":
			s.Files = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem DiffEntry
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Files = append(s.Files, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CommitComparisonStatus as json.
func (s CommitComparisonStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CommitComparisonStatus from json.
func (s *CommitComparisonStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitComparisonStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CommitComparisonStatus(v) {
	case CommitComparisonStatusDiverged:
		*s = CommitComparisonStatusDiverged
	case CommitComparisonStatusAhead:
		*s = CommitComparisonStatusAhead
	case CommitComparisonStatusBehind:
		*s = CommitComparisonStatusBehind
	case CommitComparisonStatusIdentical:
		*s = CommitComparisonStatusIdentical
	default:
		*s = CommitComparisonStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommitFilesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Filename.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Filename.Set {
			e.RawStr("\"filename\"" + ":")
			s.Filename.Encode(e)
		}
	}
	{
		if s.Additions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Additions.Set {
			e.RawStr("\"additions\"" + ":")
			s.Additions.Encode(e)
		}
	}
	{
		if s.Deletions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Deletions.Set {
			e.RawStr("\"deletions\"" + ":")
			s.Deletions.Encode(e)
		}
	}
	{
		if s.Changes.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Changes.Set {
			e.RawStr("\"changes\"" + ":")
			s.Changes.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	{
		if s.RawURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RawURL.Set {
			e.RawStr("\"raw_url\"" + ":")
			s.RawURL.Encode(e)
		}
	}
	{
		if s.BlobURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BlobURL.Set {
			e.RawStr("\"blob_url\"" + ":")
			s.BlobURL.Encode(e)
		}
	}
	{
		if s.Patch.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Patch.Set {
			e.RawStr("\"patch\"" + ":")
			s.Patch.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.ContentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentsURL.Set {
			e.RawStr("\"contents_url\"" + ":")
			s.ContentsURL.Encode(e)
		}
	}
	{
		if s.PreviousFilename.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PreviousFilename.Set {
			e.RawStr("\"previous_filename\"" + ":")
			s.PreviousFilename.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CommitFilesItem from json.
func (s *CommitFilesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitFilesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "filename":
			s.Filename.Reset()
			if err := s.Filename.Decode(d); err != nil {
				return err
			}
		case "additions":
			s.Additions.Reset()
			if err := s.Additions.Decode(d); err != nil {
				return err
			}
		case "deletions":
			s.Deletions.Reset()
			if err := s.Deletions.Decode(d); err != nil {
				return err
			}
		case "changes":
			s.Changes.Reset()
			if err := s.Changes.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "raw_url":
			s.RawURL.Reset()
			if err := s.RawURL.Decode(d); err != nil {
				return err
			}
		case "blob_url":
			s.BlobURL.Reset()
			if err := s.BlobURL.Decode(d); err != nil {
				return err
			}
		case "patch":
			s.Patch.Reset()
			if err := s.Patch.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "contents_url":
			s.ContentsURL.Reset()
			if err := s.ContentsURL.Decode(d); err != nil {
				return err
			}
		case "previous_filename":
			s.PreviousFilename.Reset()
			if err := s.PreviousFilename.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitParentsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.HTMLURL.Set {
			e.Comma()
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CommitParentsItem from json.
func (s *CommitParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitParentsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitSearchResultItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		s.Commit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committer\"" + ":")
		s.Committer.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"parents\"" + ":")
		e.ArrStart()
		if len(s.Parents) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Parents[0]
				elem.Encode(e)
			}
			for _, elem := range s.Parents[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Float64(s.Score)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		if s.TextMatches != nil {
			e.Comma()
		}
		if s.TextMatches != nil {
			e.RawStr("\"text_matches\"" + ":")
			s.TextMatches.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CommitSearchResultItem from json.
func (s *CommitSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitSearchResultItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "commit":
			if err := s.Commit.Decode(d); err != nil {
				return err
			}
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "parents":
			s.Parents = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CommitSearchResultItemParentsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Parents = append(s.Parents, elem)
				return nil
			}); err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "score":
			v, err := d.Float64()
			s.Score = float64(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "text_matches":
			s.TextMatches = nil
			var elem SearchResultTextMatches
			{
				var unwrapped []SearchResultTextMatchesItem
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = SearchResultTextMatches(unwrapped)
			}
			s.TextMatches = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitSearchResultItemCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committer\"" + ":")
		s.Committer.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comment_count\"" + ":")
		e.Int(s.CommentCount)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"tree\"" + ":")
		s.Tree.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Verification.Set {
			e.Comma()
		}
		if s.Verification.Set {
			e.RawStr("\"verification\"" + ":")
			s.Verification.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CommitSearchResultItemCommit from json.
func (s *CommitSearchResultItemCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitSearchResultItemCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "comment_count":
			v, err := d.Int()
			s.CommentCount = int(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "tree":
			if err := s.Tree.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "verification":
			s.Verification.Reset()
			if err := s.Verification.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitSearchResultItemCommitAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		e.Comma()

		e.RawStr("\"date\"" + ":")
		json.EncodeDateTime(e, s.Date)
	}
	e.ObjEnd()
}

// Decode decodes CommitSearchResultItemCommitAuthor from json.
func (s *CommitSearchResultItemCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitSearchResultItemCommitAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "date":
			v, err := json.DecodeDateTime(d)
			s.Date = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitSearchResultItemCommitTree) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

// Decode decodes CommitSearchResultItemCommitTree from json.
func (s *CommitSearchResultItemCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitSearchResultItemCommitTree to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitSearchResultItemParentsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CommitSearchResultItemParentsItem from json.
func (s *CommitSearchResultItemParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitSearchResultItemParentsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitStats) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Additions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Additions.Set {
			e.RawStr("\"additions\"" + ":")
			s.Additions.Encode(e)
		}
	}
	{
		if s.Deletions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Deletions.Set {
			e.RawStr("\"deletions\"" + ":")
			s.Deletions.Encode(e)
		}
	}
	{
		if s.Total.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Total.Set {
			e.RawStr("\"total\"" + ":")
			s.Total.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CommitStats from json.
func (s *CommitStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitStats to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "additions":
			s.Additions.Reset()
			if err := s.Additions.Decode(d); err != nil {
				return err
			}
		case "deletions":
			s.Deletions.Reset()
			if err := s.Deletions.Decode(d); err != nil {
				return err
			}
		case "total":
			s.Total.Reset()
			if err := s.Total.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommunityProfile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"health_percentage\"" + ":")
		e.Int(s.HealthPercentage)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"documentation\"" + ":")
		s.Documentation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"files\"" + ":")
		s.Files.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.ContentReportsEnabled.Set {
			e.Comma()
		}
		if s.ContentReportsEnabled.Set {
			e.RawStr("\"content_reports_enabled\"" + ":")
			s.ContentReportsEnabled.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CommunityProfile from json.
func (s *CommunityProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommunityProfile to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "health_percentage":
			v, err := d.Int()
			s.HealthPercentage = int(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "documentation":
			if err := s.Documentation.Decode(d); err != nil {
				return err
			}
		case "files":
			if err := s.Files.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "content_reports_enabled":
			s.ContentReportsEnabled.Reset()
			if err := s.ContentReportsEnabled.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommunityProfileFiles) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code_of_conduct\"" + ":")
		s.CodeOfConduct.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"code_of_conduct_file\"" + ":")
		s.CodeOfConductFile.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"contributing\"" + ":")
		s.Contributing.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"readme\"" + ":")
		s.Readme.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"issue_template\"" + ":")
		s.IssueTemplate.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request_template\"" + ":")
		s.PullRequestTemplate.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CommunityProfileFiles from json.
func (s *CommunityProfileFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommunityProfileFiles to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code_of_conduct":
			if err := s.CodeOfConduct.Decode(d); err != nil {
				return err
			}
		case "code_of_conduct_file":
			if err := s.CodeOfConductFile.Decode(d); err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "contributing":
			if err := s.Contributing.Decode(d); err != nil {
				return err
			}
		case "readme":
			if err := s.Readme.Decode(d); err != nil {
				return err
			}
		case "issue_template":
			if err := s.IssueTemplate.Decode(d); err != nil {
				return err
			}
		case "pull_request_template":
			if err := s.PullRequestTemplate.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ContentFile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"encoding\"" + ":")
		e.Str(s.Encoding)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"content\"" + ":")
		e.Str(s.Content)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		s.GitURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"download_url\"" + ":")
		s.DownloadURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		if s.Target.Set {
			e.Comma()
		}
		if s.Target.Set {
			e.RawStr("\"target\"" + ":")
			s.Target.Encode(e)
		}
	}
	{
		if s.SubmoduleGitURL.Set {
			e.Comma()
		}
		if s.SubmoduleGitURL.Set {
			e.RawStr("\"submodule_git_url\"" + ":")
			s.SubmoduleGitURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ContentFile from json.
func (s *ContentFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ContentFile to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "encoding":
			v, err := d.Str()
			s.Encoding = string(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "content":
			v, err := d.Str()
			s.Content = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "git_url":
			if err := s.GitURL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "download_url":
			if err := s.DownloadURL.Decode(d); err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "target":
			s.Target.Reset()
			if err := s.Target.Decode(d); err != nil {
				return err
			}
		case "submodule_git_url":
			s.SubmoduleGitURL.Reset()
			if err := s.SubmoduleGitURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ContentFileLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"git\"" + ":")
		s.Git.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html\"" + ":")
		s.HTML.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"self\"" + ":")
		json.EncodeURI(e, s.Self)
	}
	e.ObjEnd()
}

// Decode decodes ContentFileLinks from json.
func (s *ContentFileLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ContentFileLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "git":
			if err := s.Git.Decode(d); err != nil {
				return err
			}
		case "html":
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		case "self":
			v, err := json.DecodeURI(d)
			s.Self = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ContentReferenceAttachment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		if s.NodeID.Set {
			e.Comma()
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ContentReferenceAttachment from json.
func (s *ContentReferenceAttachment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ContentReferenceAttachment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ContentTraffic) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"count\"" + ":")
		e.Int(s.Count)
	}
	{
		e.Comma()

		e.RawStr("\"uniques\"" + ":")
		e.Int(s.Uniques)
	}
	e.ObjEnd()
}

// Decode decodes ContentTraffic from json.
func (s *ContentTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ContentTraffic to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "count":
			v, err := d.Int()
			s.Count = int(v)
			if err != nil {
				return err
			}
		case "uniques":
			v, err := d.Int()
			s.Uniques = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Contributor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Login.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Login.Set {
			e.RawStr("\"login\"" + ":")
			s.Login.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvatarURL.Set {
			e.RawStr("\"avatar_url\"" + ":")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.GravatarID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GravatarID.Set {
			e.RawStr("\"gravatar_id\"" + ":")
			s.GravatarID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.FollowersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowersURL.Set {
			e.RawStr("\"followers_url\"" + ":")
			s.FollowersURL.Encode(e)
		}
	}
	{
		if s.FollowingURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowingURL.Set {
			e.RawStr("\"following_url\"" + ":")
			s.FollowingURL.Encode(e)
		}
	}
	{
		if s.GistsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GistsURL.Set {
			e.RawStr("\"gists_url\"" + ":")
			s.GistsURL.Encode(e)
		}
	}
	{
		if s.StarredURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StarredURL.Set {
			e.RawStr("\"starred_url\"" + ":")
			s.StarredURL.Encode(e)
		}
	}
	{
		if s.SubscriptionsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscriptionsURL.Set {
			e.RawStr("\"subscriptions_url\"" + ":")
			s.SubscriptionsURL.Encode(e)
		}
	}
	{
		if s.OrganizationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationsURL.Set {
			e.RawStr("\"organizations_url\"" + ":")
			s.OrganizationsURL.Encode(e)
		}
	}
	{
		if s.ReposURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReposURL.Set {
			e.RawStr("\"repos_url\"" + ":")
			s.ReposURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsURL.Set {
			e.RawStr("\"events_url\"" + ":")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ReceivedEventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReceivedEventsURL.Set {
			e.RawStr("\"received_events_url\"" + ":")
			s.ReceivedEventsURL.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		if s.SiteAdmin.Set {
			e.Comma()
		}
		if s.SiteAdmin.Set {
			e.RawStr("\"site_admin\"" + ":")
			s.SiteAdmin.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"contributions\"" + ":")
		e.Int(s.Contributions)
	}
	{
		if s.Email.Set {
			e.Comma()
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes Contributor from json.
func (s *Contributor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Contributor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			s.Login.Reset()
			if err := s.Login.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "avatar_url":
			s.AvatarURL.Reset()
			if err := s.AvatarURL.Decode(d); err != nil {
				return err
			}
		case "gravatar_id":
			s.GravatarID.Reset()
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "followers_url":
			s.FollowersURL.Reset()
			if err := s.FollowersURL.Decode(d); err != nil {
				return err
			}
		case "following_url":
			s.FollowingURL.Reset()
			if err := s.FollowingURL.Decode(d); err != nil {
				return err
			}
		case "gists_url":
			s.GistsURL.Reset()
			if err := s.GistsURL.Decode(d); err != nil {
				return err
			}
		case "starred_url":
			s.StarredURL.Reset()
			if err := s.StarredURL.Decode(d); err != nil {
				return err
			}
		case "subscriptions_url":
			s.SubscriptionsURL.Reset()
			if err := s.SubscriptionsURL.Decode(d); err != nil {
				return err
			}
		case "organizations_url":
			s.OrganizationsURL.Reset()
			if err := s.OrganizationsURL.Decode(d); err != nil {
				return err
			}
		case "repos_url":
			s.ReposURL.Reset()
			if err := s.ReposURL.Decode(d); err != nil {
				return err
			}
		case "events_url":
			s.EventsURL.Reset()
			if err := s.EventsURL.Decode(d); err != nil {
				return err
			}
		case "received_events_url":
			s.ReceivedEventsURL.Reset()
			if err := s.ReceivedEventsURL.Decode(d); err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "site_admin":
			s.SiteAdmin.Reset()
			if err := s.SiteAdmin.Decode(d); err != nil {
				return err
			}
		case "contributions":
			v, err := d.Int()
			s.Contributions = int(v)
			if err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ContributorActivity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"total\"" + ":")
		e.Int(s.Total)
	}
	{
		e.Comma()

		e.RawStr("\"weeks\"" + ":")
		e.ArrStart()
		if len(s.Weeks) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Weeks[0]
				elem.Encode(e)
			}
			for _, elem := range s.Weeks[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ContributorActivity from json.
func (s *ContributorActivity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ContributorActivity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "total":
			v, err := d.Int()
			s.Total = int(v)
			if err != nil {
				return err
			}
		case "weeks":
			s.Weeks = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ContributorActivityWeeksItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Weeks = append(s.Weeks, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ContributorActivityWeeksItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.W.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.W.Set {
			e.RawStr("\"w\"" + ":")
			s.W.Encode(e)
		}
	}
	{
		if s.A.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.A.Set {
			e.RawStr("\"a\"" + ":")
			s.A.Encode(e)
		}
	}
	{
		if s.D.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.D.Set {
			e.RawStr("\"d\"" + ":")
			s.D.Encode(e)
		}
	}
	{
		if s.C.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.C.Set {
			e.RawStr("\"c\"" + ":")
			s.C.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ContributorActivityWeeksItem from json.
func (s *ContributorActivityWeeksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ContributorActivityWeeksItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "w":
			s.W.Reset()
			if err := s.W.Decode(d); err != nil {
				return err
			}
		case "a":
			s.A.Reset()
			if err := s.A.Decode(d); err != nil {
				return err
			}
		case "d":
			s.D.Reset()
			if err := s.D.Decode(d); err != nil {
				return err
			}
		case "c":
			s.C.Reset()
			if err := s.C.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CredentialAuthorization) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"credential_id\"" + ":")
		e.Int(s.CredentialID)
	}
	{
		e.Comma()

		e.RawStr("\"credential_type\"" + ":")
		e.Str(s.CredentialType)
	}
	{
		if s.TokenLastEight.Set {
			e.Comma()
		}
		if s.TokenLastEight.Set {
			e.RawStr("\"token_last_eight\"" + ":")
			s.TokenLastEight.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"credential_authorized_at\"" + ":")
		json.EncodeDateTime(e, s.CredentialAuthorizedAt)
	}
	{
		if s.Scopes != nil {
			e.Comma()
		}
		if s.Scopes != nil {
			e.RawStr("\"scopes\"" + ":")
			e.ArrStart()
			if len(s.Scopes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Scopes[0]
					e.Str(elem)
				}
				for _, elem := range s.Scopes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Fingerprint.Set {
			e.Comma()
		}
		if s.Fingerprint.Set {
			e.RawStr("\"fingerprint\"" + ":")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.CredentialAccessedAt.Set {
			e.Comma()
		}
		if s.CredentialAccessedAt.Set {
			e.RawStr("\"credential_accessed_at\"" + ":")
			s.CredentialAccessedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AuthorizedCredentialID.Set {
			e.Comma()
		}
		if s.AuthorizedCredentialID.Set {
			e.RawStr("\"authorized_credential_id\"" + ":")
			s.AuthorizedCredentialID.Encode(e)
		}
	}
	{
		if s.AuthorizedCredentialTitle.Set {
			e.Comma()
		}
		if s.AuthorizedCredentialTitle.Set {
			e.RawStr("\"authorized_credential_title\"" + ":")
			s.AuthorizedCredentialTitle.Encode(e)
		}
	}
	{
		if s.AuthorizedCredentialNote.Set {
			e.Comma()
		}
		if s.AuthorizedCredentialNote.Set {
			e.RawStr("\"authorized_credential_note\"" + ":")
			s.AuthorizedCredentialNote.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CredentialAuthorization from json.
func (s *CredentialAuthorization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CredentialAuthorization to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "credential_id":
			v, err := d.Int()
			s.CredentialID = int(v)
			if err != nil {
				return err
			}
		case "credential_type":
			v, err := d.Str()
			s.CredentialType = string(v)
			if err != nil {
				return err
			}
		case "token_last_eight":
			s.TokenLastEight.Reset()
			if err := s.TokenLastEight.Decode(d); err != nil {
				return err
			}
		case "credential_authorized_at":
			v, err := json.DecodeDateTime(d)
			s.CredentialAuthorizedAt = v
			if err != nil {
				return err
			}
		case "scopes":
			s.Scopes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Scopes = append(s.Scopes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "fingerprint":
			s.Fingerprint.Reset()
			if err := s.Fingerprint.Decode(d); err != nil {
				return err
			}
		case "credential_accessed_at":
			s.CredentialAccessedAt.Reset()
			if err := s.CredentialAccessedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "authorized_credential_id":
			s.AuthorizedCredentialID.Reset()
			if err := s.AuthorizedCredentialID.Decode(d); err != nil {
				return err
			}
		case "authorized_credential_title":
			s.AuthorizedCredentialTitle.Reset()
			if err := s.AuthorizedCredentialTitle.Decode(d); err != nil {
				return err
			}
		case "authorized_credential_note":
			s.AuthorizedCredentialNote.Reset()
			if err := s.AuthorizedCredentialNote.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s DeployKey) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"verified\"" + ":")
		e.Bool(s.Verified)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		e.Str(s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"read_only\"" + ":")
		e.Bool(s.ReadOnly)
	}
	e.ObjEnd()
}

// Decode decodes DeployKey from json.
func (s *DeployKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeployKey to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "verified":
			v, err := d.Bool()
			s.Verified = bool(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := d.Str()
			s.CreatedAt = string(v)
			if err != nil {
				return err
			}
		case "read_only":
			v, err := d.Bool()
			s.ReadOnly = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Deployment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"task\"" + ":")
		e.Str(s.Task)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	{
		if s.OriginalEnvironment.Set {
			e.Comma()
		}
		if s.OriginalEnvironment.Set {
			e.RawStr("\"original_environment\"" + ":")
			s.OriginalEnvironment.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"environment\"" + ":")
		e.Str(s.Environment)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		json.EncodeURI(e, s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		if s.TransientEnvironment.Set {
			e.Comma()
		}
		if s.TransientEnvironment.Set {
			e.RawStr("\"transient_environment\"" + ":")
			s.TransientEnvironment.Encode(e)
		}
	}
	{
		if s.ProductionEnvironment.Set {
			e.Comma()
		}
		if s.ProductionEnvironment.Set {
			e.RawStr("\"production_environment\"" + ":")
			s.ProductionEnvironment.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes Deployment from json.
func (s *Deployment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Deployment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "task":
			v, err := d.Str()
			s.Task = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		case "original_environment":
			s.OriginalEnvironment.Reset()
			if err := s.OriginalEnvironment.Decode(d); err != nil {
				return err
			}
		case "environment":
			v, err := d.Str()
			s.Environment = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "creator":
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := json.DecodeURI(d)
			s.StatusesURL = v
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := json.DecodeURI(d)
			s.RepositoryURL = v
			if err != nil {
				return err
			}
		case "transient_environment":
			s.TransientEnvironment.Reset()
			if err := s.TransientEnvironment.Decode(d); err != nil {
				return err
			}
		case "production_environment":
			s.ProductionEnvironment.Reset()
			if err := s.ProductionEnvironment.Decode(d); err != nil {
				return err
			}
		case "performed_via_github_app":
			s.PerformedViaGithubApp.Reset()
			if err := s.PerformedViaGithubApp.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s DeploymentBranchPolicy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"protected_branches\"" + ":")
		e.Bool(s.ProtectedBranches)
	}
	{
		e.Comma()

		e.RawStr("\"custom_branch_policies\"" + ":")
		e.Bool(s.CustomBranchPolicies)
	}
	e.ObjEnd()
}

// Decode decodes DeploymentBranchPolicy from json.
func (s *DeploymentBranchPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeploymentBranchPolicy to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "protected_branches":
			v, err := d.Bool()
			s.ProtectedBranches = bool(v)
			if err != nil {
				return err
			}
		case "custom_branch_policies":
			v, err := d.Bool()
			s.CustomBranchPolicies = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes DeploymentPayload as json.
func (s DeploymentPayload) Encode(e *jx.Writer) {
	switch s.Type {
	case DeploymentPayload0DeploymentPayload:
		s.DeploymentPayload0.Encode(e)
	case StringDeploymentPayload:
		e.Str(s.String)
	}
}

// Decode decodes DeploymentPayload from json.
func (s *DeploymentPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeploymentPayload to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.DeploymentPayload0.Decode(d); err != nil {
			return err
		}
		s.Type = DeploymentPayload0DeploymentPayload
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDeploymentPayload
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s DeploymentPayload0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes DeploymentPayload0 from json.
func (s *DeploymentPayload0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeploymentPayload0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes DeploymentReviewerType as json.
func (s DeploymentReviewerType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes DeploymentReviewerType from json.
func (s *DeploymentReviewerType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeploymentReviewerType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeploymentReviewerType(v) {
	case DeploymentReviewerTypeUser:
		*s = DeploymentReviewerTypeUser
	case DeploymentReviewerTypeTeam:
		*s = DeploymentReviewerTypeTeam
	default:
		*s = DeploymentReviewerType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s DeploymentSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"task\"" + ":")
		e.Str(s.Task)
	}
	{
		if s.OriginalEnvironment.Set {
			e.Comma()
		}
		if s.OriginalEnvironment.Set {
			e.RawStr("\"original_environment\"" + ":")
			s.OriginalEnvironment.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"environment\"" + ":")
		e.Str(s.Environment)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		json.EncodeURI(e, s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		if s.TransientEnvironment.Set {
			e.Comma()
		}
		if s.TransientEnvironment.Set {
			e.RawStr("\"transient_environment\"" + ":")
			s.TransientEnvironment.Encode(e)
		}
	}
	{
		if s.ProductionEnvironment.Set {
			e.Comma()
		}
		if s.ProductionEnvironment.Set {
			e.RawStr("\"production_environment\"" + ":")
			s.ProductionEnvironment.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes DeploymentSimple from json.
func (s *DeploymentSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeploymentSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "task":
			v, err := d.Str()
			s.Task = string(v)
			if err != nil {
				return err
			}
		case "original_environment":
			s.OriginalEnvironment.Reset()
			if err := s.OriginalEnvironment.Decode(d); err != nil {
				return err
			}
		case "environment":
			v, err := d.Str()
			s.Environment = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := json.DecodeURI(d)
			s.StatusesURL = v
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := json.DecodeURI(d)
			s.RepositoryURL = v
			if err != nil {
				return err
			}
		case "transient_environment":
			s.TransientEnvironment.Reset()
			if err := s.TransientEnvironment.Decode(d); err != nil {
				return err
			}
		case "production_environment":
			s.ProductionEnvironment.Reset()
			if err := s.ProductionEnvironment.Decode(d); err != nil {
				return err
			}
		case "performed_via_github_app":
			s.PerformedViaGithubApp.Reset()
			if err := s.PerformedViaGithubApp.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s DeploymentStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		if s.Environment.Set {
			e.Comma()
		}
		if s.Environment.Set {
			e.RawStr("\"environment\"" + ":")
			s.Environment.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"target_url\"" + ":")
		json.EncodeURI(e, s.TargetURL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"deployment_url\"" + ":")
		json.EncodeURI(e, s.DeploymentURL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		if s.EnvironmentURL.Set {
			e.Comma()
		}
		if s.EnvironmentURL.Set {
			e.RawStr("\"environment_url\"" + ":")
			s.EnvironmentURL.Encode(e)
		}
	}
	{
		if s.LogURL.Set {
			e.Comma()
		}
		if s.LogURL.Set {
			e.RawStr("\"log_url\"" + ":")
			s.LogURL.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes DeploymentStatus from json.
func (s *DeploymentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeploymentStatus to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "creator":
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		case "description":
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "environment":
			s.Environment.Reset()
			if err := s.Environment.Decode(d); err != nil {
				return err
			}
		case "target_url":
			v, err := json.DecodeURI(d)
			s.TargetURL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "deployment_url":
			v, err := json.DecodeURI(d)
			s.DeploymentURL = v
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := json.DecodeURI(d)
			s.RepositoryURL = v
			if err != nil {
				return err
			}
		case "environment_url":
			s.EnvironmentURL.Reset()
			if err := s.EnvironmentURL.Decode(d); err != nil {
				return err
			}
		case "log_url":
			s.LogURL.Reset()
			if err := s.LogURL.Decode(d); err != nil {
				return err
			}
		case "performed_via_github_app":
			s.PerformedViaGithubApp.Reset()
			if err := s.PerformedViaGithubApp.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes DeploymentStatusState as json.
func (s DeploymentStatusState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes DeploymentStatusState from json.
func (s *DeploymentStatusState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeploymentStatusState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeploymentStatusState(v) {
	case DeploymentStatusStateError:
		*s = DeploymentStatusStateError
	case DeploymentStatusStateFailure:
		*s = DeploymentStatusStateFailure
	case DeploymentStatusStateInactive:
		*s = DeploymentStatusStateInactive
	case DeploymentStatusStatePending:
		*s = DeploymentStatusStatePending
	case DeploymentStatusStateSuccess:
		*s = DeploymentStatusStateSuccess
	case DeploymentStatusStateQueued:
		*s = DeploymentStatusStateQueued
	case DeploymentStatusStateInProgress:
		*s = DeploymentStatusStateInProgress
	default:
		*s = DeploymentStatusState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s DiffEntry) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"filename\"" + ":")
		e.Str(s.Filename)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"additions\"" + ":")
		e.Int(s.Additions)
	}
	{
		e.Comma()

		e.RawStr("\"deletions\"" + ":")
		e.Int(s.Deletions)
	}
	{
		e.Comma()

		e.RawStr("\"changes\"" + ":")
		e.Int(s.Changes)
	}
	{
		e.Comma()

		e.RawStr("\"blob_url\"" + ":")
		json.EncodeURI(e, s.BlobURL)
	}
	{
		e.Comma()

		e.RawStr("\"raw_url\"" + ":")
		json.EncodeURI(e, s.RawURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		json.EncodeURI(e, s.ContentsURL)
	}
	{
		if s.Patch.Set {
			e.Comma()
		}
		if s.Patch.Set {
			e.RawStr("\"patch\"" + ":")
			s.Patch.Encode(e)
		}
	}
	{
		if s.PreviousFilename.Set {
			e.Comma()
		}
		if s.PreviousFilename.Set {
			e.RawStr("\"previous_filename\"" + ":")
			s.PreviousFilename.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes DiffEntry from json.
func (s *DiffEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DiffEntry to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "filename":
			v, err := d.Str()
			s.Filename = string(v)
			if err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "additions":
			v, err := d.Int()
			s.Additions = int(v)
			if err != nil {
				return err
			}
		case "deletions":
			v, err := d.Int()
			s.Deletions = int(v)
			if err != nil {
				return err
			}
		case "changes":
			v, err := d.Int()
			s.Changes = int(v)
			if err != nil {
				return err
			}
		case "blob_url":
			v, err := json.DecodeURI(d)
			s.BlobURL = v
			if err != nil {
				return err
			}
		case "raw_url":
			v, err := json.DecodeURI(d)
			s.RawURL = v
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := json.DecodeURI(d)
			s.ContentsURL = v
			if err != nil {
				return err
			}
		case "patch":
			s.Patch.Reset()
			if err := s.Patch.Decode(d); err != nil {
				return err
			}
		case "previous_filename":
			s.PreviousFilename.Reset()
			if err := s.PreviousFilename.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes DiffEntryStatus as json.
func (s DiffEntryStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes DiffEntryStatus from json.
func (s *DiffEntryStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DiffEntryStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DiffEntryStatus(v) {
	case DiffEntryStatusAdded:
		*s = DiffEntryStatusAdded
	case DiffEntryStatusRemoved:
		*s = DiffEntryStatusRemoved
	case DiffEntryStatusModified:
		*s = DiffEntryStatusModified
	case DiffEntryStatusRenamed:
		*s = DiffEntryStatusRenamed
	case DiffEntryStatusCopied:
		*s = DiffEntryStatusCopied
	case DiffEntryStatusChanged:
		*s = DiffEntryStatusChanged
	case DiffEntryStatusUnchanged:
		*s = DiffEntryStatusUnchanged
	default:
		*s = DiffEntryStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Email) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		e.Comma()

		e.RawStr("\"primary\"" + ":")
		e.Bool(s.Primary)
	}
	{
		e.Comma()

		e.RawStr("\"verified\"" + ":")
		e.Bool(s.Verified)
	}
	{
		e.Comma()

		e.RawStr("\"visibility\"" + ":")
		s.Visibility.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Email from json.
func (s *Email) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Email to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "primary":
			v, err := d.Bool()
			s.Primary = bool(v)
			if err != nil {
				return err
			}
		case "verified":
			v, err := d.Bool()
			s.Verified = bool(v)
			if err != nil {
				return err
			}
		case "visibility":
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EmojisGetOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EmojisGetOK from json.
func (s *EmojisGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EmojisGetOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EmptyObject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EmptyObject from json.
func (s *EmptyObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EmptyObject to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes EnabledOrganizations as json.
func (s EnabledOrganizations) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes EnabledOrganizations from json.
func (s *EnabledOrganizations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnabledOrganizations to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnabledOrganizations(v) {
	case EnabledOrganizationsAll:
		*s = EnabledOrganizationsAll
	case EnabledOrganizationsNone:
		*s = EnabledOrganizationsNone
	case EnabledOrganizationsSelected:
		*s = EnabledOrganizationsSelected
	default:
		*s = EnabledOrganizations(v)
	}

	return nil
}

// Encode encodes EnabledRepositories as json.
func (s EnabledRepositories) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes EnabledRepositories from json.
func (s *EnabledRepositories) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnabledRepositories to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnabledRepositories(v) {
	case EnabledRepositoriesAll:
		*s = EnabledRepositoriesAll
	case EnabledRepositoriesNone:
		*s = EnabledRepositoriesNone
	case EnabledRepositoriesSelected:
		*s = EnabledRepositoriesSelected
	default:
		*s = EnabledRepositories(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent from json.
func (s *EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent from json.
func (s *EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.SelectedOrganizationIds != nil {
			e.Comma()
		}
		if s.SelectedOrganizationIds != nil {
			e.RawStr("\"selected_organization_ids\"" + ":")
			e.ArrStart()
			if len(s.SelectedOrganizationIds) >= 1 {
				// Encode first element without comma.
				{
					elem := s.SelectedOrganizationIds[0]
					e.Int(elem)
				}
				for _, elem := range s.SelectedOrganizationIds[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Runners != nil {
			e.Comma()
		}
		if s.Runners != nil {
			e.RawStr("\"runners\"" + ":")
			e.ArrStart()
			if len(s.Runners) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Runners[0]
					e.Int(elem)
				}
				for _, elem := range s.Runners[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq from json.
func (s *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "selected_organization_ids":
			s.SelectedOrganizationIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.SelectedOrganizationIds = append(s.SelectedOrganizationIds, elem)
				return nil
			}); err != nil {
				return err
			}
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (s EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (s *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility(v) {
	case EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibilitySelected:
		*s = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibilitySelected
	case EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibilityAll:
		*s = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibilityAll
	default:
		*s = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent from json.
func (s *EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent from json.
func (s *EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent from json.
func (s *EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminDeleteUserFromEnterpriseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminDeleteUserFromEnterpriseNoContent from json.
func (s *EnterpriseAdminDeleteUserFromEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminDeleteUserFromEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent from json.
func (s *EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent from json.
func (s *EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes EnterpriseAdminGetAuditLogInclude as json.
func (s EnterpriseAdminGetAuditLogInclude) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes EnterpriseAdminGetAuditLogInclude from json.
func (s *EnterpriseAdminGetAuditLogInclude) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminGetAuditLogInclude to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnterpriseAdminGetAuditLogInclude(v) {
	case EnterpriseAdminGetAuditLogIncludeWeb:
		*s = EnterpriseAdminGetAuditLogIncludeWeb
	case EnterpriseAdminGetAuditLogIncludeGit:
		*s = EnterpriseAdminGetAuditLogIncludeGit
	case EnterpriseAdminGetAuditLogIncludeAll:
		*s = EnterpriseAdminGetAuditLogIncludeAll
	default:
		*s = EnterpriseAdminGetAuditLogInclude(v)
	}

	return nil
}

// Encode encodes EnterpriseAdminGetAuditLogOrder as json.
func (s EnterpriseAdminGetAuditLogOrder) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes EnterpriseAdminGetAuditLogOrder from json.
func (s *EnterpriseAdminGetAuditLogOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminGetAuditLogOrder to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnterpriseAdminGetAuditLogOrder(v) {
	case EnterpriseAdminGetAuditLogOrderDesc:
		*s = EnterpriseAdminGetAuditLogOrderDesc
	case EnterpriseAdminGetAuditLogOrderAsc:
		*s = EnterpriseAdminGetAuditLogOrderAsc
	default:
		*s = EnterpriseAdminGetAuditLogOrder(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"organizations\"" + ":")
		e.ArrStart()
		if len(s.Organizations) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Organizations[0]
				elem.Encode(e)
			}
			for _, elem := range s.Organizations[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK from json.
func (s *EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "organizations":
			s.Organizations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem OrganizationSimple
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Organizations = append(s.Organizations, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"organizations\"" + ":")
		e.ArrStart()
		if len(s.Organizations) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Organizations[0]
				elem.Encode(e)
			}
			for _, elem := range s.Organizations[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK from json.
func (s *EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "organizations":
			s.Organizations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem OrganizationSimple
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Organizations = append(s.Organizations, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"runner_groups\"" + ":")
		e.ArrStart()
		if len(s.RunnerGroups) >= 1 {
			// Encode first element without comma.
			{
				elem := s.RunnerGroups[0]
				elem.Encode(e)
			}
			for _, elem := range s.RunnerGroups[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK from json.
func (s *EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "runner_groups":
			s.RunnerGroups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem RunnerGroupsEnterprise
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.RunnerGroups = append(s.RunnerGroups, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminListSelfHostedRunnersForEnterpriseOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.TotalCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TotalCount.Set {
			e.RawStr("\"total_count\"" + ":")
			s.TotalCount.Encode(e)
		}
	}
	{
		if s.Runners != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Runners != nil {
			e.RawStr("\"runners\"" + ":")
			e.ArrStart()
			if len(s.Runners) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Runners[0]
					elem.Encode(e)
				}
				for _, elem := range s.Runners[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminListSelfHostedRunnersForEnterpriseOK from json.
func (s *EnterpriseAdminListSelfHostedRunnersForEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminListSelfHostedRunnersForEnterpriseOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			s.TotalCount.Reset()
			if err := s.TotalCount.Decode(d); err != nil {
				return err
			}
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Runner
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"runners\"" + ":")
		e.ArrStart()
		if len(s.Runners) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Runners[0]
				elem.Encode(e)
			}
			for _, elem := range s.Runners[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK from json.
func (s *EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Runner
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseGroupReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"displayName\"" + ":")
		e.Str(s.DisplayName)
	}
	{
		if s.Members != nil {
			e.Comma()
		}
		if s.Members != nil {
			e.RawStr("\"members\"" + ":")
			e.ArrStart()
			if len(s.Members) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Members[0]
					elem.Encode(e)
				}
				for _, elem := range s.Members[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseGroupReq from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseGroupReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "displayName":
			v, err := d.Str()
			s.DisplayName = string(v)
			if err != nil {
				return err
			}
		case "members":
			s.Members = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Members = append(s.Members, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			v, err := d.Str()
			s.Value = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"userName\"" + ":")
		e.Str(s.UserName)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		s.Name.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"emails\"" + ":")
		e.ArrStart()
		if len(s.Emails) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Emails[0]
				elem.Encode(e)
			}
			for _, elem := range s.Emails[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Groups != nil {
			e.Comma()
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					elem.Encode(e)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReq from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "userName":
			v, err := d.Str()
			s.UserName = string(v)
			if err != nil {
				return err
			}
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"primary\"" + ":")
		e.Bool(s.Primary)
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			v, err := d.Str()
			s.Value = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "primary":
			v, err := d.Bool()
			s.Primary = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseUserReqName) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"givenName\"" + ":")
		e.Str(s.GivenName)
	}
	{
		e.Comma()

		e.RawStr("\"familyName\"" + ":")
		e.Str(s.FamilyName)
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReqName from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqName to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			v, err := d.Str()
			s.GivenName = string(v)
			if err != nil {
				return err
			}
		case "familyName":
			v, err := d.Str()
			s.FamilyName = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent from json.
func (s *EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent from json.
func (s *EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetAllowedActionsEnterpriseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetAllowedActionsEnterpriseNoContent from json.
func (s *EnterpriseAdminSetAllowedActionsEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetAllowedActionsEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent from json.
func (s *EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled_organizations\"" + ":")
		s.EnabledOrganizations.Encode(e)
	}
	{
		if s.AllowedActions.Set {
			e.Comma()
		}
		if s.AllowedActions.Set {
			e.RawStr("\"allowed_actions\"" + ":")
			s.AllowedActions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq from json.
func (s *EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_organizations":
			if err := s.EnabledOrganizations.Decode(d); err != nil {
				return err
			}
		case "allowed_actions":
			s.AllowedActions.Reset()
			if err := s.AllowedActions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"displayName\"" + ":")
		e.Str(s.DisplayName)
	}
	{
		if s.Members != nil {
			e.Comma()
		}
		if s.Members != nil {
			e.RawStr("\"members\"" + ":")
			e.ArrStart()
			if len(s.Members) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Members[0]
					elem.Encode(e)
				}
				for _, elem := range s.Members[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "displayName":
			v, err := d.Str()
			s.DisplayName = string(v)
			if err != nil {
				return err
			}
		case "members":
			s.Members = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Members = append(s.Members, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			v, err := d.Str()
			s.Value = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"userName\"" + ":")
		e.Str(s.UserName)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		s.Name.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"emails\"" + ":")
		e.ArrStart()
		if len(s.Emails) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Emails[0]
				elem.Encode(e)
			}
			for _, elem := range s.Emails[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Groups != nil {
			e.Comma()
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					elem.Encode(e)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "userName":
			v, err := d.Str()
			s.UserName = string(v)
			if err != nil {
				return err
			}
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"primary\"" + ":")
		e.Bool(s.Primary)
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			v, err := d.Str()
			s.Value = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "primary":
			v, err := d.Bool()
			s.Primary = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"givenName\"" + ":")
		e.Str(s.GivenName)
	}
	{
		e.Comma()

		e.RawStr("\"familyName\"" + ":")
		e.Str(s.FamilyName)
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			v, err := d.Str()
			s.GivenName = string(v)
			if err != nil {
				return err
			}
		case "familyName":
			v, err := d.Str()
			s.FamilyName = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent from json.
func (s *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selected_organization_ids\"" + ":")
		e.ArrStart()
		if len(s.SelectedOrganizationIds) >= 1 {
			// Encode first element without comma.
			{
				elem := s.SelectedOrganizationIds[0]
				e.Int(elem)
			}
			for _, elem := range s.SelectedOrganizationIds[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq from json.
func (s *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_organization_ids":
			s.SelectedOrganizationIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.SelectedOrganizationIds = append(s.SelectedOrganizationIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent from json.
func (s *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selected_organization_ids\"" + ":")
		e.ArrStart()
		if len(s.SelectedOrganizationIds) >= 1 {
			// Encode first element without comma.
			{
				elem := s.SelectedOrganizationIds[0]
				e.Int(elem)
			}
			for _, elem := range s.SelectedOrganizationIds[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq from json.
func (s *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_organization_ids":
			s.SelectedOrganizationIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.SelectedOrganizationIds = append(s.SelectedOrganizationIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent from json.
func (s *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"runners\"" + ":")
		e.ArrStart()
		if len(s.Runners) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Runners[0]
				e.Int(elem)
			}
			for _, elem := range s.Runners[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq from json.
func (s *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminUpdateAttributeForEnterpriseGroupReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"Operations\"" + ":")
		e.ArrStart()
		if len(s.Operations) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Operations[0]
				elem.Encode(e)
			}
			for _, elem := range s.Operations[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReq from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "Operations":
			s.Operations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Operations = append(s.Operations, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"op\"" + ":")
		s.Op.Encode(e)
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.Comma()
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "op":
			if err := s.Op.Decode(d); err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp as json.
func (s EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp(v) {
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_add:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_add
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Add:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Add
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_remove:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_remove
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Remove:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Remove
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_replace:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_replace
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Replace:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Replace
	default:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp(v)
	}

	return nil
}

// Encode encodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue as json.
func (s EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) Encode(e *jx.Writer) {
	switch s.Type {
	case StringEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue:
		e.Str(s.String)
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue:
		s.EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1.Encode(e)
	case ArrayStringEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue
	case jx.Object:
		if err := s.EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1.Decode(d); err != nil {
			return err
		}
		s.Type = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1 from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminUpdateAttributeForEnterpriseUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"Operations\"" + ":")
		e.ArrStart()
		if len(s.Operations) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Operations[0]
				elem.Encode(e)
			}
			for _, elem := range s.Operations[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseUserReq from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "Operations":
			s.Operations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Operations = append(s.Operations, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq from json.
func (s *EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (s EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (s *EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility(v) {
	case EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibilitySelected:
		*s = EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibilitySelected
	case EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibilityAll:
		*s = EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibilityAll
	default:
		*s = EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnvironmentApprovals) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"environments\"" + ":")
		e.ArrStart()
		if len(s.Environments) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Environments[0]
				elem.Encode(e)
			}
			for _, elem := range s.Environments[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comment\"" + ":")
		e.Str(s.Comment)
	}
	e.ObjEnd()
}

// Decode decodes EnvironmentApprovals from json.
func (s *EnvironmentApprovals) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnvironmentApprovals to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "environments":
			s.Environments = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnvironmentApprovalsEnvironmentsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Environments = append(s.Environments, elem)
				return nil
			}); err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "comment":
			v, err := d.Str()
			s.Comment = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnvironmentApprovalsEnvironmentsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

// Decode decodes EnvironmentApprovalsEnvironmentsItem from json.
func (s *EnvironmentApprovalsEnvironmentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnvironmentApprovalsEnvironmentsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes EnvironmentApprovalsState as json.
func (s EnvironmentApprovalsState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes EnvironmentApprovalsState from json.
func (s *EnvironmentApprovalsState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnvironmentApprovalsState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnvironmentApprovalsState(v) {
	case EnvironmentApprovalsStateApproved:
		*s = EnvironmentApprovalsStateApproved
	case EnvironmentApprovalsStateRejected:
		*s = EnvironmentApprovalsStateRejected
	default:
		*s = EnvironmentApprovalsState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Event) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"actor\"" + ":")
		s.Actor.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"repo\"" + ":")
		s.Repo.Encode(e)
	}
	{
		if s.Org.Set {
			e.Comma()
		}
		if s.Org.Set {
			e.RawStr("\"org\"" + ":")
			s.Org.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"public\"" + ":")
		e.Bool(s.Public)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes Event from json.
func (s *Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Event to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "type":
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "actor":
			if err := s.Actor.Decode(d); err != nil {
				return err
			}
		case "repo":
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		case "org":
			s.Org.Reset()
			if err := s.Org.Decode(d); err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		case "public":
			v, err := d.Bool()
			s.Public = bool(v)
			if err != nil {
				return err
			}
		case "created_at":
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EventPayload) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Action.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Action.Set {
			e.RawStr("\"action\"" + ":")
			s.Action.Encode(e)
		}
	}
	{
		if s.Issue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Issue.Set {
			e.RawStr("\"issue\"" + ":")
			s.Issue.Encode(e)
		}
	}
	{
		if s.Comment.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Comment.Set {
			e.RawStr("\"comment\"" + ":")
			s.Comment.Encode(e)
		}
	}
	{
		if s.Pages != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pages != nil {
			e.RawStr("\"pages\"" + ":")
			e.ArrStart()
			if len(s.Pages) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Pages[0]
					elem.Encode(e)
				}
				for _, elem := range s.Pages[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes EventPayload from json.
func (s *EventPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EventPayload to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			s.Action.Reset()
			if err := s.Action.Decode(d); err != nil {
				return err
			}
		case "issue":
			s.Issue.Reset()
			if err := s.Issue.Decode(d); err != nil {
				return err
			}
		case "comment":
			s.Comment.Reset()
			if err := s.Comment.Decode(d); err != nil {
				return err
			}
		case "pages":
			s.Pages = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EventPayloadPagesItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Pages = append(s.Pages, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EventPayloadPagesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PageName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PageName.Set {
			e.RawStr("\"page_name\"" + ":")
			s.PageName.Encode(e)
		}
	}
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Summary.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Summary.Set {
			e.RawStr("\"summary\"" + ":")
			s.Summary.Encode(e)
		}
	}
	{
		if s.Action.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Action.Set {
			e.RawStr("\"action\"" + ":")
			s.Action.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes EventPayloadPagesItem from json.
func (s *EventPayloadPagesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EventPayloadPagesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page_name":
			s.PageName.Reset()
			if err := s.PageName.Decode(d); err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "summary":
			s.Summary.Reset()
			if err := s.Summary.Decode(d); err != nil {
				return err
			}
		case "action":
			s.Action.Reset()
			if err := s.Action.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EventRepo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

// Decode decodes EventRepo from json.
func (s *EventRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EventRepo to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Feed) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"timeline_url\"" + ":")
		e.Str(s.TimelineURL)
	}
	{
		e.Comma()

		e.RawStr("\"user_url\"" + ":")
		e.Str(s.UserURL)
	}
	{
		if s.CurrentUserPublicURL.Set {
			e.Comma()
		}
		if s.CurrentUserPublicURL.Set {
			e.RawStr("\"current_user_public_url\"" + ":")
			s.CurrentUserPublicURL.Encode(e)
		}
	}
	{
		if s.CurrentUserURL.Set {
			e.Comma()
		}
		if s.CurrentUserURL.Set {
			e.RawStr("\"current_user_url\"" + ":")
			s.CurrentUserURL.Encode(e)
		}
	}
	{
		if s.CurrentUserActorURL.Set {
			e.Comma()
		}
		if s.CurrentUserActorURL.Set {
			e.RawStr("\"current_user_actor_url\"" + ":")
			s.CurrentUserActorURL.Encode(e)
		}
	}
	{
		if s.CurrentUserOrganizationURL.Set {
			e.Comma()
		}
		if s.CurrentUserOrganizationURL.Set {
			e.RawStr("\"current_user_organization_url\"" + ":")
			s.CurrentUserOrganizationURL.Encode(e)
		}
	}
	{
		if s.CurrentUserOrganizationUrls != nil {
			e.Comma()
		}
		if s.CurrentUserOrganizationUrls != nil {
			e.RawStr("\"current_user_organization_urls\"" + ":")
			e.ArrStart()
			if len(s.CurrentUserOrganizationUrls) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CurrentUserOrganizationUrls[0]
					json.EncodeURI(e, elem)
				}
				for _, elem := range s.CurrentUserOrganizationUrls[1:] {
					e.Comma()
					json.EncodeURI(e, elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.SecurityAdvisoriesURL.Set {
			e.Comma()
		}
		if s.SecurityAdvisoriesURL.Set {
			e.RawStr("\"security_advisories_url\"" + ":")
			s.SecurityAdvisoriesURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Feed from json.
func (s *Feed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Feed to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeline_url":
			v, err := d.Str()
			s.TimelineURL = string(v)
			if err != nil {
				return err
			}
		case "user_url":
			v, err := d.Str()
			s.UserURL = string(v)
			if err != nil {
				return err
			}
		case "current_user_public_url":
			s.CurrentUserPublicURL.Reset()
			if err := s.CurrentUserPublicURL.Decode(d); err != nil {
				return err
			}
		case "current_user_url":
			s.CurrentUserURL.Reset()
			if err := s.CurrentUserURL.Decode(d); err != nil {
				return err
			}
		case "current_user_actor_url":
			s.CurrentUserActorURL.Reset()
			if err := s.CurrentUserActorURL.Decode(d); err != nil {
				return err
			}
		case "current_user_organization_url":
			s.CurrentUserOrganizationURL.Reset()
			if err := s.CurrentUserOrganizationURL.Decode(d); err != nil {
				return err
			}
		case "current_user_organization_urls":
			s.CurrentUserOrganizationUrls = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem url.URL
				v, err := json.DecodeURI(d)
				elem = v
				if err != nil {
					return err
				}
				s.CurrentUserOrganizationUrls = append(s.CurrentUserOrganizationUrls, elem)
				return nil
			}); err != nil {
				return err
			}
		case "security_advisories_url":
			s.SecurityAdvisoriesURL.Reset()
			if err := s.SecurityAdvisoriesURL.Decode(d); err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FeedLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"timeline\"" + ":")
		s.Timeline.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		if s.SecurityAdvisories.Set {
			e.Comma()
		}
		if s.SecurityAdvisories.Set {
			e.RawStr("\"security_advisories\"" + ":")
			s.SecurityAdvisories.Encode(e)
		}
	}
	{
		if s.CurrentUser.Set {
			e.Comma()
		}
		if s.CurrentUser.Set {
			e.RawStr("\"current_user\"" + ":")
			s.CurrentUser.Encode(e)
		}
	}
	{
		if s.CurrentUserPublic.Set {
			e.Comma()
		}
		if s.CurrentUserPublic.Set {
			e.RawStr("\"current_user_public\"" + ":")
			s.CurrentUserPublic.Encode(e)
		}
	}
	{
		if s.CurrentUserActor.Set {
			e.Comma()
		}
		if s.CurrentUserActor.Set {
			e.RawStr("\"current_user_actor\"" + ":")
			s.CurrentUserActor.Encode(e)
		}
	}
	{
		if s.CurrentUserOrganization.Set {
			e.Comma()
		}
		if s.CurrentUserOrganization.Set {
			e.RawStr("\"current_user_organization\"" + ":")
			s.CurrentUserOrganization.Encode(e)
		}
	}
	{
		if s.CurrentUserOrganizations != nil {
			e.Comma()
		}
		if s.CurrentUserOrganizations != nil {
			e.RawStr("\"current_user_organizations\"" + ":")
			e.ArrStart()
			if len(s.CurrentUserOrganizations) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CurrentUserOrganizations[0]
					elem.Encode(e)
				}
				for _, elem := range s.CurrentUserOrganizations[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes FeedLinks from json.
func (s *FeedLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FeedLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeline":
			if err := s.Timeline.Decode(d); err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "security_advisories":
			s.SecurityAdvisories.Reset()
			if err := s.SecurityAdvisories.Decode(d); err != nil {
				return err
			}
		case "current_user":
			s.CurrentUser.Reset()
			if err := s.CurrentUser.Decode(d); err != nil {
				return err
			}
		case "current_user_public":
			s.CurrentUserPublic.Reset()
			if err := s.CurrentUserPublic.Decode(d); err != nil {
				return err
			}
		case "current_user_actor":
			s.CurrentUserActor.Reset()
			if err := s.CurrentUserActor.Decode(d); err != nil {
				return err
			}
		case "current_user_organization":
			s.CurrentUserOrganization.Reset()
			if err := s.CurrentUserOrganization.Decode(d); err != nil {
				return err
			}
		case "current_user_organizations":
			s.CurrentUserOrganizations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem LinkWithType
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CurrentUserOrganizations = append(s.CurrentUserOrganizations, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		s.Commit.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes FileCommit from json.
func (s *FileCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		case "commit":
			if err := s.Commit.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Author.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Author.Set {
			e.RawStr("\"author\"" + ":")
			s.Author.Encode(e)
		}
	}
	{
		if s.Committer.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Committer.Set {
			e.RawStr("\"committer\"" + ":")
			s.Committer.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Tree.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Tree.Set {
			e.RawStr("\"tree\"" + ":")
			s.Tree.Encode(e)
		}
	}
	{
		if s.Parents != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Parents != nil {
			e.RawStr("\"parents\"" + ":")
			e.ArrStart()
			if len(s.Parents) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Parents[0]
					elem.Encode(e)
				}
				for _, elem := range s.Parents[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Verification.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Verification.Set {
			e.RawStr("\"verification\"" + ":")
			s.Verification.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes FileCommitCommit from json.
func (s *FileCommitCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "author":
			s.Author.Reset()
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			s.Committer.Reset()
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "tree":
			s.Tree.Reset()
			if err := s.Tree.Decode(d); err != nil {
				return err
			}
		case "parents":
			s.Parents = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem FileCommitCommitParentsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Parents = append(s.Parents, elem)
				return nil
			}); err != nil {
				return err
			}
		case "verification":
			s.Verification.Reset()
			if err := s.Verification.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitCommitAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Date.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes FileCommitCommitAuthor from json.
func (s *FileCommitCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitCommitAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitCommitCommitter) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Date.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes FileCommitCommitCommitter from json.
func (s *FileCommitCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitCommitCommitter to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitCommitParentsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes FileCommitCommitParentsItem from json.
func (s *FileCommitCommitParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitCommitParentsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitCommitTree) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes FileCommitCommitTree from json.
func (s *FileCommitCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitCommitTree to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitCommitVerification) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Verified.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Verified.Set {
			e.RawStr("\"verified\"" + ":")
			s.Verified.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Signature.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Signature.Set {
			e.RawStr("\"signature\"" + ":")
			s.Signature.Encode(e)
		}
	}
	{
		if s.Payload.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Payload.Set {
			e.RawStr("\"payload\"" + ":")
			s.Payload.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes FileCommitCommitVerification from json.
func (s *FileCommitCommitVerification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitCommitVerification to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verified":
			s.Verified.Reset()
			if err := s.Verified.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "signature":
			s.Signature.Reset()
			if err := s.Signature.Decode(d); err != nil {
				return err
			}
		case "payload":
			s.Payload.Reset()
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Path.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.Size.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Size.Set {
			e.RawStr("\"size\"" + ":")
			s.Size.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.GitURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitURL.Set {
			e.RawStr("\"git_url\"" + ":")
			s.GitURL.Encode(e)
		}
	}
	{
		if s.DownloadURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DownloadURL.Set {
			e.RawStr("\"download_url\"" + ":")
			s.DownloadURL.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.Links.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Links.Set {
			e.RawStr("\"_links\"" + ":")
			s.Links.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes FileCommitContent from json.
func (s *FileCommitContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "size":
			s.Size.Reset()
			if err := s.Size.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "git_url":
			s.GitURL.Reset()
			if err := s.GitURL.Decode(d); err != nil {
				return err
			}
		case "download_url":
			s.DownloadURL.Reset()
			if err := s.DownloadURL.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "_links":
			s.Links.Reset()
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitContentLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Self.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Self.Set {
			e.RawStr("\"self\"" + ":")
			s.Self.Encode(e)
		}
	}
	{
		if s.Git.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Git.Set {
			e.RawStr("\"git\"" + ":")
			s.Git.Encode(e)
		}
	}
	{
		if s.HTML.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTML.Set {
			e.RawStr("\"html\"" + ":")
			s.HTML.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes FileCommitContentLinks from json.
func (s *FileCommitContentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitContentLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			s.Self.Reset()
			if err := s.Self.Decode(d); err != nil {
				return err
			}
		case "git":
			s.Git.Reset()
			if err := s.Git.Decode(d); err != nil {
				return err
			}
		case "html":
			s.HTML.Reset()
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ForbiddenGist) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Block.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Block.Set {
			e.RawStr("\"block\"" + ":")
			s.Block.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ForbiddenGist from json.
func (s *ForbiddenGist) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ForbiddenGist to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "block":
			s.Block.Reset()
			if err := s.Block.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ForbiddenGistBlock) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ForbiddenGistBlock from json.
func (s *ForbiddenGistBlock) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ForbiddenGistBlock to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Found) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes Found from json.
func (s *Found) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Found to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FullRepository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		e.Str(s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		e.Comma()

		e.RawStr("\"ssh_url\"" + ":")
		e.Str(s.SSHURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		e.Comma()

		e.RawStr("\"clone_url\"" + ":")
		e.Str(s.CloneURL)
	}
	{
		e.Comma()

		e.RawStr("\"mirror_url\"" + ":")
		s.MirrorURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"svn_url\"" + ":")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		e.Comma()

		e.RawStr("\"homepage\"" + ":")
		s.Homepage.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"language\"" + ":")
		s.Language.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"forks_count\"" + ":")
		e.Int(s.ForksCount)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_count\"" + ":")
		e.Int(s.StargazersCount)
	}
	{
		e.Comma()

		e.RawStr("\"watchers_count\"" + ":")
		e.Int(s.WatchersCount)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"default_branch\"" + ":")
		e.Str(s.DefaultBranch)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues_count\"" + ":")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"has_issues\"" + ":")
		e.Bool(s.HasIssues)
	}
	{
		e.Comma()

		e.RawStr("\"has_projects\"" + ":")
		e.Bool(s.HasProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_wiki\"" + ":")
		e.Bool(s.HasWiki)
	}
	{
		e.Comma()

		e.RawStr("\"has_pages\"" + ":")
		e.Bool(s.HasPages)
	}
	{
		e.Comma()

		e.RawStr("\"has_downloads\"" + ":")
		e.Bool(s.HasDownloads)
	}
	{
		e.Comma()

		e.RawStr("\"archived\"" + ":")
		e.Bool(s.Archived)
	}
	{
		e.Comma()

		e.RawStr("\"disabled\"" + ":")
		e.Bool(s.Disabled)
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pushed_at\"" + ":")
		json.EncodeDateTime(e, s.PushedAt)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.Comma()
		}
		if s.TemplateRepository.Set {
			e.RawStr("\"template_repository\"" + ":")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.Comma()
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_count\"" + ":")
		e.Int(s.SubscribersCount)
	}
	{
		e.Comma()

		e.RawStr("\"network_count\"" + ":")
		e.Int(s.NetworkCount)
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		if s.Organization.Set {
			e.Comma()
		}
		if s.Organization.Set {
			e.RawStr("\"organization\"" + ":")
			s.Organization.Encode(e)
		}
	}
	{
		if s.Parent.Set {
			e.Comma()
		}
		if s.Parent.Set {
			e.RawStr("\"parent\"" + ":")
			s.Parent.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.Comma()
		}
		if s.Source.Set {
			e.RawStr("\"source\"" + ":")
			s.Source.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"forks\"" + ":")
		e.Int(s.Forks)
	}
	{
		if s.MasterBranch.Set {
			e.Comma()
		}
		if s.MasterBranch.Set {
			e.RawStr("\"master_branch\"" + ":")
			s.MasterBranch.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"watchers\"" + ":")
		e.Int(s.Watchers)
	}
	{
		if s.AnonymousAccessEnabled.Set {
			e.Comma()
		}
		if s.AnonymousAccessEnabled.Set {
			e.RawStr("\"anonymous_access_enabled\"" + ":")
			s.AnonymousAccessEnabled.Encode(e)
		}
	}
	{
		if s.CodeOfConduct.Set {
			e.Comma()
		}
		if s.CodeOfConduct.Set {
			e.RawStr("\"code_of_conduct\"" + ":")
			s.CodeOfConduct.Encode(e)
		}
	}
	{
		if s.SecurityAndAnalysis.Set {
			e.Comma()
		}
		if s.SecurityAndAnalysis.Set {
			e.RawStr("\"security_and_analysis\"" + ":")
			s.SecurityAndAnalysis.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes FullRepository from json.
func (s *FullRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FullRepository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "git_url":
			v, err := d.Str()
			s.GitURL = string(v)
			if err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			v, err := d.Str()
			s.SSHURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "clone_url":
			v, err := d.Str()
			s.CloneURL = string(v)
			if err != nil {
				return err
			}
		case "mirror_url":
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "svn_url":
			v, err := json.DecodeURI(d)
			s.SvnURL = v
			if err != nil {
				return err
			}
		case "homepage":
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			v, err := d.Int()
			s.ForksCount = int(v)
			if err != nil {
				return err
			}
		case "stargazers_count":
			v, err := d.Int()
			s.StargazersCount = int(v)
			if err != nil {
				return err
			}
		case "watchers_count":
			v, err := d.Int()
			s.WatchersCount = int(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "default_branch":
			v, err := d.Str()
			s.DefaultBranch = string(v)
			if err != nil {
				return err
			}
		case "open_issues_count":
			v, err := d.Int()
			s.OpenIssuesCount = int(v)
			if err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			v, err := d.Bool()
			s.HasIssues = bool(v)
			if err != nil {
				return err
			}
		case "has_projects":
			v, err := d.Bool()
			s.HasProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_wiki":
			v, err := d.Bool()
			s.HasWiki = bool(v)
			if err != nil {
				return err
			}
		case "has_pages":
			v, err := d.Bool()
			s.HasPages = bool(v)
			if err != nil {
				return err
			}
		case "has_downloads":
			v, err := d.Bool()
			s.HasDownloads = bool(v)
			if err != nil {
				return err
			}
		case "archived":
			v, err := d.Bool()
			s.Archived = bool(v)
			if err != nil {
				return err
			}
		case "disabled":
			v, err := d.Bool()
			s.Disabled = bool(v)
			if err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			v, err := json.DecodeDateTime(d)
			s.PushedAt = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "template_repository":
			s.TemplateRepository.Reset()
			if err := s.TemplateRepository.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			v, err := d.Int()
			s.SubscribersCount = int(v)
			if err != nil {
				return err
			}
		case "network_count":
			v, err := d.Int()
			s.NetworkCount = int(v)
			if err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "organization":
			s.Organization.Reset()
			if err := s.Organization.Decode(d); err != nil {
				return err
			}
		case "parent":
			s.Parent.Reset()
			if err := s.Parent.Decode(d); err != nil {
				return err
			}
		case "source":
			s.Source.Reset()
			if err := s.Source.Decode(d); err != nil {
				return err
			}
		case "forks":
			v, err := d.Int()
			s.Forks = int(v)
			if err != nil {
				return err
			}
		case "master_branch":
			s.MasterBranch.Reset()
			if err := s.MasterBranch.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "watchers":
			v, err := d.Int()
			s.Watchers = int(v)
			if err != nil {
				return err
			}
		case "anonymous_access_enabled":
			s.AnonymousAccessEnabled.Reset()
			if err := s.AnonymousAccessEnabled.Decode(d); err != nil {
				return err
			}
		case "code_of_conduct":
			s.CodeOfConduct.Reset()
			if err := s.CodeOfConduct.Decode(d); err != nil {
				return err
			}
		case "security_and_analysis":
			s.SecurityAndAnalysis.Reset()
			if err := s.SecurityAndAnalysis.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FullRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	e.ObjEnd()
}

// Decode decodes FullRepositoryPermissions from json.
func (s *FullRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FullRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FullRepositorySecurityAndAnalysis) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AdvancedSecurity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AdvancedSecurity.Set {
			e.RawStr("\"advanced_security\"" + ":")
			s.AdvancedSecurity.Encode(e)
		}
	}
	{
		if s.SecretScanning.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretScanning.Set {
			e.RawStr("\"secret_scanning\"" + ":")
			s.SecretScanning.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes FullRepositorySecurityAndAnalysis from json.
func (s *FullRepositorySecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FullRepositorySecurityAndAnalysis to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "advanced_security":
			s.AdvancedSecurity.Reset()
			if err := s.AdvancedSecurity.Decode(d); err != nil {
				return err
			}
		case "secret_scanning":
			s.SecretScanning.Reset()
			if err := s.SecretScanning.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FullRepositorySecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurity from json.
func (s *FullRepositorySecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FullRepositorySecurityAndAnalysisAdvancedSecurity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus as json.
func (s FullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus from json.
func (s *FullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FullRepositorySecurityAndAnalysisAdvancedSecurityStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FullRepositorySecurityAndAnalysisAdvancedSecurityStatus(v) {
	case FullRepositorySecurityAndAnalysisAdvancedSecurityStatusEnabled:
		*s = FullRepositorySecurityAndAnalysisAdvancedSecurityStatusEnabled
	case FullRepositorySecurityAndAnalysisAdvancedSecurityStatusDisabled:
		*s = FullRepositorySecurityAndAnalysisAdvancedSecurityStatusDisabled
	default:
		*s = FullRepositorySecurityAndAnalysisAdvancedSecurityStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FullRepositorySecurityAndAnalysisSecretScanning) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanning from json.
func (s *FullRepositorySecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FullRepositorySecurityAndAnalysisSecretScanning to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes FullRepositorySecurityAndAnalysisSecretScanningStatus as json.
func (s FullRepositorySecurityAndAnalysisSecretScanningStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanningStatus from json.
func (s *FullRepositorySecurityAndAnalysisSecretScanningStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FullRepositorySecurityAndAnalysisSecretScanningStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FullRepositorySecurityAndAnalysisSecretScanningStatus(v) {
	case FullRepositorySecurityAndAnalysisSecretScanningStatusEnabled:
		*s = FullRepositorySecurityAndAnalysisSecretScanningStatusEnabled
	case FullRepositorySecurityAndAnalysisSecretScanningStatusDisabled:
		*s = FullRepositorySecurityAndAnalysisSecretScanningStatusDisabled
	default:
		*s = FullRepositorySecurityAndAnalysisSecretScanningStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistComment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GistComment from json.
func (s *GistComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistComment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"version\"" + ":")
		e.Str(s.Version)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"change_status\"" + ":")
		s.ChangeStatus.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committed_at\"" + ":")
		json.EncodeDateTime(e, s.CommittedAt)
	}
	e.ObjEnd()
}

// Decode decodes GistCommit from json.
func (s *GistCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "version":
			v, err := d.Str()
			s.Version = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "change_status":
			if err := s.ChangeStatus.Decode(d); err != nil {
				return err
			}
		case "committed_at":
			v, err := json.DecodeDateTime(d)
			s.CommittedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistCommitChangeStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Total.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Total.Set {
			e.RawStr("\"total\"" + ":")
			s.Total.Encode(e)
		}
	}
	{
		if s.Additions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Additions.Set {
			e.RawStr("\"additions\"" + ":")
			s.Additions.Encode(e)
		}
	}
	{
		if s.Deletions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Deletions.Set {
			e.RawStr("\"deletions\"" + ":")
			s.Deletions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GistCommitChangeStatus from json.
func (s *GistCommitChangeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistCommitChangeStatus to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			s.Total.Reset()
			if err := s.Total.Decode(d); err != nil {
				return err
			}
		case "additions":
			s.Additions.Reset()
			if err := s.Additions.Decode(d); err != nil {
				return err
			}
		case "deletions":
			s.Deletions.Reset()
			if err := s.Deletions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistHistory) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.User.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	{
		if s.Version.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Version.Set {
			e.RawStr("\"version\"" + ":")
			s.Version.Encode(e)
		}
	}
	{
		if s.CommittedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommittedAt.Set {
			e.RawStr("\"committed_at\"" + ":")
			s.CommittedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ChangeStatus.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChangeStatus.Set {
			e.RawStr("\"change_status\"" + ":")
			s.ChangeStatus.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GistHistory from json.
func (s *GistHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistHistory to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "version":
			s.Version.Reset()
			if err := s.Version.Decode(d); err != nil {
				return err
			}
		case "committed_at":
			s.CommittedAt.Reset()
			if err := s.CommittedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "change_status":
			s.ChangeStatus.Reset()
			if err := s.ChangeStatus.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistHistoryChangeStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Total.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Total.Set {
			e.RawStr("\"total\"" + ":")
			s.Total.Encode(e)
		}
	}
	{
		if s.Additions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Additions.Set {
			e.RawStr("\"additions\"" + ":")
			s.Additions.Encode(e)
		}
	}
	{
		if s.Deletions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Deletions.Set {
			e.RawStr("\"deletions\"" + ":")
			s.Deletions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GistHistoryChangeStatus from json.
func (s *GistHistoryChangeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistHistoryChangeStatus to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			s.Total.Reset()
			if err := s.Total.Decode(d); err != nil {
				return err
			}
		case "additions":
			s.Additions.Reset()
			if err := s.Additions.Decode(d); err != nil {
				return err
			}
		case "deletions":
			s.Deletions.Reset()
			if err := s.Deletions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Forks.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Forks.Set {
			e.RawStr("\"forks\"" + ":")
			s.Forks.Encode(e)
		}
	}
	{
		if s.History.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.History.Set {
			e.RawStr("\"history\"" + ":")
			s.History.Encode(e)
		}
	}
	{
		if s.ForkOf.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForkOf.Set {
			e.RawStr("\"fork_of\"" + ":")
			s.ForkOf.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ForksURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForksURL.Set {
			e.RawStr("\"forks_url\"" + ":")
			s.ForksURL.Encode(e)
		}
	}
	{
		if s.CommitsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommitsURL.Set {
			e.RawStr("\"commits_url\"" + ":")
			s.CommitsURL.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.GitPullURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitPullURL.Set {
			e.RawStr("\"git_pull_url\"" + ":")
			s.GitPullURL.Encode(e)
		}
	}
	{
		if s.GitPushURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitPushURL.Set {
			e.RawStr("\"git_push_url\"" + ":")
			s.GitPushURL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Files != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Files != nil {
			e.RawStr("\"files\"" + ":")
			s.Files.Encode(e)
		}
	}
	{
		if s.Public.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Public.Set {
			e.RawStr("\"public\"" + ":")
			s.Public.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Comments.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Comments.Set {
			e.RawStr("\"comments\"" + ":")
			s.Comments.Encode(e)
		}
	}
	{
		if s.User.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	{
		if s.CommentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommentsURL.Set {
			e.RawStr("\"comments_url\"" + ":")
			s.CommentsURL.Encode(e)
		}
	}
	{
		if s.Owner.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Truncated.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Truncated.Set {
			e.RawStr("\"truncated\"" + ":")
			s.Truncated.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GistSimple from json.
func (s *GistSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "forks":
			s.Forks.Reset()
			if err := s.Forks.Decode(d); err != nil {
				return err
			}
		case "history":
			s.History.Reset()
			if err := s.History.Decode(d); err != nil {
				return err
			}
		case "fork_of":
			s.ForkOf.Reset()
			if err := s.ForkOf.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "forks_url":
			s.ForksURL.Reset()
			if err := s.ForksURL.Decode(d); err != nil {
				return err
			}
		case "commits_url":
			s.CommitsURL.Reset()
			if err := s.CommitsURL.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "git_pull_url":
			s.GitPullURL.Reset()
			if err := s.GitPullURL.Decode(d); err != nil {
				return err
			}
		case "git_push_url":
			s.GitPushURL.Reset()
			if err := s.GitPushURL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "files":
			s.Files = nil
			var elem GistSimpleFiles
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Files = &elem
		case "public":
			s.Public.Reset()
			if err := s.Public.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "comments":
			s.Comments.Reset()
			if err := s.Comments.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "comments_url":
			s.CommentsURL.Reset()
			if err := s.CommentsURL.Decode(d); err != nil {
				return err
			}
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "truncated":
			s.Truncated.Reset()
			if err := s.Truncated.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistSimpleFiles) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes GistSimpleFiles from json.
func (s *GistSimpleFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistSimpleFiles to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistSimpleForkOf) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		json.EncodeURI(e, s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"git_pull_url\"" + ":")
		json.EncodeURI(e, s.GitPullURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_push_url\"" + ":")
		json.EncodeURI(e, s.GitPushURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"files\"" + ":")
		s.Files.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"public\"" + ":")
		e.Bool(s.Public)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comments\"" + ":")
		e.Int(s.Comments)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		if s.Owner.Set {
			e.Comma()
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Truncated.Set {
			e.Comma()
		}
		if s.Truncated.Set {
			e.RawStr("\"truncated\"" + ":")
			s.Truncated.Encode(e)
		}
	}
	{
		if s.Forks != nil {
			e.Comma()
		}
		if s.Forks != nil {
			e.RawStr("\"forks\"" + ":")
			e.ArrStart()
			if len(s.Forks) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Forks[0]
					e.Str(elem)
				}
				for _, elem := range s.Forks[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.History != nil {
			e.Comma()
		}
		if s.History != nil {
			e.RawStr("\"history\"" + ":")
			e.ArrStart()
			if len(s.History) >= 1 {
				// Encode first element without comma.
				{
					elem := s.History[0]
					e.Str(elem)
				}
				for _, elem := range s.History[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes GistSimpleForkOf from json.
func (s *GistSimpleForkOf) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistSimpleForkOf to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := json.DecodeURI(d)
			s.CommitsURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "git_pull_url":
			v, err := json.DecodeURI(d)
			s.GitPullURL = v
			if err != nil {
				return err
			}
		case "git_push_url":
			v, err := json.DecodeURI(d)
			s.GitPushURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "files":
			if err := s.Files.Decode(d); err != nil {
				return err
			}
		case "public":
			v, err := d.Bool()
			s.Public = bool(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "comments":
			v, err := d.Int()
			s.Comments = int(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "truncated":
			s.Truncated.Reset()
			if err := s.Truncated.Decode(d); err != nil {
				return err
			}
		case "forks":
			s.Forks = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Forks = append(s.Forks, elem)
				return nil
			}); err != nil {
				return err
			}
		case "history":
			s.History = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.History = append(s.History, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistSimpleForkOfFiles) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes GistSimpleForkOfFiles from json.
func (s *GistSimpleForkOfFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistSimpleForkOfFiles to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistSimpleForksItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.User.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

// Decode decodes GistSimpleForksItem from json.
func (s *GistSimpleForksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistSimpleForksItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistsCheckIsStarredNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes GistsCheckIsStarredNoContent from json.
func (s *GistsCheckIsStarredNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCheckIsStarredNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistsCheckIsStarredNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes GistsCheckIsStarredNotFound from json.
func (s *GistsCheckIsStarredNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCheckIsStarredNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GistsCreateApplicationJSONForbidden as json.
func (s GistsCreateApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsCreateApplicationJSONForbidden from json.
func (s *GistsCreateApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCreateApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsCreateApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsCreateApplicationJSONNotFound as json.
func (s GistsCreateApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsCreateApplicationJSONNotFound from json.
func (s *GistsCreateApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCreateApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsCreateApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsCreateCommentApplicationJSONForbidden as json.
func (s GistsCreateCommentApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsCreateCommentApplicationJSONForbidden from json.
func (s *GistsCreateCommentApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCreateCommentApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsCreateCommentApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsCreateCommentApplicationJSONNotFound as json.
func (s GistsCreateCommentApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsCreateCommentApplicationJSONNotFound from json.
func (s *GistsCreateCommentApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCreateCommentApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsCreateCommentApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GistsCreateCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

// Decode decodes GistsCreateCommentReq from json.
func (s *GistsCreateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCreateCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistsCreateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"files\"" + ":")
		s.Files.Encode(e)
	}
	{
		if s.Public.Set {
			e.Comma()
		}
		if s.Public.Set {
			e.RawStr("\"public\"" + ":")
			s.Public.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GistsCreateReq from json.
func (s *GistsCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCreateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "files":
			if err := s.Files.Decode(d); err != nil {
				return err
			}
		case "public":
			s.Public.Reset()
			if err := s.Public.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistsCreateReqFiles) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes GistsCreateReqFiles from json.
func (s *GistsCreateReqFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCreateReqFiles to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GistsCreateReqPublic as json.
func (s GistsCreateReqPublic) Encode(e *jx.Writer) {
	switch s.Type {
	case BoolGistsCreateReqPublic:
		e.Bool(s.Bool)
	case GistsCreateReqPublic1GistsCreateReqPublic:
		s.GistsCreateReqPublic1.Encode(e)
	}
}

// Decode decodes GistsCreateReqPublic from json.
func (s *GistsCreateReqPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCreateReqPublic to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolGistsCreateReqPublic
	case jx.String:
		if err := s.GistsCreateReqPublic1.Decode(d); err != nil {
			return err
		}
		s.Type = GistsCreateReqPublic1GistsCreateReqPublic
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode encodes GistsCreateReqPublic1 as json.
func (s GistsCreateReqPublic1) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes GistsCreateReqPublic1 from json.
func (s *GistsCreateReqPublic1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCreateReqPublic1 to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GistsCreateReqPublic1(v) {
	case GistsCreateReqPublic1True:
		*s = GistsCreateReqPublic1True
	case GistsCreateReqPublic1False:
		*s = GistsCreateReqPublic1False
	default:
		*s = GistsCreateReqPublic1(v)
	}

	return nil
}

// Encode encodes GistsDeleteApplicationJSONForbidden as json.
func (s GistsDeleteApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteApplicationJSONForbidden from json.
func (s *GistsDeleteApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsDeleteApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsDeleteApplicationJSONNotFound as json.
func (s GistsDeleteApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteApplicationJSONNotFound from json.
func (s *GistsDeleteApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsDeleteApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsDeleteCommentApplicationJSONForbidden as json.
func (s GistsDeleteCommentApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteCommentApplicationJSONForbidden from json.
func (s *GistsDeleteCommentApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsDeleteCommentApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteCommentApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsDeleteCommentApplicationJSONNotFound as json.
func (s GistsDeleteCommentApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteCommentApplicationJSONNotFound from json.
func (s *GistsDeleteCommentApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsDeleteCommentApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteCommentApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GistsDeleteCommentNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes GistsDeleteCommentNoContent from json.
func (s *GistsDeleteCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsDeleteCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistsDeleteNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes GistsDeleteNoContent from json.
func (s *GistsDeleteNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsDeleteNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GistsForkApplicationJSONForbidden as json.
func (s GistsForkApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsForkApplicationJSONForbidden from json.
func (s *GistsForkApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsForkApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsForkApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsForkApplicationJSONNotFound as json.
func (s GistsForkApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsForkApplicationJSONNotFound from json.
func (s *GistsForkApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsForkApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsForkApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsGetRevisionApplicationJSONForbidden as json.
func (s GistsGetRevisionApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsGetRevisionApplicationJSONForbidden from json.
func (s *GistsGetRevisionApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsGetRevisionApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsGetRevisionApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsGetRevisionApplicationJSONNotFound as json.
func (s GistsGetRevisionApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsGetRevisionApplicationJSONNotFound from json.
func (s *GistsGetRevisionApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsGetRevisionApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsGetRevisionApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsListCommentsApplicationJSONForbidden as json.
func (s GistsListCommentsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListCommentsApplicationJSONForbidden from json.
func (s *GistsListCommentsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListCommentsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommentsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsListCommentsApplicationJSONNotFound as json.
func (s GistsListCommentsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListCommentsApplicationJSONNotFound from json.
func (s *GistsListCommentsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListCommentsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommentsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsListCommentsOKApplicationJSON as json.
func (s GistsListCommentsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []GistComment(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes GistsListCommentsOKApplicationJSON from json.
func (s *GistsListCommentsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListCommentsOKApplicationJSON to nil`)
	}
	var unwrapped []GistComment
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GistComment
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommentsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListCommitsApplicationJSONForbidden as json.
func (s GistsListCommitsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListCommitsApplicationJSONForbidden from json.
func (s *GistsListCommitsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListCommitsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommitsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsListCommitsApplicationJSONNotFound as json.
func (s GistsListCommitsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListCommitsApplicationJSONNotFound from json.
func (s *GistsListCommitsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListCommitsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommitsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsListCommitsOKApplicationJSON as json.
func (s GistsListCommitsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []GistCommit(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes GistsListCommitsOKApplicationJSON from json.
func (s *GistsListCommitsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListCommitsOKApplicationJSON to nil`)
	}
	var unwrapped []GistCommit
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GistCommit
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommitsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListForUserOKApplicationJSON as json.
func (s GistsListForUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []BaseGist(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes GistsListForUserOKApplicationJSON from json.
func (s *GistsListForUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListForUserOKApplicationJSON to nil`)
	}
	var unwrapped []BaseGist
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BaseGist
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListForUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListForksApplicationJSONForbidden as json.
func (s GistsListForksApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListForksApplicationJSONForbidden from json.
func (s *GistsListForksApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListForksApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListForksApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsListForksApplicationJSONNotFound as json.
func (s GistsListForksApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListForksApplicationJSONNotFound from json.
func (s *GistsListForksApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListForksApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListForksApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsListForksOKApplicationJSON as json.
func (s GistsListForksOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []GistSimple(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes GistsListForksOKApplicationJSON from json.
func (s *GistsListForksOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListForksOKApplicationJSON to nil`)
	}
	var unwrapped []GistSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GistSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListForksOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListOKApplicationJSON as json.
func (s GistsListOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []BaseGist(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes GistsListOKApplicationJSON from json.
func (s *GistsListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListOKApplicationJSON to nil`)
	}
	var unwrapped []BaseGist
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BaseGist
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListPublicOKApplicationJSON as json.
func (s GistsListPublicOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []BaseGist(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes GistsListPublicOKApplicationJSON from json.
func (s *GistsListPublicOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListPublicOKApplicationJSON to nil`)
	}
	var unwrapped []BaseGist
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BaseGist
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListPublicOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListStarredApplicationJSONForbidden as json.
func (s GistsListStarredApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListStarredApplicationJSONForbidden from json.
func (s *GistsListStarredApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListStarredApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListStarredApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsListStarredApplicationJSONUnauthorized as json.
func (s GistsListStarredApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListStarredApplicationJSONUnauthorized from json.
func (s *GistsListStarredApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListStarredApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListStarredApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes GistsListStarredOKApplicationJSON as json.
func (s GistsListStarredOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []BaseGist(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes GistsListStarredOKApplicationJSON from json.
func (s *GistsListStarredOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListStarredOKApplicationJSON to nil`)
	}
	var unwrapped []BaseGist
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BaseGist
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListStarredOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsStarApplicationJSONForbidden as json.
func (s GistsStarApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsStarApplicationJSONForbidden from json.
func (s *GistsStarApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsStarApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsStarApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsStarApplicationJSONNotFound as json.
func (s GistsStarApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsStarApplicationJSONNotFound from json.
func (s *GistsStarApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsStarApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsStarApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GistsStarNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes GistsStarNoContent from json.
func (s *GistsStarNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsStarNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GistsUnstarApplicationJSONForbidden as json.
func (s GistsUnstarApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsUnstarApplicationJSONForbidden from json.
func (s *GistsUnstarApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsUnstarApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsUnstarApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsUnstarApplicationJSONNotFound as json.
func (s GistsUnstarApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsUnstarApplicationJSONNotFound from json.
func (s *GistsUnstarApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsUnstarApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsUnstarApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GistsUnstarNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes GistsUnstarNoContent from json.
func (s *GistsUnstarNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsUnstarNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistsUpdateCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

// Decode decodes GistsUpdateCommentReq from json.
func (s *GistsUpdateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsUpdateCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committer\"" + ":")
		s.Committer.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"tree\"" + ":")
		s.Tree.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"parents\"" + ":")
		e.ArrStart()
		if len(s.Parents) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Parents[0]
				elem.Encode(e)
			}
			for _, elem := range s.Parents[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"verification\"" + ":")
		s.Verification.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	e.ObjEnd()
}

// Decode decodes GitCommit from json.
func (s *GitCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "tree":
			if err := s.Tree.Decode(d); err != nil {
				return err
			}
		case "parents":
			s.Parents = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem GitCommitParentsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Parents = append(s.Parents, elem)
				return nil
			}); err != nil {
				return err
			}
		case "verification":
			if err := s.Verification.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCommitAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"date\"" + ":")
		json.EncodeDateTime(e, s.Date)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

// Decode decodes GitCommitAuthor from json.
func (s *GitCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCommitAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			v, err := json.DecodeDateTime(d)
			s.Date = v
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCommitCommitter) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"date\"" + ":")
		json.EncodeDateTime(e, s.Date)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

// Decode decodes GitCommitCommitter from json.
func (s *GitCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCommitCommitter to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			v, err := json.DecodeDateTime(d)
			s.Date = v
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCommitParentsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	e.ObjEnd()
}

// Decode decodes GitCommitParentsItem from json.
func (s *GitCommitParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCommitParentsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCommitTree) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

// Decode decodes GitCommitTree from json.
func (s *GitCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCommitTree to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCommitVerification) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"verified\"" + ":")
		e.Bool(s.Verified)
	}
	{
		e.Comma()

		e.RawStr("\"reason\"" + ":")
		e.Str(s.Reason)
	}
	{
		e.Comma()

		e.RawStr("\"signature\"" + ":")
		s.Signature.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GitCommitVerification from json.
func (s *GitCommitVerification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCommitVerification to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verified":
			v, err := d.Bool()
			s.Verified = bool(v)
			if err != nil {
				return err
			}
		case "reason":
			v, err := d.Str()
			s.Reason = string(v)
			if err != nil {
				return err
			}
		case "signature":
			if err := s.Signature.Decode(d); err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GitCreateBlobApplicationJSONConflict as json.
func (s GitCreateBlobApplicationJSONConflict) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GitCreateBlobApplicationJSONConflict from json.
func (s *GitCreateBlobApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateBlobApplicationJSONConflict to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitCreateBlobApplicationJSONConflict(unwrapped)
	return nil
}

// Encode encodes GitCreateBlobApplicationJSONForbidden as json.
func (s GitCreateBlobApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GitCreateBlobApplicationJSONForbidden from json.
func (s *GitCreateBlobApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateBlobApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitCreateBlobApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GitCreateBlobApplicationJSONNotFound as json.
func (s GitCreateBlobApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GitCreateBlobApplicationJSONNotFound from json.
func (s *GitCreateBlobApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateBlobApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitCreateBlobApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GitCreateBlobReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		e.Str(s.Content)
	}
	{
		if s.Encoding.Set {
			e.Comma()
		}
		if s.Encoding.Set {
			e.RawStr("\"encoding\"" + ":")
			s.Encoding.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GitCreateBlobReq from json.
func (s *GitCreateBlobReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateBlobReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			v, err := d.Str()
			s.Content = string(v)
			if err != nil {
				return err
			}
		case "encoding":
			s.Encoding.Reset()
			if err := s.Encoding.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCreateCommitReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"tree\"" + ":")
		e.Str(s.Tree)
	}
	{
		if s.Parents != nil {
			e.Comma()
		}
		if s.Parents != nil {
			e.RawStr("\"parents\"" + ":")
			e.ArrStart()
			if len(s.Parents) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Parents[0]
					e.Str(elem)
				}
				for _, elem := range s.Parents[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Author.Set {
			e.Comma()
		}
		if s.Author.Set {
			e.RawStr("\"author\"" + ":")
			s.Author.Encode(e)
		}
	}
	{
		if s.Committer.Set {
			e.Comma()
		}
		if s.Committer.Set {
			e.RawStr("\"committer\"" + ":")
			s.Committer.Encode(e)
		}
	}
	{
		if s.Signature.Set {
			e.Comma()
		}
		if s.Signature.Set {
			e.RawStr("\"signature\"" + ":")
			s.Signature.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GitCreateCommitReq from json.
func (s *GitCreateCommitReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateCommitReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "tree":
			v, err := d.Str()
			s.Tree = string(v)
			if err != nil {
				return err
			}
		case "parents":
			s.Parents = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Parents = append(s.Parents, elem)
				return nil
			}); err != nil {
				return err
			}
		case "author":
			s.Author.Reset()
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			s.Committer.Reset()
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "signature":
			s.Signature.Reset()
			if err := s.Signature.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCreateCommitReqAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		if s.Date.Set {
			e.Comma()
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

// Decode decodes GitCreateCommitReqAuthor from json.
func (s *GitCreateCommitReqAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateCommitReqAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCreateCommitReqCommitter) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Date.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

// Decode decodes GitCreateCommitReqCommitter from json.
func (s *GitCreateCommitReqCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateCommitReqCommitter to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCreateRefReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		if s.Key.Set {
			e.Comma()
		}
		if s.Key.Set {
			e.RawStr("\"key\"" + ":")
			s.Key.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GitCreateRefReq from json.
func (s *GitCreateRefReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateRefReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "key":
			s.Key.Reset()
			if err := s.Key.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCreateTagReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"tag\"" + ":")
		e.Str(s.Tag)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"object\"" + ":")
		e.Str(s.Object)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		if s.Tagger.Set {
			e.Comma()
		}
		if s.Tagger.Set {
			e.RawStr("\"tagger\"" + ":")
			s.Tagger.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GitCreateTagReq from json.
func (s *GitCreateTagReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTagReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			v, err := d.Str()
			s.Tag = string(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "object":
			v, err := d.Str()
			s.Object = string(v)
			if err != nil {
				return err
			}
		case "type":
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "tagger":
			s.Tagger.Reset()
			if err := s.Tagger.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCreateTagReqTagger) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		if s.Date.Set {
			e.Comma()
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

// Decode decodes GitCreateTagReqTagger from json.
func (s *GitCreateTagReqTagger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTagReqTagger to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GitCreateTagReqType as json.
func (s GitCreateTagReqType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes GitCreateTagReqType from json.
func (s *GitCreateTagReqType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTagReqType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GitCreateTagReqType(v) {
	case GitCreateTagReqTypeCommit:
		*s = GitCreateTagReqTypeCommit
	case GitCreateTagReqTypeTree:
		*s = GitCreateTagReqTypeTree
	case GitCreateTagReqTypeBlob:
		*s = GitCreateTagReqTypeBlob
	default:
		*s = GitCreateTagReqType(v)
	}

	return nil
}

// Encode encodes GitCreateTreeApplicationJSONForbidden as json.
func (s GitCreateTreeApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GitCreateTreeApplicationJSONForbidden from json.
func (s *GitCreateTreeApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTreeApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitCreateTreeApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GitCreateTreeApplicationJSONNotFound as json.
func (s GitCreateTreeApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GitCreateTreeApplicationJSONNotFound from json.
func (s *GitCreateTreeApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTreeApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitCreateTreeApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GitCreateTreeReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"tree\"" + ":")
		e.ArrStart()
		if len(s.Tree) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Tree[0]
				elem.Encode(e)
			}
			for _, elem := range s.Tree[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.BaseTree.Set {
			e.Comma()
		}
		if s.BaseTree.Set {
			e.RawStr("\"base_tree\"" + ":")
			s.BaseTree.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GitCreateTreeReq from json.
func (s *GitCreateTreeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTreeReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tree":
			s.Tree = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem GitCreateTreeReqTreeItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Tree = append(s.Tree, elem)
				return nil
			}); err != nil {
				return err
			}
		case "base_tree":
			s.BaseTree.Reset()
			if err := s.BaseTree.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCreateTreeReqTreeItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Path.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Mode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Mode.Set {
			e.RawStr("\"mode\"" + ":")
			s.Mode.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.Content.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Content.Set {
			e.RawStr("\"content\"" + ":")
			s.Content.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GitCreateTreeReqTreeItem from json.
func (s *GitCreateTreeReqTreeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTreeReqTreeItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "mode":
			s.Mode.Reset()
			if err := s.Mode.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "content":
			s.Content.Reset()
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GitCreateTreeReqTreeItemMode as json.
func (s GitCreateTreeReqTreeItemMode) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes GitCreateTreeReqTreeItemMode from json.
func (s *GitCreateTreeReqTreeItemMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTreeReqTreeItemMode to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GitCreateTreeReqTreeItemMode(v) {
	case GitCreateTreeReqTreeItemMode100644:
		*s = GitCreateTreeReqTreeItemMode100644
	case GitCreateTreeReqTreeItemMode100755:
		*s = GitCreateTreeReqTreeItemMode100755
	case GitCreateTreeReqTreeItemMode040000:
		*s = GitCreateTreeReqTreeItemMode040000
	case GitCreateTreeReqTreeItemMode160000:
		*s = GitCreateTreeReqTreeItemMode160000
	case GitCreateTreeReqTreeItemMode120000:
		*s = GitCreateTreeReqTreeItemMode120000
	default:
		*s = GitCreateTreeReqTreeItemMode(v)
	}

	return nil
}

// Encode encodes GitCreateTreeReqTreeItemType as json.
func (s GitCreateTreeReqTreeItemType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes GitCreateTreeReqTreeItemType from json.
func (s *GitCreateTreeReqTreeItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTreeReqTreeItemType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GitCreateTreeReqTreeItemType(v) {
	case GitCreateTreeReqTreeItemTypeBlob:
		*s = GitCreateTreeReqTreeItemTypeBlob
	case GitCreateTreeReqTreeItemTypeTree:
		*s = GitCreateTreeReqTreeItemTypeTree
	case GitCreateTreeReqTreeItemTypeCommit:
		*s = GitCreateTreeReqTreeItemTypeCommit
	default:
		*s = GitCreateTreeReqTreeItemType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitDeleteRefNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes GitDeleteRefNoContent from json.
func (s *GitDeleteRefNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitDeleteRefNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GitGetBlobApplicationJSONForbidden as json.
func (s GitGetBlobApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GitGetBlobApplicationJSONForbidden from json.
func (s *GitGetBlobApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitGetBlobApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitGetBlobApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GitGetBlobApplicationJSONNotFound as json.
func (s GitGetBlobApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GitGetBlobApplicationJSONNotFound from json.
func (s *GitGetBlobApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitGetBlobApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitGetBlobApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GitRef) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"object\"" + ":")
		s.Object.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GitRef from json.
func (s *GitRef) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitRef to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "object":
			if err := s.Object.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitRefObject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

// Decode decodes GitRefObject from json.
func (s *GitRefObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitRefObject to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitTag) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"tag\"" + ":")
		e.Str(s.Tag)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"tagger\"" + ":")
		s.Tagger.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"object\"" + ":")
		s.Object.Encode(e)
	}
	{
		if s.Verification.Set {
			e.Comma()
		}
		if s.Verification.Set {
			e.RawStr("\"verification\"" + ":")
			s.Verification.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GitTag from json.
func (s *GitTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitTag to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "tag":
			v, err := d.Str()
			s.Tag = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "tagger":
			if err := s.Tagger.Decode(d); err != nil {
				return err
			}
		case "object":
			if err := s.Object.Decode(d); err != nil {
				return err
			}
		case "verification":
			s.Verification.Reset()
			if err := s.Verification.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitTagObject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

// Decode decodes GitTagObject from json.
func (s *GitTagObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitTagObject to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitTagTagger) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"date\"" + ":")
		e.Str(s.Date)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

// Decode decodes GitTagTagger from json.
func (s *GitTagTagger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitTagTagger to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			v, err := d.Str()
			s.Date = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitTree) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"truncated\"" + ":")
		e.Bool(s.Truncated)
	}
	{
		e.Comma()

		e.RawStr("\"tree\"" + ":")
		e.ArrStart()
		if len(s.Tree) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Tree[0]
				elem.Encode(e)
			}
			for _, elem := range s.Tree[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes GitTree from json.
func (s *GitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitTree to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "truncated":
			v, err := d.Bool()
			s.Truncated = bool(v)
			if err != nil {
				return err
			}
		case "tree":
			s.Tree = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem GitTreeTreeItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Tree = append(s.Tree, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitTreeTreeItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Path.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Mode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Mode.Set {
			e.RawStr("\"mode\"" + ":")
			s.Mode.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.Size.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Size.Set {
			e.RawStr("\"size\"" + ":")
			s.Size.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GitTreeTreeItem from json.
func (s *GitTreeTreeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitTreeTreeItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "mode":
			s.Mode.Reset()
			if err := s.Mode.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "size":
			s.Size.Reset()
			if err := s.Size.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitUpdateRefReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		if s.Force.Set {
			e.Comma()
		}
		if s.Force.Set {
			e.RawStr("\"force\"" + ":")
			s.Force.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GitUpdateRefReq from json.
func (s *GitUpdateRefReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitUpdateRefReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "force":
			s.Force.Reset()
			if err := s.Force.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GitignoreGetAllTemplatesOKApplicationJSON as json.
func (s GitignoreGetAllTemplatesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []string(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			e.Str(elem)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			e.Str(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes GitignoreGetAllTemplatesOKApplicationJSON from json.
func (s *GitignoreGetAllTemplatesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitignoreGetAllTemplatesOKApplicationJSON to nil`)
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitignoreGetAllTemplatesOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GitignoreTemplate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"source\"" + ":")
		e.Str(s.Source)
	}
	e.ObjEnd()
}

// Decode decodes GitignoreTemplate from json.
func (s *GitignoreTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitignoreTemplate to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "source":
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GpgKey) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"primary_key_id\"" + ":")
		s.PrimaryKeyID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"key_id\"" + ":")
		e.Str(s.KeyID)
	}
	{
		e.Comma()

		e.RawStr("\"public_key\"" + ":")
		e.Str(s.PublicKey)
	}
	{
		e.Comma()

		e.RawStr("\"emails\"" + ":")
		e.ArrStart()
		if len(s.Emails) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Emails[0]
				elem.Encode(e)
			}
			for _, elem := range s.Emails[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"subkeys\"" + ":")
		e.ArrStart()
		if len(s.Subkeys) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Subkeys[0]
				elem.Encode(e)
			}
			for _, elem := range s.Subkeys[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"can_sign\"" + ":")
		e.Bool(s.CanSign)
	}
	{
		e.Comma()

		e.RawStr("\"can_encrypt_comms\"" + ":")
		e.Bool(s.CanEncryptComms)
	}
	{
		e.Comma()

		e.RawStr("\"can_encrypt_storage\"" + ":")
		e.Bool(s.CanEncryptStorage)
	}
	{
		e.Comma()

		e.RawStr("\"can_certify\"" + ":")
		e.Bool(s.CanCertify)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"expires_at\"" + ":")
		s.ExpiresAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"raw_key\"" + ":")
		s.RawKey.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GpgKey from json.
func (s *GpgKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GpgKey to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "primary_key_id":
			if err := s.PrimaryKeyID.Decode(d); err != nil {
				return err
			}
		case "key_id":
			v, err := d.Str()
			s.KeyID = string(v)
			if err != nil {
				return err
			}
		case "public_key":
			v, err := d.Str()
			s.PublicKey = string(v)
			if err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem GpgKeyEmailsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		case "subkeys":
			s.Subkeys = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem GpgKeySubkeysItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Subkeys = append(s.Subkeys, elem)
				return nil
			}); err != nil {
				return err
			}
		case "can_sign":
			v, err := d.Bool()
			s.CanSign = bool(v)
			if err != nil {
				return err
			}
		case "can_encrypt_comms":
			v, err := d.Bool()
			s.CanEncryptComms = bool(v)
			if err != nil {
				return err
			}
		case "can_encrypt_storage":
			v, err := d.Bool()
			s.CanEncryptStorage = bool(v)
			if err != nil {
				return err
			}
		case "can_certify":
			v, err := d.Bool()
			s.CanCertify = bool(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "expires_at":
			if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "raw_key":
			if err := s.RawKey.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GpgKeyEmailsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Verified.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Verified.Set {
			e.RawStr("\"verified\"" + ":")
			s.Verified.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GpgKeyEmailsItem from json.
func (s *GpgKeyEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GpgKeyEmailsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "verified":
			s.Verified.Reset()
			if err := s.Verified.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GpgKeySubkeysItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.PrimaryKeyID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PrimaryKeyID.Set {
			e.RawStr("\"primary_key_id\"" + ":")
			s.PrimaryKeyID.Encode(e)
		}
	}
	{
		if s.KeyID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.KeyID.Set {
			e.RawStr("\"key_id\"" + ":")
			s.KeyID.Encode(e)
		}
	}
	{
		if s.PublicKey.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PublicKey.Set {
			e.RawStr("\"public_key\"" + ":")
			s.PublicKey.Encode(e)
		}
	}
	{
		if s.Emails != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Emails != nil {
			e.RawStr("\"emails\"" + ":")
			e.ArrStart()
			if len(s.Emails) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Emails[0]
					e.Str(elem)
				}
				for _, elem := range s.Emails[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Subkeys != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Subkeys != nil {
			e.RawStr("\"subkeys\"" + ":")
			e.ArrStart()
			if len(s.Subkeys) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Subkeys[0]
					e.Str(elem)
				}
				for _, elem := range s.Subkeys[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.CanSign.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanSign.Set {
			e.RawStr("\"can_sign\"" + ":")
			s.CanSign.Encode(e)
		}
	}
	{
		if s.CanEncryptComms.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanEncryptComms.Set {
			e.RawStr("\"can_encrypt_comms\"" + ":")
			s.CanEncryptComms.Encode(e)
		}
	}
	{
		if s.CanEncryptStorage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanEncryptStorage.Set {
			e.RawStr("\"can_encrypt_storage\"" + ":")
			s.CanEncryptStorage.Encode(e)
		}
	}
	{
		if s.CanCertify.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanCertify.Set {
			e.RawStr("\"can_certify\"" + ":")
			s.CanCertify.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.ExpiresAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExpiresAt.Set {
			e.RawStr("\"expires_at\"" + ":")
			s.ExpiresAt.Encode(e)
		}
	}
	{
		if s.RawKey.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RawKey.Set {
			e.RawStr("\"raw_key\"" + ":")
			s.RawKey.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GpgKeySubkeysItem from json.
func (s *GpgKeySubkeysItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GpgKeySubkeysItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "primary_key_id":
			s.PrimaryKeyID.Reset()
			if err := s.PrimaryKeyID.Decode(d); err != nil {
				return err
			}
		case "key_id":
			s.KeyID.Reset()
			if err := s.KeyID.Decode(d); err != nil {
				return err
			}
		case "public_key":
			s.PublicKey.Reset()
			if err := s.PublicKey.Decode(d); err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		case "subkeys":
			s.Subkeys = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Subkeys = append(s.Subkeys, elem)
				return nil
			}); err != nil {
				return err
			}
		case "can_sign":
			s.CanSign.Reset()
			if err := s.CanSign.Decode(d); err != nil {
				return err
			}
		case "can_encrypt_comms":
			s.CanEncryptComms.Reset()
			if err := s.CanEncryptComms.Decode(d); err != nil {
				return err
			}
		case "can_encrypt_storage":
			s.CanEncryptStorage.Reset()
			if err := s.CanEncryptStorage.Decode(d); err != nil {
				return err
			}
		case "can_certify":
			s.CanCertify.Reset()
			if err := s.CanCertify.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "expires_at":
			s.ExpiresAt.Reset()
			if err := s.ExpiresAt.Decode(d); err != nil {
				return err
			}
		case "raw_key":
			s.RawKey.Reset()
			if err := s.RawKey.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GroupMapping) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Groups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					elem.Encode(e)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes GroupMapping from json.
func (s *GroupMapping) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GroupMapping to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem GroupMappingGroupsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GroupMappingGroupsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"group_id\"" + ":")
		e.Str(s.GroupID)
	}
	{
		e.Comma()

		e.RawStr("\"group_name\"" + ":")
		e.Str(s.GroupName)
	}
	{
		e.Comma()

		e.RawStr("\"group_description\"" + ":")
		e.Str(s.GroupDescription)
	}
	{
		if s.Status.Set {
			e.Comma()
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	{
		if s.SyncedAt.Set {
			e.Comma()
		}
		if s.SyncedAt.Set {
			e.RawStr("\"synced_at\"" + ":")
			s.SyncedAt.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes GroupMappingGroupsItem from json.
func (s *GroupMappingGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GroupMappingGroupsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group_id":
			v, err := d.Str()
			s.GroupID = string(v)
			if err != nil {
				return err
			}
		case "group_name":
			v, err := d.Str()
			s.GroupName = string(v)
			if err != nil {
				return err
			}
		case "group_description":
			v, err := d.Str()
			s.GroupDescription = string(v)
			if err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "synced_at":
			s.SyncedAt.Reset()
			if err := s.SyncedAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Hook) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"active\"" + ":")
		e.Bool(s.Active)
	}
	{
		e.Comma()

		e.RawStr("\"events\"" + ":")
		e.ArrStart()
		if len(s.Events) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Events[0]
				e.Str(elem)
			}
			for _, elem := range s.Events[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"config\"" + ":")
		s.Config.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"test_url\"" + ":")
		json.EncodeURI(e, s.TestURL)
	}
	{
		e.Comma()

		e.RawStr("\"ping_url\"" + ":")
		json.EncodeURI(e, s.PingURL)
	}
	{
		if s.DeliveriesURL.Set {
			e.Comma()
		}
		if s.DeliveriesURL.Set {
			e.RawStr("\"deliveries_url\"" + ":")
			s.DeliveriesURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"last_response\"" + ":")
		s.LastResponse.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Hook from json.
func (s *Hook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Hook to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "active":
			v, err := d.Bool()
			s.Active = bool(v)
			if err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "config":
			if err := s.Config.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "test_url":
			v, err := json.DecodeURI(d)
			s.TestURL = v
			if err != nil {
				return err
			}
		case "ping_url":
			v, err := json.DecodeURI(d)
			s.PingURL = v
			if err != nil {
				return err
			}
		case "deliveries_url":
			s.DeliveriesURL.Reset()
			if err := s.DeliveriesURL.Decode(d); err != nil {
				return err
			}
		case "last_response":
			if err := s.LastResponse.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Password.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Password.Set {
			e.RawStr("\"password\"" + ":")
			s.Password.Encode(e)
		}
	}
	{
		if s.Room.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Room.Set {
			e.RawStr("\"room\"" + ":")
			s.Room.Encode(e)
		}
	}
	{
		if s.Subdomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Subdomain.Set {
			e.RawStr("\"subdomain\"" + ":")
			s.Subdomain.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Digest.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Digest.Set {
			e.RawStr("\"digest\"" + ":")
			s.Digest.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.Token.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Token.Set {
			e.RawStr("\"token\"" + ":")
			s.Token.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes HookConfig from json.
func (s *HookConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookConfig to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "password":
			s.Password.Reset()
			if err := s.Password.Decode(d); err != nil {
				return err
			}
		case "room":
			s.Room.Reset()
			if err := s.Room.Decode(d); err != nil {
				return err
			}
		case "subdomain":
			s.Subdomain.Reset()
			if err := s.Subdomain.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl.Reset()
			if err := s.InsecureSsl.Decode(d); err != nil {
				return err
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "digest":
			s.Digest.Reset()
			if err := s.Digest.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "token":
			s.Token.Reset()
			if err := s.Token.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookDelivery) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"guid\"" + ":")
		e.Str(s.GUID)
	}
	{
		e.Comma()

		e.RawStr("\"delivered_at\"" + ":")
		json.EncodeDateTime(e, s.DeliveredAt)
	}
	{
		e.Comma()

		e.RawStr("\"redelivery\"" + ":")
		e.Bool(s.Redelivery)
	}
	{
		e.Comma()

		e.RawStr("\"duration\"" + ":")
		e.Float64(s.Duration)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"status_code\"" + ":")
		e.Int(s.StatusCode)
	}
	{
		e.Comma()

		e.RawStr("\"event\"" + ":")
		e.Str(s.Event)
	}
	{
		e.Comma()

		e.RawStr("\"action\"" + ":")
		s.Action.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"installation_id\"" + ":")
		s.InstallationID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"repository_id\"" + ":")
		s.RepositoryID.Encode(e)
	}
	{
		if s.URL.Set {
			e.Comma()
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"request\"" + ":")
		s.Request.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"response\"" + ":")
		s.Response.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes HookDelivery from json.
func (s *HookDelivery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookDelivery to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "guid":
			v, err := d.Str()
			s.GUID = string(v)
			if err != nil {
				return err
			}
		case "delivered_at":
			v, err := json.DecodeDateTime(d)
			s.DeliveredAt = v
			if err != nil {
				return err
			}
		case "redelivery":
			v, err := d.Bool()
			s.Redelivery = bool(v)
			if err != nil {
				return err
			}
		case "duration":
			v, err := d.Float64()
			s.Duration = float64(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "status_code":
			v, err := d.Int()
			s.StatusCode = int(v)
			if err != nil {
				return err
			}
		case "event":
			v, err := d.Str()
			s.Event = string(v)
			if err != nil {
				return err
			}
		case "action":
			if err := s.Action.Decode(d); err != nil {
				return err
			}
		case "installation_id":
			if err := s.InstallationID.Decode(d); err != nil {
				return err
			}
		case "repository_id":
			if err := s.RepositoryID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "request":
			if err := s.Request.Decode(d); err != nil {
				return err
			}
		case "response":
			if err := s.Response.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookDeliveryItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"guid\"" + ":")
		e.Str(s.GUID)
	}
	{
		e.Comma()

		e.RawStr("\"delivered_at\"" + ":")
		json.EncodeDateTime(e, s.DeliveredAt)
	}
	{
		e.Comma()

		e.RawStr("\"redelivery\"" + ":")
		e.Bool(s.Redelivery)
	}
	{
		e.Comma()

		e.RawStr("\"duration\"" + ":")
		e.Float64(s.Duration)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"status_code\"" + ":")
		e.Int(s.StatusCode)
	}
	{
		e.Comma()

		e.RawStr("\"event\"" + ":")
		e.Str(s.Event)
	}
	{
		e.Comma()

		e.RawStr("\"action\"" + ":")
		s.Action.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"installation_id\"" + ":")
		s.InstallationID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"repository_id\"" + ":")
		s.RepositoryID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes HookDeliveryItem from json.
func (s *HookDeliveryItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookDeliveryItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "guid":
			v, err := d.Str()
			s.GUID = string(v)
			if err != nil {
				return err
			}
		case "delivered_at":
			v, err := json.DecodeDateTime(d)
			s.DeliveredAt = v
			if err != nil {
				return err
			}
		case "redelivery":
			v, err := d.Bool()
			s.Redelivery = bool(v)
			if err != nil {
				return err
			}
		case "duration":
			v, err := d.Float64()
			s.Duration = float64(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "status_code":
			v, err := d.Int()
			s.StatusCode = int(v)
			if err != nil {
				return err
			}
		case "event":
			v, err := d.Str()
			s.Event = string(v)
			if err != nil {
				return err
			}
		case "action":
			if err := s.Action.Decode(d); err != nil {
				return err
			}
		case "installation_id":
			if err := s.InstallationID.Decode(d); err != nil {
				return err
			}
		case "repository_id":
			if err := s.RepositoryID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookDeliveryRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"headers\"" + ":")
		if s.Headers == nil {
			e.Null()
		} else {
			s.Headers.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		if s.Payload == nil {
			e.Null()
		} else {
			s.Payload.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes HookDeliveryRequest from json.
func (s *HookDeliveryRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookDeliveryRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headers":
			s.Headers = nil
			var elem HookDeliveryRequestHeaders
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Headers = &elem
		case "payload":
			s.Payload = nil
			var elem HookDeliveryRequestPayload
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Payload = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookDeliveryRequestHeaders) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes HookDeliveryRequestHeaders from json.
func (s *HookDeliveryRequestHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookDeliveryRequestHeaders to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookDeliveryRequestPayload) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes HookDeliveryRequestPayload from json.
func (s *HookDeliveryRequestPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookDeliveryRequestPayload to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookDeliveryResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"headers\"" + ":")
		if s.Headers == nil {
			e.Null()
		} else {
			s.Headers.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes HookDeliveryResponse from json.
func (s *HookDeliveryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookDeliveryResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headers":
			s.Headers = nil
			var elem HookDeliveryResponseHeaders
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Headers = &elem
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookDeliveryResponseHeaders) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes HookDeliveryResponseHeaders from json.
func (s *HookDeliveryResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookDeliveryResponseHeaders to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		s.Code.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		s.Message.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes HookResponse from json.
func (s *HookResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := s.Code.Decode(d); err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "message":
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Hovercard) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"contexts\"" + ":")
		e.ArrStart()
		if len(s.Contexts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Contexts[0]
				elem.Encode(e)
			}
			for _, elem := range s.Contexts[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes Hovercard from json.
func (s *Hovercard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Hovercard to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contexts":
			s.Contexts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem HovercardContextsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Contexts = append(s.Contexts, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HovercardContextsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"octicon\"" + ":")
		e.Str(s.Octicon)
	}
	e.ObjEnd()
}

// Decode decodes HovercardContextsItem from json.
func (s *HovercardContextsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HovercardContextsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "octicon":
			v, err := d.Str()
			s.Octicon = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Import) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"vcs\"" + ":")
		s.Vcs.Encode(e)
	}
	{
		if s.UseLfs.Set {
			e.Comma()
		}
		if s.UseLfs.Set {
			e.RawStr("\"use_lfs\"" + ":")
			s.UseLfs.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"vcs_url\"" + ":")
		e.Str(s.VcsURL)
	}
	{
		if s.SvcRoot.Set {
			e.Comma()
		}
		if s.SvcRoot.Set {
			e.RawStr("\"svc_root\"" + ":")
			s.SvcRoot.Encode(e)
		}
	}
	{
		if s.TfvcProject.Set {
			e.Comma()
		}
		if s.TfvcProject.Set {
			e.RawStr("\"tfvc_project\"" + ":")
			s.TfvcProject.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		if s.StatusText.Set {
			e.Comma()
		}
		if s.StatusText.Set {
			e.RawStr("\"status_text\"" + ":")
			s.StatusText.Encode(e)
		}
	}
	{
		if s.FailedStep.Set {
			e.Comma()
		}
		if s.FailedStep.Set {
			e.RawStr("\"failed_step\"" + ":")
			s.FailedStep.Encode(e)
		}
	}
	{
		if s.ErrorMessage.Set {
			e.Comma()
		}
		if s.ErrorMessage.Set {
			e.RawStr("\"error_message\"" + ":")
			s.ErrorMessage.Encode(e)
		}
	}
	{
		if s.ImportPercent.Set {
			e.Comma()
		}
		if s.ImportPercent.Set {
			e.RawStr("\"import_percent\"" + ":")
			s.ImportPercent.Encode(e)
		}
	}
	{
		if s.CommitCount.Set {
			e.Comma()
		}
		if s.CommitCount.Set {
			e.RawStr("\"commit_count\"" + ":")
			s.CommitCount.Encode(e)
		}
	}
	{
		if s.PushPercent.Set {
			e.Comma()
		}
		if s.PushPercent.Set {
			e.RawStr("\"push_percent\"" + ":")
			s.PushPercent.Encode(e)
		}
	}
	{
		if s.HasLargeFiles.Set {
			e.Comma()
		}
		if s.HasLargeFiles.Set {
			e.RawStr("\"has_large_files\"" + ":")
			s.HasLargeFiles.Encode(e)
		}
	}
	{
		if s.LargeFilesSize.Set {
			e.Comma()
		}
		if s.LargeFilesSize.Set {
			e.RawStr("\"large_files_size\"" + ":")
			s.LargeFilesSize.Encode(e)
		}
	}
	{
		if s.LargeFilesCount.Set {
			e.Comma()
		}
		if s.LargeFilesCount.Set {
			e.RawStr("\"large_files_count\"" + ":")
			s.LargeFilesCount.Encode(e)
		}
	}
	{
		if s.ProjectChoices != nil {
			e.Comma()
		}
		if s.ProjectChoices != nil {
			e.RawStr("\"project_choices\"" + ":")
			e.ArrStart()
			if len(s.ProjectChoices) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ProjectChoices[0]
					elem.Encode(e)
				}
				for _, elem := range s.ProjectChoices[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Message.Set {
			e.Comma()
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.AuthorsCount.Set {
			e.Comma()
		}
		if s.AuthorsCount.Set {
			e.RawStr("\"authors_count\"" + ":")
			s.AuthorsCount.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"authors_url\"" + ":")
		json.EncodeURI(e, s.AuthorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		if s.SvnRoot.Set {
			e.Comma()
		}
		if s.SvnRoot.Set {
			e.RawStr("\"svn_root\"" + ":")
			s.SvnRoot.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes Import from json.
func (s *Import) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Import to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs":
			if err := s.Vcs.Decode(d); err != nil {
				return err
			}
		case "use_lfs":
			s.UseLfs.Reset()
			if err := s.UseLfs.Decode(d); err != nil {
				return err
			}
		case "vcs_url":
			v, err := d.Str()
			s.VcsURL = string(v)
			if err != nil {
				return err
			}
		case "svc_root":
			s.SvcRoot.Reset()
			if err := s.SvcRoot.Decode(d); err != nil {
				return err
			}
		case "tfvc_project":
			s.TfvcProject.Reset()
			if err := s.TfvcProject.Decode(d); err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "status_text":
			s.StatusText.Reset()
			if err := s.StatusText.Decode(d); err != nil {
				return err
			}
		case "failed_step":
			s.FailedStep.Reset()
			if err := s.FailedStep.Decode(d); err != nil {
				return err
			}
		case "error_message":
			s.ErrorMessage.Reset()
			if err := s.ErrorMessage.Decode(d); err != nil {
				return err
			}
		case "import_percent":
			s.ImportPercent.Reset()
			if err := s.ImportPercent.Decode(d); err != nil {
				return err
			}
		case "commit_count":
			s.CommitCount.Reset()
			if err := s.CommitCount.Decode(d); err != nil {
				return err
			}
		case "push_percent":
			s.PushPercent.Reset()
			if err := s.PushPercent.Decode(d); err != nil {
				return err
			}
		case "has_large_files":
			s.HasLargeFiles.Reset()
			if err := s.HasLargeFiles.Decode(d); err != nil {
				return err
			}
		case "large_files_size":
			s.LargeFilesSize.Reset()
			if err := s.LargeFilesSize.Decode(d); err != nil {
				return err
			}
		case "large_files_count":
			s.LargeFilesCount.Reset()
			if err := s.LargeFilesCount.Decode(d); err != nil {
				return err
			}
		case "project_choices":
			s.ProjectChoices = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ImportProjectChoicesItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ProjectChoices = append(s.ProjectChoices, elem)
				return nil
			}); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "authors_count":
			s.AuthorsCount.Reset()
			if err := s.AuthorsCount.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "authors_url":
			v, err := json.DecodeURI(d)
			s.AuthorsURL = v
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := json.DecodeURI(d)
			s.RepositoryURL = v
			if err != nil {
				return err
			}
		case "svn_root":
			s.SvnRoot.Reset()
			if err := s.SvnRoot.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ImportProjectChoicesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Vcs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Vcs.Set {
			e.RawStr("\"vcs\"" + ":")
			s.Vcs.Encode(e)
		}
	}
	{
		if s.TfvcProject.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TfvcProject.Set {
			e.RawStr("\"tfvc_project\"" + ":")
			s.TfvcProject.Encode(e)
		}
	}
	{
		if s.HumanName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HumanName.Set {
			e.RawStr("\"human_name\"" + ":")
			s.HumanName.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ImportProjectChoicesItem from json.
func (s *ImportProjectChoicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ImportProjectChoicesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs":
			s.Vcs.Reset()
			if err := s.Vcs.Decode(d); err != nil {
				return err
			}
		case "tfvc_project":
			s.TfvcProject.Reset()
			if err := s.TfvcProject.Decode(d); err != nil {
				return err
			}
		case "human_name":
			s.HumanName.Reset()
			if err := s.HumanName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ImportStatus as json.
func (s ImportStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ImportStatus from json.
func (s *ImportStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ImportStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ImportStatus(v) {
	case ImportStatusAuth:
		*s = ImportStatusAuth
	case ImportStatusError:
		*s = ImportStatusError
	case ImportStatusNone:
		*s = ImportStatusNone
	case ImportStatusDetecting:
		*s = ImportStatusDetecting
	case ImportStatusChoose:
		*s = ImportStatusChoose
	case ImportStatusAuthFailed:
		*s = ImportStatusAuthFailed
	case ImportStatusImporting:
		*s = ImportStatusImporting
	case ImportStatusMapping:
		*s = ImportStatusMapping
	case ImportStatusWaitingToPush:
		*s = ImportStatusWaitingToPush
	case ImportStatusPushing:
		*s = ImportStatusPushing
	case ImportStatusComplete:
		*s = ImportStatusComplete
	case ImportStatusSetup:
		*s = ImportStatusSetup
	case ImportStatusUnknown:
		*s = ImportStatusUnknown
	case ImportStatusDetectionFoundMultiple:
		*s = ImportStatusDetectionFoundMultiple
	case ImportStatusDetectionFoundNothing:
		*s = ImportStatusDetectionFoundNothing
	case ImportStatusDetectionNeedsAuth:
		*s = ImportStatusDetectionNeedsAuth
	default:
		*s = ImportStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InstallationToken) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"token\"" + ":")
		e.Str(s.Token)
	}
	{
		e.Comma()

		e.RawStr("\"expires_at\"" + ":")
		e.Str(s.ExpiresAt)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.RepositorySelection.Set {
			e.Comma()
		}
		if s.RepositorySelection.Set {
			e.RawStr("\"repository_selection\"" + ":")
			s.RepositorySelection.Encode(e)
		}
	}
	{
		if s.Repositories != nil {
			e.Comma()
		}
		if s.Repositories != nil {
			e.RawStr("\"repositories\"" + ":")
			e.ArrStart()
			if len(s.Repositories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Repositories[0]
					elem.Encode(e)
				}
				for _, elem := range s.Repositories[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.SingleFile.Set {
			e.Comma()
		}
		if s.SingleFile.Set {
			e.RawStr("\"single_file\"" + ":")
			s.SingleFile.Encode(e)
		}
	}
	{
		if s.HasMultipleSingleFiles.Set {
			e.Comma()
		}
		if s.HasMultipleSingleFiles.Set {
			e.RawStr("\"has_multiple_single_files\"" + ":")
			s.HasMultipleSingleFiles.Encode(e)
		}
	}
	{
		if s.SingleFilePaths != nil {
			e.Comma()
		}
		if s.SingleFilePaths != nil {
			e.RawStr("\"single_file_paths\"" + ":")
			e.ArrStart()
			if len(s.SingleFilePaths) >= 1 {
				// Encode first element without comma.
				{
					elem := s.SingleFilePaths[0]
					e.Str(elem)
				}
				for _, elem := range s.SingleFilePaths[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes InstallationToken from json.
func (s *InstallationToken) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InstallationToken to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			v, err := d.Str()
			s.Token = string(v)
			if err != nil {
				return err
			}
		case "expires_at":
			v, err := d.Str()
			s.ExpiresAt = string(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "repository_selection":
			s.RepositorySelection.Reset()
			if err := s.RepositorySelection.Decode(d); err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Repository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "single_file":
			s.SingleFile.Reset()
			if err := s.SingleFile.Decode(d); err != nil {
				return err
			}
		case "has_multiple_single_files":
			s.HasMultipleSingleFiles.Reset()
			if err := s.HasMultipleSingleFiles.Decode(d); err != nil {
				return err
			}
		case "single_file_paths":
			s.SingleFilePaths = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.SingleFilePaths = append(s.SingleFilePaths, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes InstallationTokenRepositorySelection as json.
func (s InstallationTokenRepositorySelection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes InstallationTokenRepositorySelection from json.
func (s *InstallationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InstallationTokenRepositorySelection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InstallationTokenRepositorySelection(v) {
	case InstallationTokenRepositorySelectionAll:
		*s = InstallationTokenRepositorySelectionAll
	case InstallationTokenRepositorySelectionSelected:
		*s = InstallationTokenRepositorySelectionSelected
	default:
		*s = InstallationTokenRepositorySelection(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Integration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		if s.Slug.Set {
			e.Comma()
		}
		if s.Slug.Set {
			e.RawStr("\"slug\"" + ":")
			s.Slug.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"external_url\"" + ":")
		json.EncodeURI(e, s.ExternalURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"permissions\"" + ":")
		s.Permissions.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"events\"" + ":")
		e.ArrStart()
		if len(s.Events) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Events[0]
				e.Str(elem)
			}
			for _, elem := range s.Events[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.InstallationsCount.Set {
			e.Comma()
		}
		if s.InstallationsCount.Set {
			e.RawStr("\"installations_count\"" + ":")
			s.InstallationsCount.Encode(e)
		}
	}
	{
		if s.ClientID.Set {
			e.Comma()
		}
		if s.ClientID.Set {
			e.RawStr("\"client_id\"" + ":")
			s.ClientID.Encode(e)
		}
	}
	{
		if s.ClientSecret.Set {
			e.Comma()
		}
		if s.ClientSecret.Set {
			e.RawStr("\"client_secret\"" + ":")
			s.ClientSecret.Encode(e)
		}
	}
	{
		if s.WebhookSecret.Set {
			e.Comma()
		}
		if s.WebhookSecret.Set {
			e.RawStr("\"webhook_secret\"" + ":")
			s.WebhookSecret.Encode(e)
		}
	}
	{
		if s.Pem.Set {
			e.Comma()
		}
		if s.Pem.Set {
			e.RawStr("\"pem\"" + ":")
			s.Pem.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes Integration from json.
func (s *Integration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Integration to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "slug":
			s.Slug.Reset()
			if err := s.Slug.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "external_url":
			v, err := json.DecodeURI(d)
			s.ExternalURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "permissions":
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "installations_count":
			s.InstallationsCount.Reset()
			if err := s.InstallationsCount.Decode(d); err != nil {
				return err
			}
		case "client_id":
			s.ClientID.Reset()
			if err := s.ClientID.Decode(d); err != nil {
				return err
			}
		case "client_secret":
			s.ClientSecret.Reset()
			if err := s.ClientSecret.Decode(d); err != nil {
				return err
			}
		case "webhook_secret":
			s.WebhookSecret.Reset()
			if err := s.WebhookSecret.Decode(d); err != nil {
				return err
			}
		case "pem":
			s.Pem.Reset()
			if err := s.Pem.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IntegrationPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Issues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Issues.Set {
			e.RawStr("\"issues\"" + ":")
			s.Issues.Encode(e)
		}
	}
	{
		if s.Checks.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Checks.Set {
			e.RawStr("\"checks\"" + ":")
			s.Checks.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Contents.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Contents.Set {
			e.RawStr("\"contents\"" + ":")
			s.Contents.Encode(e)
		}
	}
	{
		if s.Deployments.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Deployments.Set {
			e.RawStr("\"deployments\"" + ":")
			s.Deployments.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes IntegrationPermissions from json.
func (s *IntegrationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IntegrationPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "issues":
			s.Issues.Reset()
			if err := s.Issues.Decode(d); err != nil {
				return err
			}
		case "checks":
			s.Checks.Reset()
			if err := s.Checks.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "contents":
			s.Contents.Reset()
			if err := s.Contents.Decode(d); err != nil {
				return err
			}
		case "deployments":
			s.Deployments.Reset()
			if err := s.Deployments.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes InteractionExpiry as json.
func (s InteractionExpiry) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes InteractionExpiry from json.
func (s *InteractionExpiry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionExpiry to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InteractionExpiry(v) {
	case InteractionExpiryOneDay:
		*s = InteractionExpiryOneDay
	case InteractionExpiryThreeDays:
		*s = InteractionExpiryThreeDays
	case InteractionExpiryOneWeek:
		*s = InteractionExpiryOneWeek
	case InteractionExpiryOneMonth:
		*s = InteractionExpiryOneMonth
	case InteractionExpirySixMonths:
		*s = InteractionExpirySixMonths
	default:
		*s = InteractionExpiry(v)
	}

	return nil
}

// Encode encodes InteractionGroup as json.
func (s InteractionGroup) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes InteractionGroup from json.
func (s *InteractionGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionGroup to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InteractionGroup(v) {
	case InteractionGroupExistingUsers:
		*s = InteractionGroupExistingUsers
	case InteractionGroupContributorsOnly:
		*s = InteractionGroupContributorsOnly
	case InteractionGroupCollaboratorsOnly:
		*s = InteractionGroupCollaboratorsOnly
	default:
		*s = InteractionGroup(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InteractionLimit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"limit\"" + ":")
		s.Limit.Encode(e)
	}
	{
		if s.Expiry.Set {
			e.Comma()
		}
		if s.Expiry.Set {
			e.RawStr("\"expiry\"" + ":")
			s.Expiry.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes InteractionLimit from json.
func (s *InteractionLimit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionLimit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			if err := s.Limit.Decode(d); err != nil {
				return err
			}
		case "expiry":
			s.Expiry.Reset()
			if err := s.Expiry.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InteractionLimitResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"limit\"" + ":")
		s.Limit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"origin\"" + ":")
		e.Str(s.Origin)
	}
	{
		e.Comma()

		e.RawStr("\"expires_at\"" + ":")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	e.ObjEnd()
}

// Decode decodes InteractionLimitResponse from json.
func (s *InteractionLimitResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionLimitResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			if err := s.Limit.Decode(d); err != nil {
				return err
			}
		case "origin":
			v, err := d.Str()
			s.Origin = string(v)
			if err != nil {
				return err
			}
		case "expires_at":
			v, err := json.DecodeDateTime(d)
			s.ExpiresAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InteractionsRemoveRestrictionsForAuthenticatedUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes InteractionsRemoveRestrictionsForAuthenticatedUserNoContent from json.
func (s *InteractionsRemoveRestrictionsForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionsRemoveRestrictionsForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InteractionsRemoveRestrictionsForOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes InteractionsRemoveRestrictionsForOrgNoContent from json.
func (s *InteractionsRemoveRestrictionsForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionsRemoveRestrictionsForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InteractionsRemoveRestrictionsForRepoConflict) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes InteractionsRemoveRestrictionsForRepoConflict from json.
func (s *InteractionsRemoveRestrictionsForRepoConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionsRemoveRestrictionsForRepoConflict to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InteractionsRemoveRestrictionsForRepoNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes InteractionsRemoveRestrictionsForRepoNoContent from json.
func (s *InteractionsRemoveRestrictionsForRepoNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionsRemoveRestrictionsForRepoNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InteractionsSetRestrictionsForRepoConflict) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes InteractionsSetRestrictionsForRepoConflict from json.
func (s *InteractionsSetRestrictionsForRepoConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionsSetRestrictionsForRepoConflict to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Issue) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"labels\"" + ":")
		e.ArrStart()
		if len(s.Labels) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Labels[0]
				elem.Encode(e)
			}
			for _, elem := range s.Labels[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"assignee\"" + ":")
		s.Assignee.Encode(e)
	}
	{
		if s.Assignees.Set {
			e.Comma()
		}
		if s.Assignees.Set {
			e.RawStr("\"assignees\"" + ":")
			s.Assignees.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"milestone\"" + ":")
		s.Milestone.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"locked\"" + ":")
		e.Bool(s.Locked)
	}
	{
		if s.ActiveLockReason.Set {
			e.Comma()
		}
		if s.ActiveLockReason.Set {
			e.RawStr("\"active_lock_reason\"" + ":")
			s.ActiveLockReason.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"comments\"" + ":")
		e.Int(s.Comments)
	}
	{
		if s.PullRequest.Set {
			e.Comma()
		}
		if s.PullRequest.Set {
			e.RawStr("\"pull_request\"" + ":")
			s.PullRequest.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"closed_at\"" + ":")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.ClosedBy.Set {
			e.Comma()
		}
		if s.ClosedBy.Set {
			e.RawStr("\"closed_by\"" + ":")
			s.ClosedBy.Encode(e)
		}
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.TimelineURL.Set {
			e.Comma()
		}
		if s.TimelineURL.Set {
			e.RawStr("\"timeline_url\"" + ":")
			s.TimelineURL.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			e.Comma()
		}
		if s.Repository.Set {
			e.RawStr("\"repository\"" + ":")
			s.Repository.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes Issue from json.
func (s *Issue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Issue to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := json.DecodeURI(d)
			s.RepositoryURL = v
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "labels":
			s.Labels = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IssueLabelsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Labels = append(s.Labels, elem)
				return nil
			}); err != nil {
				return err
			}
		case "assignee":
			if err := s.Assignee.Decode(d); err != nil {
				return err
			}
		case "assignees":
			s.Assignees.Reset()
			if err := s.Assignees.Decode(d); err != nil {
				return err
			}
		case "milestone":
			if err := s.Milestone.Decode(d); err != nil {
				return err
			}
		case "locked":
			v, err := d.Bool()
			s.Locked = bool(v)
			if err != nil {
				return err
			}
		case "active_lock_reason":
			s.ActiveLockReason.Reset()
			if err := s.ActiveLockReason.Decode(d); err != nil {
				return err
			}
		case "comments":
			v, err := d.Int()
			s.Comments = int(v)
			if err != nil {
				return err
			}
		case "pull_request":
			s.PullRequest.Reset()
			if err := s.PullRequest.Decode(d); err != nil {
				return err
			}
		case "closed_at":
			if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "closed_by":
			s.ClosedBy.Reset()
			if err := s.ClosedBy.Decode(d); err != nil {
				return err
			}
		case "body_html":
			s.BodyHTML.Reset()
			if err := s.BodyHTML.Decode(d); err != nil {
				return err
			}
		case "body_text":
			s.BodyText.Reset()
			if err := s.BodyText.Decode(d); err != nil {
				return err
			}
		case "timeline_url":
			s.TimelineURL.Reset()
			if err := s.TimelineURL.Decode(d); err != nil {
				return err
			}
		case "repository":
			s.Repository.Reset()
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "performed_via_github_app":
			s.PerformedViaGithubApp.Reset()
			if err := s.PerformedViaGithubApp.Decode(d); err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "reactions":
			s.Reactions.Reset()
			if err := s.Reactions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueComment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"issue_url\"" + ":")
		json.EncodeURI(e, s.IssueURL)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes IssueComment from json.
func (s *IssueComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueComment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "body_text":
			s.BodyText.Reset()
			if err := s.BodyText.Decode(d); err != nil {
				return err
			}
		case "body_html":
			s.BodyHTML.Reset()
			if err := s.BodyHTML.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "issue_url":
			v, err := json.DecodeURI(d)
			s.IssueURL = v
			if err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "performed_via_github_app":
			s.PerformedViaGithubApp.Reset()
			if err := s.PerformedViaGithubApp.Decode(d); err != nil {
				return err
			}
		case "reactions":
			s.Reactions.Reset()
			if err := s.Reactions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueEvent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"actor\"" + ":")
		s.Actor.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"event\"" + ":")
		e.Str(s.Event)
	}
	{
		e.Comma()

		e.RawStr("\"commit_id\"" + ":")
		s.CommitID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commit_url\"" + ":")
		s.CommitURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.Issue.Set {
			e.Comma()
		}
		if s.Issue.Set {
			e.RawStr("\"issue\"" + ":")
			s.Issue.Encode(e)
		}
	}
	{
		if s.Label.Set {
			e.Comma()
		}
		if s.Label.Set {
			e.RawStr("\"label\"" + ":")
			s.Label.Encode(e)
		}
	}
	{
		if s.Assignee.Set {
			e.Comma()
		}
		if s.Assignee.Set {
			e.RawStr("\"assignee\"" + ":")
			s.Assignee.Encode(e)
		}
	}
	{
		if s.Assigner.Set {
			e.Comma()
		}
		if s.Assigner.Set {
			e.RawStr("\"assigner\"" + ":")
			s.Assigner.Encode(e)
		}
	}
	{
		if s.ReviewRequester.Set {
			e.Comma()
		}
		if s.ReviewRequester.Set {
			e.RawStr("\"review_requester\"" + ":")
			s.ReviewRequester.Encode(e)
		}
	}
	{
		if s.RequestedReviewer.Set {
			e.Comma()
		}
		if s.RequestedReviewer.Set {
			e.RawStr("\"requested_reviewer\"" + ":")
			s.RequestedReviewer.Encode(e)
		}
	}
	{
		if s.RequestedTeam.Set {
			e.Comma()
		}
		if s.RequestedTeam.Set {
			e.RawStr("\"requested_team\"" + ":")
			s.RequestedTeam.Encode(e)
		}
	}
	{
		if s.DismissedReview.Set {
			e.Comma()
		}
		if s.DismissedReview.Set {
			e.RawStr("\"dismissed_review\"" + ":")
			s.DismissedReview.Encode(e)
		}
	}
	{
		if s.Milestone.Set {
			e.Comma()
		}
		if s.Milestone.Set {
			e.RawStr("\"milestone\"" + ":")
			s.Milestone.Encode(e)
		}
	}
	{
		if s.ProjectCard.Set {
			e.Comma()
		}
		if s.ProjectCard.Set {
			e.RawStr("\"project_card\"" + ":")
			s.ProjectCard.Encode(e)
		}
	}
	{
		if s.Rename.Set {
			e.Comma()
		}
		if s.Rename.Set {
			e.RawStr("\"rename\"" + ":")
			s.Rename.Encode(e)
		}
	}
	{
		if s.AuthorAssociation.Set {
			e.Comma()
		}
		if s.AuthorAssociation.Set {
			e.RawStr("\"author_association\"" + ":")
			s.AuthorAssociation.Encode(e)
		}
	}
	{
		if s.LockReason.Set {
			e.Comma()
		}
		if s.LockReason.Set {
			e.RawStr("\"lock_reason\"" + ":")
			s.LockReason.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes IssueEvent from json.
func (s *IssueEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueEvent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "actor":
			if err := s.Actor.Decode(d); err != nil {
				return err
			}
		case "event":
			v, err := d.Str()
			s.Event = string(v)
			if err != nil {
				return err
			}
		case "commit_id":
			if err := s.CommitID.Decode(d); err != nil {
				return err
			}
		case "commit_url":
			if err := s.CommitURL.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "issue":
			s.Issue.Reset()
			if err := s.Issue.Decode(d); err != nil {
				return err
			}
		case "label":
			s.Label.Reset()
			if err := s.Label.Decode(d); err != nil {
				return err
			}
		case "assignee":
			s.Assignee.Reset()
			if err := s.Assignee.Decode(d); err != nil {
				return err
			}
		case "assigner":
			s.Assigner.Reset()
			if err := s.Assigner.Decode(d); err != nil {
				return err
			}
		case "review_requester":
			s.ReviewRequester.Reset()
			if err := s.ReviewRequester.Decode(d); err != nil {
				return err
			}
		case "requested_reviewer":
			s.RequestedReviewer.Reset()
			if err := s.RequestedReviewer.Decode(d); err != nil {
				return err
			}
		case "requested_team":
			s.RequestedTeam.Reset()
			if err := s.RequestedTeam.Decode(d); err != nil {
				return err
			}
		case "dismissed_review":
			s.DismissedReview.Reset()
			if err := s.DismissedReview.Decode(d); err != nil {
				return err
			}
		case "milestone":
			s.Milestone.Reset()
			if err := s.Milestone.Decode(d); err != nil {
				return err
			}
		case "project_card":
			s.ProjectCard.Reset()
			if err := s.ProjectCard.Decode(d); err != nil {
				return err
			}
		case "rename":
			s.Rename.Reset()
			if err := s.Rename.Decode(d); err != nil {
				return err
			}
		case "author_association":
			s.AuthorAssociation.Reset()
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "lock_reason":
			s.LockReason.Reset()
			if err := s.LockReason.Decode(d); err != nil {
				return err
			}
		case "performed_via_github_app":
			s.PerformedViaGithubApp.Reset()
			if err := s.PerformedViaGithubApp.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueEventDismissedReview) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"review_id\"" + ":")
		e.Int(s.ReviewID)
	}
	{
		e.Comma()

		e.RawStr("\"dismissal_message\"" + ":")
		s.DismissalMessage.Encode(e)
	}
	{
		if s.DismissalCommitID.Set {
			e.Comma()
		}
		if s.DismissalCommitID.Set {
			e.RawStr("\"dismissal_commit_id\"" + ":")
			s.DismissalCommitID.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes IssueEventDismissedReview from json.
func (s *IssueEventDismissedReview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueEventDismissedReview to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "review_id":
			v, err := d.Int()
			s.ReviewID = int(v)
			if err != nil {
				return err
			}
		case "dismissal_message":
			if err := s.DismissalMessage.Decode(d); err != nil {
				return err
			}
		case "dismissal_commit_id":
			s.DismissalCommitID.Reset()
			if err := s.DismissalCommitID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueEventLabel) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		s.Name.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"color\"" + ":")
		s.Color.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes IssueEventLabel from json.
func (s *IssueEventLabel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueEventLabel to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "color":
			if err := s.Color.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueEventMilestone) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	e.ObjEnd()
}

// Decode decodes IssueEventMilestone from json.
func (s *IssueEventMilestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueEventMilestone to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueEventProjectCard) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"project_url\"" + ":")
		json.EncodeURI(e, s.ProjectURL)
	}
	{
		e.Comma()

		e.RawStr("\"project_id\"" + ":")
		e.Int(s.ProjectID)
	}
	{
		e.Comma()

		e.RawStr("\"column_name\"" + ":")
		e.Str(s.ColumnName)
	}
	{
		if s.PreviousColumnName.Set {
			e.Comma()
		}
		if s.PreviousColumnName.Set {
			e.RawStr("\"previous_column_name\"" + ":")
			s.PreviousColumnName.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes IssueEventProjectCard from json.
func (s *IssueEventProjectCard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueEventProjectCard to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "project_url":
			v, err := json.DecodeURI(d)
			s.ProjectURL = v
			if err != nil {
				return err
			}
		case "project_id":
			v, err := d.Int()
			s.ProjectID = int(v)
			if err != nil {
				return err
			}
		case "column_name":
			v, err := d.Str()
			s.ColumnName = string(v)
			if err != nil {
				return err
			}
		case "previous_column_name":
			s.PreviousColumnName.Reset()
			if err := s.PreviousColumnName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueEventRename) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"from\"" + ":")
		e.Str(s.From)
	}
	{
		e.Comma()

		e.RawStr("\"to\"" + ":")
		e.Str(s.To)
	}
	e.ObjEnd()
}

// Decode decodes IssueEventRename from json.
func (s *IssueEventRename) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueEventRename to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			v, err := d.Str()
			s.From = string(v)
			if err != nil {
				return err
			}
		case "to":
			v, err := d.Str()
			s.To = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssueLabelsItem as json.
func (s IssueLabelsItem) Encode(e *jx.Writer) {
	switch s.Type {
	case StringIssueLabelsItem:
		e.Str(s.String)
	case IssueLabelsItem1IssueLabelsItem:
		s.IssueLabelsItem1.Encode(e)
	}
}

// Decode decodes IssueLabelsItem from json.
func (s *IssueLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueLabelsItem to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssueLabelsItem
	case jx.Object:
		if err := s.IssueLabelsItem1.Decode(d); err != nil {
			return err
		}
		s.Type = IssueLabelsItem1IssueLabelsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s IssueLabelsItem1) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Color.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	{
		if s.Default.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Default.Set {
			e.RawStr("\"default\"" + ":")
			s.Default.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes IssueLabelsItem1 from json.
func (s *IssueLabelsItem1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueLabelsItem1 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "color":
			s.Color.Reset()
			if err := s.Color.Decode(d); err != nil {
				return err
			}
		case "default":
			s.Default.Reset()
			if err := s.Default.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuePullRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MergedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MergedAt.Set {
			e.RawStr("\"merged_at\"" + ":")
			s.MergedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"diff_url\"" + ":")
		s.DiffURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"patch_url\"" + ":")
		s.PatchURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes IssuePullRequest from json.
func (s *IssuePullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuePullRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "merged_at":
			s.MergedAt.Reset()
			if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "diff_url":
			if err := s.DiffURL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "patch_url":
			if err := s.PatchURL.Decode(d); err != nil {
				return err
			}
		case "url":
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueSearchResultItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"locked\"" + ":")
		e.Bool(s.Locked)
	}
	{
		if s.ActiveLockReason.Set {
			e.Comma()
		}
		if s.ActiveLockReason.Set {
			e.RawStr("\"active_lock_reason\"" + ":")
			s.ActiveLockReason.Encode(e)
		}
	}
	{
		if s.Assignees.Set {
			e.Comma()
		}
		if s.Assignees.Set {
			e.RawStr("\"assignees\"" + ":")
			s.Assignees.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"labels\"" + ":")
		e.ArrStart()
		if len(s.Labels) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Labels[0]
				elem.Encode(e)
			}
			for _, elem := range s.Labels[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"assignee\"" + ":")
		s.Assignee.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"milestone\"" + ":")
		s.Milestone.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comments\"" + ":")
		e.Int(s.Comments)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"closed_at\"" + ":")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.TextMatches != nil {
			e.Comma()
		}
		if s.TextMatches != nil {
			e.RawStr("\"text_matches\"" + ":")
			s.TextMatches.Encode(e)
		}
	}
	{
		if s.PullRequest.Set {
			e.Comma()
		}
		if s.PullRequest.Set {
			e.RawStr("\"pull_request\"" + ":")
			s.PullRequest.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Float64(s.Score)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		if s.Draft.Set {
			e.Comma()
		}
		if s.Draft.Set {
			e.RawStr("\"draft\"" + ":")
			s.Draft.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			e.Comma()
		}
		if s.Repository.Set {
			e.RawStr("\"repository\"" + ":")
			s.Repository.Encode(e)
		}
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.TimelineURL.Set {
			e.Comma()
		}
		if s.TimelineURL.Set {
			e.RawStr("\"timeline_url\"" + ":")
			s.TimelineURL.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes IssueSearchResultItem from json.
func (s *IssueSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueSearchResultItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := json.DecodeURI(d)
			s.RepositoryURL = v
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "locked":
			v, err := d.Bool()
			s.Locked = bool(v)
			if err != nil {
				return err
			}
		case "active_lock_reason":
			s.ActiveLockReason.Reset()
			if err := s.ActiveLockReason.Decode(d); err != nil {
				return err
			}
		case "assignees":
			s.Assignees.Reset()
			if err := s.Assignees.Decode(d); err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "labels":
			s.Labels = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IssueSearchResultItemLabelsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Labels = append(s.Labels, elem)
				return nil
			}); err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "assignee":
			if err := s.Assignee.Decode(d); err != nil {
				return err
			}
		case "milestone":
			if err := s.Milestone.Decode(d); err != nil {
				return err
			}
		case "comments":
			v, err := d.Int()
			s.Comments = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "closed_at":
			if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "text_matches":
			s.TextMatches = nil
			var elem SearchResultTextMatches
			{
				var unwrapped []SearchResultTextMatchesItem
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = SearchResultTextMatches(unwrapped)
			}
			s.TextMatches = &elem
		case "pull_request":
			s.PullRequest.Reset()
			if err := s.PullRequest.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "score":
			v, err := d.Float64()
			s.Score = float64(v)
			if err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "draft":
			s.Draft.Reset()
			if err := s.Draft.Decode(d); err != nil {
				return err
			}
		case "repository":
			s.Repository.Reset()
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "body_html":
			s.BodyHTML.Reset()
			if err := s.BodyHTML.Decode(d); err != nil {
				return err
			}
		case "body_text":
			s.BodyText.Reset()
			if err := s.BodyText.Decode(d); err != nil {
				return err
			}
		case "timeline_url":
			s.TimelineURL.Reset()
			if err := s.TimelineURL.Decode(d); err != nil {
				return err
			}
		case "performed_via_github_app":
			s.PerformedViaGithubApp.Reset()
			if err := s.PerformedViaGithubApp.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueSearchResultItemLabelsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Color.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	{
		if s.Default.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Default.Set {
			e.RawStr("\"default\"" + ":")
			s.Default.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes IssueSearchResultItemLabelsItem from json.
func (s *IssueSearchResultItemLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueSearchResultItemLabelsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "color":
			s.Color.Reset()
			if err := s.Color.Decode(d); err != nil {
				return err
			}
		case "default":
			s.Default.Reset()
			if err := s.Default.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueSearchResultItemPullRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MergedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MergedAt.Set {
			e.RawStr("\"merged_at\"" + ":")
			s.MergedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"diff_url\"" + ":")
		s.DiffURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"patch_url\"" + ":")
		s.PatchURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes IssueSearchResultItemPullRequest from json.
func (s *IssueSearchResultItemPullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueSearchResultItemPullRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "merged_at":
			s.MergedAt.Reset()
			if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "diff_url":
			if err := s.DiffURL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "patch_url":
			if err := s.PatchURL.Decode(d); err != nil {
				return err
			}
		case "url":
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"labels\"" + ":")
		e.ArrStart()
		if len(s.Labels) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Labels[0]
				elem.Encode(e)
			}
			for _, elem := range s.Labels[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"assignee\"" + ":")
		s.Assignee.Encode(e)
	}
	{
		if s.Assignees.Set {
			e.Comma()
		}
		if s.Assignees.Set {
			e.RawStr("\"assignees\"" + ":")
			s.Assignees.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"milestone\"" + ":")
		s.Milestone.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"locked\"" + ":")
		e.Bool(s.Locked)
	}
	{
		if s.ActiveLockReason.Set {
			e.Comma()
		}
		if s.ActiveLockReason.Set {
			e.RawStr("\"active_lock_reason\"" + ":")
			s.ActiveLockReason.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"comments\"" + ":")
		e.Int(s.Comments)
	}
	{
		if s.PullRequest.Set {
			e.Comma()
		}
		if s.PullRequest.Set {
			e.RawStr("\"pull_request\"" + ":")
			s.PullRequest.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"closed_at\"" + ":")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.TimelineURL.Set {
			e.Comma()
		}
		if s.TimelineURL.Set {
			e.RawStr("\"timeline_url\"" + ":")
			s.TimelineURL.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			e.Comma()
		}
		if s.Repository.Set {
			e.RawStr("\"repository\"" + ":")
			s.Repository.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes IssueSimple from json.
func (s *IssueSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := json.DecodeURI(d)
			s.RepositoryURL = v
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "labels":
			s.Labels = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Label
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Labels = append(s.Labels, elem)
				return nil
			}); err != nil {
				return err
			}
		case "assignee":
			if err := s.Assignee.Decode(d); err != nil {
				return err
			}
		case "assignees":
			s.Assignees.Reset()
			if err := s.Assignees.Decode(d); err != nil {
				return err
			}
		case "milestone":
			if err := s.Milestone.Decode(d); err != nil {
				return err
			}
		case "locked":
			v, err := d.Bool()
			s.Locked = bool(v)
			if err != nil {
				return err
			}
		case "active_lock_reason":
			s.ActiveLockReason.Reset()
			if err := s.ActiveLockReason.Decode(d); err != nil {
				return err
			}
		case "comments":
			v, err := d.Int()
			s.Comments = int(v)
			if err != nil {
				return err
			}
		case "pull_request":
			s.PullRequest.Reset()
			if err := s.PullRequest.Decode(d); err != nil {
				return err
			}
		case "closed_at":
			if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "body_html":
			s.BodyHTML.Reset()
			if err := s.BodyHTML.Decode(d); err != nil {
				return err
			}
		case "body_text":
			s.BodyText.Reset()
			if err := s.BodyText.Decode(d); err != nil {
				return err
			}
		case "timeline_url":
			s.TimelineURL.Reset()
			if err := s.TimelineURL.Decode(d); err != nil {
				return err
			}
		case "repository":
			s.Repository.Reset()
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "performed_via_github_app":
			s.PerformedViaGithubApp.Reset()
			if err := s.PerformedViaGithubApp.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueSimplePullRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MergedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MergedAt.Set {
			e.RawStr("\"merged_at\"" + ":")
			s.MergedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"diff_url\"" + ":")
		s.DiffURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"patch_url\"" + ":")
		s.PatchURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes IssueSimplePullRequest from json.
func (s *IssueSimplePullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueSimplePullRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "merged_at":
			s.MergedAt.Reset()
			if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "diff_url":
			if err := s.DiffURL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "patch_url":
			if err := s.PatchURL.Decode(d); err != nil {
				return err
			}
		case "url":
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesAddAssigneesReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Assignees != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Assignees != nil {
			e.RawStr("\"assignees\"" + ":")
			e.ArrStart()
			if len(s.Assignees) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Assignees[0]
					e.Str(elem)
				}
				for _, elem := range s.Assignees[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes IssuesAddAssigneesReq from json.
func (s *IssuesAddAssigneesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesAddAssigneesReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assignees":
			s.Assignees = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Assignees = append(s.Assignees, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesCheckUserCanBeAssignedNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes IssuesCheckUserCanBeAssignedNoContent from json.
func (s *IssuesCheckUserCanBeAssignedNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCheckUserCanBeAssignedNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesCreateApplicationJSONForbidden as json.
func (s IssuesCreateApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateApplicationJSONForbidden from json.
func (s *IssuesCreateApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes IssuesCreateApplicationJSONGone as json.
func (s IssuesCreateApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateApplicationJSONGone from json.
func (s *IssuesCreateApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesCreateApplicationJSONNotFound as json.
func (s IssuesCreateApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateApplicationJSONNotFound from json.
func (s *IssuesCreateApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesCreateCommentApplicationJSONForbidden as json.
func (s IssuesCreateCommentApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateCommentApplicationJSONForbidden from json.
func (s *IssuesCreateCommentApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateCommentApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateCommentApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes IssuesCreateCommentApplicationJSONGone as json.
func (s IssuesCreateCommentApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateCommentApplicationJSONGone from json.
func (s *IssuesCreateCommentApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateCommentApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateCommentApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesCreateCommentApplicationJSONNotFound as json.
func (s IssuesCreateCommentApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateCommentApplicationJSONNotFound from json.
func (s *IssuesCreateCommentApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateCommentApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateCommentApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesCreateCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

// Decode decodes IssuesCreateCommentReq from json.
func (s *IssuesCreateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesCreateLabelReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Color.Set {
			e.Comma()
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes IssuesCreateLabelReq from json.
func (s *IssuesCreateLabelReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateLabelReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "color":
			s.Color.Reset()
			if err := s.Color.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesCreateMilestoneReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		if s.State.Set {
			e.Comma()
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.DueOn.Set {
			e.Comma()
		}
		if s.DueOn.Set {
			e.RawStr("\"due_on\"" + ":")
			s.DueOn.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

// Decode decodes IssuesCreateMilestoneReq from json.
func (s *IssuesCreateMilestoneReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateMilestoneReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "due_on":
			s.DueOn.Reset()
			if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesCreateMilestoneReqState as json.
func (s IssuesCreateMilestoneReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesCreateMilestoneReqState from json.
func (s *IssuesCreateMilestoneReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateMilestoneReqState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesCreateMilestoneReqState(v) {
	case IssuesCreateMilestoneReqStateOpen:
		*s = IssuesCreateMilestoneReqStateOpen
	case IssuesCreateMilestoneReqStateClosed:
		*s = IssuesCreateMilestoneReqStateClosed
	default:
		*s = IssuesCreateMilestoneReqState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssuesCreateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		s.Title.Encode(e)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.Assignee.Set {
			e.Comma()
		}
		if s.Assignee.Set {
			e.RawStr("\"assignee\"" + ":")
			s.Assignee.Encode(e)
		}
	}
	{
		if s.Milestone.Set {
			e.Comma()
		}
		if s.Milestone.Set {
			e.RawStr("\"milestone\"" + ":")
			s.Milestone.Encode(e)
		}
	}
	{
		if s.Labels != nil {
			e.Comma()
		}
		if s.Labels != nil {
			e.RawStr("\"labels\"" + ":")
			e.ArrStart()
			if len(s.Labels) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Labels[0]
					elem.Encode(e)
				}
				for _, elem := range s.Labels[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Assignees != nil {
			e.Comma()
		}
		if s.Assignees != nil {
			e.RawStr("\"assignees\"" + ":")
			e.ArrStart()
			if len(s.Assignees) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Assignees[0]
					e.Str(elem)
				}
				for _, elem := range s.Assignees[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes IssuesCreateReq from json.
func (s *IssuesCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "assignee":
			s.Assignee.Reset()
			if err := s.Assignee.Decode(d); err != nil {
				return err
			}
		case "milestone":
			s.Milestone.Reset()
			if err := s.Milestone.Decode(d); err != nil {
				return err
			}
		case "labels":
			s.Labels = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IssuesCreateReqLabelsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Labels = append(s.Labels, elem)
				return nil
			}); err != nil {
				return err
			}
		case "assignees":
			s.Assignees = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Assignees = append(s.Assignees, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesCreateReqLabelsItem as json.
func (s IssuesCreateReqLabelsItem) Encode(e *jx.Writer) {
	switch s.Type {
	case StringIssuesCreateReqLabelsItem:
		e.Str(s.String)
	case IssuesCreateReqLabelsItem1IssuesCreateReqLabelsItem:
		s.IssuesCreateReqLabelsItem1.Encode(e)
	}
}

// Decode decodes IssuesCreateReqLabelsItem from json.
func (s *IssuesCreateReqLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateReqLabelsItem to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesCreateReqLabelsItem
	case jx.Object:
		if err := s.IssuesCreateReqLabelsItem1.Decode(d); err != nil {
			return err
		}
		s.Type = IssuesCreateReqLabelsItem1IssuesCreateReqLabelsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesCreateReqLabelsItem1) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Color.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes IssuesCreateReqLabelsItem1 from json.
func (s *IssuesCreateReqLabelsItem1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateReqLabelsItem1 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "color":
			s.Color.Reset()
			if err := s.Color.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesCreateReqMilestone as json.
func (s IssuesCreateReqMilestone) Encode(e *jx.Writer) {
	switch s.Type {
	case StringIssuesCreateReqMilestone:
		e.Str(s.String)
	case IntIssuesCreateReqMilestone:
		e.Int(s.Int)
	}
}

// Decode decodes IssuesCreateReqMilestone from json.
func (s *IssuesCreateReqMilestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateReqMilestone to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesCreateReqMilestone
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntIssuesCreateReqMilestone
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode encodes IssuesCreateReqTitle as json.
func (s IssuesCreateReqTitle) Encode(e *jx.Writer) {
	switch s.Type {
	case StringIssuesCreateReqTitle:
		e.Str(s.String)
	case IntIssuesCreateReqTitle:
		e.Int(s.Int)
	}
}

// Decode decodes IssuesCreateReqTitle from json.
func (s *IssuesCreateReqTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateReqTitle to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesCreateReqTitle
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntIssuesCreateReqTitle
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesDeleteCommentNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes IssuesDeleteCommentNoContent from json.
func (s *IssuesDeleteCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesDeleteCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesDeleteLabelNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes IssuesDeleteLabelNoContent from json.
func (s *IssuesDeleteLabelNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesDeleteLabelNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesDeleteMilestoneNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes IssuesDeleteMilestoneNoContent from json.
func (s *IssuesDeleteMilestoneNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesDeleteMilestoneNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesGetApplicationJSONGone as json.
func (s IssuesGetApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesGetApplicationJSONGone from json.
func (s *IssuesGetApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesGetApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesGetApplicationJSONMovedPermanently as json.
func (s IssuesGetApplicationJSONMovedPermanently) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesGetApplicationJSONMovedPermanently from json.
func (s *IssuesGetApplicationJSONMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesGetApplicationJSONMovedPermanently to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetApplicationJSONMovedPermanently(unwrapped)
	return nil
}

// Encode encodes IssuesGetApplicationJSONNotFound as json.
func (s IssuesGetApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesGetApplicationJSONNotFound from json.
func (s *IssuesGetApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesGetApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesGetEventApplicationJSONForbidden as json.
func (s IssuesGetEventApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesGetEventApplicationJSONForbidden from json.
func (s *IssuesGetEventApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesGetEventApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetEventApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes IssuesGetEventApplicationJSONGone as json.
func (s IssuesGetEventApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesGetEventApplicationJSONGone from json.
func (s *IssuesGetEventApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesGetEventApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetEventApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesGetEventApplicationJSONNotFound as json.
func (s IssuesGetEventApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesGetEventApplicationJSONNotFound from json.
func (s *IssuesGetEventApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesGetEventApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetEventApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesListAssigneesOKApplicationJSON as json.
func (s IssuesListAssigneesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListAssigneesOKApplicationJSON from json.
func (s *IssuesListAssigneesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListAssigneesOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListAssigneesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListCommentsApplicationJSONGone as json.
func (s IssuesListCommentsApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesListCommentsApplicationJSONGone from json.
func (s *IssuesListCommentsApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListCommentsApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListCommentsApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesListCommentsApplicationJSONNotFound as json.
func (s IssuesListCommentsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesListCommentsApplicationJSONNotFound from json.
func (s *IssuesListCommentsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListCommentsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListCommentsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesListCommentsForRepoDirection as json.
func (s IssuesListCommentsForRepoDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListCommentsForRepoDirection from json.
func (s *IssuesListCommentsForRepoDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListCommentsForRepoDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListCommentsForRepoDirection(v) {
	case IssuesListCommentsForRepoDirectionAsc:
		*s = IssuesListCommentsForRepoDirectionAsc
	case IssuesListCommentsForRepoDirectionDesc:
		*s = IssuesListCommentsForRepoDirectionDesc
	default:
		*s = IssuesListCommentsForRepoDirection(v)
	}

	return nil
}

// Encode encodes IssuesListCommentsForRepoOKApplicationJSON as json.
func (s IssuesListCommentsForRepoOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []IssueComment(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListCommentsForRepoOKApplicationJSON from json.
func (s *IssuesListCommentsForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListCommentsForRepoOKApplicationJSON to nil`)
	}
	var unwrapped []IssueComment
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem IssueComment
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListCommentsForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListCommentsForRepoSort as json.
func (s IssuesListCommentsForRepoSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListCommentsForRepoSort from json.
func (s *IssuesListCommentsForRepoSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListCommentsForRepoSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListCommentsForRepoSort(v) {
	case IssuesListCommentsForRepoSortCreated:
		*s = IssuesListCommentsForRepoSortCreated
	case IssuesListCommentsForRepoSortUpdated:
		*s = IssuesListCommentsForRepoSortUpdated
	default:
		*s = IssuesListCommentsForRepoSort(v)
	}

	return nil
}

// Encode encodes IssuesListCommentsOKApplicationJSON as json.
func (s IssuesListCommentsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []IssueComment(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListCommentsOKApplicationJSON from json.
func (s *IssuesListCommentsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListCommentsOKApplicationJSON to nil`)
	}
	var unwrapped []IssueComment
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem IssueComment
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListCommentsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListDirection as json.
func (s IssuesListDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListDirection from json.
func (s *IssuesListDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListDirection(v) {
	case IssuesListDirectionAsc:
		*s = IssuesListDirectionAsc
	case IssuesListDirectionDesc:
		*s = IssuesListDirectionDesc
	default:
		*s = IssuesListDirection(v)
	}

	return nil
}

// Encode encodes IssuesListEventsForRepoOKApplicationJSON as json.
func (s IssuesListEventsForRepoOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []IssueEvent(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListEventsForRepoOKApplicationJSON from json.
func (s *IssuesListEventsForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListEventsForRepoOKApplicationJSON to nil`)
	}
	var unwrapped []IssueEvent
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem IssueEvent
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListEventsForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListFilter as json.
func (s IssuesListFilter) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListFilter from json.
func (s *IssuesListFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListFilter to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListFilter(v) {
	case IssuesListFilterAssigned:
		*s = IssuesListFilterAssigned
	case IssuesListFilterCreated:
		*s = IssuesListFilterCreated
	case IssuesListFilterMentioned:
		*s = IssuesListFilterMentioned
	case IssuesListFilterSubscribed:
		*s = IssuesListFilterSubscribed
	case IssuesListFilterRepos:
		*s = IssuesListFilterRepos
	case IssuesListFilterAll:
		*s = IssuesListFilterAll
	default:
		*s = IssuesListFilter(v)
	}

	return nil
}

// Encode encodes IssuesListForAuthenticatedUserDirection as json.
func (s IssuesListForAuthenticatedUserDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListForAuthenticatedUserDirection from json.
func (s *IssuesListForAuthenticatedUserDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForAuthenticatedUserDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListForAuthenticatedUserDirection(v) {
	case IssuesListForAuthenticatedUserDirectionAsc:
		*s = IssuesListForAuthenticatedUserDirectionAsc
	case IssuesListForAuthenticatedUserDirectionDesc:
		*s = IssuesListForAuthenticatedUserDirectionDesc
	default:
		*s = IssuesListForAuthenticatedUserDirection(v)
	}

	return nil
}

// Encode encodes IssuesListForAuthenticatedUserFilter as json.
func (s IssuesListForAuthenticatedUserFilter) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListForAuthenticatedUserFilter from json.
func (s *IssuesListForAuthenticatedUserFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForAuthenticatedUserFilter to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListForAuthenticatedUserFilter(v) {
	case IssuesListForAuthenticatedUserFilterAssigned:
		*s = IssuesListForAuthenticatedUserFilterAssigned
	case IssuesListForAuthenticatedUserFilterCreated:
		*s = IssuesListForAuthenticatedUserFilterCreated
	case IssuesListForAuthenticatedUserFilterMentioned:
		*s = IssuesListForAuthenticatedUserFilterMentioned
	case IssuesListForAuthenticatedUserFilterSubscribed:
		*s = IssuesListForAuthenticatedUserFilterSubscribed
	case IssuesListForAuthenticatedUserFilterRepos:
		*s = IssuesListForAuthenticatedUserFilterRepos
	case IssuesListForAuthenticatedUserFilterAll:
		*s = IssuesListForAuthenticatedUserFilterAll
	default:
		*s = IssuesListForAuthenticatedUserFilter(v)
	}

	return nil
}

// Encode encodes IssuesListForAuthenticatedUserOKApplicationJSON as json.
func (s IssuesListForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Issue(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListForAuthenticatedUserOKApplicationJSON from json.
func (s *IssuesListForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []Issue
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Issue
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListForAuthenticatedUserSort as json.
func (s IssuesListForAuthenticatedUserSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListForAuthenticatedUserSort from json.
func (s *IssuesListForAuthenticatedUserSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForAuthenticatedUserSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListForAuthenticatedUserSort(v) {
	case IssuesListForAuthenticatedUserSortCreated:
		*s = IssuesListForAuthenticatedUserSortCreated
	case IssuesListForAuthenticatedUserSortUpdated:
		*s = IssuesListForAuthenticatedUserSortUpdated
	case IssuesListForAuthenticatedUserSortComments:
		*s = IssuesListForAuthenticatedUserSortComments
	default:
		*s = IssuesListForAuthenticatedUserSort(v)
	}

	return nil
}

// Encode encodes IssuesListForAuthenticatedUserState as json.
func (s IssuesListForAuthenticatedUserState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListForAuthenticatedUserState from json.
func (s *IssuesListForAuthenticatedUserState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForAuthenticatedUserState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListForAuthenticatedUserState(v) {
	case IssuesListForAuthenticatedUserStateOpen:
		*s = IssuesListForAuthenticatedUserStateOpen
	case IssuesListForAuthenticatedUserStateClosed:
		*s = IssuesListForAuthenticatedUserStateClosed
	case IssuesListForAuthenticatedUserStateAll:
		*s = IssuesListForAuthenticatedUserStateAll
	default:
		*s = IssuesListForAuthenticatedUserState(v)
	}

	return nil
}

// Encode encodes IssuesListForOrgDirection as json.
func (s IssuesListForOrgDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListForOrgDirection from json.
func (s *IssuesListForOrgDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForOrgDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListForOrgDirection(v) {
	case IssuesListForOrgDirectionAsc:
		*s = IssuesListForOrgDirectionAsc
	case IssuesListForOrgDirectionDesc:
		*s = IssuesListForOrgDirectionDesc
	default:
		*s = IssuesListForOrgDirection(v)
	}

	return nil
}

// Encode encodes IssuesListForOrgFilter as json.
func (s IssuesListForOrgFilter) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListForOrgFilter from json.
func (s *IssuesListForOrgFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForOrgFilter to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListForOrgFilter(v) {
	case IssuesListForOrgFilterAssigned:
		*s = IssuesListForOrgFilterAssigned
	case IssuesListForOrgFilterCreated:
		*s = IssuesListForOrgFilterCreated
	case IssuesListForOrgFilterMentioned:
		*s = IssuesListForOrgFilterMentioned
	case IssuesListForOrgFilterSubscribed:
		*s = IssuesListForOrgFilterSubscribed
	case IssuesListForOrgFilterRepos:
		*s = IssuesListForOrgFilterRepos
	case IssuesListForOrgFilterAll:
		*s = IssuesListForOrgFilterAll
	default:
		*s = IssuesListForOrgFilter(v)
	}

	return nil
}

// Encode encodes IssuesListForOrgOKApplicationJSON as json.
func (s IssuesListForOrgOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Issue(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListForOrgOKApplicationJSON from json.
func (s *IssuesListForOrgOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForOrgOKApplicationJSON to nil`)
	}
	var unwrapped []Issue
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Issue
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListForOrgOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListForOrgSort as json.
func (s IssuesListForOrgSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListForOrgSort from json.
func (s *IssuesListForOrgSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForOrgSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListForOrgSort(v) {
	case IssuesListForOrgSortCreated:
		*s = IssuesListForOrgSortCreated
	case IssuesListForOrgSortUpdated:
		*s = IssuesListForOrgSortUpdated
	case IssuesListForOrgSortComments:
		*s = IssuesListForOrgSortComments
	default:
		*s = IssuesListForOrgSort(v)
	}

	return nil
}

// Encode encodes IssuesListForOrgState as json.
func (s IssuesListForOrgState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListForOrgState from json.
func (s *IssuesListForOrgState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForOrgState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListForOrgState(v) {
	case IssuesListForOrgStateOpen:
		*s = IssuesListForOrgStateOpen
	case IssuesListForOrgStateClosed:
		*s = IssuesListForOrgStateClosed
	case IssuesListForOrgStateAll:
		*s = IssuesListForOrgStateAll
	default:
		*s = IssuesListForOrgState(v)
	}

	return nil
}

// Encode encodes IssuesListForRepoApplicationJSONMovedPermanently as json.
func (s IssuesListForRepoApplicationJSONMovedPermanently) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesListForRepoApplicationJSONMovedPermanently from json.
func (s *IssuesListForRepoApplicationJSONMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForRepoApplicationJSONMovedPermanently to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListForRepoApplicationJSONMovedPermanently(unwrapped)
	return nil
}

// Encode encodes IssuesListForRepoApplicationJSONNotFound as json.
func (s IssuesListForRepoApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesListForRepoApplicationJSONNotFound from json.
func (s *IssuesListForRepoApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForRepoApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListForRepoApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesListForRepoDirection as json.
func (s IssuesListForRepoDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListForRepoDirection from json.
func (s *IssuesListForRepoDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForRepoDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListForRepoDirection(v) {
	case IssuesListForRepoDirectionAsc:
		*s = IssuesListForRepoDirectionAsc
	case IssuesListForRepoDirectionDesc:
		*s = IssuesListForRepoDirectionDesc
	default:
		*s = IssuesListForRepoDirection(v)
	}

	return nil
}

// Encode encodes IssuesListForRepoOKApplicationJSON as json.
func (s IssuesListForRepoOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []IssueSimple(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListForRepoOKApplicationJSON from json.
func (s *IssuesListForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForRepoOKApplicationJSON to nil`)
	}
	var unwrapped []IssueSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem IssueSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListForRepoSort as json.
func (s IssuesListForRepoSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListForRepoSort from json.
func (s *IssuesListForRepoSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForRepoSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListForRepoSort(v) {
	case IssuesListForRepoSortCreated:
		*s = IssuesListForRepoSortCreated
	case IssuesListForRepoSortUpdated:
		*s = IssuesListForRepoSortUpdated
	case IssuesListForRepoSortComments:
		*s = IssuesListForRepoSortComments
	default:
		*s = IssuesListForRepoSort(v)
	}

	return nil
}

// Encode encodes IssuesListForRepoState as json.
func (s IssuesListForRepoState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListForRepoState from json.
func (s *IssuesListForRepoState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForRepoState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListForRepoState(v) {
	case IssuesListForRepoStateOpen:
		*s = IssuesListForRepoStateOpen
	case IssuesListForRepoStateClosed:
		*s = IssuesListForRepoStateClosed
	case IssuesListForRepoStateAll:
		*s = IssuesListForRepoStateAll
	default:
		*s = IssuesListForRepoState(v)
	}

	return nil
}

// Encode encodes IssuesListLabelsForRepoOKApplicationJSON as json.
func (s IssuesListLabelsForRepoOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Label(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListLabelsForRepoOKApplicationJSON from json.
func (s *IssuesListLabelsForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListLabelsForRepoOKApplicationJSON to nil`)
	}
	var unwrapped []Label
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Label
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListLabelsForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListLabelsOnIssueOKApplicationJSON as json.
func (s IssuesListLabelsOnIssueOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Label(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListLabelsOnIssueOKApplicationJSON from json.
func (s *IssuesListLabelsOnIssueOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListLabelsOnIssueOKApplicationJSON to nil`)
	}
	var unwrapped []Label
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Label
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListLabelsOnIssueOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListMilestonesDirection as json.
func (s IssuesListMilestonesDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListMilestonesDirection from json.
func (s *IssuesListMilestonesDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListMilestonesDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListMilestonesDirection(v) {
	case IssuesListMilestonesDirectionAsc:
		*s = IssuesListMilestonesDirectionAsc
	case IssuesListMilestonesDirectionDesc:
		*s = IssuesListMilestonesDirectionDesc
	default:
		*s = IssuesListMilestonesDirection(v)
	}

	return nil
}

// Encode encodes IssuesListMilestonesOKApplicationJSON as json.
func (s IssuesListMilestonesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Milestone(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListMilestonesOKApplicationJSON from json.
func (s *IssuesListMilestonesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListMilestonesOKApplicationJSON to nil`)
	}
	var unwrapped []Milestone
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Milestone
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListMilestonesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListMilestonesSort as json.
func (s IssuesListMilestonesSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListMilestonesSort from json.
func (s *IssuesListMilestonesSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListMilestonesSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListMilestonesSort(v) {
	case IssuesListMilestonesSortDueOn:
		*s = IssuesListMilestonesSortDueOn
	case IssuesListMilestonesSortCompleteness:
		*s = IssuesListMilestonesSortCompleteness
	default:
		*s = IssuesListMilestonesSort(v)
	}

	return nil
}

// Encode encodes IssuesListMilestonesState as json.
func (s IssuesListMilestonesState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListMilestonesState from json.
func (s *IssuesListMilestonesState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListMilestonesState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListMilestonesState(v) {
	case IssuesListMilestonesStateOpen:
		*s = IssuesListMilestonesStateOpen
	case IssuesListMilestonesStateClosed:
		*s = IssuesListMilestonesStateClosed
	case IssuesListMilestonesStateAll:
		*s = IssuesListMilestonesStateAll
	default:
		*s = IssuesListMilestonesState(v)
	}

	return nil
}

// Encode encodes IssuesListOKApplicationJSON as json.
func (s IssuesListOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Issue(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListOKApplicationJSON from json.
func (s *IssuesListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListOKApplicationJSON to nil`)
	}
	var unwrapped []Issue
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Issue
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListSort as json.
func (s IssuesListSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListSort from json.
func (s *IssuesListSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListSort(v) {
	case IssuesListSortCreated:
		*s = IssuesListSortCreated
	case IssuesListSortUpdated:
		*s = IssuesListSortUpdated
	case IssuesListSortComments:
		*s = IssuesListSortComments
	default:
		*s = IssuesListSort(v)
	}

	return nil
}

// Encode encodes IssuesListState as json.
func (s IssuesListState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesListState from json.
func (s *IssuesListState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesListState(v) {
	case IssuesListStateOpen:
		*s = IssuesListStateOpen
	case IssuesListStateClosed:
		*s = IssuesListStateClosed
	case IssuesListStateAll:
		*s = IssuesListStateAll
	default:
		*s = IssuesListState(v)
	}

	return nil
}

// Encode encodes IssuesLockApplicationJSONForbidden as json.
func (s IssuesLockApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesLockApplicationJSONForbidden from json.
func (s *IssuesLockApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesLockApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesLockApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes IssuesLockApplicationJSONGone as json.
func (s IssuesLockApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesLockApplicationJSONGone from json.
func (s *IssuesLockApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesLockApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesLockApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesLockApplicationJSONNotFound as json.
func (s IssuesLockApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesLockApplicationJSONNotFound from json.
func (s *IssuesLockApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesLockApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesLockApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesLockNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes IssuesLockNoContent from json.
func (s *IssuesLockNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesLockNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesLockReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LockReason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LockReason.Set {
			e.RawStr("\"lock_reason\"" + ":")
			s.LockReason.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes IssuesLockReq from json.
func (s *IssuesLockReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesLockReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lock_reason":
			s.LockReason.Reset()
			if err := s.LockReason.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesLockReqLockReason as json.
func (s IssuesLockReqLockReason) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesLockReqLockReason from json.
func (s *IssuesLockReqLockReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesLockReqLockReason to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesLockReqLockReason(v) {
	case IssuesLockReqLockReasonOffMinusTopic:
		*s = IssuesLockReqLockReasonOffMinusTopic
	case IssuesLockReqLockReasonTooHeated:
		*s = IssuesLockReqLockReasonTooHeated
	case IssuesLockReqLockReasonResolved:
		*s = IssuesLockReqLockReasonResolved
	case IssuesLockReqLockReasonSpam:
		*s = IssuesLockReqLockReasonSpam
	default:
		*s = IssuesLockReqLockReason(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssuesRemoveAllLabelsNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes IssuesRemoveAllLabelsNoContent from json.
func (s *IssuesRemoveAllLabelsNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesRemoveAllLabelsNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesRemoveAssigneesReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Assignees != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Assignees != nil {
			e.RawStr("\"assignees\"" + ":")
			e.ArrStart()
			if len(s.Assignees) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Assignees[0]
					e.Str(elem)
				}
				for _, elem := range s.Assignees[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes IssuesRemoveAssigneesReq from json.
func (s *IssuesRemoveAssigneesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesRemoveAssigneesReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assignees":
			s.Assignees = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Assignees = append(s.Assignees, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesRemoveLabelApplicationJSONGone as json.
func (s IssuesRemoveLabelApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesRemoveLabelApplicationJSONGone from json.
func (s *IssuesRemoveLabelApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesRemoveLabelApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesRemoveLabelApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesRemoveLabelApplicationJSONNotFound as json.
func (s IssuesRemoveLabelApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesRemoveLabelApplicationJSONNotFound from json.
func (s *IssuesRemoveLabelApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesRemoveLabelApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesRemoveLabelApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesRemoveLabelOKApplicationJSON as json.
func (s IssuesRemoveLabelOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Label(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesRemoveLabelOKApplicationJSON from json.
func (s *IssuesRemoveLabelOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesRemoveLabelOKApplicationJSON to nil`)
	}
	var unwrapped []Label
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Label
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesRemoveLabelOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesUnlockApplicationJSONForbidden as json.
func (s IssuesUnlockApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesUnlockApplicationJSONForbidden from json.
func (s *IssuesUnlockApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUnlockApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUnlockApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes IssuesUnlockApplicationJSONNotFound as json.
func (s IssuesUnlockApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesUnlockApplicationJSONNotFound from json.
func (s *IssuesUnlockApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUnlockApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUnlockApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesUnlockNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes IssuesUnlockNoContent from json.
func (s *IssuesUnlockNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUnlockNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesUpdateApplicationJSONForbidden as json.
func (s IssuesUpdateApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesUpdateApplicationJSONForbidden from json.
func (s *IssuesUpdateApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUpdateApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes IssuesUpdateApplicationJSONGone as json.
func (s IssuesUpdateApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesUpdateApplicationJSONGone from json.
func (s *IssuesUpdateApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUpdateApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesUpdateApplicationJSONMovedPermanently as json.
func (s IssuesUpdateApplicationJSONMovedPermanently) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesUpdateApplicationJSONMovedPermanently from json.
func (s *IssuesUpdateApplicationJSONMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateApplicationJSONMovedPermanently to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUpdateApplicationJSONMovedPermanently(unwrapped)
	return nil
}

// Encode encodes IssuesUpdateApplicationJSONNotFound as json.
func (s IssuesUpdateApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesUpdateApplicationJSONNotFound from json.
func (s *IssuesUpdateApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUpdateApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesUpdateCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

// Decode decodes IssuesUpdateCommentReq from json.
func (s *IssuesUpdateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesUpdateLabelReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.NewName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NewName.Set {
			e.RawStr("\"new_name\"" + ":")
			s.NewName.Encode(e)
		}
	}
	{
		if s.Color.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes IssuesUpdateLabelReq from json.
func (s *IssuesUpdateLabelReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateLabelReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "new_name":
			s.NewName.Reset()
			if err := s.NewName.Decode(d); err != nil {
				return err
			}
		case "color":
			s.Color.Reset()
			if err := s.Color.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesUpdateMilestoneReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.DueOn.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DueOn.Set {
			e.RawStr("\"due_on\"" + ":")
			s.DueOn.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

// Decode decodes IssuesUpdateMilestoneReq from json.
func (s *IssuesUpdateMilestoneReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateMilestoneReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "due_on":
			s.DueOn.Reset()
			if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesUpdateMilestoneReqState as json.
func (s IssuesUpdateMilestoneReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesUpdateMilestoneReqState from json.
func (s *IssuesUpdateMilestoneReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateMilestoneReqState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesUpdateMilestoneReqState(v) {
	case IssuesUpdateMilestoneReqStateOpen:
		*s = IssuesUpdateMilestoneReqStateOpen
	case IssuesUpdateMilestoneReqStateClosed:
		*s = IssuesUpdateMilestoneReqStateClosed
	default:
		*s = IssuesUpdateMilestoneReqState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssuesUpdateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.Assignee.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Assignee.Set {
			e.RawStr("\"assignee\"" + ":")
			s.Assignee.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.Milestone.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Milestone.Set {
			e.RawStr("\"milestone\"" + ":")
			s.Milestone.Encode(e)
		}
	}
	{
		if s.Labels != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Labels != nil {
			e.RawStr("\"labels\"" + ":")
			e.ArrStart()
			if len(s.Labels) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Labels[0]
					elem.Encode(e)
				}
				for _, elem := range s.Labels[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Assignees != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Assignees != nil {
			e.RawStr("\"assignees\"" + ":")
			e.ArrStart()
			if len(s.Assignees) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Assignees[0]
					e.Str(elem)
				}
				for _, elem := range s.Assignees[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes IssuesUpdateReq from json.
func (s *IssuesUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "assignee":
			s.Assignee.Reset()
			if err := s.Assignee.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "milestone":
			s.Milestone.Reset()
			if err := s.Milestone.Decode(d); err != nil {
				return err
			}
		case "labels":
			s.Labels = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IssuesUpdateReqLabelsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Labels = append(s.Labels, elem)
				return nil
			}); err != nil {
				return err
			}
		case "assignees":
			s.Assignees = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Assignees = append(s.Assignees, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesUpdateReqLabelsItem as json.
func (s IssuesUpdateReqLabelsItem) Encode(e *jx.Writer) {
	switch s.Type {
	case StringIssuesUpdateReqLabelsItem:
		e.Str(s.String)
	case IssuesUpdateReqLabelsItem1IssuesUpdateReqLabelsItem:
		s.IssuesUpdateReqLabelsItem1.Encode(e)
	}
}

// Decode decodes IssuesUpdateReqLabelsItem from json.
func (s *IssuesUpdateReqLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateReqLabelsItem to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesUpdateReqLabelsItem
	case jx.Object:
		if err := s.IssuesUpdateReqLabelsItem1.Decode(d); err != nil {
			return err
		}
		s.Type = IssuesUpdateReqLabelsItem1IssuesUpdateReqLabelsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesUpdateReqLabelsItem1) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Color.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes IssuesUpdateReqLabelsItem1 from json.
func (s *IssuesUpdateReqLabelsItem1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateReqLabelsItem1 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "color":
			s.Color.Reset()
			if err := s.Color.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesUpdateReqMilestone as json.
func (s IssuesUpdateReqMilestone) Encode(e *jx.Writer) {
	switch s.Type {
	case StringIssuesUpdateReqMilestone:
		e.Str(s.String)
	case IntIssuesUpdateReqMilestone:
		e.Int(s.Int)
	}
}

// Decode decodes IssuesUpdateReqMilestone from json.
func (s *IssuesUpdateReqMilestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateReqMilestone to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesUpdateReqMilestone
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntIssuesUpdateReqMilestone
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode encodes IssuesUpdateReqState as json.
func (s IssuesUpdateReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesUpdateReqState from json.
func (s *IssuesUpdateReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateReqState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesUpdateReqState(v) {
	case IssuesUpdateReqStateOpen:
		*s = IssuesUpdateReqStateOpen
	case IssuesUpdateReqStateClosed:
		*s = IssuesUpdateReqStateClosed
	default:
		*s = IssuesUpdateReqState(v)
	}

	return nil
}

// Encode encodes IssuesUpdateReqTitle as json.
func (s IssuesUpdateReqTitle) Encode(e *jx.Writer) {
	switch s.Type {
	case StringIssuesUpdateReqTitle:
		e.Str(s.String)
	case IntIssuesUpdateReqTitle:
		e.Int(s.Int)
	}
}

// Decode decodes IssuesUpdateReqTitle from json.
func (s *IssuesUpdateReqTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateReqTitle to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesUpdateReqTitle
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntIssuesUpdateReqTitle
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s Job) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"run_id\"" + ":")
		e.Int(s.RunID)
	}
	{
		e.Comma()

		e.RawStr("\"run_url\"" + ":")
		e.Str(s.RunURL)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"head_sha\"" + ":")
		e.Str(s.HeadSha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"conclusion\"" + ":")
		s.Conclusion.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"started_at\"" + ":")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.Comma()

		e.RawStr("\"completed_at\"" + ":")
		s.CompletedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Steps != nil {
			e.Comma()
		}
		if s.Steps != nil {
			e.RawStr("\"steps\"" + ":")
			e.ArrStart()
			if len(s.Steps) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Steps[0]
					elem.Encode(e)
				}
				for _, elem := range s.Steps[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"check_run_url\"" + ":")
		e.Str(s.CheckRunURL)
	}
	e.ObjEnd()
}

// Decode decodes Job from json.
func (s *Job) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Job to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "run_id":
			v, err := d.Int()
			s.RunID = int(v)
			if err != nil {
				return err
			}
		case "run_url":
			v, err := d.Str()
			s.RunURL = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "head_sha":
			v, err := d.Str()
			s.HeadSha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "conclusion":
			if err := s.Conclusion.Decode(d); err != nil {
				return err
			}
		case "started_at":
			v, err := json.DecodeDateTime(d)
			s.StartedAt = v
			if err != nil {
				return err
			}
		case "completed_at":
			if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "steps":
			s.Steps = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem JobStepsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Steps = append(s.Steps, elem)
				return nil
			}); err != nil {
				return err
			}
		case "check_run_url":
			v, err := d.Str()
			s.CheckRunURL = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes JobStatus as json.
func (s JobStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes JobStatus from json.
func (s *JobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode JobStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch JobStatus(v) {
	case JobStatusQueued:
		*s = JobStatusQueued
	case JobStatusInProgress:
		*s = JobStatusInProgress
	case JobStatusCompleted:
		*s = JobStatusCompleted
	default:
		*s = JobStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s JobStepsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"conclusion\"" + ":")
		s.Conclusion.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		if s.StartedAt.Set {
			e.Comma()
		}
		if s.StartedAt.Set {
			e.RawStr("\"started_at\"" + ":")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CompletedAt.Set {
			e.Comma()
		}
		if s.CompletedAt.Set {
			e.RawStr("\"completed_at\"" + ":")
			s.CompletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

// Decode decodes JobStepsItem from json.
func (s *JobStepsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode JobStepsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "conclusion":
			if err := s.Conclusion.Decode(d); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "started_at":
			s.StartedAt.Reset()
			if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "completed_at":
			s.CompletedAt.Reset()
			if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes JobStepsItemStatus as json.
func (s JobStepsItemStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes JobStepsItemStatus from json.
func (s *JobStepsItemStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode JobStepsItemStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch JobStepsItemStatus(v) {
	case JobStepsItemStatusQueued:
		*s = JobStepsItemStatusQueued
	case JobStepsItemStatusInProgress:
		*s = JobStepsItemStatusInProgress
	case JobStepsItemStatusCompleted:
		*s = JobStepsItemStatusCompleted
	default:
		*s = JobStepsItemStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Key) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"verified\"" + ":")
		e.Bool(s.Verified)
	}
	{
		e.Comma()

		e.RawStr("\"read_only\"" + ":")
		e.Bool(s.ReadOnly)
	}
	e.ObjEnd()
}

// Decode decodes Key from json.
func (s *Key) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Key to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "verified":
			v, err := d.Bool()
			s.Verified = bool(v)
			if err != nil {
				return err
			}
		case "read_only":
			v, err := d.Bool()
			s.ReadOnly = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s KeySimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	e.ObjEnd()
}

// Decode decodes KeySimple from json.
func (s *KeySimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode KeySimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Label) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int64(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"color\"" + ":")
		e.Str(s.Color)
	}
	{
		e.Comma()

		e.RawStr("\"default\"" + ":")
		e.Bool(s.Default)
	}
	e.ObjEnd()
}

// Decode decodes Label from json.
func (s *Label) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Label to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int64()
			s.ID = int64(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "color":
			v, err := d.Str()
			s.Color = string(v)
			if err != nil {
				return err
			}
		case "default":
			v, err := d.Bool()
			s.Default = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s LabelSearchResultItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"color\"" + ":")
		e.Str(s.Color)
	}
	{
		e.Comma()

		e.RawStr("\"default\"" + ":")
		e.Bool(s.Default)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Float64(s.Score)
	}
	{
		if s.TextMatches != nil {
			e.Comma()
		}
		if s.TextMatches != nil {
			e.RawStr("\"text_matches\"" + ":")
			s.TextMatches.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes LabelSearchResultItem from json.
func (s *LabelSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LabelSearchResultItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "color":
			v, err := d.Str()
			s.Color = string(v)
			if err != nil {
				return err
			}
		case "default":
			v, err := d.Bool()
			s.Default = bool(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "score":
			v, err := d.Float64()
			s.Score = float64(v)
			if err != nil {
				return err
			}
		case "text_matches":
			s.TextMatches = nil
			var elem SearchResultTextMatches
			{
				var unwrapped []SearchResultTextMatchesItem
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = SearchResultTextMatches(unwrapped)
			}
			s.TextMatches = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Language) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes Language from json.
func (s *Language) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Language to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s License) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"spdx_id\"" + ":")
		s.SpdxID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"implementation\"" + ":")
		e.Str(s.Implementation)
	}
	{
		e.Comma()

		e.RawStr("\"permissions\"" + ":")
		e.ArrStart()
		if len(s.Permissions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Permissions[0]
				e.Str(elem)
			}
			for _, elem := range s.Permissions[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"conditions\"" + ":")
		e.ArrStart()
		if len(s.Conditions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Conditions[0]
				e.Str(elem)
			}
			for _, elem := range s.Conditions[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"limitations\"" + ":")
		e.ArrStart()
		if len(s.Limitations) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Limitations[0]
				e.Str(elem)
			}
			for _, elem := range s.Limitations[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"featured\"" + ":")
		e.Bool(s.Featured)
	}
	e.ObjEnd()
}

// Decode decodes License from json.
func (s *License) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode License to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "spdx_id":
			if err := s.SpdxID.Decode(d); err != nil {
				return err
			}
		case "url":
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "implementation":
			v, err := d.Str()
			s.Implementation = string(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Permissions = append(s.Permissions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "limitations":
			s.Limitations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Limitations = append(s.Limitations, elem)
				return nil
			}); err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "featured":
			v, err := d.Bool()
			s.Featured = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s LicenseContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		s.GitURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"download_url\"" + ":")
		s.DownloadURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"content\"" + ":")
		e.Str(s.Content)
	}
	{
		e.Comma()

		e.RawStr("\"encoding\"" + ":")
		e.Str(s.Encoding)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes LicenseContent from json.
func (s *LicenseContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LicenseContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "git_url":
			if err := s.GitURL.Decode(d); err != nil {
				return err
			}
		case "download_url":
			if err := s.DownloadURL.Decode(d); err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "content":
			v, err := d.Str()
			s.Content = string(v)
			if err != nil {
				return err
			}
		case "encoding":
			v, err := d.Str()
			s.Encoding = string(v)
			if err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s LicenseContentLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"git\"" + ":")
		s.Git.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html\"" + ":")
		s.HTML.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"self\"" + ":")
		json.EncodeURI(e, s.Self)
	}
	e.ObjEnd()
}

// Decode decodes LicenseContentLinks from json.
func (s *LicenseContentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LicenseContentLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "git":
			if err := s.Git.Decode(d); err != nil {
				return err
			}
		case "html":
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		case "self":
			v, err := json.DecodeURI(d)
			s.Self = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s LicenseSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"spdx_id\"" + ":")
		s.SpdxID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		if s.HTMLURL.Set {
			e.Comma()
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes LicenseSimple from json.
func (s *LicenseSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LicenseSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "spdx_id":
			if err := s.SpdxID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes LicensesGetAllCommonlyUsedOKApplicationJSON as json.
func (s LicensesGetAllCommonlyUsedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []LicenseSimple(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes LicensesGetAllCommonlyUsedOKApplicationJSON from json.
func (s *LicensesGetAllCommonlyUsedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LicensesGetAllCommonlyUsedOKApplicationJSON to nil`)
	}
	var unwrapped []LicenseSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LicenseSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LicensesGetAllCommonlyUsedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes LicensesGetApplicationJSONForbidden as json.
func (s LicensesGetApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes LicensesGetApplicationJSONForbidden from json.
func (s *LicensesGetApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LicensesGetApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LicensesGetApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes LicensesGetApplicationJSONNotFound as json.
func (s LicensesGetApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes LicensesGetApplicationJSONNotFound from json.
func (s *LicensesGetApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LicensesGetApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LicensesGetApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s Link) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"href\"" + ":")
		e.Str(s.Href)
	}
	e.ObjEnd()
}

// Decode decodes Link from json.
func (s *Link) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Link to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			v, err := d.Str()
			s.Href = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s LinkWithType) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"href\"" + ":")
		e.Str(s.Href)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

// Decode decodes LinkWithType from json.
func (s *LinkWithType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LinkWithType to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			v, err := d.Str()
			s.Href = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MarkdownRenderReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"text\"" + ":")
		e.Str(s.Text)
	}
	{
		if s.Mode.Set {
			e.Comma()
		}
		if s.Mode.Set {
			e.RawStr("\"mode\"" + ":")
			s.Mode.Encode(e)
		}
	}
	{
		if s.Context.Set {
			e.Comma()
		}
		if s.Context.Set {
			e.RawStr("\"context\"" + ":")
			s.Context.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes MarkdownRenderReq from json.
func (s *MarkdownRenderReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarkdownRenderReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			v, err := d.Str()
			s.Text = string(v)
			if err != nil {
				return err
			}
		case "mode":
			s.Mode.Reset()
			if err := s.Mode.Decode(d); err != nil {
				return err
			}
		case "context":
			s.Context.Reset()
			if err := s.Context.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MarkdownRenderReqMode as json.
func (s MarkdownRenderReqMode) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MarkdownRenderReqMode from json.
func (s *MarkdownRenderReqMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarkdownRenderReqMode to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MarkdownRenderReqMode(v) {
	case MarkdownRenderReqModeMarkdown:
		*s = MarkdownRenderReqModeMarkdown
	case MarkdownRenderReqModeGfm:
		*s = MarkdownRenderReqModeGfm
	default:
		*s = MarkdownRenderReqMode(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MarketplaceAccount) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		if s.NodeID.Set {
			e.Comma()
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		if s.Email.Set {
			e.Comma()
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.OrganizationBillingEmail.Set {
			e.Comma()
		}
		if s.OrganizationBillingEmail.Set {
			e.RawStr("\"organization_billing_email\"" + ":")
			s.OrganizationBillingEmail.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes MarketplaceAccount from json.
func (s *MarketplaceAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarketplaceAccount to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "organization_billing_email":
			s.OrganizationBillingEmail.Reset()
			if err := s.OrganizationBillingEmail.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MarketplaceListingPlan) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"accounts_url\"" + ":")
		json.EncodeURI(e, s.AccountsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"monthly_price_in_cents\"" + ":")
		e.Int(s.MonthlyPriceInCents)
	}
	{
		e.Comma()

		e.RawStr("\"yearly_price_in_cents\"" + ":")
		e.Int(s.YearlyPriceInCents)
	}
	{
		e.Comma()

		e.RawStr("\"price_model\"" + ":")
		e.Str(s.PriceModel)
	}
	{
		e.Comma()

		e.RawStr("\"has_free_trial\"" + ":")
		e.Bool(s.HasFreeTrial)
	}
	{
		e.Comma()

		e.RawStr("\"unit_name\"" + ":")
		s.UnitName.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"bullets\"" + ":")
		e.ArrStart()
		if len(s.Bullets) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Bullets[0]
				e.Str(elem)
			}
			for _, elem := range s.Bullets[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes MarketplaceListingPlan from json.
func (s *MarketplaceListingPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarketplaceListingPlan to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "accounts_url":
			v, err := json.DecodeURI(d)
			s.AccountsURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "monthly_price_in_cents":
			v, err := d.Int()
			s.MonthlyPriceInCents = int(v)
			if err != nil {
				return err
			}
		case "yearly_price_in_cents":
			v, err := d.Int()
			s.YearlyPriceInCents = int(v)
			if err != nil {
				return err
			}
		case "price_model":
			v, err := d.Str()
			s.PriceModel = string(v)
			if err != nil {
				return err
			}
		case "has_free_trial":
			v, err := d.Bool()
			s.HasFreeTrial = bool(v)
			if err != nil {
				return err
			}
		case "unit_name":
			if err := s.UnitName.Decode(d); err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "bullets":
			s.Bullets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Bullets = append(s.Bullets, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MarketplacePurchase) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		if s.OrganizationBillingEmail.Set {
			e.Comma()
		}
		if s.OrganizationBillingEmail.Set {
			e.RawStr("\"organization_billing_email\"" + ":")
			s.OrganizationBillingEmail.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.Comma()
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.MarketplacePendingChange.Set {
			e.Comma()
		}
		if s.MarketplacePendingChange.Set {
			e.RawStr("\"marketplace_pending_change\"" + ":")
			s.MarketplacePendingChange.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"marketplace_purchase\"" + ":")
		s.MarketplacePurchase.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MarketplacePurchase from json.
func (s *MarketplacePurchase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarketplacePurchase to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "organization_billing_email":
			s.OrganizationBillingEmail.Reset()
			if err := s.OrganizationBillingEmail.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "marketplace_pending_change":
			s.MarketplacePendingChange.Reset()
			if err := s.MarketplacePendingChange.Decode(d); err != nil {
				return err
			}
		case "marketplace_purchase":
			if err := s.MarketplacePurchase.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MarketplacePurchaseMarketplacePendingChange) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.IsInstalled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsInstalled.Set {
			e.RawStr("\"is_installed\"" + ":")
			s.IsInstalled.Encode(e)
		}
	}
	{
		if s.EffectiveDate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EffectiveDate.Set {
			e.RawStr("\"effective_date\"" + ":")
			s.EffectiveDate.Encode(e)
		}
	}
	{
		if s.UnitCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UnitCount.Set {
			e.RawStr("\"unit_count\"" + ":")
			s.UnitCount.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Plan.Set {
			e.RawStr("\"plan\"" + ":")
			s.Plan.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes MarketplacePurchaseMarketplacePendingChange from json.
func (s *MarketplacePurchaseMarketplacePendingChange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarketplacePurchaseMarketplacePendingChange to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_installed":
			s.IsInstalled.Reset()
			if err := s.IsInstalled.Decode(d); err != nil {
				return err
			}
		case "effective_date":
			s.EffectiveDate.Reset()
			if err := s.EffectiveDate.Decode(d); err != nil {
				return err
			}
		case "unit_count":
			s.UnitCount.Reset()
			if err := s.UnitCount.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "plan":
			s.Plan.Reset()
			if err := s.Plan.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MarketplacePurchaseMarketplacePurchase) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.BillingCycle.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BillingCycle.Set {
			e.RawStr("\"billing_cycle\"" + ":")
			s.BillingCycle.Encode(e)
		}
	}
	{
		if s.NextBillingDate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NextBillingDate.Set {
			e.RawStr("\"next_billing_date\"" + ":")
			s.NextBillingDate.Encode(e)
		}
	}
	{
		if s.IsInstalled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsInstalled.Set {
			e.RawStr("\"is_installed\"" + ":")
			s.IsInstalled.Encode(e)
		}
	}
	{
		if s.UnitCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UnitCount.Set {
			e.RawStr("\"unit_count\"" + ":")
			s.UnitCount.Encode(e)
		}
	}
	{
		if s.OnFreeTrial.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OnFreeTrial.Set {
			e.RawStr("\"on_free_trial\"" + ":")
			s.OnFreeTrial.Encode(e)
		}
	}
	{
		if s.FreeTrialEndsOn.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FreeTrialEndsOn.Set {
			e.RawStr("\"free_trial_ends_on\"" + ":")
			s.FreeTrialEndsOn.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Plan.Set {
			e.RawStr("\"plan\"" + ":")
			s.Plan.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes MarketplacePurchaseMarketplacePurchase from json.
func (s *MarketplacePurchaseMarketplacePurchase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarketplacePurchaseMarketplacePurchase to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billing_cycle":
			s.BillingCycle.Reset()
			if err := s.BillingCycle.Decode(d); err != nil {
				return err
			}
		case "next_billing_date":
			s.NextBillingDate.Reset()
			if err := s.NextBillingDate.Decode(d); err != nil {
				return err
			}
		case "is_installed":
			s.IsInstalled.Reset()
			if err := s.IsInstalled.Decode(d); err != nil {
				return err
			}
		case "unit_count":
			s.UnitCount.Reset()
			if err := s.UnitCount.Decode(d); err != nil {
				return err
			}
		case "on_free_trial":
			s.OnFreeTrial.Reset()
			if err := s.OnFreeTrial.Decode(d); err != nil {
				return err
			}
		case "free_trial_ends_on":
			s.FreeTrialEndsOn.Reset()
			if err := s.FreeTrialEndsOn.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d); err != nil {
				return err
			}
		case "plan":
			s.Plan.Reset()
			if err := s.Plan.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MergedUpstream) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.MergeType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MergeType.Set {
			e.RawStr("\"merge_type\"" + ":")
			s.MergeType.Encode(e)
		}
	}
	{
		if s.BaseBranch.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BaseBranch.Set {
			e.RawStr("\"base_branch\"" + ":")
			s.BaseBranch.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes MergedUpstream from json.
func (s *MergedUpstream) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MergedUpstream to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "merge_type":
			s.MergeType.Reset()
			if err := s.MergeType.Decode(d); err != nil {
				return err
			}
		case "base_branch":
			s.BaseBranch.Reset()
			if err := s.BaseBranch.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MergedUpstreamMergeType as json.
func (s MergedUpstreamMergeType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MergedUpstreamMergeType from json.
func (s *MergedUpstreamMergeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MergedUpstreamMergeType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MergedUpstreamMergeType(v) {
	case MergedUpstreamMergeTypeMerge:
		*s = MergedUpstreamMergeTypeMerge
	case MergedUpstreamMergeTypeFastMinusForward:
		*s = MergedUpstreamMergeTypeFastMinusForward
	case MergedUpstreamMergeTypeNone:
		*s = MergedUpstreamMergeTypeNone
	default:
		*s = MergedUpstreamMergeType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MetaRootOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"current_user_url\"" + ":")
		e.Str(s.CurrentUserURL)
	}
	{
		e.Comma()

		e.RawStr("\"current_user_authorizations_html_url\"" + ":")
		e.Str(s.CurrentUserAuthorizationsHTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"authorizations_url\"" + ":")
		e.Str(s.AuthorizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"code_search_url\"" + ":")
		e.Str(s.CodeSearchURL)
	}
	{
		e.Comma()

		e.RawStr("\"commit_search_url\"" + ":")
		e.Str(s.CommitSearchURL)
	}
	{
		e.Comma()

		e.RawStr("\"emails_url\"" + ":")
		e.Str(s.EmailsURL)
	}
	{
		e.Comma()

		e.RawStr("\"emojis_url\"" + ":")
		e.Str(s.EmojisURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"feeds_url\"" + ":")
		e.Str(s.FeedsURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		e.Str(s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"hub_url\"" + ":")
		e.Str(s.HubURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_search_url\"" + ":")
		e.Str(s.IssueSearchURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"label_search_url\"" + ":")
		e.Str(s.LabelSearchURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"organization_url\"" + ":")
		e.Str(s.OrganizationURL)
	}
	{
		e.Comma()

		e.RawStr("\"organization_repositories_url\"" + ":")
		e.Str(s.OrganizationRepositoriesURL)
	}
	{
		e.Comma()

		e.RawStr("\"organization_teams_url\"" + ":")
		e.Str(s.OrganizationTeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"public_gists_url\"" + ":")
		e.Str(s.PublicGistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"rate_limit_url\"" + ":")
		e.Str(s.RateLimitURL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		e.Str(s.RepositoryURL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_search_url\"" + ":")
		e.Str(s.RepositorySearchURL)
	}
	{
		e.Comma()

		e.RawStr("\"current_user_repositories_url\"" + ":")
		e.Str(s.CurrentUserRepositoriesURL)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"starred_gists_url\"" + ":")
		e.Str(s.StarredGistsURL)
	}
	{
		if s.TopicSearchURL.Set {
			e.Comma()
		}
		if s.TopicSearchURL.Set {
			e.RawStr("\"topic_search_url\"" + ":")
			s.TopicSearchURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"user_url\"" + ":")
		e.Str(s.UserURL)
	}
	{
		e.Comma()

		e.RawStr("\"user_organizations_url\"" + ":")
		e.Str(s.UserOrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"user_repositories_url\"" + ":")
		e.Str(s.UserRepositoriesURL)
	}
	{
		e.Comma()

		e.RawStr("\"user_search_url\"" + ":")
		e.Str(s.UserSearchURL)
	}
	e.ObjEnd()
}

// Decode decodes MetaRootOK from json.
func (s *MetaRootOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MetaRootOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current_user_url":
			v, err := d.Str()
			s.CurrentUserURL = string(v)
			if err != nil {
				return err
			}
		case "current_user_authorizations_html_url":
			v, err := d.Str()
			s.CurrentUserAuthorizationsHTMLURL = string(v)
			if err != nil {
				return err
			}
		case "authorizations_url":
			v, err := d.Str()
			s.AuthorizationsURL = string(v)
			if err != nil {
				return err
			}
		case "code_search_url":
			v, err := d.Str()
			s.CodeSearchURL = string(v)
			if err != nil {
				return err
			}
		case "commit_search_url":
			v, err := d.Str()
			s.CommitSearchURL = string(v)
			if err != nil {
				return err
			}
		case "emails_url":
			v, err := d.Str()
			s.EmailsURL = string(v)
			if err != nil {
				return err
			}
		case "emojis_url":
			v, err := d.Str()
			s.EmojisURL = string(v)
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "feeds_url":
			v, err := d.Str()
			s.FeedsURL = string(v)
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := d.Str()
			s.FollowersURL = string(v)
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "hub_url":
			v, err := d.Str()
			s.HubURL = string(v)
			if err != nil {
				return err
			}
		case "issue_search_url":
			v, err := d.Str()
			s.IssueSearchURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "label_search_url":
			v, err := d.Str()
			s.LabelSearchURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "organization_url":
			v, err := d.Str()
			s.OrganizationURL = string(v)
			if err != nil {
				return err
			}
		case "organization_repositories_url":
			v, err := d.Str()
			s.OrganizationRepositoriesURL = string(v)
			if err != nil {
				return err
			}
		case "organization_teams_url":
			v, err := d.Str()
			s.OrganizationTeamsURL = string(v)
			if err != nil {
				return err
			}
		case "public_gists_url":
			v, err := d.Str()
			s.PublicGistsURL = string(v)
			if err != nil {
				return err
			}
		case "rate_limit_url":
			v, err := d.Str()
			s.RateLimitURL = string(v)
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := d.Str()
			s.RepositoryURL = string(v)
			if err != nil {
				return err
			}
		case "repository_search_url":
			v, err := d.Str()
			s.RepositorySearchURL = string(v)
			if err != nil {
				return err
			}
		case "current_user_repositories_url":
			v, err := d.Str()
			s.CurrentUserRepositoriesURL = string(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "starred_gists_url":
			v, err := d.Str()
			s.StarredGistsURL = string(v)
			if err != nil {
				return err
			}
		case "topic_search_url":
			s.TopicSearchURL.Reset()
			if err := s.TopicSearchURL.Decode(d); err != nil {
				return err
			}
		case "user_url":
			v, err := d.Str()
			s.UserURL = string(v)
			if err != nil {
				return err
			}
		case "user_organizations_url":
			v, err := d.Str()
			s.UserOrganizationsURL = string(v)
			if err != nil {
				return err
			}
		case "user_repositories_url":
			v, err := d.Str()
			s.UserRepositoriesURL = string(v)
			if err != nil {
				return err
			}
		case "user_search_url":
			v, err := d.Str()
			s.UserSearchURL = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Migration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"guid\"" + ":")
		e.Str(s.GUID)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"lock_repositories\"" + ":")
		e.Bool(s.LockRepositories)
	}
	{
		e.Comma()

		e.RawStr("\"exclude_metadata\"" + ":")
		e.Bool(s.ExcludeMetadata)
	}
	{
		e.Comma()

		e.RawStr("\"exclude_git_data\"" + ":")
		e.Bool(s.ExcludeGitData)
	}
	{
		e.Comma()

		e.RawStr("\"exclude_attachments\"" + ":")
		e.Bool(s.ExcludeAttachments)
	}
	{
		e.Comma()

		e.RawStr("\"exclude_releases\"" + ":")
		e.Bool(s.ExcludeReleases)
	}
	{
		e.Comma()

		e.RawStr("\"exclude_owner_projects\"" + ":")
		e.Bool(s.ExcludeOwnerProjects)
	}
	{
		e.Comma()

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				elem.Encode(e)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		if s.ArchiveURL.Set {
			e.Comma()
		}
		if s.ArchiveURL.Set {
			e.RawStr("\"archive_url\"" + ":")
			s.ArchiveURL.Encode(e)
		}
	}
	{
		if s.Exclude != nil {
			e.Comma()
		}
		if s.Exclude != nil {
			e.RawStr("\"exclude\"" + ":")
			e.ArrStart()
			if len(s.Exclude) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Exclude[0]
					e.Str(elem)
				}
				for _, elem := range s.Exclude[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes Migration from json.
func (s *Migration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Migration to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "guid":
			v, err := d.Str()
			s.GUID = string(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "lock_repositories":
			v, err := d.Bool()
			s.LockRepositories = bool(v)
			if err != nil {
				return err
			}
		case "exclude_metadata":
			v, err := d.Bool()
			s.ExcludeMetadata = bool(v)
			if err != nil {
				return err
			}
		case "exclude_git_data":
			v, err := d.Bool()
			s.ExcludeGitData = bool(v)
			if err != nil {
				return err
			}
		case "exclude_attachments":
			v, err := d.Bool()
			s.ExcludeAttachments = bool(v)
			if err != nil {
				return err
			}
		case "exclude_releases":
			v, err := d.Bool()
			s.ExcludeReleases = bool(v)
			if err != nil {
				return err
			}
		case "exclude_owner_projects":
			v, err := d.Bool()
			s.ExcludeOwnerProjects = bool(v)
			if err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Repository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "archive_url":
			s.ArchiveURL.Reset()
			if err := s.ArchiveURL.Decode(d); err != nil {
				return err
			}
		case "exclude":
			s.Exclude = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Exclude = append(s.Exclude, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MigrationsCancelImportNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes MigrationsCancelImportNoContent from json.
func (s *MigrationsCancelImportNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsCancelImportNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound as json.
func (s MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound from json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsDeleteArchiveForAuthenticatedUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes MigrationsDeleteArchiveForAuthenticatedUserNoContent from json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsDeleteArchiveForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MigrationsDeleteArchiveForOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes MigrationsDeleteArchiveForOrgNoContent from json.
func (s *MigrationsDeleteArchiveForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsDeleteArchiveForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MigrationsDownloadArchiveForOrgFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes MigrationsDownloadArchiveForOrgFound from json.
func (s *MigrationsDownloadArchiveForOrgFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsDownloadArchiveForOrgFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsGetArchiveForAuthenticatedUserFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes MigrationsGetArchiveForAuthenticatedUserFound from json.
func (s *MigrationsGetArchiveForAuthenticatedUserFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetArchiveForAuthenticatedUserFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MigrationsGetCommitAuthorsOKApplicationJSON as json.
func (s MigrationsGetCommitAuthorsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PorterAuthor(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes MigrationsGetCommitAuthorsOKApplicationJSON from json.
func (s *MigrationsGetCommitAuthorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetCommitAuthorsOKApplicationJSON to nil`)
	}
	var unwrapped []PorterAuthor
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PorterAuthor
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetCommitAuthorsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound as json.
func (s MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound from json.
func (s *MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes MigrationsGetStatusForOrgExcludeItem as json.
func (s MigrationsGetStatusForOrgExcludeItem) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MigrationsGetStatusForOrgExcludeItem from json.
func (s *MigrationsGetStatusForOrgExcludeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetStatusForOrgExcludeItem to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MigrationsGetStatusForOrgExcludeItem(v) {
	case MigrationsGetStatusForOrgExcludeItemRepositories:
		*s = MigrationsGetStatusForOrgExcludeItemRepositories
	default:
		*s = MigrationsGetStatusForOrgExcludeItem(v)
	}

	return nil
}

// Encode encodes MigrationsListForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsListForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsListForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsListForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsListForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsListForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsListForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsListForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsListForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsListForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes MigrationsListForAuthenticatedUserOKApplicationJSON as json.
func (s MigrationsListForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Migration(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes MigrationsListForAuthenticatedUserOKApplicationJSON from json.
func (s *MigrationsListForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsListForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []Migration
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Migration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes MigrationsListForOrgExcludeItem as json.
func (s MigrationsListForOrgExcludeItem) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MigrationsListForOrgExcludeItem from json.
func (s *MigrationsListForOrgExcludeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsListForOrgExcludeItem to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MigrationsListForOrgExcludeItem(v) {
	case MigrationsListForOrgExcludeItemRepositories:
		*s = MigrationsListForOrgExcludeItemRepositories
	default:
		*s = MigrationsListForOrgExcludeItem(v)
	}

	return nil
}

// Encode encodes MigrationsListReposForOrgOKApplicationJSON as json.
func (s MigrationsListReposForOrgOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes MigrationsListReposForOrgOKApplicationJSON from json.
func (s *MigrationsListReposForOrgOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsListReposForOrgOKApplicationJSON to nil`)
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListReposForOrgOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes MigrationsListReposForUserOKApplicationJSON as json.
func (s MigrationsListReposForUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes MigrationsListReposForUserOKApplicationJSON from json.
func (s *MigrationsListReposForUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsListReposForUserOKApplicationJSON to nil`)
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListReposForUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsMapCommitAuthorReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes MigrationsMapCommitAuthorReq from json.
func (s *MigrationsMapCommitAuthorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsMapCommitAuthorReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MigrationsSetLfsPreferenceReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"use_lfs\"" + ":")
		s.UseLfs.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MigrationsSetLfsPreferenceReq from json.
func (s *MigrationsSetLfsPreferenceReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsSetLfsPreferenceReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "use_lfs":
			if err := s.UseLfs.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MigrationsSetLfsPreferenceReqUseLfs as json.
func (s MigrationsSetLfsPreferenceReqUseLfs) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MigrationsSetLfsPreferenceReqUseLfs from json.
func (s *MigrationsSetLfsPreferenceReqUseLfs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsSetLfsPreferenceReqUseLfs to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MigrationsSetLfsPreferenceReqUseLfs(v) {
	case MigrationsSetLfsPreferenceReqUseLfsOptIn:
		*s = MigrationsSetLfsPreferenceReqUseLfsOptIn
	case MigrationsSetLfsPreferenceReqUseLfsOptOut:
		*s = MigrationsSetLfsPreferenceReqUseLfsOptOut
	default:
		*s = MigrationsSetLfsPreferenceReqUseLfs(v)
	}

	return nil
}

// Encode encodes MigrationsStartForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsStartForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsStartForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsStartForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsStartForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsStartForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsStartForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsStartForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsStartForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsStartForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsStartForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsStartForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsStartForAuthenticatedUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LockRepositories.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LockRepositories.Set {
			e.RawStr("\"lock_repositories\"" + ":")
			s.LockRepositories.Encode(e)
		}
	}
	{
		if s.ExcludeAttachments.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExcludeAttachments.Set {
			e.RawStr("\"exclude_attachments\"" + ":")
			s.ExcludeAttachments.Encode(e)
		}
	}
	{
		if s.ExcludeReleases.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExcludeReleases.Set {
			e.RawStr("\"exclude_releases\"" + ":")
			s.ExcludeReleases.Encode(e)
		}
	}
	{
		if s.ExcludeOwnerProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExcludeOwnerProjects.Set {
			e.RawStr("\"exclude_owner_projects\"" + ":")
			s.ExcludeOwnerProjects.Encode(e)
		}
	}
	{
		if s.Exclude != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Exclude != nil {
			e.RawStr("\"exclude\"" + ":")
			e.ArrStart()
			if len(s.Exclude) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Exclude[0]
					elem.Encode(e)
				}
				for _, elem := range s.Exclude[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				e.Str(elem)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes MigrationsStartForAuthenticatedUserReq from json.
func (s *MigrationsStartForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsStartForAuthenticatedUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lock_repositories":
			s.LockRepositories.Reset()
			if err := s.LockRepositories.Decode(d); err != nil {
				return err
			}
		case "exclude_attachments":
			s.ExcludeAttachments.Reset()
			if err := s.ExcludeAttachments.Decode(d); err != nil {
				return err
			}
		case "exclude_releases":
			s.ExcludeReleases.Reset()
			if err := s.ExcludeReleases.Decode(d); err != nil {
				return err
			}
		case "exclude_owner_projects":
			s.ExcludeOwnerProjects.Reset()
			if err := s.ExcludeOwnerProjects.Decode(d); err != nil {
				return err
			}
		case "exclude":
			s.Exclude = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MigrationsStartForAuthenticatedUserReqExcludeItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Exclude = append(s.Exclude, elem)
				return nil
			}); err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MigrationsStartForAuthenticatedUserReqExcludeItem as json.
func (s MigrationsStartForAuthenticatedUserReqExcludeItem) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MigrationsStartForAuthenticatedUserReqExcludeItem from json.
func (s *MigrationsStartForAuthenticatedUserReqExcludeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsStartForAuthenticatedUserReqExcludeItem to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MigrationsStartForAuthenticatedUserReqExcludeItem(v) {
	case MigrationsStartForAuthenticatedUserReqExcludeItemRepositories:
		*s = MigrationsStartForAuthenticatedUserReqExcludeItemRepositories
	default:
		*s = MigrationsStartForAuthenticatedUserReqExcludeItem(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsStartForOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				e.Str(elem)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.LockRepositories.Set {
			e.Comma()
		}
		if s.LockRepositories.Set {
			e.RawStr("\"lock_repositories\"" + ":")
			s.LockRepositories.Encode(e)
		}
	}
	{
		if s.ExcludeAttachments.Set {
			e.Comma()
		}
		if s.ExcludeAttachments.Set {
			e.RawStr("\"exclude_attachments\"" + ":")
			s.ExcludeAttachments.Encode(e)
		}
	}
	{
		if s.ExcludeReleases.Set {
			e.Comma()
		}
		if s.ExcludeReleases.Set {
			e.RawStr("\"exclude_releases\"" + ":")
			s.ExcludeReleases.Encode(e)
		}
	}
	{
		if s.ExcludeOwnerProjects.Set {
			e.Comma()
		}
		if s.ExcludeOwnerProjects.Set {
			e.RawStr("\"exclude_owner_projects\"" + ":")
			s.ExcludeOwnerProjects.Encode(e)
		}
	}
	{
		if s.Exclude != nil {
			e.Comma()
		}
		if s.Exclude != nil {
			e.RawStr("\"exclude\"" + ":")
			e.ArrStart()
			if len(s.Exclude) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Exclude[0]
					elem.Encode(e)
				}
				for _, elem := range s.Exclude[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes MigrationsStartForOrgReq from json.
func (s *MigrationsStartForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsStartForOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "lock_repositories":
			s.LockRepositories.Reset()
			if err := s.LockRepositories.Decode(d); err != nil {
				return err
			}
		case "exclude_attachments":
			s.ExcludeAttachments.Reset()
			if err := s.ExcludeAttachments.Decode(d); err != nil {
				return err
			}
		case "exclude_releases":
			s.ExcludeReleases.Reset()
			if err := s.ExcludeReleases.Decode(d); err != nil {
				return err
			}
		case "exclude_owner_projects":
			s.ExcludeOwnerProjects.Reset()
			if err := s.ExcludeOwnerProjects.Decode(d); err != nil {
				return err
			}
		case "exclude":
			s.Exclude = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MigrationsStartForOrgReqExcludeItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Exclude = append(s.Exclude, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MigrationsStartForOrgReqExcludeItem as json.
func (s MigrationsStartForOrgReqExcludeItem) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MigrationsStartForOrgReqExcludeItem from json.
func (s *MigrationsStartForOrgReqExcludeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsStartForOrgReqExcludeItem to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MigrationsStartForOrgReqExcludeItem(v) {
	case MigrationsStartForOrgReqExcludeItemRepositories:
		*s = MigrationsStartForOrgReqExcludeItemRepositories
	default:
		*s = MigrationsStartForOrgReqExcludeItem(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsStartImportReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"vcs_url\"" + ":")
		e.Str(s.VcsURL)
	}
	{
		if s.Vcs.Set {
			e.Comma()
		}
		if s.Vcs.Set {
			e.RawStr("\"vcs\"" + ":")
			s.Vcs.Encode(e)
		}
	}
	{
		if s.VcsUsername.Set {
			e.Comma()
		}
		if s.VcsUsername.Set {
			e.RawStr("\"vcs_username\"" + ":")
			s.VcsUsername.Encode(e)
		}
	}
	{
		if s.VcsPassword.Set {
			e.Comma()
		}
		if s.VcsPassword.Set {
			e.RawStr("\"vcs_password\"" + ":")
			s.VcsPassword.Encode(e)
		}
	}
	{
		if s.TfvcProject.Set {
			e.Comma()
		}
		if s.TfvcProject.Set {
			e.RawStr("\"tfvc_project\"" + ":")
			s.TfvcProject.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes MigrationsStartImportReq from json.
func (s *MigrationsStartImportReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsStartImportReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs_url":
			v, err := d.Str()
			s.VcsURL = string(v)
			if err != nil {
				return err
			}
		case "vcs":
			s.Vcs.Reset()
			if err := s.Vcs.Decode(d); err != nil {
				return err
			}
		case "vcs_username":
			s.VcsUsername.Reset()
			if err := s.VcsUsername.Decode(d); err != nil {
				return err
			}
		case "vcs_password":
			s.VcsPassword.Reset()
			if err := s.VcsPassword.Decode(d); err != nil {
				return err
			}
		case "tfvc_project":
			s.TfvcProject.Reset()
			if err := s.TfvcProject.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MigrationsStartImportReqVcs as json.
func (s MigrationsStartImportReqVcs) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MigrationsStartImportReqVcs from json.
func (s *MigrationsStartImportReqVcs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsStartImportReqVcs to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MigrationsStartImportReqVcs(v) {
	case MigrationsStartImportReqVcsSubversion:
		*s = MigrationsStartImportReqVcsSubversion
	case MigrationsStartImportReqVcsGit:
		*s = MigrationsStartImportReqVcsGit
	case MigrationsStartImportReqVcsMercurial:
		*s = MigrationsStartImportReqVcsMercurial
	case MigrationsStartImportReqVcsTfvc:
		*s = MigrationsStartImportReqVcsTfvc
	default:
		*s = MigrationsStartImportReqVcs(v)
	}

	return nil
}

// Encode encodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound as json.
func (s MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound from json.
func (s *MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsUnlockRepoForAuthenticatedUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes MigrationsUnlockRepoForAuthenticatedUserNoContent from json.
func (s *MigrationsUnlockRepoForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsUnlockRepoForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MigrationsUnlockRepoForOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes MigrationsUnlockRepoForOrgNoContent from json.
func (s *MigrationsUnlockRepoForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsUnlockRepoForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MigrationsUpdateImportReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.VcsUsername.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VcsUsername.Set {
			e.RawStr("\"vcs_username\"" + ":")
			s.VcsUsername.Encode(e)
		}
	}
	{
		if s.VcsPassword.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VcsPassword.Set {
			e.RawStr("\"vcs_password\"" + ":")
			s.VcsPassword.Encode(e)
		}
	}
	{
		if s.Vcs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Vcs.Set {
			e.RawStr("\"vcs\"" + ":")
			s.Vcs.Encode(e)
		}
	}
	{
		if s.TfvcProject.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TfvcProject.Set {
			e.RawStr("\"tfvc_project\"" + ":")
			s.TfvcProject.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes MigrationsUpdateImportReq from json.
func (s *MigrationsUpdateImportReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsUpdateImportReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs_username":
			s.VcsUsername.Reset()
			if err := s.VcsUsername.Decode(d); err != nil {
				return err
			}
		case "vcs_password":
			s.VcsPassword.Reset()
			if err := s.VcsPassword.Decode(d); err != nil {
				return err
			}
		case "vcs":
			s.Vcs.Reset()
			if err := s.Vcs.Decode(d); err != nil {
				return err
			}
		case "tfvc_project":
			s.TfvcProject.Reset()
			if err := s.TfvcProject.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Milestone) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		json.EncodeURI(e, s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"closed_issues\"" + ":")
		e.Int(s.ClosedIssues)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"closed_at\"" + ":")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"due_on\"" + ":")
		s.DueOn.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes Milestone from json.
func (s *Milestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Milestone to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := json.DecodeURI(d)
			s.LabelsURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "creator":
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "closed_issues":
			v, err := d.Int()
			s.ClosedIssues = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "closed_at":
			if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "due_on":
			if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MilestoneState as json.
func (s MilestoneState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MilestoneState from json.
func (s *MilestoneState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MilestoneState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MilestoneState(v) {
	case MilestoneStateOpen:
		*s = MilestoneStateOpen
	case MilestoneStateClosed:
		*s = MilestoneStateClosed
	default:
		*s = MilestoneState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MinimalRepository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		if s.GitURL.Set {
			e.Comma()
		}
		if s.GitURL.Set {
			e.RawStr("\"git_url\"" + ":")
			s.GitURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		if s.SSHURL.Set {
			e.Comma()
		}
		if s.SSHURL.Set {
			e.RawStr("\"ssh_url\"" + ":")
			s.SSHURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		if s.CloneURL.Set {
			e.Comma()
		}
		if s.CloneURL.Set {
			e.RawStr("\"clone_url\"" + ":")
			s.CloneURL.Encode(e)
		}
	}
	{
		if s.MirrorURL.Set {
			e.Comma()
		}
		if s.MirrorURL.Set {
			e.RawStr("\"mirror_url\"" + ":")
			s.MirrorURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		if s.SvnURL.Set {
			e.Comma()
		}
		if s.SvnURL.Set {
			e.RawStr("\"svn_url\"" + ":")
			s.SvnURL.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			e.Comma()
		}
		if s.Homepage.Set {
			e.RawStr("\"homepage\"" + ":")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.Comma()
		}
		if s.Language.Set {
			e.RawStr("\"language\"" + ":")
			s.Language.Encode(e)
		}
	}
	{
		if s.ForksCount.Set {
			e.Comma()
		}
		if s.ForksCount.Set {
			e.RawStr("\"forks_count\"" + ":")
			s.ForksCount.Encode(e)
		}
	}
	{
		if s.StargazersCount.Set {
			e.Comma()
		}
		if s.StargazersCount.Set {
			e.RawStr("\"stargazers_count\"" + ":")
			s.StargazersCount.Encode(e)
		}
	}
	{
		if s.WatchersCount.Set {
			e.Comma()
		}
		if s.WatchersCount.Set {
			e.RawStr("\"watchers_count\"" + ":")
			s.WatchersCount.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.Comma()
		}
		if s.Size.Set {
			e.RawStr("\"size\"" + ":")
			s.Size.Encode(e)
		}
	}
	{
		if s.DefaultBranch.Set {
			e.Comma()
		}
		if s.DefaultBranch.Set {
			e.RawStr("\"default_branch\"" + ":")
			s.DefaultBranch.Encode(e)
		}
	}
	{
		if s.OpenIssuesCount.Set {
			e.Comma()
		}
		if s.OpenIssuesCount.Set {
			e.RawStr("\"open_issues_count\"" + ":")
			s.OpenIssuesCount.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.HasIssues.Set {
			e.Comma()
		}
		if s.HasIssues.Set {
			e.RawStr("\"has_issues\"" + ":")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			e.Comma()
		}
		if s.HasProjects.Set {
			e.RawStr("\"has_projects\"" + ":")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			e.Comma()
		}
		if s.HasWiki.Set {
			e.RawStr("\"has_wiki\"" + ":")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.HasPages.Set {
			e.Comma()
		}
		if s.HasPages.Set {
			e.RawStr("\"has_pages\"" + ":")
			s.HasPages.Encode(e)
		}
	}
	{
		if s.HasDownloads.Set {
			e.Comma()
		}
		if s.HasDownloads.Set {
			e.RawStr("\"has_downloads\"" + ":")
			s.HasDownloads.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			e.Comma()
		}
		if s.Archived.Set {
			e.RawStr("\"archived\"" + ":")
			s.Archived.Encode(e)
		}
	}
	{
		if s.Disabled.Set {
			e.Comma()
		}
		if s.Disabled.Set {
			e.RawStr("\"disabled\"" + ":")
			s.Disabled.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.PushedAt.Set {
			e.Comma()
		}
		if s.PushedAt.Set {
			e.RawStr("\"pushed_at\"" + ":")
			s.PushedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedAt.Set {
			e.Comma()
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.Comma()
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.Comma()
		}
		if s.TemplateRepository.Set {
			e.RawStr("\"template_repository\"" + ":")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.Comma()
		}
		if s.SubscribersCount.Set {
			e.RawStr("\"subscribers_count\"" + ":")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.Comma()
		}
		if s.NetworkCount.Set {
			e.RawStr("\"network_count\"" + ":")
			s.NetworkCount.Encode(e)
		}
	}
	{
		if s.CodeOfConduct.Set {
			e.Comma()
		}
		if s.CodeOfConduct.Set {
			e.RawStr("\"code_of_conduct\"" + ":")
			s.CodeOfConduct.Encode(e)
		}
	}
	{
		if s.License.Set {
			e.Comma()
		}
		if s.License.Set {
			e.RawStr("\"license\"" + ":")
			s.License.Encode(e)
		}
	}
	{
		if s.Forks.Set {
			e.Comma()
		}
		if s.Forks.Set {
			e.RawStr("\"forks\"" + ":")
			s.Forks.Encode(e)
		}
	}
	{
		if s.OpenIssues.Set {
			e.Comma()
		}
		if s.OpenIssues.Set {
			e.RawStr("\"open_issues\"" + ":")
			s.OpenIssues.Encode(e)
		}
	}
	{
		if s.Watchers.Set {
			e.Comma()
		}
		if s.Watchers.Set {
			e.RawStr("\"watchers\"" + ":")
			s.Watchers.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes MinimalRepository from json.
func (s *MinimalRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MinimalRepository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "git_url":
			s.GitURL.Reset()
			if err := s.GitURL.Decode(d); err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			s.SSHURL.Reset()
			if err := s.SSHURL.Decode(d); err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "clone_url":
			s.CloneURL.Reset()
			if err := s.CloneURL.Decode(d); err != nil {
				return err
			}
		case "mirror_url":
			s.MirrorURL.Reset()
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "svn_url":
			s.SvnURL.Reset()
			if err := s.SvnURL.Decode(d); err != nil {
				return err
			}
		case "homepage":
			s.Homepage.Reset()
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			s.Language.Reset()
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			s.ForksCount.Reset()
			if err := s.ForksCount.Decode(d); err != nil {
				return err
			}
		case "stargazers_count":
			s.StargazersCount.Reset()
			if err := s.StargazersCount.Decode(d); err != nil {
				return err
			}
		case "watchers_count":
			s.WatchersCount.Reset()
			if err := s.WatchersCount.Decode(d); err != nil {
				return err
			}
		case "size":
			s.Size.Reset()
			if err := s.Size.Decode(d); err != nil {
				return err
			}
		case "default_branch":
			s.DefaultBranch.Reset()
			if err := s.DefaultBranch.Decode(d); err != nil {
				return err
			}
		case "open_issues_count":
			s.OpenIssuesCount.Reset()
			if err := s.OpenIssuesCount.Decode(d); err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			s.HasIssues.Reset()
			if err := s.HasIssues.Decode(d); err != nil {
				return err
			}
		case "has_projects":
			s.HasProjects.Reset()
			if err := s.HasProjects.Decode(d); err != nil {
				return err
			}
		case "has_wiki":
			s.HasWiki.Reset()
			if err := s.HasWiki.Decode(d); err != nil {
				return err
			}
		case "has_pages":
			s.HasPages.Reset()
			if err := s.HasPages.Decode(d); err != nil {
				return err
			}
		case "has_downloads":
			s.HasDownloads.Reset()
			if err := s.HasDownloads.Decode(d); err != nil {
				return err
			}
		case "archived":
			s.Archived.Reset()
			if err := s.Archived.Decode(d); err != nil {
				return err
			}
		case "disabled":
			s.Disabled.Reset()
			if err := s.Disabled.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			s.PushedAt.Reset()
			if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "template_repository":
			s.TemplateRepository.Reset()
			if err := s.TemplateRepository.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			s.SubscribersCount.Reset()
			if err := s.SubscribersCount.Decode(d); err != nil {
				return err
			}
		case "network_count":
			s.NetworkCount.Reset()
			if err := s.NetworkCount.Decode(d); err != nil {
				return err
			}
		case "code_of_conduct":
			s.CodeOfConduct.Reset()
			if err := s.CodeOfConduct.Decode(d); err != nil {
				return err
			}
		case "license":
			s.License.Reset()
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "forks":
			s.Forks.Reset()
			if err := s.Forks.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			s.OpenIssues.Reset()
			if err := s.OpenIssues.Decode(d); err != nil {
				return err
			}
		case "watchers":
			s.Watchers.Reset()
			if err := s.Watchers.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MinimalRepositoryLicense) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Key.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Key.Set {
			e.RawStr("\"key\"" + ":")
			s.Key.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.SpdxID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SpdxID.Set {
			e.RawStr("\"spdx_id\"" + ":")
			s.SpdxID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes MinimalRepositoryLicense from json.
func (s *MinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MinimalRepositoryLicense to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			s.Key.Reset()
			if err := s.Key.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "spdx_id":
			s.SpdxID.Reset()
			if err := s.SpdxID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MinimalRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Admin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Admin.Set {
			e.RawStr("\"admin\"" + ":")
			s.Admin.Encode(e)
		}
	}
	{
		if s.Maintain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		if s.Push.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Push.Set {
			e.RawStr("\"push\"" + ":")
			s.Push.Encode(e)
		}
	}
	{
		if s.Triage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		if s.Pull.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pull.Set {
			e.RawStr("\"pull\"" + ":")
			s.Pull.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes MinimalRepositoryPermissions from json.
func (s *MinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MinimalRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			s.Admin.Reset()
			if err := s.Admin.Decode(d); err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			s.Push.Reset()
			if err := s.Push.Decode(d); err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			s.Pull.Reset()
			if err := s.Pull.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AutoMerge as json.
func (o NilAutoMerge) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AutoMerge from json.
func (o *NilAutoMerge) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilAutoMerge to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v AutoMerge
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilAutoMerge`, d.Next())
	}
}

// Encode encodes bool as json.
func (o NilBool) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *NilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilBool to nil`)
	}
	switch d.Next() {
	case jx.Bool:
		o.Null = false
		v, err := d.Bool()
		if err != nil {
			return err
		}
		o.Value = bool(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v bool
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilBool`, d.Next())
	}
}

// Encode encodes CheckRunCheckSuite as json.
func (o NilCheckRunCheckSuite) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CheckRunCheckSuite from json.
func (o *NilCheckRunCheckSuite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilCheckRunCheckSuite to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CheckRunCheckSuite
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilCheckRunCheckSuite`, d.Next())
	}
}

// Encode encodes CheckRunConclusion as json.
func (o NilCheckRunConclusion) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CheckRunConclusion from json.
func (o *NilCheckRunConclusion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilCheckRunConclusion to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CheckRunConclusion
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilCheckRunConclusion`, d.Next())
	}
}

// Encode encodes CheckSuiteConclusion as json.
func (o NilCheckSuiteConclusion) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CheckSuiteConclusion from json.
func (o *NilCheckSuiteConclusion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilCheckSuiteConclusion to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CheckSuiteConclusion
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilCheckSuiteConclusion`, d.Next())
	}
}

// Encode encodes CheckSuiteStatus as json.
func (o NilCheckSuiteStatus) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CheckSuiteStatus from json.
func (o *NilCheckSuiteStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilCheckSuiteStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CheckSuiteStatus
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilCheckSuiteStatus`, d.Next())
	}
}

// Encode encodes CodeScanningAlertDismissedAt as json.
func (o NilCodeScanningAlertDismissedAt) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes CodeScanningAlertDismissedAt from json.
func (o *NilCodeScanningAlertDismissedAt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilCodeScanningAlertDismissedAt to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertDismissedAt
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilCodeScanningAlertDismissedAt`, d.Next())
	}
}

// Encode encodes CodeScanningAlertDismissedReason as json.
func (o NilCodeScanningAlertDismissedReason) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertDismissedReason from json.
func (o *NilCodeScanningAlertDismissedReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilCodeScanningAlertDismissedReason to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertDismissedReason
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilCodeScanningAlertDismissedReason`, d.Next())
	}
}

// Encode encodes FileCommitContent as json.
func (o NilFileCommitContent) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileCommitContent from json.
func (o *NilFileCommitContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilFileCommitContent to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v FileCommitContent
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilFileCommitContent`, d.Next())
	}
}

// Encode encodes int as json.
func (o NilInt) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *NilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilInt to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Null = false
		v, err := d.Int()
		if err != nil {
			return err
		}
		o.Value = int(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v int
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilInt`, d.Next())
	}
}

// Encode encodes NullableCodeOfConductSimple as json.
func (o NilNullableCodeOfConductSimple) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableCodeOfConductSimple from json.
func (o *NilNullableCodeOfConductSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableCodeOfConductSimple to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableCodeOfConductSimple
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableCodeOfConductSimple`, d.Next())
	}
}

// Encode encodes NullableCommunityHealthFile as json.
func (o NilNullableCommunityHealthFile) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableCommunityHealthFile from json.
func (o *NilNullableCommunityHealthFile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableCommunityHealthFile to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableCommunityHealthFile
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableCommunityHealthFile`, d.Next())
	}
}

// Encode encodes NullableGitUser as json.
func (o NilNullableGitUser) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableGitUser from json.
func (o *NilNullableGitUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableGitUser to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableGitUser
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableGitUser`, d.Next())
	}
}

// Encode encodes NullableIntegration as json.
func (o NilNullableIntegration) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableIntegration from json.
func (o *NilNullableIntegration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableIntegration to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableIntegration
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableIntegration`, d.Next())
	}
}

// Encode encodes NullableLicenseSimple as json.
func (o NilNullableLicenseSimple) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableLicenseSimple from json.
func (o *NilNullableLicenseSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableLicenseSimple to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableLicenseSimple
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableLicenseSimple`, d.Next())
	}
}

// Encode encodes NullableMilestone as json.
func (o NilNullableMilestone) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableMilestone from json.
func (o *NilNullableMilestone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableMilestone to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableMilestone
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableMilestone`, d.Next())
	}
}

// Encode encodes NullableSimpleCommit as json.
func (o NilNullableSimpleCommit) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleCommit from json.
func (o *NilNullableSimpleCommit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableSimpleCommit to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableSimpleCommit
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableSimpleCommit`, d.Next())
	}
}

// Encode encodes NullableSimpleCommitAuthor as json.
func (o NilNullableSimpleCommitAuthor) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleCommitAuthor from json.
func (o *NilNullableSimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableSimpleCommitAuthor to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableSimpleCommitAuthor
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableSimpleCommitAuthor`, d.Next())
	}
}

// Encode encodes NullableSimpleCommitCommitter as json.
func (o NilNullableSimpleCommitCommitter) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleCommitCommitter from json.
func (o *NilNullableSimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableSimpleCommitCommitter to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableSimpleCommitCommitter
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableSimpleCommitCommitter`, d.Next())
	}
}

// Encode encodes NullableSimpleUser as json.
func (o NilNullableSimpleUser) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleUser from json.
func (o *NilNullableSimpleUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableSimpleUser to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableSimpleUser
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableSimpleUser`, d.Next())
	}
}

// Encode encodes NullableTeamSimple as json.
func (o NilNullableTeamSimple) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableTeamSimple from json.
func (o *NilNullableTeamSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableTeamSimple to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableTeamSimple
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableTeamSimple`, d.Next())
	}
}

// Encode encodes PageStatus as json.
func (o NilPageStatus) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PageStatus from json.
func (o *NilPageStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilPageStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PageStatus
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilPageStatus`, d.Next())
	}
}

// Encode encodes PullRequestHeadRepo as json.
func (o NilPullRequestHeadRepo) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullRequestHeadRepo from json.
func (o *NilPullRequestHeadRepo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilPullRequestHeadRepo to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PullRequestHeadRepo
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilPullRequestHeadRepo`, d.Next())
	}
}

// Encode encodes PullRequestHeadRepoLicense as json.
func (o NilPullRequestHeadRepoLicense) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullRequestHeadRepoLicense from json.
func (o *NilPullRequestHeadRepoLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilPullRequestHeadRepoLicense to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PullRequestHeadRepoLicense
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilPullRequestHeadRepoLicense`, d.Next())
	}
}

// Encode encodes ReposUpdateBranchProtectionReqRequiredPullRequestReviews as json.
func (o NilReposUpdateBranchProtectionReqRequiredPullRequestReviews) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviews from json.
func (o *NilReposUpdateBranchProtectionReqRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilReposUpdateBranchProtectionReqRequiredPullRequestReviews to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v ReposUpdateBranchProtectionReqRequiredPullRequestReviews
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilReposUpdateBranchProtectionReqRequiredPullRequestReviews`, d.Next())
	}
}

// Encode encodes ReposUpdateBranchProtectionReqRequiredStatusChecks as json.
func (o NilReposUpdateBranchProtectionReqRequiredStatusChecks) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredStatusChecks from json.
func (o *NilReposUpdateBranchProtectionReqRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilReposUpdateBranchProtectionReqRequiredStatusChecks to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v ReposUpdateBranchProtectionReqRequiredStatusChecks
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilReposUpdateBranchProtectionReqRequiredStatusChecks`, d.Next())
	}
}

// Encode encodes ReposUpdateBranchProtectionReqRestrictions as json.
func (o NilReposUpdateBranchProtectionReqRestrictions) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRestrictions from json.
func (o *NilReposUpdateBranchProtectionReqRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilReposUpdateBranchProtectionReqRestrictions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v ReposUpdateBranchProtectionReqRestrictions
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilReposUpdateBranchProtectionReqRestrictions`, d.Next())
	}
}

// Encode encodes SimpleCommitAuthor as json.
func (o NilSimpleCommitAuthor) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SimpleCommitAuthor from json.
func (o *NilSimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilSimpleCommitAuthor to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v SimpleCommitAuthor
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilSimpleCommitAuthor`, d.Next())
	}
}

// Encode encodes SimpleCommitCommitter as json.
func (o NilSimpleCommitCommitter) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SimpleCommitCommitter from json.
func (o *NilSimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilSimpleCommitCommitter to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v SimpleCommitCommitter
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilSimpleCommitCommitter`, d.Next())
	}
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilString to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v string
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilString`, d.Next())
	}
}

// Encode encodes time.Time as json.
func (o NilTime) Encode(e *jx.Writer, format func(*jx.Writer, time.Time)) {
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *NilTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilTime to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		v, err := format(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v time.Time
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilTime`, d.Next())
	}
}

// Encode encodes url.URL as json.
func (o NilURL) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *NilURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilURL to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		v, err := json.DecodeURI(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v url.URL
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilURL`, d.Next())
	}
}

// Encode implements json.Marshaler.
func (s NoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes NoContent from json.
func (s *NoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NotModified) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes NotModified from json.
func (s *NotModified) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NotModified to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableCodeOfConductSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableCodeOfConductSimple from json.
func (s *NullableCodeOfConductSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableCodeOfConductSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableCommunityHealthFile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	e.ObjEnd()
}

// Decode decodes NullableCommunityHealthFile from json.
func (s *NullableCommunityHealthFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableCommunityHealthFile to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableGitUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Date.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes NullableGitUser from json.
func (s *NullableGitUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableGitUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableIntegration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		if s.Slug.Set {
			e.Comma()
		}
		if s.Slug.Set {
			e.RawStr("\"slug\"" + ":")
			s.Slug.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"external_url\"" + ":")
		json.EncodeURI(e, s.ExternalURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"permissions\"" + ":")
		s.Permissions.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"events\"" + ":")
		e.ArrStart()
		if len(s.Events) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Events[0]
				e.Str(elem)
			}
			for _, elem := range s.Events[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.InstallationsCount.Set {
			e.Comma()
		}
		if s.InstallationsCount.Set {
			e.RawStr("\"installations_count\"" + ":")
			s.InstallationsCount.Encode(e)
		}
	}
	{
		if s.ClientID.Set {
			e.Comma()
		}
		if s.ClientID.Set {
			e.RawStr("\"client_id\"" + ":")
			s.ClientID.Encode(e)
		}
	}
	{
		if s.ClientSecret.Set {
			e.Comma()
		}
		if s.ClientSecret.Set {
			e.RawStr("\"client_secret\"" + ":")
			s.ClientSecret.Encode(e)
		}
	}
	{
		if s.WebhookSecret.Set {
			e.Comma()
		}
		if s.WebhookSecret.Set {
			e.RawStr("\"webhook_secret\"" + ":")
			s.WebhookSecret.Encode(e)
		}
	}
	{
		if s.Pem.Set {
			e.Comma()
		}
		if s.Pem.Set {
			e.RawStr("\"pem\"" + ":")
			s.Pem.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes NullableIntegration from json.
func (s *NullableIntegration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableIntegration to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "slug":
			s.Slug.Reset()
			if err := s.Slug.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "external_url":
			v, err := json.DecodeURI(d)
			s.ExternalURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "permissions":
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "installations_count":
			s.InstallationsCount.Reset()
			if err := s.InstallationsCount.Decode(d); err != nil {
				return err
			}
		case "client_id":
			s.ClientID.Reset()
			if err := s.ClientID.Decode(d); err != nil {
				return err
			}
		case "client_secret":
			s.ClientSecret.Reset()
			if err := s.ClientSecret.Decode(d); err != nil {
				return err
			}
		case "webhook_secret":
			s.WebhookSecret.Reset()
			if err := s.WebhookSecret.Decode(d); err != nil {
				return err
			}
		case "pem":
			s.Pem.Reset()
			if err := s.Pem.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableIntegrationPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Issues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Issues.Set {
			e.RawStr("\"issues\"" + ":")
			s.Issues.Encode(e)
		}
	}
	{
		if s.Checks.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Checks.Set {
			e.RawStr("\"checks\"" + ":")
			s.Checks.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Contents.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Contents.Set {
			e.RawStr("\"contents\"" + ":")
			s.Contents.Encode(e)
		}
	}
	{
		if s.Deployments.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Deployments.Set {
			e.RawStr("\"deployments\"" + ":")
			s.Deployments.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes NullableIntegrationPermissions from json.
func (s *NullableIntegrationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableIntegrationPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "issues":
			s.Issues.Reset()
			if err := s.Issues.Decode(d); err != nil {
				return err
			}
		case "checks":
			s.Checks.Reset()
			if err := s.Checks.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "contents":
			s.Contents.Reset()
			if err := s.Contents.Decode(d); err != nil {
				return err
			}
		case "deployments":
			s.Deployments.Reset()
			if err := s.Deployments.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableLicenseSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"spdx_id\"" + ":")
		s.SpdxID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		if s.HTMLURL.Set {
			e.Comma()
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes NullableLicenseSimple from json.
func (s *NullableLicenseSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableLicenseSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "spdx_id":
			if err := s.SpdxID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableMilestone) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		json.EncodeURI(e, s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"closed_issues\"" + ":")
		e.Int(s.ClosedIssues)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"closed_at\"" + ":")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"due_on\"" + ":")
		s.DueOn.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes NullableMilestone from json.
func (s *NullableMilestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableMilestone to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := json.DecodeURI(d)
			s.LabelsURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "creator":
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "closed_issues":
			v, err := d.Int()
			s.ClosedIssues = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "closed_at":
			if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "due_on":
			if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes NullableMilestoneState as json.
func (s NullableMilestoneState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes NullableMilestoneState from json.
func (s *NullableMilestoneState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableMilestoneState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NullableMilestoneState(v) {
	case NullableMilestoneStateOpen:
		*s = NullableMilestoneStateOpen
	case NullableMilestoneStateClosed:
		*s = NullableMilestoneStateClosed
	default:
		*s = NullableMilestoneState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableMinimalRepository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		if s.GitURL.Set {
			e.Comma()
		}
		if s.GitURL.Set {
			e.RawStr("\"git_url\"" + ":")
			s.GitURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		if s.SSHURL.Set {
			e.Comma()
		}
		if s.SSHURL.Set {
			e.RawStr("\"ssh_url\"" + ":")
			s.SSHURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		if s.CloneURL.Set {
			e.Comma()
		}
		if s.CloneURL.Set {
			e.RawStr("\"clone_url\"" + ":")
			s.CloneURL.Encode(e)
		}
	}
	{
		if s.MirrorURL.Set {
			e.Comma()
		}
		if s.MirrorURL.Set {
			e.RawStr("\"mirror_url\"" + ":")
			s.MirrorURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		if s.SvnURL.Set {
			e.Comma()
		}
		if s.SvnURL.Set {
			e.RawStr("\"svn_url\"" + ":")
			s.SvnURL.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			e.Comma()
		}
		if s.Homepage.Set {
			e.RawStr("\"homepage\"" + ":")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.Comma()
		}
		if s.Language.Set {
			e.RawStr("\"language\"" + ":")
			s.Language.Encode(e)
		}
	}
	{
		if s.ForksCount.Set {
			e.Comma()
		}
		if s.ForksCount.Set {
			e.RawStr("\"forks_count\"" + ":")
			s.ForksCount.Encode(e)
		}
	}
	{
		if s.StargazersCount.Set {
			e.Comma()
		}
		if s.StargazersCount.Set {
			e.RawStr("\"stargazers_count\"" + ":")
			s.StargazersCount.Encode(e)
		}
	}
	{
		if s.WatchersCount.Set {
			e.Comma()
		}
		if s.WatchersCount.Set {
			e.RawStr("\"watchers_count\"" + ":")
			s.WatchersCount.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.Comma()
		}
		if s.Size.Set {
			e.RawStr("\"size\"" + ":")
			s.Size.Encode(e)
		}
	}
	{
		if s.DefaultBranch.Set {
			e.Comma()
		}
		if s.DefaultBranch.Set {
			e.RawStr("\"default_branch\"" + ":")
			s.DefaultBranch.Encode(e)
		}
	}
	{
		if s.OpenIssuesCount.Set {
			e.Comma()
		}
		if s.OpenIssuesCount.Set {
			e.RawStr("\"open_issues_count\"" + ":")
			s.OpenIssuesCount.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.HasIssues.Set {
			e.Comma()
		}
		if s.HasIssues.Set {
			e.RawStr("\"has_issues\"" + ":")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			e.Comma()
		}
		if s.HasProjects.Set {
			e.RawStr("\"has_projects\"" + ":")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			e.Comma()
		}
		if s.HasWiki.Set {
			e.RawStr("\"has_wiki\"" + ":")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.HasPages.Set {
			e.Comma()
		}
		if s.HasPages.Set {
			e.RawStr("\"has_pages\"" + ":")
			s.HasPages.Encode(e)
		}
	}
	{
		if s.HasDownloads.Set {
			e.Comma()
		}
		if s.HasDownloads.Set {
			e.RawStr("\"has_downloads\"" + ":")
			s.HasDownloads.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			e.Comma()
		}
		if s.Archived.Set {
			e.RawStr("\"archived\"" + ":")
			s.Archived.Encode(e)
		}
	}
	{
		if s.Disabled.Set {
			e.Comma()
		}
		if s.Disabled.Set {
			e.RawStr("\"disabled\"" + ":")
			s.Disabled.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.PushedAt.Set {
			e.Comma()
		}
		if s.PushedAt.Set {
			e.RawStr("\"pushed_at\"" + ":")
			s.PushedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedAt.Set {
			e.Comma()
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.Comma()
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.Comma()
		}
		if s.TemplateRepository.Set {
			e.RawStr("\"template_repository\"" + ":")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.Comma()
		}
		if s.SubscribersCount.Set {
			e.RawStr("\"subscribers_count\"" + ":")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.Comma()
		}
		if s.NetworkCount.Set {
			e.RawStr("\"network_count\"" + ":")
			s.NetworkCount.Encode(e)
		}
	}
	{
		if s.CodeOfConduct.Set {
			e.Comma()
		}
		if s.CodeOfConduct.Set {
			e.RawStr("\"code_of_conduct\"" + ":")
			s.CodeOfConduct.Encode(e)
		}
	}
	{
		if s.License.Set {
			e.Comma()
		}
		if s.License.Set {
			e.RawStr("\"license\"" + ":")
			s.License.Encode(e)
		}
	}
	{
		if s.Forks.Set {
			e.Comma()
		}
		if s.Forks.Set {
			e.RawStr("\"forks\"" + ":")
			s.Forks.Encode(e)
		}
	}
	{
		if s.OpenIssues.Set {
			e.Comma()
		}
		if s.OpenIssues.Set {
			e.RawStr("\"open_issues\"" + ":")
			s.OpenIssues.Encode(e)
		}
	}
	{
		if s.Watchers.Set {
			e.Comma()
		}
		if s.Watchers.Set {
			e.RawStr("\"watchers\"" + ":")
			s.Watchers.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes NullableMinimalRepository from json.
func (s *NullableMinimalRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableMinimalRepository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "git_url":
			s.GitURL.Reset()
			if err := s.GitURL.Decode(d); err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			s.SSHURL.Reset()
			if err := s.SSHURL.Decode(d); err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "clone_url":
			s.CloneURL.Reset()
			if err := s.CloneURL.Decode(d); err != nil {
				return err
			}
		case "mirror_url":
			s.MirrorURL.Reset()
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "svn_url":
			s.SvnURL.Reset()
			if err := s.SvnURL.Decode(d); err != nil {
				return err
			}
		case "homepage":
			s.Homepage.Reset()
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			s.Language.Reset()
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			s.ForksCount.Reset()
			if err := s.ForksCount.Decode(d); err != nil {
				return err
			}
		case "stargazers_count":
			s.StargazersCount.Reset()
			if err := s.StargazersCount.Decode(d); err != nil {
				return err
			}
		case "watchers_count":
			s.WatchersCount.Reset()
			if err := s.WatchersCount.Decode(d); err != nil {
				return err
			}
		case "size":
			s.Size.Reset()
			if err := s.Size.Decode(d); err != nil {
				return err
			}
		case "default_branch":
			s.DefaultBranch.Reset()
			if err := s.DefaultBranch.Decode(d); err != nil {
				return err
			}
		case "open_issues_count":
			s.OpenIssuesCount.Reset()
			if err := s.OpenIssuesCount.Decode(d); err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			s.HasIssues.Reset()
			if err := s.HasIssues.Decode(d); err != nil {
				return err
			}
		case "has_projects":
			s.HasProjects.Reset()
			if err := s.HasProjects.Decode(d); err != nil {
				return err
			}
		case "has_wiki":
			s.HasWiki.Reset()
			if err := s.HasWiki.Decode(d); err != nil {
				return err
			}
		case "has_pages":
			s.HasPages.Reset()
			if err := s.HasPages.Decode(d); err != nil {
				return err
			}
		case "has_downloads":
			s.HasDownloads.Reset()
			if err := s.HasDownloads.Decode(d); err != nil {
				return err
			}
		case "archived":
			s.Archived.Reset()
			if err := s.Archived.Decode(d); err != nil {
				return err
			}
		case "disabled":
			s.Disabled.Reset()
			if err := s.Disabled.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			s.PushedAt.Reset()
			if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "template_repository":
			s.TemplateRepository.Reset()
			if err := s.TemplateRepository.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			s.SubscribersCount.Reset()
			if err := s.SubscribersCount.Decode(d); err != nil {
				return err
			}
		case "network_count":
			s.NetworkCount.Reset()
			if err := s.NetworkCount.Decode(d); err != nil {
				return err
			}
		case "code_of_conduct":
			s.CodeOfConduct.Reset()
			if err := s.CodeOfConduct.Decode(d); err != nil {
				return err
			}
		case "license":
			s.License.Reset()
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "forks":
			s.Forks.Reset()
			if err := s.Forks.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			s.OpenIssues.Reset()
			if err := s.OpenIssues.Decode(d); err != nil {
				return err
			}
		case "watchers":
			s.Watchers.Reset()
			if err := s.Watchers.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableMinimalRepositoryLicense) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Key.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Key.Set {
			e.RawStr("\"key\"" + ":")
			s.Key.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.SpdxID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SpdxID.Set {
			e.RawStr("\"spdx_id\"" + ":")
			s.SpdxID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes NullableMinimalRepositoryLicense from json.
func (s *NullableMinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableMinimalRepositoryLicense to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			s.Key.Reset()
			if err := s.Key.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "spdx_id":
			s.SpdxID.Reset()
			if err := s.SpdxID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableMinimalRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Admin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Admin.Set {
			e.RawStr("\"admin\"" + ":")
			s.Admin.Encode(e)
		}
	}
	{
		if s.Maintain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		if s.Push.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Push.Set {
			e.RawStr("\"push\"" + ":")
			s.Push.Encode(e)
		}
	}
	{
		if s.Triage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		if s.Pull.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pull.Set {
			e.RawStr("\"pull\"" + ":")
			s.Pull.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes NullableMinimalRepositoryPermissions from json.
func (s *NullableMinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableMinimalRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			s.Admin.Reset()
			if err := s.Admin.Decode(d); err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			s.Push.Reset()
			if err := s.Push.Decode(d); err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			s.Pull.Reset()
			if err := s.Pull.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableRepository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		if s.Organization.Set {
			e.Comma()
		}
		if s.Organization.Set {
			e.RawStr("\"organization\"" + ":")
			s.Organization.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"forks\"" + ":")
		e.Int(s.Forks)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		e.Str(s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		e.Comma()

		e.RawStr("\"ssh_url\"" + ":")
		e.Str(s.SSHURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		e.Comma()

		e.RawStr("\"clone_url\"" + ":")
		e.Str(s.CloneURL)
	}
	{
		e.Comma()

		e.RawStr("\"mirror_url\"" + ":")
		s.MirrorURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"svn_url\"" + ":")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		e.Comma()

		e.RawStr("\"homepage\"" + ":")
		s.Homepage.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"language\"" + ":")
		s.Language.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"forks_count\"" + ":")
		e.Int(s.ForksCount)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_count\"" + ":")
		e.Int(s.StargazersCount)
	}
	{
		e.Comma()

		e.RawStr("\"watchers_count\"" + ":")
		e.Int(s.WatchersCount)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"default_branch\"" + ":")
		e.Str(s.DefaultBranch)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues_count\"" + ":")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"has_issues\"" + ":")
		e.Bool(s.HasIssues)
	}
	{
		e.Comma()

		e.RawStr("\"has_projects\"" + ":")
		e.Bool(s.HasProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_wiki\"" + ":")
		e.Bool(s.HasWiki)
	}
	{
		e.Comma()

		e.RawStr("\"has_pages\"" + ":")
		e.Bool(s.HasPages)
	}
	{
		e.Comma()

		e.RawStr("\"has_downloads\"" + ":")
		e.Bool(s.HasDownloads)
	}
	{
		e.Comma()

		e.RawStr("\"archived\"" + ":")
		e.Bool(s.Archived)
	}
	{
		e.Comma()

		e.RawStr("\"disabled\"" + ":")
		e.Bool(s.Disabled)
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pushed_at\"" + ":")
		s.PushedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.Comma()
		}
		if s.TemplateRepository.Set {
			e.RawStr("\"template_repository\"" + ":")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.Comma()
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.Comma()
		}
		if s.SubscribersCount.Set {
			e.RawStr("\"subscribers_count\"" + ":")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.Comma()
		}
		if s.NetworkCount.Set {
			e.RawStr("\"network_count\"" + ":")
			s.NetworkCount.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"watchers\"" + ":")
		e.Int(s.Watchers)
	}
	{
		if s.MasterBranch.Set {
			e.Comma()
		}
		if s.MasterBranch.Set {
			e.RawStr("\"master_branch\"" + ":")
			s.MasterBranch.Encode(e)
		}
	}
	{
		if s.StarredAt.Set {
			e.Comma()
		}
		if s.StarredAt.Set {
			e.RawStr("\"starred_at\"" + ":")
			s.StarredAt.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes NullableRepository from json.
func (s *NullableRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableRepository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "organization":
			s.Organization.Reset()
			if err := s.Organization.Decode(d); err != nil {
				return err
			}
		case "forks":
			v, err := d.Int()
			s.Forks = int(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "git_url":
			v, err := d.Str()
			s.GitURL = string(v)
			if err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			v, err := d.Str()
			s.SSHURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "clone_url":
			v, err := d.Str()
			s.CloneURL = string(v)
			if err != nil {
				return err
			}
		case "mirror_url":
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "svn_url":
			v, err := json.DecodeURI(d)
			s.SvnURL = v
			if err != nil {
				return err
			}
		case "homepage":
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			v, err := d.Int()
			s.ForksCount = int(v)
			if err != nil {
				return err
			}
		case "stargazers_count":
			v, err := d.Int()
			s.StargazersCount = int(v)
			if err != nil {
				return err
			}
		case "watchers_count":
			v, err := d.Int()
			s.WatchersCount = int(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "default_branch":
			v, err := d.Str()
			s.DefaultBranch = string(v)
			if err != nil {
				return err
			}
		case "open_issues_count":
			v, err := d.Int()
			s.OpenIssuesCount = int(v)
			if err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			v, err := d.Bool()
			s.HasIssues = bool(v)
			if err != nil {
				return err
			}
		case "has_projects":
			v, err := d.Bool()
			s.HasProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_wiki":
			v, err := d.Bool()
			s.HasWiki = bool(v)
			if err != nil {
				return err
			}
		case "has_pages":
			v, err := d.Bool()
			s.HasPages = bool(v)
			if err != nil {
				return err
			}
		case "has_downloads":
			v, err := d.Bool()
			s.HasDownloads = bool(v)
			if err != nil {
				return err
			}
		case "archived":
			v, err := d.Bool()
			s.Archived = bool(v)
			if err != nil {
				return err
			}
		case "disabled":
			v, err := d.Bool()
			s.Disabled = bool(v)
			if err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "created_at":
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "template_repository":
			s.TemplateRepository.Reset()
			if err := s.TemplateRepository.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			s.SubscribersCount.Reset()
			if err := s.SubscribersCount.Decode(d); err != nil {
				return err
			}
		case "network_count":
			s.NetworkCount.Reset()
			if err := s.NetworkCount.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "watchers":
			v, err := d.Int()
			s.Watchers = int(v)
			if err != nil {
				return err
			}
		case "master_branch":
			s.MasterBranch.Reset()
			if err := s.MasterBranch.Decode(d); err != nil {
				return err
			}
		case "starred_at":
			s.StarredAt.Reset()
			if err := s.StarredAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	{
		e.Comma()

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes NullableRepositoryPermissions from json.
func (s *NullableRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableRepositoryTemplateRepository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.FullName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FullName.Set {
			e.RawStr("\"full_name\"" + ":")
			s.FullName.Encode(e)
		}
	}
	{
		if s.Owner.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Private.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Fork.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fork.Set {
			e.RawStr("\"fork\"" + ":")
			s.Fork.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ArchiveURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ArchiveURL.Set {
			e.RawStr("\"archive_url\"" + ":")
			s.ArchiveURL.Encode(e)
		}
	}
	{
		if s.AssigneesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AssigneesURL.Set {
			e.RawStr("\"assignees_url\"" + ":")
			s.AssigneesURL.Encode(e)
		}
	}
	{
		if s.BlobsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BlobsURL.Set {
			e.RawStr("\"blobs_url\"" + ":")
			s.BlobsURL.Encode(e)
		}
	}
	{
		if s.BranchesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BranchesURL.Set {
			e.RawStr("\"branches_url\"" + ":")
			s.BranchesURL.Encode(e)
		}
	}
	{
		if s.CollaboratorsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CollaboratorsURL.Set {
			e.RawStr("\"collaborators_url\"" + ":")
			s.CollaboratorsURL.Encode(e)
		}
	}
	{
		if s.CommentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommentsURL.Set {
			e.RawStr("\"comments_url\"" + ":")
			s.CommentsURL.Encode(e)
		}
	}
	{
		if s.CommitsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommitsURL.Set {
			e.RawStr("\"commits_url\"" + ":")
			s.CommitsURL.Encode(e)
		}
	}
	{
		if s.CompareURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CompareURL.Set {
			e.RawStr("\"compare_url\"" + ":")
			s.CompareURL.Encode(e)
		}
	}
	{
		if s.ContentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentsURL.Set {
			e.RawStr("\"contents_url\"" + ":")
			s.ContentsURL.Encode(e)
		}
	}
	{
		if s.ContributorsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContributorsURL.Set {
			e.RawStr("\"contributors_url\"" + ":")
			s.ContributorsURL.Encode(e)
		}
	}
	{
		if s.DeploymentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeploymentsURL.Set {
			e.RawStr("\"deployments_url\"" + ":")
			s.DeploymentsURL.Encode(e)
		}
	}
	{
		if s.DownloadsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DownloadsURL.Set {
			e.RawStr("\"downloads_url\"" + ":")
			s.DownloadsURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsURL.Set {
			e.RawStr("\"events_url\"" + ":")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ForksURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForksURL.Set {
			e.RawStr("\"forks_url\"" + ":")
			s.ForksURL.Encode(e)
		}
	}
	{
		if s.GitCommitsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitCommitsURL.Set {
			e.RawStr("\"git_commits_url\"" + ":")
			s.GitCommitsURL.Encode(e)
		}
	}
	{
		if s.GitRefsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitRefsURL.Set {
			e.RawStr("\"git_refs_url\"" + ":")
			s.GitRefsURL.Encode(e)
		}
	}
	{
		if s.GitTagsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitTagsURL.Set {
			e.RawStr("\"git_tags_url\"" + ":")
			s.GitTagsURL.Encode(e)
		}
	}
	{
		if s.GitURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitURL.Set {
			e.RawStr("\"git_url\"" + ":")
			s.GitURL.Encode(e)
		}
	}
	{
		if s.IssueCommentURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IssueCommentURL.Set {
			e.RawStr("\"issue_comment_url\"" + ":")
			s.IssueCommentURL.Encode(e)
		}
	}
	{
		if s.IssueEventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IssueEventsURL.Set {
			e.RawStr("\"issue_events_url\"" + ":")
			s.IssueEventsURL.Encode(e)
		}
	}
	{
		if s.IssuesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IssuesURL.Set {
			e.RawStr("\"issues_url\"" + ":")
			s.IssuesURL.Encode(e)
		}
	}
	{
		if s.KeysURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.KeysURL.Set {
			e.RawStr("\"keys_url\"" + ":")
			s.KeysURL.Encode(e)
		}
	}
	{
		if s.LabelsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LabelsURL.Set {
			e.RawStr("\"labels_url\"" + ":")
			s.LabelsURL.Encode(e)
		}
	}
	{
		if s.LanguagesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LanguagesURL.Set {
			e.RawStr("\"languages_url\"" + ":")
			s.LanguagesURL.Encode(e)
		}
	}
	{
		if s.MergesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MergesURL.Set {
			e.RawStr("\"merges_url\"" + ":")
			s.MergesURL.Encode(e)
		}
	}
	{
		if s.MilestonesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MilestonesURL.Set {
			e.RawStr("\"milestones_url\"" + ":")
			s.MilestonesURL.Encode(e)
		}
	}
	{
		if s.NotificationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NotificationsURL.Set {
			e.RawStr("\"notifications_url\"" + ":")
			s.NotificationsURL.Encode(e)
		}
	}
	{
		if s.PullsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PullsURL.Set {
			e.RawStr("\"pulls_url\"" + ":")
			s.PullsURL.Encode(e)
		}
	}
	{
		if s.ReleasesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReleasesURL.Set {
			e.RawStr("\"releases_url\"" + ":")
			s.ReleasesURL.Encode(e)
		}
	}
	{
		if s.SSHURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SSHURL.Set {
			e.RawStr("\"ssh_url\"" + ":")
			s.SSHURL.Encode(e)
		}
	}
	{
		if s.StargazersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StargazersURL.Set {
			e.RawStr("\"stargazers_url\"" + ":")
			s.StargazersURL.Encode(e)
		}
	}
	{
		if s.StatusesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StatusesURL.Set {
			e.RawStr("\"statuses_url\"" + ":")
			s.StatusesURL.Encode(e)
		}
	}
	{
		if s.SubscribersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscribersURL.Set {
			e.RawStr("\"subscribers_url\"" + ":")
			s.SubscribersURL.Encode(e)
		}
	}
	{
		if s.SubscriptionURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscriptionURL.Set {
			e.RawStr("\"subscription_url\"" + ":")
			s.SubscriptionURL.Encode(e)
		}
	}
	{
		if s.TagsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TagsURL.Set {
			e.RawStr("\"tags_url\"" + ":")
			s.TagsURL.Encode(e)
		}
	}
	{
		if s.TeamsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TeamsURL.Set {
			e.RawStr("\"teams_url\"" + ":")
			s.TeamsURL.Encode(e)
		}
	}
	{
		if s.TreesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TreesURL.Set {
			e.RawStr("\"trees_url\"" + ":")
			s.TreesURL.Encode(e)
		}
	}
	{
		if s.CloneURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CloneURL.Set {
			e.RawStr("\"clone_url\"" + ":")
			s.CloneURL.Encode(e)
		}
	}
	{
		if s.MirrorURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MirrorURL.Set {
			e.RawStr("\"mirror_url\"" + ":")
			s.MirrorURL.Encode(e)
		}
	}
	{
		if s.HooksURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HooksURL.Set {
			e.RawStr("\"hooks_url\"" + ":")
			s.HooksURL.Encode(e)
		}
	}
	{
		if s.SvnURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SvnURL.Set {
			e.RawStr("\"svn_url\"" + ":")
			s.SvnURL.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Homepage.Set {
			e.RawStr("\"homepage\"" + ":")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Language.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Language.Set {
			e.RawStr("\"language\"" + ":")
			s.Language.Encode(e)
		}
	}
	{
		if s.ForksCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForksCount.Set {
			e.RawStr("\"forks_count\"" + ":")
			s.ForksCount.Encode(e)
		}
	}
	{
		if s.StargazersCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StargazersCount.Set {
			e.RawStr("\"stargazers_count\"" + ":")
			s.StargazersCount.Encode(e)
		}
	}
	{
		if s.WatchersCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.WatchersCount.Set {
			e.RawStr("\"watchers_count\"" + ":")
			s.WatchersCount.Encode(e)
		}
	}
	{
		if s.Size.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Size.Set {
			e.RawStr("\"size\"" + ":")
			s.Size.Encode(e)
		}
	}
	{
		if s.DefaultBranch.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultBranch.Set {
			e.RawStr("\"default_branch\"" + ":")
			s.DefaultBranch.Encode(e)
		}
	}
	{
		if s.OpenIssuesCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OpenIssuesCount.Set {
			e.RawStr("\"open_issues_count\"" + ":")
			s.OpenIssuesCount.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.HasIssues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasIssues.Set {
			e.RawStr("\"has_issues\"" + ":")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasProjects.Set {
			e.RawStr("\"has_projects\"" + ":")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasWiki.Set {
			e.RawStr("\"has_wiki\"" + ":")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.HasPages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasPages.Set {
			e.RawStr("\"has_pages\"" + ":")
			s.HasPages.Encode(e)
		}
	}
	{
		if s.HasDownloads.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasDownloads.Set {
			e.RawStr("\"has_downloads\"" + ":")
			s.HasDownloads.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Archived.Set {
			e.RawStr("\"archived\"" + ":")
			s.Archived.Encode(e)
		}
	}
	{
		if s.Disabled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Disabled.Set {
			e.RawStr("\"disabled\"" + ":")
			s.Disabled.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.PushedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PushedAt.Set {
			e.RawStr("\"pushed_at\"" + ":")
			s.PushedAt.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.Permissions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscribersCount.Set {
			e.RawStr("\"subscribers_count\"" + ":")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NetworkCount.Set {
			e.RawStr("\"network_count\"" + ":")
			s.NetworkCount.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes NullableRepositoryTemplateRepository from json.
func (s *NullableRepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableRepositoryTemplateRepository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "full_name":
			s.FullName.Reset()
			if err := s.FullName.Decode(d); err != nil {
				return err
			}
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			s.Fork.Reset()
			if err := s.Fork.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "archive_url":
			s.ArchiveURL.Reset()
			if err := s.ArchiveURL.Decode(d); err != nil {
				return err
			}
		case "assignees_url":
			s.AssigneesURL.Reset()
			if err := s.AssigneesURL.Decode(d); err != nil {
				return err
			}
		case "blobs_url":
			s.BlobsURL.Reset()
			if err := s.BlobsURL.Decode(d); err != nil {
				return err
			}
		case "branches_url":
			s.BranchesURL.Reset()
			if err := s.BranchesURL.Decode(d); err != nil {
				return err
			}
		case "collaborators_url":
			s.CollaboratorsURL.Reset()
			if err := s.CollaboratorsURL.Decode(d); err != nil {
				return err
			}
		case "comments_url":
			s.CommentsURL.Reset()
			if err := s.CommentsURL.Decode(d); err != nil {
				return err
			}
		case "commits_url":
			s.CommitsURL.Reset()
			if err := s.CommitsURL.Decode(d); err != nil {
				return err
			}
		case "compare_url":
			s.CompareURL.Reset()
			if err := s.CompareURL.Decode(d); err != nil {
				return err
			}
		case "contents_url":
			s.ContentsURL.Reset()
			if err := s.ContentsURL.Decode(d); err != nil {
				return err
			}
		case "contributors_url":
			s.ContributorsURL.Reset()
			if err := s.ContributorsURL.Decode(d); err != nil {
				return err
			}
		case "deployments_url":
			s.DeploymentsURL.Reset()
			if err := s.DeploymentsURL.Decode(d); err != nil {
				return err
			}
		case "downloads_url":
			s.DownloadsURL.Reset()
			if err := s.DownloadsURL.Decode(d); err != nil {
				return err
			}
		case "events_url":
			s.EventsURL.Reset()
			if err := s.EventsURL.Decode(d); err != nil {
				return err
			}
		case "forks_url":
			s.ForksURL.Reset()
			if err := s.ForksURL.Decode(d); err != nil {
				return err
			}
		case "git_commits_url":
			s.GitCommitsURL.Reset()
			if err := s.GitCommitsURL.Decode(d); err != nil {
				return err
			}
		case "git_refs_url":
			s.GitRefsURL.Reset()
			if err := s.GitRefsURL.Decode(d); err != nil {
				return err
			}
		case "git_tags_url":
			s.GitTagsURL.Reset()
			if err := s.GitTagsURL.Decode(d); err != nil {
				return err
			}
		case "git_url":
			s.GitURL.Reset()
			if err := s.GitURL.Decode(d); err != nil {
				return err
			}
		case "issue_comment_url":
			s.IssueCommentURL.Reset()
			if err := s.IssueCommentURL.Decode(d); err != nil {
				return err
			}
		case "issue_events_url":
			s.IssueEventsURL.Reset()
			if err := s.IssueEventsURL.Decode(d); err != nil {
				return err
			}
		case "issues_url":
			s.IssuesURL.Reset()
			if err := s.IssuesURL.Decode(d); err != nil {
				return err
			}
		case "keys_url":
			s.KeysURL.Reset()
			if err := s.KeysURL.Decode(d); err != nil {
				return err
			}
		case "labels_url":
			s.LabelsURL.Reset()
			if err := s.LabelsURL.Decode(d); err != nil {
				return err
			}
		case "languages_url":
			s.LanguagesURL.Reset()
			if err := s.LanguagesURL.Decode(d); err != nil {
				return err
			}
		case "merges_url":
			s.MergesURL.Reset()
			if err := s.MergesURL.Decode(d); err != nil {
				return err
			}
		case "milestones_url":
			s.MilestonesURL.Reset()
			if err := s.MilestonesURL.Decode(d); err != nil {
				return err
			}
		case "notifications_url":
			s.NotificationsURL.Reset()
			if err := s.NotificationsURL.Decode(d); err != nil {
				return err
			}
		case "pulls_url":
			s.PullsURL.Reset()
			if err := s.PullsURL.Decode(d); err != nil {
				return err
			}
		case "releases_url":
			s.ReleasesURL.Reset()
			if err := s.ReleasesURL.Decode(d); err != nil {
				return err
			}
		case "ssh_url":
			s.SSHURL.Reset()
			if err := s.SSHURL.Decode(d); err != nil {
				return err
			}
		case "stargazers_url":
			s.StargazersURL.Reset()
			if err := s.StargazersURL.Decode(d); err != nil {
				return err
			}
		case "statuses_url":
			s.StatusesURL.Reset()
			if err := s.StatusesURL.Decode(d); err != nil {
				return err
			}
		case "subscribers_url":
			s.SubscribersURL.Reset()
			if err := s.SubscribersURL.Decode(d); err != nil {
				return err
			}
		case "subscription_url":
			s.SubscriptionURL.Reset()
			if err := s.SubscriptionURL.Decode(d); err != nil {
				return err
			}
		case "tags_url":
			s.TagsURL.Reset()
			if err := s.TagsURL.Decode(d); err != nil {
				return err
			}
		case "teams_url":
			s.TeamsURL.Reset()
			if err := s.TeamsURL.Decode(d); err != nil {
				return err
			}
		case "trees_url":
			s.TreesURL.Reset()
			if err := s.TreesURL.Decode(d); err != nil {
				return err
			}
		case "clone_url":
			s.CloneURL.Reset()
			if err := s.CloneURL.Decode(d); err != nil {
				return err
			}
		case "mirror_url":
			s.MirrorURL.Reset()
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			s.HooksURL.Reset()
			if err := s.HooksURL.Decode(d); err != nil {
				return err
			}
		case "svn_url":
			s.SvnURL.Reset()
			if err := s.SvnURL.Decode(d); err != nil {
				return err
			}
		case "homepage":
			s.Homepage.Reset()
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			s.Language.Reset()
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			s.ForksCount.Reset()
			if err := s.ForksCount.Decode(d); err != nil {
				return err
			}
		case "stargazers_count":
			s.StargazersCount.Reset()
			if err := s.StargazersCount.Decode(d); err != nil {
				return err
			}
		case "watchers_count":
			s.WatchersCount.Reset()
			if err := s.WatchersCount.Decode(d); err != nil {
				return err
			}
		case "size":
			s.Size.Reset()
			if err := s.Size.Decode(d); err != nil {
				return err
			}
		case "default_branch":
			s.DefaultBranch.Reset()
			if err := s.DefaultBranch.Decode(d); err != nil {
				return err
			}
		case "open_issues_count":
			s.OpenIssuesCount.Reset()
			if err := s.OpenIssuesCount.Decode(d); err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			s.HasIssues.Reset()
			if err := s.HasIssues.Decode(d); err != nil {
				return err
			}
		case "has_projects":
			s.HasProjects.Reset()
			if err := s.HasProjects.Decode(d); err != nil {
				return err
			}
		case "has_wiki":
			s.HasWiki.Reset()
			if err := s.HasWiki.Decode(d); err != nil {
				return err
			}
		case "has_pages":
			s.HasPages.Reset()
			if err := s.HasPages.Decode(d); err != nil {
				return err
			}
		case "has_downloads":
			s.HasDownloads.Reset()
			if err := s.HasDownloads.Decode(d); err != nil {
				return err
			}
		case "archived":
			s.Archived.Reset()
			if err := s.Archived.Decode(d); err != nil {
				return err
			}
		case "disabled":
			s.Disabled.Reset()
			if err := s.Disabled.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			s.PushedAt.Reset()
			if err := s.PushedAt.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			s.SubscribersCount.Reset()
			if err := s.SubscribersCount.Decode(d); err != nil {
				return err
			}
		case "network_count":
			s.NetworkCount.Reset()
			if err := s.NetworkCount.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableRepositoryTemplateRepositoryOwner) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Login.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Login.Set {
			e.RawStr("\"login\"" + ":")
			s.Login.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvatarURL.Set {
			e.RawStr("\"avatar_url\"" + ":")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.GravatarID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GravatarID.Set {
			e.RawStr("\"gravatar_id\"" + ":")
			s.GravatarID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.FollowersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowersURL.Set {
			e.RawStr("\"followers_url\"" + ":")
			s.FollowersURL.Encode(e)
		}
	}
	{
		if s.FollowingURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowingURL.Set {
			e.RawStr("\"following_url\"" + ":")
			s.FollowingURL.Encode(e)
		}
	}
	{
		if s.GistsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GistsURL.Set {
			e.RawStr("\"gists_url\"" + ":")
			s.GistsURL.Encode(e)
		}
	}
	{
		if s.StarredURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StarredURL.Set {
			e.RawStr("\"starred_url\"" + ":")
			s.StarredURL.Encode(e)
		}
	}
	{
		if s.SubscriptionsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscriptionsURL.Set {
			e.RawStr("\"subscriptions_url\"" + ":")
			s.SubscriptionsURL.Encode(e)
		}
	}
	{
		if s.OrganizationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationsURL.Set {
			e.RawStr("\"organizations_url\"" + ":")
			s.OrganizationsURL.Encode(e)
		}
	}
	{
		if s.ReposURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReposURL.Set {
			e.RawStr("\"repos_url\"" + ":")
			s.ReposURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsURL.Set {
			e.RawStr("\"events_url\"" + ":")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ReceivedEventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReceivedEventsURL.Set {
			e.RawStr("\"received_events_url\"" + ":")
			s.ReceivedEventsURL.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.SiteAdmin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SiteAdmin.Set {
			e.RawStr("\"site_admin\"" + ":")
			s.SiteAdmin.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes NullableRepositoryTemplateRepositoryOwner from json.
func (s *NullableRepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableRepositoryTemplateRepositoryOwner to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			s.Login.Reset()
			if err := s.Login.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "avatar_url":
			s.AvatarURL.Reset()
			if err := s.AvatarURL.Decode(d); err != nil {
				return err
			}
		case "gravatar_id":
			s.GravatarID.Reset()
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "followers_url":
			s.FollowersURL.Reset()
			if err := s.FollowersURL.Decode(d); err != nil {
				return err
			}
		case "following_url":
			s.FollowingURL.Reset()
			if err := s.FollowingURL.Decode(d); err != nil {
				return err
			}
		case "gists_url":
			s.GistsURL.Reset()
			if err := s.GistsURL.Decode(d); err != nil {
				return err
			}
		case "starred_url":
			s.StarredURL.Reset()
			if err := s.StarredURL.Decode(d); err != nil {
				return err
			}
		case "subscriptions_url":
			s.SubscriptionsURL.Reset()
			if err := s.SubscriptionsURL.Decode(d); err != nil {
				return err
			}
		case "organizations_url":
			s.OrganizationsURL.Reset()
			if err := s.OrganizationsURL.Decode(d); err != nil {
				return err
			}
		case "repos_url":
			s.ReposURL.Reset()
			if err := s.ReposURL.Decode(d); err != nil {
				return err
			}
		case "events_url":
			s.EventsURL.Reset()
			if err := s.EventsURL.Decode(d); err != nil {
				return err
			}
		case "received_events_url":
			s.ReceivedEventsURL.Reset()
			if err := s.ReceivedEventsURL.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "site_admin":
			s.SiteAdmin.Reset()
			if err := s.SiteAdmin.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableRepositoryTemplateRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Admin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Admin.Set {
			e.RawStr("\"admin\"" + ":")
			s.Admin.Encode(e)
		}
	}
	{
		if s.Maintain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		if s.Push.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Push.Set {
			e.RawStr("\"push\"" + ":")
			s.Push.Encode(e)
		}
	}
	{
		if s.Triage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		if s.Pull.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pull.Set {
			e.RawStr("\"pull\"" + ":")
			s.Pull.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes NullableRepositoryTemplateRepositoryPermissions from json.
func (s *NullableRepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableRepositoryTemplateRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			s.Admin.Reset()
			if err := s.Admin.Decode(d); err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			s.Push.Reset()
			if err := s.Push.Decode(d); err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			s.Pull.Reset()
			if err := s.Pull.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableScopedInstallation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"permissions\"" + ":")
		s.Permissions.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"repository_selection\"" + ":")
		s.RepositorySelection.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"single_file_name\"" + ":")
		s.SingleFileName.Encode(e)
	}
	{
		if s.HasMultipleSingleFiles.Set {
			e.Comma()
		}
		if s.HasMultipleSingleFiles.Set {
			e.RawStr("\"has_multiple_single_files\"" + ":")
			s.HasMultipleSingleFiles.Encode(e)
		}
	}
	{
		if s.SingleFilePaths != nil {
			e.Comma()
		}
		if s.SingleFilePaths != nil {
			e.RawStr("\"single_file_paths\"" + ":")
			e.ArrStart()
			if len(s.SingleFilePaths) >= 1 {
				// Encode first element without comma.
				{
					elem := s.SingleFilePaths[0]
					e.Str(elem)
				}
				for _, elem := range s.SingleFilePaths[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"repositories_url\"" + ":")
		json.EncodeURI(e, s.RepositoriesURL)
	}
	{
		e.Comma()

		e.RawStr("\"account\"" + ":")
		s.Account.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableScopedInstallation from json.
func (s *NullableScopedInstallation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableScopedInstallation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permissions":
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "repository_selection":
			if err := s.RepositorySelection.Decode(d); err != nil {
				return err
			}
		case "single_file_name":
			if err := s.SingleFileName.Decode(d); err != nil {
				return err
			}
		case "has_multiple_single_files":
			s.HasMultipleSingleFiles.Reset()
			if err := s.HasMultipleSingleFiles.Decode(d); err != nil {
				return err
			}
		case "single_file_paths":
			s.SingleFilePaths = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.SingleFilePaths = append(s.SingleFilePaths, elem)
				return nil
			}); err != nil {
				return err
			}
		case "repositories_url":
			v, err := json.DecodeURI(d)
			s.RepositoriesURL = v
			if err != nil {
				return err
			}
		case "account":
			if err := s.Account.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes NullableScopedInstallationRepositorySelection as json.
func (s NullableScopedInstallationRepositorySelection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes NullableScopedInstallationRepositorySelection from json.
func (s *NullableScopedInstallationRepositorySelection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableScopedInstallationRepositorySelection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NullableScopedInstallationRepositorySelection(v) {
	case NullableScopedInstallationRepositorySelectionAll:
		*s = NullableScopedInstallationRepositorySelectionAll
	case NullableScopedInstallationRepositorySelectionSelected:
		*s = NullableScopedInstallationRepositorySelectionSelected
	default:
		*s = NullableScopedInstallationRepositorySelection(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableSimpleCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"tree_id\"" + ":")
		e.Str(s.TreeID)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"timestamp\"" + ":")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		e.Comma()

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committer\"" + ":")
		s.Committer.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableSimpleCommit from json.
func (s *NullableSimpleCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableSimpleCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "tree_id":
			v, err := d.Str()
			s.TreeID = string(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "timestamp":
			v, err := json.DecodeDateTime(d)
			s.Timestamp = v
			if err != nil {
				return err
			}
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableSimpleCommitAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	e.ObjEnd()
}

// Decode decodes NullableSimpleCommitAuthor from json.
func (s *NullableSimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableSimpleCommitAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableSimpleCommitCommitter) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	e.ObjEnd()
}

// Decode decodes NullableSimpleCommitCommitter from json.
func (s *NullableSimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableSimpleCommitCommitter to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableSimpleUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		if s.StarredAt.Set {
			e.Comma()
		}
		if s.StarredAt.Set {
			e.RawStr("\"starred_at\"" + ":")
			s.StarredAt.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes NullableSimpleUser from json.
func (s *NullableSimpleUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableSimpleUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "starred_at":
			s.StarredAt.Reset()
			if err := s.StarredAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableTeamSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"members_url\"" + ":")
		e.Str(s.MembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"permission\"" + ":")
		e.Str(s.Permission)
	}
	{
		if s.Privacy.Set {
			e.Comma()
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"repositories_url\"" + ":")
		json.EncodeURI(e, s.RepositoriesURL)
	}
	{
		e.Comma()

		e.RawStr("\"slug\"" + ":")
		e.Str(s.Slug)
	}
	{
		if s.LdapDn.Set {
			e.Comma()
		}
		if s.LdapDn.Set {
			e.RawStr("\"ldap_dn\"" + ":")
			s.LdapDn.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes NullableTeamSimple from json.
func (s *NullableTeamSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableTeamSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "members_url":
			v, err := d.Str()
			s.MembersURL = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "permission":
			v, err := d.Str()
			s.Permission = string(v)
			if err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "repositories_url":
			v, err := json.DecodeURI(d)
			s.RepositoriesURL = v
			if err != nil {
				return err
			}
		case "slug":
			v, err := d.Str()
			s.Slug = string(v)
			if err != nil {
				return err
			}
		case "ldap_dn":
			s.LdapDn.Reset()
			if err := s.LdapDn.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OAuthAuthorizationsCreateAuthorizationApplicationJSONForbidden as json.
func (s OAuthAuthorizationsCreateAuthorizationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsCreateAuthorizationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsCreateAuthorizationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsCreateAuthorizationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsCreateAuthorizationApplicationJSONGone as json.
func (s OAuthAuthorizationsCreateAuthorizationApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationApplicationJSONGone from json.
func (s *OAuthAuthorizationsCreateAuthorizationApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsCreateAuthorizationApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsCreateAuthorizationApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsCreateAuthorizationApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsCreateAuthorizationApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsCreateAuthorizationApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsCreateAuthorizationApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsCreateAuthorizationApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsCreateAuthorizationReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Scopes.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Scopes.Set {
			e.RawStr("\"scopes\"" + ":")
			s.Scopes.Encode(e)
		}
	}
	{
		if s.Note.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Note.Set {
			e.RawStr("\"note\"" + ":")
			s.Note.Encode(e)
		}
	}
	{
		if s.NoteURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NoteURL.Set {
			e.RawStr("\"note_url\"" + ":")
			s.NoteURL.Encode(e)
		}
	}
	{
		if s.ClientID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClientID.Set {
			e.RawStr("\"client_id\"" + ":")
			s.ClientID.Encode(e)
		}
	}
	{
		if s.ClientSecret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClientSecret.Set {
			e.RawStr("\"client_secret\"" + ":")
			s.ClientSecret.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fingerprint.Set {
			e.RawStr("\"fingerprint\"" + ":")
			s.Fingerprint.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationReq from json.
func (s *OAuthAuthorizationsCreateAuthorizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsCreateAuthorizationReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scopes":
			s.Scopes.Reset()
			if err := s.Scopes.Decode(d); err != nil {
				return err
			}
		case "note":
			s.Note.Reset()
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "note_url":
			s.NoteURL.Reset()
			if err := s.NoteURL.Decode(d); err != nil {
				return err
			}
		case "client_id":
			s.ClientID.Reset()
			if err := s.ClientID.Decode(d); err != nil {
				return err
			}
		case "client_secret":
			s.ClientSecret.Reset()
			if err := s.ClientSecret.Decode(d); err != nil {
				return err
			}
		case "fingerprint":
			s.Fingerprint.Reset()
			if err := s.Fingerprint.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden as json.
func (s OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsDeleteAuthorizationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OAuthAuthorizationsDeleteAuthorizationNoContent from json.
func (s *OAuthAuthorizationsDeleteAuthorizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsDeleteAuthorizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OAuthAuthorizationsDeleteGrantApplicationJSONForbidden as json.
func (s OAuthAuthorizationsDeleteGrantApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteGrantApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsDeleteGrantApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsDeleteGrantApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteGrantApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsDeleteGrantNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OAuthAuthorizationsDeleteGrantNoContent from json.
func (s *OAuthAuthorizationsDeleteGrantNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsDeleteGrantNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden as json.
func (s OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetGrantApplicationJSONForbidden as json.
func (s OAuthAuthorizationsGetGrantApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetGrantApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsGetGrantApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetGrantApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetGrantApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetGrantApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsGetGrantApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetGrantApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsGetGrantApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetGrantApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetGrantApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONCreated as json.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Authorization(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONCreated from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONCreated to nil`)
	}
	var unwrapped Authorization
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONOK as json.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Authorization(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONOK from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONOK to nil`)
	}
	var unwrapped Authorization
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"client_secret\"" + ":")
		e.Str(s.ClientSecret)
	}
	{
		if s.Scopes.Set {
			e.Comma()
		}
		if s.Scopes.Set {
			e.RawStr("\"scopes\"" + ":")
			s.Scopes.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.Comma()
		}
		if s.Note.Set {
			e.RawStr("\"note\"" + ":")
			s.Note.Encode(e)
		}
	}
	{
		if s.NoteURL.Set {
			e.Comma()
		}
		if s.NoteURL.Set {
			e.RawStr("\"note_url\"" + ":")
			s.NoteURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_secret":
			v, err := d.Str()
			s.ClientSecret = string(v)
			if err != nil {
				return err
			}
		case "scopes":
			s.Scopes.Reset()
			if err := s.Scopes.Decode(d); err != nil {
				return err
			}
		case "note":
			s.Note.Reset()
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "note_url":
			s.NoteURL.Reset()
			if err := s.NoteURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONCreated as json.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Authorization(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONCreated from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONCreated to nil`)
	}
	var unwrapped Authorization
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONForbidden as json.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONOK as json.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Authorization(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONOK from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONOK to nil`)
	}
	var unwrapped Authorization
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONOK(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"client_secret\"" + ":")
		e.Str(s.ClientSecret)
	}
	{
		if s.Scopes.Set {
			e.Comma()
		}
		if s.Scopes.Set {
			e.RawStr("\"scopes\"" + ":")
			s.Scopes.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.Comma()
		}
		if s.Note.Set {
			e.RawStr("\"note\"" + ":")
			s.Note.Encode(e)
		}
	}
	{
		if s.NoteURL.Set {
			e.Comma()
		}
		if s.NoteURL.Set {
			e.RawStr("\"note_url\"" + ":")
			s.NoteURL.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.Comma()
		}
		if s.Fingerprint.Set {
			e.RawStr("\"fingerprint\"" + ":")
			s.Fingerprint.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppReq from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_secret":
			v, err := d.Str()
			s.ClientSecret = string(v)
			if err != nil {
				return err
			}
		case "scopes":
			s.Scopes.Reset()
			if err := s.Scopes.Decode(d); err != nil {
				return err
			}
		case "note":
			s.Note.Reset()
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "note_url":
			s.NoteURL.Reset()
			if err := s.NoteURL.Decode(d); err != nil {
				return err
			}
		case "fingerprint":
			s.Fingerprint.Reset()
			if err := s.Fingerprint.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden as json.
func (s OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound as json.
func (s OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound from json.
func (s *OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListAuthorizationsOKApplicationJSON as json.
func (s OAuthAuthorizationsListAuthorizationsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Authorization(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OAuthAuthorizationsListAuthorizationsOKApplicationJSON from json.
func (s *OAuthAuthorizationsListAuthorizationsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListAuthorizationsOKApplicationJSON to nil`)
	}
	var unwrapped []Authorization
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Authorization
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListAuthorizationsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListGrantsApplicationJSONForbidden as json.
func (s OAuthAuthorizationsListGrantsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListGrantsApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsListGrantsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListGrantsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListGrantsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListGrantsApplicationJSONNotFound as json.
func (s OAuthAuthorizationsListGrantsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListGrantsApplicationJSONNotFound from json.
func (s *OAuthAuthorizationsListGrantsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListGrantsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListGrantsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListGrantsApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsListGrantsApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListGrantsApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsListGrantsApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListGrantsApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListGrantsApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListGrantsOKApplicationJSON as json.
func (s OAuthAuthorizationsListGrantsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ApplicationGrant(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OAuthAuthorizationsListGrantsOKApplicationJSON from json.
func (s *OAuthAuthorizationsListGrantsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListGrantsOKApplicationJSON to nil`)
	}
	var unwrapped []ApplicationGrant
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ApplicationGrant
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListGrantsOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsUpdateAuthorizationReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Scopes.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Scopes.Set {
			e.RawStr("\"scopes\"" + ":")
			s.Scopes.Encode(e)
		}
	}
	{
		if s.AddScopes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AddScopes != nil {
			e.RawStr("\"add_scopes\"" + ":")
			e.ArrStart()
			if len(s.AddScopes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AddScopes[0]
					e.Str(elem)
				}
				for _, elem := range s.AddScopes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RemoveScopes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RemoveScopes != nil {
			e.RawStr("\"remove_scopes\"" + ":")
			e.ArrStart()
			if len(s.RemoveScopes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RemoveScopes[0]
					e.Str(elem)
				}
				for _, elem := range s.RemoveScopes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Note.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Note.Set {
			e.RawStr("\"note\"" + ":")
			s.Note.Encode(e)
		}
	}
	{
		if s.NoteURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NoteURL.Set {
			e.RawStr("\"note_url\"" + ":")
			s.NoteURL.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fingerprint.Set {
			e.RawStr("\"fingerprint\"" + ":")
			s.Fingerprint.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OAuthAuthorizationsUpdateAuthorizationReq from json.
func (s *OAuthAuthorizationsUpdateAuthorizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsUpdateAuthorizationReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scopes":
			s.Scopes.Reset()
			if err := s.Scopes.Decode(d); err != nil {
				return err
			}
		case "add_scopes":
			s.AddScopes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AddScopes = append(s.AddScopes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "remove_scopes":
			s.RemoveScopes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.RemoveScopes = append(s.RemoveScopes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "note":
			s.Note.Reset()
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "note_url":
			s.NoteURL.Reset()
			if err := s.NoteURL.Decode(d); err != nil {
				return err
			}
		case "fingerprint":
			s.Fingerprint.Reset()
			if err := s.Fingerprint.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes APIOverviewSSHKeyFingerprints as json.
func (o OptAPIOverviewSSHKeyFingerprints) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes APIOverviewSSHKeyFingerprints from json.
func (o *OptAPIOverviewSSHKeyFingerprints) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAPIOverviewSSHKeyFingerprints to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAPIOverviewSSHKeyFingerprints`, d.Next())
	}
}

// Encode encodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (o OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (o *OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility`, d.Next())
	}
}

// Encode encodes ActionsListJobsForWorkflowRunFilter as json.
func (o OptActionsListJobsForWorkflowRunFilter) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ActionsListJobsForWorkflowRunFilter from json.
func (o *OptActionsListJobsForWorkflowRunFilter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActionsListJobsForWorkflowRunFilter to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActionsListJobsForWorkflowRunFilter`, d.Next())
	}
}

// Encode encodes ActionsListWorkflowRunsForRepoStatus as json.
func (o OptActionsListWorkflowRunsForRepoStatus) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ActionsListWorkflowRunsForRepoStatus from json.
func (o *OptActionsListWorkflowRunsForRepoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActionsListWorkflowRunsForRepoStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActionsListWorkflowRunsForRepoStatus`, d.Next())
	}
}

// Encode encodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (o OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (o *OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility`, d.Next())
	}
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserDirection as json.
func (o OptActivityListReposStarredByAuthenticatedUserDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserDirection from json.
func (o *OptActivityListReposStarredByAuthenticatedUserDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActivityListReposStarredByAuthenticatedUserDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActivityListReposStarredByAuthenticatedUserDirection`, d.Next())
	}
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserSort as json.
func (o OptActivityListReposStarredByAuthenticatedUserSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserSort from json.
func (o *OptActivityListReposStarredByAuthenticatedUserSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActivityListReposStarredByAuthenticatedUserSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActivityListReposStarredByAuthenticatedUserSort`, d.Next())
	}
}

// Encode encodes ActivityMarkNotificationsAsReadReq as json.
func (o OptActivityMarkNotificationsAsReadReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ActivityMarkNotificationsAsReadReq from json.
func (o *OptActivityMarkNotificationsAsReadReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActivityMarkNotificationsAsReadReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActivityMarkNotificationsAsReadReq`, d.Next())
	}
}

// Encode encodes ActivityMarkRepoNotificationsAsReadReq as json.
func (o OptActivityMarkRepoNotificationsAsReadReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ActivityMarkRepoNotificationsAsReadReq from json.
func (o *OptActivityMarkRepoNotificationsAsReadReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActivityMarkRepoNotificationsAsReadReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActivityMarkRepoNotificationsAsReadReq`, d.Next())
	}
}

// Encode encodes ActivitySetRepoSubscriptionReq as json.
func (o OptActivitySetRepoSubscriptionReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ActivitySetRepoSubscriptionReq from json.
func (o *OptActivitySetRepoSubscriptionReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActivitySetRepoSubscriptionReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActivitySetRepoSubscriptionReq`, d.Next())
	}
}

// Encode encodes ActivitySetThreadSubscriptionReq as json.
func (o OptActivitySetThreadSubscriptionReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ActivitySetThreadSubscriptionReq from json.
func (o *OptActivitySetThreadSubscriptionReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActivitySetThreadSubscriptionReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActivitySetThreadSubscriptionReq`, d.Next())
	}
}

// Encode encodes Actor as json.
func (o OptActor) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes Actor from json.
func (o *OptActor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActor to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActor`, d.Next())
	}
}

// Encode encodes AlertCreatedAt as json.
func (o OptAlertCreatedAt) Encode(e *jx.Writer) {
}

// Decode decodes AlertCreatedAt from json.
func (o *OptAlertCreatedAt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAlertCreatedAt to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAlertCreatedAt`, d.Next())
	}
}

// Encode encodes AlertHTMLURL as json.
func (o OptAlertHTMLURL) Encode(e *jx.Writer) {
}

// Decode decodes AlertHTMLURL from json.
func (o *OptAlertHTMLURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAlertHTMLURL to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAlertHTMLURL`, d.Next())
	}
}

// Encode encodes AlertNumber as json.
func (o OptAlertNumber) Encode(e *jx.Writer) {
}

// Decode decodes AlertNumber from json.
func (o *OptAlertNumber) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAlertNumber to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAlertNumber`, d.Next())
	}
}

// Encode encodes AlertURL as json.
func (o OptAlertURL) Encode(e *jx.Writer) {
}

// Decode decodes AlertURL from json.
func (o *OptAlertURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAlertURL to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAlertURL`, d.Next())
	}
}

// Encode encodes AllowedActions as json.
func (o OptAllowedActions) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AllowedActions from json.
func (o *OptAllowedActions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAllowedActions to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAllowedActions`, d.Next())
	}
}

// Encode encodes AppPermissions as json.
func (o OptAppPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes AppPermissions from json.
func (o *OptAppPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissions`, d.Next())
	}
}

// Encode encodes AppPermissionsActions as json.
func (o OptAppPermissionsActions) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsActions from json.
func (o *OptAppPermissionsActions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsActions to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsActions`, d.Next())
	}
}

// Encode encodes AppPermissionsAdministration as json.
func (o OptAppPermissionsAdministration) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsAdministration from json.
func (o *OptAppPermissionsAdministration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsAdministration to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsAdministration`, d.Next())
	}
}

// Encode encodes AppPermissionsChecks as json.
func (o OptAppPermissionsChecks) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsChecks from json.
func (o *OptAppPermissionsChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsChecks to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsChecks`, d.Next())
	}
}

// Encode encodes AppPermissionsContentReferences as json.
func (o OptAppPermissionsContentReferences) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsContentReferences from json.
func (o *OptAppPermissionsContentReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsContentReferences to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsContentReferences`, d.Next())
	}
}

// Encode encodes AppPermissionsContents as json.
func (o OptAppPermissionsContents) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsContents from json.
func (o *OptAppPermissionsContents) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsContents to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsContents`, d.Next())
	}
}

// Encode encodes AppPermissionsDeployments as json.
func (o OptAppPermissionsDeployments) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsDeployments from json.
func (o *OptAppPermissionsDeployments) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsDeployments to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsDeployments`, d.Next())
	}
}

// Encode encodes AppPermissionsEnvironments as json.
func (o OptAppPermissionsEnvironments) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsEnvironments from json.
func (o *OptAppPermissionsEnvironments) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsEnvironments to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsEnvironments`, d.Next())
	}
}

// Encode encodes AppPermissionsIssues as json.
func (o OptAppPermissionsIssues) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsIssues from json.
func (o *OptAppPermissionsIssues) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsIssues to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsIssues`, d.Next())
	}
}

// Encode encodes AppPermissionsMembers as json.
func (o OptAppPermissionsMembers) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsMembers from json.
func (o *OptAppPermissionsMembers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsMembers to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsMembers`, d.Next())
	}
}

// Encode encodes AppPermissionsMetadata as json.
func (o OptAppPermissionsMetadata) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsMetadata from json.
func (o *OptAppPermissionsMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsMetadata to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsMetadata`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationAdministration as json.
func (o OptAppPermissionsOrganizationAdministration) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationAdministration from json.
func (o *OptAppPermissionsOrganizationAdministration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationAdministration to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationAdministration`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationHooks as json.
func (o OptAppPermissionsOrganizationHooks) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationHooks from json.
func (o *OptAppPermissionsOrganizationHooks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationHooks to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationHooks`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationPackages as json.
func (o OptAppPermissionsOrganizationPackages) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationPackages from json.
func (o *OptAppPermissionsOrganizationPackages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationPackages to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationPackages`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationPlan as json.
func (o OptAppPermissionsOrganizationPlan) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationPlan from json.
func (o *OptAppPermissionsOrganizationPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationPlan to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationPlan`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationProjects as json.
func (o OptAppPermissionsOrganizationProjects) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationProjects from json.
func (o *OptAppPermissionsOrganizationProjects) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationProjects to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationProjects`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationSecrets as json.
func (o OptAppPermissionsOrganizationSecrets) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationSecrets from json.
func (o *OptAppPermissionsOrganizationSecrets) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationSecrets to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationSecrets`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationSelfHostedRunners as json.
func (o OptAppPermissionsOrganizationSelfHostedRunners) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationSelfHostedRunners from json.
func (o *OptAppPermissionsOrganizationSelfHostedRunners) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationSelfHostedRunners to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationSelfHostedRunners`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationUserBlocking as json.
func (o OptAppPermissionsOrganizationUserBlocking) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationUserBlocking from json.
func (o *OptAppPermissionsOrganizationUserBlocking) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationUserBlocking to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationUserBlocking`, d.Next())
	}
}

// Encode encodes AppPermissionsPackages as json.
func (o OptAppPermissionsPackages) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsPackages from json.
func (o *OptAppPermissionsPackages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsPackages to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsPackages`, d.Next())
	}
}

// Encode encodes AppPermissionsPages as json.
func (o OptAppPermissionsPages) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsPages from json.
func (o *OptAppPermissionsPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsPages to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsPages`, d.Next())
	}
}

// Encode encodes AppPermissionsPullRequests as json.
func (o OptAppPermissionsPullRequests) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsPullRequests from json.
func (o *OptAppPermissionsPullRequests) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsPullRequests to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsPullRequests`, d.Next())
	}
}

// Encode encodes AppPermissionsRepositoryHooks as json.
func (o OptAppPermissionsRepositoryHooks) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsRepositoryHooks from json.
func (o *OptAppPermissionsRepositoryHooks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsRepositoryHooks to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsRepositoryHooks`, d.Next())
	}
}

// Encode encodes AppPermissionsRepositoryProjects as json.
func (o OptAppPermissionsRepositoryProjects) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsRepositoryProjects from json.
func (o *OptAppPermissionsRepositoryProjects) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsRepositoryProjects to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsRepositoryProjects`, d.Next())
	}
}

// Encode encodes AppPermissionsSecretScanningAlerts as json.
func (o OptAppPermissionsSecretScanningAlerts) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSecretScanningAlerts from json.
func (o *OptAppPermissionsSecretScanningAlerts) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsSecretScanningAlerts to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsSecretScanningAlerts`, d.Next())
	}
}

// Encode encodes AppPermissionsSecrets as json.
func (o OptAppPermissionsSecrets) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSecrets from json.
func (o *OptAppPermissionsSecrets) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsSecrets to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsSecrets`, d.Next())
	}
}

// Encode encodes AppPermissionsSecurityEvents as json.
func (o OptAppPermissionsSecurityEvents) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSecurityEvents from json.
func (o *OptAppPermissionsSecurityEvents) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsSecurityEvents to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsSecurityEvents`, d.Next())
	}
}

// Encode encodes AppPermissionsSingleFile as json.
func (o OptAppPermissionsSingleFile) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSingleFile from json.
func (o *OptAppPermissionsSingleFile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsSingleFile to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsSingleFile`, d.Next())
	}
}

// Encode encodes AppPermissionsStatuses as json.
func (o OptAppPermissionsStatuses) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsStatuses from json.
func (o *OptAppPermissionsStatuses) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsStatuses to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsStatuses`, d.Next())
	}
}

// Encode encodes AppPermissionsTeamDiscussions as json.
func (o OptAppPermissionsTeamDiscussions) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsTeamDiscussions from json.
func (o *OptAppPermissionsTeamDiscussions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsTeamDiscussions to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsTeamDiscussions`, d.Next())
	}
}

// Encode encodes AppPermissionsVulnerabilityAlerts as json.
func (o OptAppPermissionsVulnerabilityAlerts) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsVulnerabilityAlerts from json.
func (o *OptAppPermissionsVulnerabilityAlerts) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsVulnerabilityAlerts to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsVulnerabilityAlerts`, d.Next())
	}
}

// Encode encodes AppPermissionsWorkflows as json.
func (o OptAppPermissionsWorkflows) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsWorkflows from json.
func (o *OptAppPermissionsWorkflows) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsWorkflows to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsWorkflows`, d.Next())
	}
}

// Encode encodes AppsCreateFromManifestReq as json.
func (o OptAppsCreateFromManifestReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes AppsCreateFromManifestReq from json.
func (o *OptAppsCreateFromManifestReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppsCreateFromManifestReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppsCreateFromManifestReq`, d.Next())
	}
}

// Encode encodes AppsCreateInstallationAccessTokenReq as json.
func (o OptAppsCreateInstallationAccessTokenReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes AppsCreateInstallationAccessTokenReq from json.
func (o *OptAppsCreateInstallationAccessTokenReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppsCreateInstallationAccessTokenReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppsCreateInstallationAccessTokenReq`, d.Next())
	}
}

// Encode encodes AppsListAccountsForPlanDirection as json.
func (o OptAppsListAccountsForPlanDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppsListAccountsForPlanDirection from json.
func (o *OptAppsListAccountsForPlanDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppsListAccountsForPlanDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppsListAccountsForPlanDirection`, d.Next())
	}
}

// Encode encodes AppsListAccountsForPlanSort as json.
func (o OptAppsListAccountsForPlanSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppsListAccountsForPlanSort from json.
func (o *OptAppsListAccountsForPlanSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppsListAccountsForPlanSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppsListAccountsForPlanSort`, d.Next())
	}
}

// Encode encodes AppsListAccountsForPlanStubbedDirection as json.
func (o OptAppsListAccountsForPlanStubbedDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppsListAccountsForPlanStubbedDirection from json.
func (o *OptAppsListAccountsForPlanStubbedDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppsListAccountsForPlanStubbedDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppsListAccountsForPlanStubbedDirection`, d.Next())
	}
}

// Encode encodes AppsListAccountsForPlanStubbedSort as json.
func (o OptAppsListAccountsForPlanStubbedSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AppsListAccountsForPlanStubbedSort from json.
func (o *OptAppsListAccountsForPlanStubbedSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppsListAccountsForPlanStubbedSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppsListAccountsForPlanStubbedSort`, d.Next())
	}
}

// Encode encodes AppsUpdateWebhookConfigForAppReq as json.
func (o OptAppsUpdateWebhookConfigForAppReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes AppsUpdateWebhookConfigForAppReq from json.
func (o *OptAppsUpdateWebhookConfigForAppReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppsUpdateWebhookConfigForAppReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppsUpdateWebhookConfigForAppReq`, d.Next())
	}
}

// Encode encodes AuditLogEventActorLocation as json.
func (o OptAuditLogEventActorLocation) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes AuditLogEventActorLocation from json.
func (o *OptAuditLogEventActorLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAuditLogEventActorLocation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAuditLogEventActorLocation`, d.Next())
	}
}

// Encode encodes AuthenticationTokenRepositorySelection as json.
func (o OptAuthenticationTokenRepositorySelection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AuthenticationTokenRepositorySelection from json.
func (o *OptAuthenticationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAuthenticationTokenRepositorySelection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAuthenticationTokenRepositorySelection`, d.Next())
	}
}

// Encode encodes AuthorAssociation as json.
func (o OptAuthorAssociation) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes AuthorAssociation from json.
func (o *OptAuthorAssociation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAuthorAssociation to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAuthorAssociation`, d.Next())
	}
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Writer) {
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBool to nil`)
	}
	switch d.Next() {
	case jx.Bool:
		o.Set = true
		v, err := d.Bool()
		if err != nil {
			return err
		}
		o.Value = bool(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBool`, d.Next())
	}
}

// Encode encodes BranchProtection as json.
func (o OptBranchProtection) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes BranchProtection from json.
func (o *OptBranchProtection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchProtection to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchProtection`, d.Next())
	}
}

// Encode encodes BranchProtectionAllowDeletions as json.
func (o OptBranchProtectionAllowDeletions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionAllowDeletions from json.
func (o *OptBranchProtectionAllowDeletions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchProtectionAllowDeletions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchProtectionAllowDeletions`, d.Next())
	}
}

// Encode encodes BranchProtectionAllowForcePushes as json.
func (o OptBranchProtectionAllowForcePushes) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionAllowForcePushes from json.
func (o *OptBranchProtectionAllowForcePushes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchProtectionAllowForcePushes to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchProtectionAllowForcePushes`, d.Next())
	}
}

// Encode encodes BranchProtectionRequiredConversationResolution as json.
func (o OptBranchProtectionRequiredConversationResolution) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredConversationResolution from json.
func (o *OptBranchProtectionRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchProtectionRequiredConversationResolution to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchProtectionRequiredConversationResolution`, d.Next())
	}
}

// Encode encodes BranchProtectionRequiredLinearHistory as json.
func (o OptBranchProtectionRequiredLinearHistory) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredLinearHistory from json.
func (o *OptBranchProtectionRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchProtectionRequiredLinearHistory to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchProtectionRequiredLinearHistory`, d.Next())
	}
}

// Encode encodes BranchProtectionRequiredSignatures as json.
func (o OptBranchProtectionRequiredSignatures) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredSignatures from json.
func (o *OptBranchProtectionRequiredSignatures) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchProtectionRequiredSignatures to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchProtectionRequiredSignatures`, d.Next())
	}
}

// Encode encodes BranchProtectionRequiredStatusChecks as json.
func (o OptBranchProtectionRequiredStatusChecks) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredStatusChecks from json.
func (o *OptBranchProtectionRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchProtectionRequiredStatusChecks to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchProtectionRequiredStatusChecks`, d.Next())
	}
}

// Encode encodes BranchRestrictionPolicy as json.
func (o OptBranchRestrictionPolicy) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes BranchRestrictionPolicy from json.
func (o *OptBranchRestrictionPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchRestrictionPolicy to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchRestrictionPolicy`, d.Next())
	}
}

// Encode encodes BranchRestrictionPolicyAppsItemOwner as json.
func (o OptBranchRestrictionPolicyAppsItemOwner) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes BranchRestrictionPolicyAppsItemOwner from json.
func (o *OptBranchRestrictionPolicyAppsItemOwner) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchRestrictionPolicyAppsItemOwner to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchRestrictionPolicyAppsItemOwner`, d.Next())
	}
}

// Encode encodes BranchRestrictionPolicyAppsItemPermissions as json.
func (o OptBranchRestrictionPolicyAppsItemPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes BranchRestrictionPolicyAppsItemPermissions from json.
func (o *OptBranchRestrictionPolicyAppsItemPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchRestrictionPolicyAppsItemPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchRestrictionPolicyAppsItemPermissions`, d.Next())
	}
}

// Encode encodes ChecksListForRefFilter as json.
func (o OptChecksListForRefFilter) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ChecksListForRefFilter from json.
func (o *OptChecksListForRefFilter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChecksListForRefFilter to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChecksListForRefFilter`, d.Next())
	}
}

// Encode encodes ChecksListForRefStatus as json.
func (o OptChecksListForRefStatus) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ChecksListForRefStatus from json.
func (o *OptChecksListForRefStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChecksListForRefStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChecksListForRefStatus`, d.Next())
	}
}

// Encode encodes ChecksListForSuiteFilter as json.
func (o OptChecksListForSuiteFilter) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ChecksListForSuiteFilter from json.
func (o *OptChecksListForSuiteFilter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChecksListForSuiteFilter to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChecksListForSuiteFilter`, d.Next())
	}
}

// Encode encodes ChecksListForSuiteStatus as json.
func (o OptChecksListForSuiteStatus) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ChecksListForSuiteStatus from json.
func (o *OptChecksListForSuiteStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChecksListForSuiteStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChecksListForSuiteStatus`, d.Next())
	}
}

// Encode encodes CodeOfConduct as json.
func (o OptCodeOfConduct) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes CodeOfConduct from json.
func (o *OptCodeOfConduct) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeOfConduct to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeOfConduct`, d.Next())
	}
}

// Encode encodes CodeOfConductSimple as json.
func (o OptCodeOfConductSimple) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes CodeOfConductSimple from json.
func (o *OptCodeOfConductSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeOfConductSimple to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeOfConductSimple`, d.Next())
	}
}

// Encode encodes CodeScanningAlertEnvironment as json.
func (o OptCodeScanningAlertEnvironment) Encode(e *jx.Writer) {
}

// Decode decodes CodeScanningAlertEnvironment from json.
func (o *OptCodeScanningAlertEnvironment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAlertEnvironment to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAlertEnvironment`, d.Next())
	}
}

// Encode encodes CodeScanningAlertInstanceMessage as json.
func (o OptCodeScanningAlertInstanceMessage) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAlertInstanceMessage from json.
func (o *OptCodeScanningAlertInstanceMessage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAlertInstanceMessage to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAlertInstanceMessage`, d.Next())
	}
}

// Encode encodes CodeScanningAlertLocation as json.
func (o OptCodeScanningAlertLocation) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAlertLocation from json.
func (o *OptCodeScanningAlertLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAlertLocation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAlertLocation`, d.Next())
	}
}

// Encode encodes CodeScanningAlertState as json.
func (o OptCodeScanningAlertState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertState from json.
func (o *OptCodeScanningAlertState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAlertState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAlertState`, d.Next())
	}
}

// Encode encodes CodeScanningAnalysisAnalysisKey as json.
func (o OptCodeScanningAnalysisAnalysisKey) Encode(e *jx.Writer) {
}

// Decode decodes CodeScanningAnalysisAnalysisKey from json.
func (o *OptCodeScanningAnalysisAnalysisKey) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAnalysisAnalysisKey to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAnalysisAnalysisKey`, d.Next())
	}
}

// Encode encodes CodeScanningAnalysisCategory as json.
func (o OptCodeScanningAnalysisCategory) Encode(e *jx.Writer) {
}

// Decode decodes CodeScanningAnalysisCategory from json.
func (o *OptCodeScanningAnalysisCategory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAnalysisCategory to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAnalysisCategory`, d.Next())
	}
}

// Encode encodes CodeScanningAnalysisSarifID as json.
func (o OptCodeScanningAnalysisSarifID) Encode(e *jx.Writer) {
}

// Decode decodes CodeScanningAnalysisSarifID from json.
func (o *OptCodeScanningAnalysisSarifID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAnalysisSarifID to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAnalysisSarifID`, d.Next())
	}
}

// Encode encodes CodeScanningAnalysisToolName as json.
func (o OptCodeScanningAnalysisToolName) Encode(e *jx.Writer) {
}

// Decode decodes CodeScanningAnalysisToolName from json.
func (o *OptCodeScanningAnalysisToolName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAnalysisToolName to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAnalysisToolName`, d.Next())
	}
}

// Encode encodes CodeScanningRef as json.
func (o OptCodeScanningRef) Encode(e *jx.Writer) {
}

// Decode decodes CodeScanningRef from json.
func (o *OptCodeScanningRef) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningRef to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningRef`, d.Next())
	}
}

// Encode encodes CodeScanningSarifsStatusProcessingStatus as json.
func (o OptCodeScanningSarifsStatusProcessingStatus) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningSarifsStatusProcessingStatus from json.
func (o *OptCodeScanningSarifsStatusProcessingStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningSarifsStatusProcessingStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningSarifsStatusProcessingStatus`, d.Next())
	}
}

// Encode encodes CollaboratorPermissions as json.
func (o OptCollaboratorPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes CollaboratorPermissions from json.
func (o *OptCollaboratorPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCollaboratorPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCollaboratorPermissions`, d.Next())
	}
}

// Encode encodes CommitStats as json.
func (o OptCommitStats) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes CommitStats from json.
func (o *OptCommitStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCommitStats to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCommitStats`, d.Next())
	}
}

// Encode encodes DeploymentReviewerType as json.
func (o OptDeploymentReviewerType) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes DeploymentReviewerType from json.
func (o *OptDeploymentReviewerType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptDeploymentReviewerType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptDeploymentReviewerType`, d.Next())
	}
}

// Encode encodes DeploymentSimple as json.
func (o OptDeploymentSimple) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes DeploymentSimple from json.
func (o *OptDeploymentSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptDeploymentSimple to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptDeploymentSimple`, d.Next())
	}
}

// Encode encodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (o OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (o *OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility`, d.Next())
	}
}

// Encode encodes EnterpriseAdminGetAuditLogInclude as json.
func (o OptEnterpriseAdminGetAuditLogInclude) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes EnterpriseAdminGetAuditLogInclude from json.
func (o *OptEnterpriseAdminGetAuditLogInclude) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptEnterpriseAdminGetAuditLogInclude to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptEnterpriseAdminGetAuditLogInclude`, d.Next())
	}
}

// Encode encodes EnterpriseAdminGetAuditLogOrder as json.
func (o OptEnterpriseAdminGetAuditLogOrder) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes EnterpriseAdminGetAuditLogOrder from json.
func (o *OptEnterpriseAdminGetAuditLogOrder) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptEnterpriseAdminGetAuditLogOrder to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptEnterpriseAdminGetAuditLogOrder`, d.Next())
	}
}

// Encode encodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue as json.
func (o OptEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) Encode(e *jx.Writer) {
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue from json.
func (o *OptEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue`, d.Next())
	}
}

// Encode encodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq as json.
func (o OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq from json.
func (o *OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq`, d.Next())
	}
}

// Encode encodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (o OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (o *OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility`, d.Next())
	}
}

// Encode encodes FileCommitCommitAuthor as json.
func (o OptFileCommitCommitAuthor) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitAuthor from json.
func (o *OptFileCommitCommitAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFileCommitCommitAuthor to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFileCommitCommitAuthor`, d.Next())
	}
}

// Encode encodes FileCommitCommitCommitter as json.
func (o OptFileCommitCommitCommitter) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitCommitter from json.
func (o *OptFileCommitCommitCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFileCommitCommitCommitter to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFileCommitCommitCommitter`, d.Next())
	}
}

// Encode encodes FileCommitCommitTree as json.
func (o OptFileCommitCommitTree) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitTree from json.
func (o *OptFileCommitCommitTree) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFileCommitCommitTree to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFileCommitCommitTree`, d.Next())
	}
}

// Encode encodes FileCommitCommitVerification as json.
func (o OptFileCommitCommitVerification) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitVerification from json.
func (o *OptFileCommitCommitVerification) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFileCommitCommitVerification to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFileCommitCommitVerification`, d.Next())
	}
}

// Encode encodes FileCommitContentLinks as json.
func (o OptFileCommitContentLinks) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes FileCommitContentLinks from json.
func (o *OptFileCommitContentLinks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFileCommitContentLinks to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFileCommitContentLinks`, d.Next())
	}
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Writer) {
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFloat64 to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Float64()
		if err != nil {
			return err
		}
		o.Value = float64(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFloat64`, d.Next())
	}
}

// Encode encodes ForbiddenGistBlock as json.
func (o OptForbiddenGistBlock) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ForbiddenGistBlock from json.
func (o *OptForbiddenGistBlock) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptForbiddenGistBlock to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptForbiddenGistBlock`, d.Next())
	}
}

// Encode encodes FullRepositoryPermissions as json.
func (o OptFullRepositoryPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes FullRepositoryPermissions from json.
func (o *OptFullRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFullRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFullRepositoryPermissions`, d.Next())
	}
}

// Encode encodes FullRepositorySecurityAndAnalysisAdvancedSecurity as json.
func (o OptFullRepositorySecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurity from json.
func (o *OptFullRepositorySecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFullRepositorySecurityAndAnalysisAdvancedSecurity to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFullRepositorySecurityAndAnalysisAdvancedSecurity`, d.Next())
	}
}

// Encode encodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus as json.
func (o OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus from json.
func (o *OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus`, d.Next())
	}
}

// Encode encodes FullRepositorySecurityAndAnalysisSecretScanning as json.
func (o OptFullRepositorySecurityAndAnalysisSecretScanning) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanning from json.
func (o *OptFullRepositorySecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFullRepositorySecurityAndAnalysisSecretScanning to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFullRepositorySecurityAndAnalysisSecretScanning`, d.Next())
	}
}

// Encode encodes FullRepositorySecurityAndAnalysisSecretScanningStatus as json.
func (o OptFullRepositorySecurityAndAnalysisSecretScanningStatus) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanningStatus from json.
func (o *OptFullRepositorySecurityAndAnalysisSecretScanningStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFullRepositorySecurityAndAnalysisSecretScanningStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFullRepositorySecurityAndAnalysisSecretScanningStatus`, d.Next())
	}
}

// Encode encodes GistHistoryChangeStatus as json.
func (o OptGistHistoryChangeStatus) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes GistHistoryChangeStatus from json.
func (o *OptGistHistoryChangeStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGistHistoryChangeStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGistHistoryChangeStatus`, d.Next())
	}
}

// Encode encodes GistsCreateReqPublic as json.
func (o OptGistsCreateReqPublic) Encode(e *jx.Writer) {
}

// Decode decodes GistsCreateReqPublic from json.
func (o *OptGistsCreateReqPublic) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGistsCreateReqPublic to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGistsCreateReqPublic`, d.Next())
	}
}

// Encode encodes GitCreateCommitReqAuthor as json.
func (o OptGitCreateCommitReqAuthor) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes GitCreateCommitReqAuthor from json.
func (o *OptGitCreateCommitReqAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGitCreateCommitReqAuthor to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGitCreateCommitReqAuthor`, d.Next())
	}
}

// Encode encodes GitCreateCommitReqCommitter as json.
func (o OptGitCreateCommitReqCommitter) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes GitCreateCommitReqCommitter from json.
func (o *OptGitCreateCommitReqCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGitCreateCommitReqCommitter to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGitCreateCommitReqCommitter`, d.Next())
	}
}

// Encode encodes GitCreateTagReqTagger as json.
func (o OptGitCreateTagReqTagger) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes GitCreateTagReqTagger from json.
func (o *OptGitCreateTagReqTagger) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGitCreateTagReqTagger to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGitCreateTagReqTagger`, d.Next())
	}
}

// Encode encodes GitCreateTreeReqTreeItemMode as json.
func (o OptGitCreateTreeReqTreeItemMode) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes GitCreateTreeReqTreeItemMode from json.
func (o *OptGitCreateTreeReqTreeItemMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGitCreateTreeReqTreeItemMode to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGitCreateTreeReqTreeItemMode`, d.Next())
	}
}

// Encode encodes GitCreateTreeReqTreeItemType as json.
func (o OptGitCreateTreeReqTreeItemType) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes GitCreateTreeReqTreeItemType from json.
func (o *OptGitCreateTreeReqTreeItemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGitCreateTreeReqTreeItemType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGitCreateTreeReqTreeItemType`, d.Next())
	}
}

// Encode encodes InstallationTokenRepositorySelection as json.
func (o OptInstallationTokenRepositorySelection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes InstallationTokenRepositorySelection from json.
func (o *OptInstallationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInstallationTokenRepositorySelection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInstallationTokenRepositorySelection`, d.Next())
	}
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Writer) {
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInt to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int()
		if err != nil {
			return err
		}
		o.Value = int(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInt`, d.Next())
	}
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Writer) {
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInt64 to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int64()
		if err != nil {
			return err
		}
		o.Value = int64(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInt64`, d.Next())
	}
}

// Encode encodes InteractionExpiry as json.
func (o OptInteractionExpiry) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes InteractionExpiry from json.
func (o *OptInteractionExpiry) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInteractionExpiry to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInteractionExpiry`, d.Next())
	}
}

// Encode encodes IssueComment as json.
func (o OptIssueComment) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssueComment from json.
func (o *OptIssueComment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueComment to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueComment`, d.Next())
	}
}

// Encode encodes IssueEventDismissedReview as json.
func (o OptIssueEventDismissedReview) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssueEventDismissedReview from json.
func (o *OptIssueEventDismissedReview) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueEventDismissedReview to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueEventDismissedReview`, d.Next())
	}
}

// Encode encodes IssueEventLabel as json.
func (o OptIssueEventLabel) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssueEventLabel from json.
func (o *OptIssueEventLabel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueEventLabel to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueEventLabel`, d.Next())
	}
}

// Encode encodes IssueEventMilestone as json.
func (o OptIssueEventMilestone) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssueEventMilestone from json.
func (o *OptIssueEventMilestone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueEventMilestone to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueEventMilestone`, d.Next())
	}
}

// Encode encodes IssueEventProjectCard as json.
func (o OptIssueEventProjectCard) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssueEventProjectCard from json.
func (o *OptIssueEventProjectCard) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueEventProjectCard to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueEventProjectCard`, d.Next())
	}
}

// Encode encodes IssueEventRename as json.
func (o OptIssueEventRename) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssueEventRename from json.
func (o *OptIssueEventRename) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueEventRename to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueEventRename`, d.Next())
	}
}

// Encode encodes IssuePullRequest as json.
func (o OptIssuePullRequest) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssuePullRequest from json.
func (o *OptIssuePullRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuePullRequest to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuePullRequest`, d.Next())
	}
}

// Encode encodes IssueSearchResultItemPullRequest as json.
func (o OptIssueSearchResultItemPullRequest) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssueSearchResultItemPullRequest from json.
func (o *OptIssueSearchResultItemPullRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueSearchResultItemPullRequest to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueSearchResultItemPullRequest`, d.Next())
	}
}

// Encode encodes IssueSimple as json.
func (o OptIssueSimple) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssueSimple from json.
func (o *OptIssueSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueSimple to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueSimple`, d.Next())
	}
}

// Encode encodes IssueSimplePullRequest as json.
func (o OptIssueSimplePullRequest) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssueSimplePullRequest from json.
func (o *OptIssueSimplePullRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueSimplePullRequest to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueSimplePullRequest`, d.Next())
	}
}

// Encode encodes IssuesAddAssigneesReq as json.
func (o OptIssuesAddAssigneesReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssuesAddAssigneesReq from json.
func (o *OptIssuesAddAssigneesReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesAddAssigneesReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesAddAssigneesReq`, d.Next())
	}
}

// Encode encodes IssuesCreateMilestoneReqState as json.
func (o OptIssuesCreateMilestoneReqState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesCreateMilestoneReqState from json.
func (o *OptIssuesCreateMilestoneReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesCreateMilestoneReqState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesCreateMilestoneReqState`, d.Next())
	}
}

// Encode encodes IssuesListCommentsForRepoDirection as json.
func (o OptIssuesListCommentsForRepoDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListCommentsForRepoDirection from json.
func (o *OptIssuesListCommentsForRepoDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListCommentsForRepoDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListCommentsForRepoDirection`, d.Next())
	}
}

// Encode encodes IssuesListCommentsForRepoSort as json.
func (o OptIssuesListCommentsForRepoSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListCommentsForRepoSort from json.
func (o *OptIssuesListCommentsForRepoSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListCommentsForRepoSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListCommentsForRepoSort`, d.Next())
	}
}

// Encode encodes IssuesListDirection as json.
func (o OptIssuesListDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListDirection from json.
func (o *OptIssuesListDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListDirection`, d.Next())
	}
}

// Encode encodes IssuesListFilter as json.
func (o OptIssuesListFilter) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListFilter from json.
func (o *OptIssuesListFilter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListFilter to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListFilter`, d.Next())
	}
}

// Encode encodes IssuesListForAuthenticatedUserDirection as json.
func (o OptIssuesListForAuthenticatedUserDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListForAuthenticatedUserDirection from json.
func (o *OptIssuesListForAuthenticatedUserDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListForAuthenticatedUserDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListForAuthenticatedUserDirection`, d.Next())
	}
}

// Encode encodes IssuesListForAuthenticatedUserFilter as json.
func (o OptIssuesListForAuthenticatedUserFilter) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListForAuthenticatedUserFilter from json.
func (o *OptIssuesListForAuthenticatedUserFilter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListForAuthenticatedUserFilter to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListForAuthenticatedUserFilter`, d.Next())
	}
}

// Encode encodes IssuesListForAuthenticatedUserSort as json.
func (o OptIssuesListForAuthenticatedUserSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListForAuthenticatedUserSort from json.
func (o *OptIssuesListForAuthenticatedUserSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListForAuthenticatedUserSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListForAuthenticatedUserSort`, d.Next())
	}
}

// Encode encodes IssuesListForAuthenticatedUserState as json.
func (o OptIssuesListForAuthenticatedUserState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListForAuthenticatedUserState from json.
func (o *OptIssuesListForAuthenticatedUserState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListForAuthenticatedUserState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListForAuthenticatedUserState`, d.Next())
	}
}

// Encode encodes IssuesListForOrgDirection as json.
func (o OptIssuesListForOrgDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListForOrgDirection from json.
func (o *OptIssuesListForOrgDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListForOrgDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListForOrgDirection`, d.Next())
	}
}

// Encode encodes IssuesListForOrgFilter as json.
func (o OptIssuesListForOrgFilter) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListForOrgFilter from json.
func (o *OptIssuesListForOrgFilter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListForOrgFilter to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListForOrgFilter`, d.Next())
	}
}

// Encode encodes IssuesListForOrgSort as json.
func (o OptIssuesListForOrgSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListForOrgSort from json.
func (o *OptIssuesListForOrgSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListForOrgSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListForOrgSort`, d.Next())
	}
}

// Encode encodes IssuesListForOrgState as json.
func (o OptIssuesListForOrgState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListForOrgState from json.
func (o *OptIssuesListForOrgState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListForOrgState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListForOrgState`, d.Next())
	}
}

// Encode encodes IssuesListForRepoDirection as json.
func (o OptIssuesListForRepoDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListForRepoDirection from json.
func (o *OptIssuesListForRepoDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListForRepoDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListForRepoDirection`, d.Next())
	}
}

// Encode encodes IssuesListForRepoSort as json.
func (o OptIssuesListForRepoSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListForRepoSort from json.
func (o *OptIssuesListForRepoSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListForRepoSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListForRepoSort`, d.Next())
	}
}

// Encode encodes IssuesListForRepoState as json.
func (o OptIssuesListForRepoState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListForRepoState from json.
func (o *OptIssuesListForRepoState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListForRepoState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListForRepoState`, d.Next())
	}
}

// Encode encodes IssuesListMilestonesDirection as json.
func (o OptIssuesListMilestonesDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListMilestonesDirection from json.
func (o *OptIssuesListMilestonesDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListMilestonesDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListMilestonesDirection`, d.Next())
	}
}

// Encode encodes IssuesListMilestonesSort as json.
func (o OptIssuesListMilestonesSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListMilestonesSort from json.
func (o *OptIssuesListMilestonesSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListMilestonesSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListMilestonesSort`, d.Next())
	}
}

// Encode encodes IssuesListMilestonesState as json.
func (o OptIssuesListMilestonesState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListMilestonesState from json.
func (o *OptIssuesListMilestonesState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListMilestonesState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListMilestonesState`, d.Next())
	}
}

// Encode encodes IssuesListSort as json.
func (o OptIssuesListSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListSort from json.
func (o *OptIssuesListSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListSort`, d.Next())
	}
}

// Encode encodes IssuesListState as json.
func (o OptIssuesListState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListState from json.
func (o *OptIssuesListState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListState`, d.Next())
	}
}

// Encode encodes IssuesLockReq as json.
func (o OptIssuesLockReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssuesLockReq from json.
func (o *OptIssuesLockReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesLockReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesLockReq`, d.Next())
	}
}

// Encode encodes IssuesLockReqLockReason as json.
func (o OptIssuesLockReqLockReason) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesLockReqLockReason from json.
func (o *OptIssuesLockReqLockReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesLockReqLockReason to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesLockReqLockReason`, d.Next())
	}
}

// Encode encodes IssuesRemoveAssigneesReq as json.
func (o OptIssuesRemoveAssigneesReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssuesRemoveAssigneesReq from json.
func (o *OptIssuesRemoveAssigneesReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesRemoveAssigneesReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesRemoveAssigneesReq`, d.Next())
	}
}

// Encode encodes IssuesUpdateLabelReq as json.
func (o OptIssuesUpdateLabelReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssuesUpdateLabelReq from json.
func (o *OptIssuesUpdateLabelReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesUpdateLabelReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesUpdateLabelReq`, d.Next())
	}
}

// Encode encodes IssuesUpdateMilestoneReq as json.
func (o OptIssuesUpdateMilestoneReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssuesUpdateMilestoneReq from json.
func (o *OptIssuesUpdateMilestoneReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesUpdateMilestoneReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesUpdateMilestoneReq`, d.Next())
	}
}

// Encode encodes IssuesUpdateMilestoneReqState as json.
func (o OptIssuesUpdateMilestoneReqState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesUpdateMilestoneReqState from json.
func (o *OptIssuesUpdateMilestoneReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesUpdateMilestoneReqState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesUpdateMilestoneReqState`, d.Next())
	}
}

// Encode encodes IssuesUpdateReq as json.
func (o OptIssuesUpdateReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes IssuesUpdateReq from json.
func (o *OptIssuesUpdateReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesUpdateReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesUpdateReq`, d.Next())
	}
}

// Encode encodes IssuesUpdateReqState as json.
func (o OptIssuesUpdateReqState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesUpdateReqState from json.
func (o *OptIssuesUpdateReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesUpdateReqState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesUpdateReqState`, d.Next())
	}
}

// Encode encodes LinkWithType as json.
func (o OptLinkWithType) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes LinkWithType from json.
func (o *OptLinkWithType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptLinkWithType to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptLinkWithType`, d.Next())
	}
}

// Encode encodes MarkdownRenderReqMode as json.
func (o OptMarkdownRenderReqMode) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes MarkdownRenderReqMode from json.
func (o *OptMarkdownRenderReqMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMarkdownRenderReqMode to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMarkdownRenderReqMode`, d.Next())
	}
}

// Encode encodes MarketplaceListingPlan as json.
func (o OptMarketplaceListingPlan) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes MarketplaceListingPlan from json.
func (o *OptMarketplaceListingPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMarketplaceListingPlan to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMarketplaceListingPlan`, d.Next())
	}
}

// Encode encodes MergedUpstreamMergeType as json.
func (o OptMergedUpstreamMergeType) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes MergedUpstreamMergeType from json.
func (o *OptMergedUpstreamMergeType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMergedUpstreamMergeType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMergedUpstreamMergeType`, d.Next())
	}
}

// Encode encodes MigrationsMapCommitAuthorReq as json.
func (o OptMigrationsMapCommitAuthorReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes MigrationsMapCommitAuthorReq from json.
func (o *OptMigrationsMapCommitAuthorReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMigrationsMapCommitAuthorReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMigrationsMapCommitAuthorReq`, d.Next())
	}
}

// Encode encodes MigrationsStartImportReqVcs as json.
func (o OptMigrationsStartImportReqVcs) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes MigrationsStartImportReqVcs from json.
func (o *OptMigrationsStartImportReqVcs) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMigrationsStartImportReqVcs to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMigrationsStartImportReqVcs`, d.Next())
	}
}

// Encode encodes MigrationsUpdateImportReq as json.
func (o OptMigrationsUpdateImportReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes MigrationsUpdateImportReq from json.
func (o *OptMigrationsUpdateImportReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMigrationsUpdateImportReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMigrationsUpdateImportReq`, d.Next())
	}
}

// Encode encodes MinimalRepository as json.
func (o OptMinimalRepository) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes MinimalRepository from json.
func (o *OptMinimalRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMinimalRepository to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMinimalRepository`, d.Next())
	}
}

// Encode encodes MinimalRepositoryPermissions as json.
func (o OptMinimalRepositoryPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes MinimalRepositoryPermissions from json.
func (o *OptMinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMinimalRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMinimalRepositoryPermissions`, d.Next())
	}
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilBool to nil`)
	}
	switch d.Next() {
	case jx.Bool:
		o.Set = true
		o.Null = false
		v, err := d.Bool()
		if err != nil {
			return err
		}
		o.Value = bool(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilBool`, d.Next())
	}
}

// Encode encodes CodeScanningAlertDismissedReason as json.
func (o OptNilCodeScanningAlertDismissedReason) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertDismissedReason from json.
func (o *OptNilCodeScanningAlertDismissedReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilCodeScanningAlertDismissedReason to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertDismissedReason
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilCodeScanningAlertDismissedReason`, d.Next())
	}
}

// Encode encodes CodeScanningAlertRuleSecuritySeverityLevel as json.
func (o OptNilCodeScanningAlertRuleSecuritySeverityLevel) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertRuleSecuritySeverityLevel from json.
func (o *OptNilCodeScanningAlertRuleSecuritySeverityLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilCodeScanningAlertRuleSecuritySeverityLevel to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertRuleSecuritySeverityLevel
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilCodeScanningAlertRuleSecuritySeverityLevel`, d.Next())
	}
}

// Encode encodes CodeScanningAlertRuleSeverity as json.
func (o OptNilCodeScanningAlertRuleSeverity) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertRuleSeverity from json.
func (o *OptNilCodeScanningAlertRuleSeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilCodeScanningAlertRuleSeverity to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertRuleSeverity
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilCodeScanningAlertRuleSeverity`, d.Next())
	}
}

// Encode encodes CodeScanningAlertRuleSummarySeverity as json.
func (o OptNilCodeScanningAlertRuleSummarySeverity) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertRuleSummarySeverity from json.
func (o *OptNilCodeScanningAlertRuleSummarySeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilCodeScanningAlertRuleSummarySeverity to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertRuleSummarySeverity
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilCodeScanningAlertRuleSummarySeverity`, d.Next())
	}
}

// Encode encodes CodeScanningAnalysisToolGUID as json.
func (o OptNilCodeScanningAnalysisToolGUID) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes CodeScanningAnalysisToolGUID from json.
func (o *OptNilCodeScanningAnalysisToolGUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilCodeScanningAnalysisToolGUID to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAnalysisToolGUID
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilCodeScanningAnalysisToolGUID`, d.Next())
	}
}

// Encode encodes CodeScanningAnalysisToolVersion as json.
func (o OptNilCodeScanningAnalysisToolVersion) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes CodeScanningAnalysisToolVersion from json.
func (o *OptNilCodeScanningAnalysisToolVersion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilCodeScanningAnalysisToolVersion to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAnalysisToolVersion
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilCodeScanningAnalysisToolVersion`, d.Next())
	}
}

// Encode encodes DeploymentBranchPolicy as json.
func (o OptNilDeploymentBranchPolicy) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeploymentBranchPolicy from json.
func (o *OptNilDeploymentBranchPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilDeploymentBranchPolicy to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v DeploymentBranchPolicy
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilDeploymentBranchPolicy`, d.Next())
	}
}

// Encode encodes FullRepositorySecurityAndAnalysis as json.
func (o OptNilFullRepositorySecurityAndAnalysis) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FullRepositorySecurityAndAnalysis from json.
func (o *OptNilFullRepositorySecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilFullRepositorySecurityAndAnalysis to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v FullRepositorySecurityAndAnalysis
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilFullRepositorySecurityAndAnalysis`, d.Next())
	}
}

// Encode encodes []GistHistory as json.
func (o OptNilGistHistoryArray) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []GistHistory from json.
func (o *OptNilGistHistoryArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilGistHistoryArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []GistHistory
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilGistHistoryArray`, d.Next())
	}
}

// Encode encodes GistSimpleForkOf as json.
func (o OptNilGistSimpleForkOf) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GistSimpleForkOf from json.
func (o *OptNilGistSimpleForkOf) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilGistSimpleForkOf to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v GistSimpleForkOf
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilGistSimpleForkOf`, d.Next())
	}
}

// Encode encodes []GistSimpleForksItem as json.
func (o OptNilGistSimpleForksItemArray) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []GistSimpleForksItem from json.
func (o *OptNilGistSimpleForksItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilGistSimpleForksItemArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []GistSimpleForksItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilGistSimpleForksItemArray`, d.Next())
	}
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilInt to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		o.Null = false
		v, err := d.Int()
		if err != nil {
			return err
		}
		o.Value = int(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilInt`, d.Next())
	}
}

// Encode encodes IssuesCreateReqMilestone as json.
func (o OptNilIssuesCreateReqMilestone) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes IssuesCreateReqMilestone from json.
func (o *OptNilIssuesCreateReqMilestone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilIssuesCreateReqMilestone to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v IssuesCreateReqMilestone
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilIssuesCreateReqMilestone`, d.Next())
	}
}

// Encode encodes IssuesUpdateReqMilestone as json.
func (o OptNilIssuesUpdateReqMilestone) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes IssuesUpdateReqMilestone from json.
func (o *OptNilIssuesUpdateReqMilestone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilIssuesUpdateReqMilestone to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v IssuesUpdateReqMilestone
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilIssuesUpdateReqMilestone`, d.Next())
	}
}

// Encode encodes IssuesUpdateReqTitle as json.
func (o OptNilIssuesUpdateReqTitle) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes IssuesUpdateReqTitle from json.
func (o *OptNilIssuesUpdateReqTitle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilIssuesUpdateReqTitle to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v IssuesUpdateReqTitle
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilIssuesUpdateReqTitle`, d.Next())
	}
}

// Encode encodes MarketplacePurchaseMarketplacePendingChange as json.
func (o OptNilMarketplacePurchaseMarketplacePendingChange) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MarketplacePurchaseMarketplacePendingChange from json.
func (o *OptNilMarketplacePurchaseMarketplacePendingChange) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilMarketplacePurchaseMarketplacePendingChange to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v MarketplacePurchaseMarketplacePendingChange
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilMarketplacePurchaseMarketplacePendingChange`, d.Next())
	}
}

// Encode encodes MinimalRepositoryLicense as json.
func (o OptNilMinimalRepositoryLicense) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MinimalRepositoryLicense from json.
func (o *OptNilMinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilMinimalRepositoryLicense to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v MinimalRepositoryLicense
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilMinimalRepositoryLicense`, d.Next())
	}
}

// Encode encodes NullableIntegration as json.
func (o OptNilNullableIntegration) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableIntegration from json.
func (o *OptNilNullableIntegration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableIntegration to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableIntegration
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableIntegration`, d.Next())
	}
}

// Encode encodes NullableMinimalRepository as json.
func (o OptNilNullableMinimalRepository) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableMinimalRepository from json.
func (o *OptNilNullableMinimalRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableMinimalRepository to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableMinimalRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableMinimalRepository`, d.Next())
	}
}

// Encode encodes NullableMinimalRepositoryLicense as json.
func (o OptNilNullableMinimalRepositoryLicense) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableMinimalRepositoryLicense from json.
func (o *OptNilNullableMinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableMinimalRepositoryLicense to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableMinimalRepositoryLicense
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableMinimalRepositoryLicense`, d.Next())
	}
}

// Encode encodes NullableRepository as json.
func (o OptNilNullableRepository) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableRepository from json.
func (o *OptNilNullableRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableRepository to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableRepository`, d.Next())
	}
}

// Encode encodes NullableRepositoryTemplateRepository as json.
func (o OptNilNullableRepositoryTemplateRepository) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryTemplateRepository from json.
func (o *OptNilNullableRepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableRepositoryTemplateRepository to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableRepositoryTemplateRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableRepositoryTemplateRepository`, d.Next())
	}
}

// Encode encodes NullableScopedInstallation as json.
func (o OptNilNullableScopedInstallation) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableScopedInstallation from json.
func (o *OptNilNullableScopedInstallation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableScopedInstallation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableScopedInstallation
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableScopedInstallation`, d.Next())
	}
}

// Encode encodes NullableSimpleUser as json.
func (o OptNilNullableSimpleUser) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleUser from json.
func (o *OptNilNullableSimpleUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableSimpleUser to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableSimpleUser
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableSimpleUser`, d.Next())
	}
}

// Encode encodes NullableTeamSimple as json.
func (o OptNilNullableTeamSimple) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableTeamSimple from json.
func (o *OptNilNullableTeamSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableTeamSimple to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableTeamSimple
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableTeamSimple`, d.Next())
	}
}

// Encode encodes PageProtectedDomainState as json.
func (o OptNilPageProtectedDomainState) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PageProtectedDomainState from json.
func (o *OptNilPageProtectedDomainState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilPageProtectedDomainState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PageProtectedDomainState
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilPageProtectedDomainState`, d.Next())
	}
}

// Encode encodes PagesHealthCheckAltDomain as json.
func (o OptNilPagesHealthCheckAltDomain) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PagesHealthCheckAltDomain from json.
func (o *OptNilPagesHealthCheckAltDomain) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilPagesHealthCheckAltDomain to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PagesHealthCheckAltDomain
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilPagesHealthCheckAltDomain`, d.Next())
	}
}

// Encode encodes PullRequestReviewCommentStartSide as json.
func (o OptNilPullRequestReviewCommentStartSide) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullRequestReviewCommentStartSide from json.
func (o *OptNilPullRequestReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilPullRequestReviewCommentStartSide to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PullRequestReviewCommentStartSide
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilPullRequestReviewCommentStartSide`, d.Next())
	}
}

// Encode encodes []ReposCreateOrUpdateEnvironmentReqReviewersItem as json.
func (o OptNilReposCreateOrUpdateEnvironmentReqReviewersItemArray) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []ReposCreateOrUpdateEnvironmentReqReviewersItem from json.
func (o *OptNilReposCreateOrUpdateEnvironmentReqReviewersItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilReposCreateOrUpdateEnvironmentReqReviewersItemArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []ReposCreateOrUpdateEnvironmentReqReviewersItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilReposCreateOrUpdateEnvironmentReqReviewersItemArray`, d.Next())
	}
}

// Encode encodes ReposUpdateReqSecurityAndAnalysis as json.
func (o OptNilReposUpdateReqSecurityAndAnalysis) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReqSecurityAndAnalysis from json.
func (o *OptNilReposUpdateReqSecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilReposUpdateReqSecurityAndAnalysis to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v ReposUpdateReqSecurityAndAnalysis
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilReposUpdateReqSecurityAndAnalysis`, d.Next())
	}
}

// Encode encodes RepositoryTemplateRepository as json.
func (o OptNilRepositoryTemplateRepository) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RepositoryTemplateRepository from json.
func (o *OptNilRepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilRepositoryTemplateRepository to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v RepositoryTemplateRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilRepositoryTemplateRepository`, d.Next())
	}
}

// Encode encodes ReviewCommentStartSide as json.
func (o OptNilReviewCommentStartSide) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReviewCommentStartSide from json.
func (o *OptNilReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilReviewCommentStartSide to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v ReviewCommentStartSide
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilReviewCommentStartSide`, d.Next())
	}
}

// Encode encodes SecretScanningAlertResolution as json.
func (o OptNilSecretScanningAlertResolution) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SecretScanningAlertResolution from json.
func (o *OptNilSecretScanningAlertResolution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilSecretScanningAlertResolution to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v SecretScanningAlertResolution
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilSecretScanningAlertResolution`, d.Next())
	}
}

// Encode encodes []SimpleUser as json.
func (o OptNilSimpleUserArray) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []SimpleUser from json.
func (o *OptNilSimpleUserArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilSimpleUserArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []SimpleUser
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilSimpleUserArray`, d.Next())
	}
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilString to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilString`, d.Next())
	}
}

// Encode encodes []string as json.
func (o OptNilStringArray) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []string from json.
func (o *OptNilStringArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilStringArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilStringArray`, d.Next())
	}
}

// Encode encodes []Team as json.
func (o OptNilTeamArray) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []Team from json.
func (o *OptNilTeamArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilTeamArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []Team
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilTeamArray`, d.Next())
	}
}

// Encode encodes []TeamSimple as json.
func (o OptNilTeamSimpleArray) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []TeamSimple from json.
func (o *OptNilTeamSimpleArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilTeamSimpleArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []TeamSimple
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilTeamSimpleArray`, d.Next())
	}
}

// Encode encodes time.Time as json.
func (o OptNilTime) Encode(e *jx.Writer, format func(*jx.Writer, time.Time)) {
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilTime to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := format(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilTime`, d.Next())
	}
}

// Encode encodes []TopicSearchResultItemAliasesItem as json.
func (o OptNilTopicSearchResultItemAliasesItemArray) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []TopicSearchResultItemAliasesItem from json.
func (o *OptNilTopicSearchResultItemAliasesItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilTopicSearchResultItemAliasesItemArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []TopicSearchResultItemAliasesItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilTopicSearchResultItemAliasesItemArray`, d.Next())
	}
}

// Encode encodes []TopicSearchResultItemRelatedItem as json.
func (o OptNilTopicSearchResultItemRelatedItemArray) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []TopicSearchResultItemRelatedItem from json.
func (o *OptNilTopicSearchResultItemRelatedItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilTopicSearchResultItemRelatedItemArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []TopicSearchResultItemRelatedItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilTopicSearchResultItemRelatedItemArray`, d.Next())
	}
}

// Encode encodes url.URL as json.
func (o OptNilURL) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptNilURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilURL to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := json.DecodeURI(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v url.URL
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilURL`, d.Next())
	}
}

// Encode encodes NullableMinimalRepositoryPermissions as json.
func (o OptNullableMinimalRepositoryPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes NullableMinimalRepositoryPermissions from json.
func (o *OptNullableMinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNullableMinimalRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNullableMinimalRepositoryPermissions`, d.Next())
	}
}

// Encode encodes NullableRepositoryPermissions as json.
func (o OptNullableRepositoryPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryPermissions from json.
func (o *OptNullableRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNullableRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNullableRepositoryPermissions`, d.Next())
	}
}

// Encode encodes NullableRepositoryTemplateRepositoryOwner as json.
func (o OptNullableRepositoryTemplateRepositoryOwner) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryTemplateRepositoryOwner from json.
func (o *OptNullableRepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNullableRepositoryTemplateRepositoryOwner to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNullableRepositoryTemplateRepositoryOwner`, d.Next())
	}
}

// Encode encodes NullableRepositoryTemplateRepositoryPermissions as json.
func (o OptNullableRepositoryTemplateRepositoryPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryTemplateRepositoryPermissions from json.
func (o *OptNullableRepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNullableRepositoryTemplateRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNullableRepositoryTemplateRepositoryPermissions`, d.Next())
	}
}

// Encode encodes OAuthAuthorizationsCreateAuthorizationReq as json.
func (o OptOAuthAuthorizationsCreateAuthorizationReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationReq from json.
func (o *OptOAuthAuthorizationsCreateAuthorizationReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOAuthAuthorizationsCreateAuthorizationReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOAuthAuthorizationsCreateAuthorizationReq`, d.Next())
	}
}

// Encode encodes OAuthAuthorizationsUpdateAuthorizationReq as json.
func (o OptOAuthAuthorizationsUpdateAuthorizationReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes OAuthAuthorizationsUpdateAuthorizationReq from json.
func (o *OptOAuthAuthorizationsUpdateAuthorizationReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOAuthAuthorizationsUpdateAuthorizationReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOAuthAuthorizationsUpdateAuthorizationReq`, d.Next())
	}
}

// Encode encodes OrgMembershipPermissions as json.
func (o OptOrgMembershipPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes OrgMembershipPermissions from json.
func (o *OptOrgMembershipPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgMembershipPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgMembershipPermissions`, d.Next())
	}
}

// Encode encodes OrganizationFullPlan as json.
func (o OptOrganizationFullPlan) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes OrganizationFullPlan from json.
func (o *OptOrganizationFullPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrganizationFullPlan to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrganizationFullPlan`, d.Next())
	}
}

// Encode encodes OrgsCreateInvitationReq as json.
func (o OptOrgsCreateInvitationReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes OrgsCreateInvitationReq from json.
func (o *OptOrgsCreateInvitationReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsCreateInvitationReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsCreateInvitationReq`, d.Next())
	}
}

// Encode encodes OrgsCreateInvitationReqRole as json.
func (o OptOrgsCreateInvitationReqRole) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsCreateInvitationReqRole from json.
func (o *OptOrgsCreateInvitationReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsCreateInvitationReqRole to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsCreateInvitationReqRole`, d.Next())
	}
}

// Encode encodes OrgsGetAuditLogInclude as json.
func (o OptOrgsGetAuditLogInclude) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsGetAuditLogInclude from json.
func (o *OptOrgsGetAuditLogInclude) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsGetAuditLogInclude to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsGetAuditLogInclude`, d.Next())
	}
}

// Encode encodes OrgsGetAuditLogOrder as json.
func (o OptOrgsGetAuditLogOrder) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsGetAuditLogOrder from json.
func (o *OptOrgsGetAuditLogOrder) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsGetAuditLogOrder to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsGetAuditLogOrder`, d.Next())
	}
}

// Encode encodes OrgsListMembersFilter as json.
func (o OptOrgsListMembersFilter) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsListMembersFilter from json.
func (o *OptOrgsListMembersFilter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsListMembersFilter to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsListMembersFilter`, d.Next())
	}
}

// Encode encodes OrgsListMembersRole as json.
func (o OptOrgsListMembersRole) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsListMembersRole from json.
func (o *OptOrgsListMembersRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsListMembersRole to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsListMembersRole`, d.Next())
	}
}

// Encode encodes OrgsListMembershipsForAuthenticatedUserState as json.
func (o OptOrgsListMembershipsForAuthenticatedUserState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsListMembershipsForAuthenticatedUserState from json.
func (o *OptOrgsListMembershipsForAuthenticatedUserState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsListMembershipsForAuthenticatedUserState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsListMembershipsForAuthenticatedUserState`, d.Next())
	}
}

// Encode encodes OrgsListOutsideCollaboratorsFilter as json.
func (o OptOrgsListOutsideCollaboratorsFilter) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsListOutsideCollaboratorsFilter from json.
func (o *OptOrgsListOutsideCollaboratorsFilter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsListOutsideCollaboratorsFilter to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsListOutsideCollaboratorsFilter`, d.Next())
	}
}

// Encode encodes OrgsSetMembershipForUserReq as json.
func (o OptOrgsSetMembershipForUserReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes OrgsSetMembershipForUserReq from json.
func (o *OptOrgsSetMembershipForUserReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsSetMembershipForUserReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsSetMembershipForUserReq`, d.Next())
	}
}

// Encode encodes OrgsSetMembershipForUserReqRole as json.
func (o OptOrgsSetMembershipForUserReqRole) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsSetMembershipForUserReqRole from json.
func (o *OptOrgsSetMembershipForUserReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsSetMembershipForUserReqRole to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsSetMembershipForUserReqRole`, d.Next())
	}
}

// Encode encodes OrgsUpdateReq as json.
func (o OptOrgsUpdateReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes OrgsUpdateReq from json.
func (o *OptOrgsUpdateReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsUpdateReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsUpdateReq`, d.Next())
	}
}

// Encode encodes OrgsUpdateReqDefaultRepositoryPermission as json.
func (o OptOrgsUpdateReqDefaultRepositoryPermission) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsUpdateReqDefaultRepositoryPermission from json.
func (o *OptOrgsUpdateReqDefaultRepositoryPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsUpdateReqDefaultRepositoryPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsUpdateReqDefaultRepositoryPermission`, d.Next())
	}
}

// Encode encodes OrgsUpdateReqMembersAllowedRepositoryCreationType as json.
func (o OptOrgsUpdateReqMembersAllowedRepositoryCreationType) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsUpdateReqMembersAllowedRepositoryCreationType from json.
func (o *OptOrgsUpdateReqMembersAllowedRepositoryCreationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsUpdateReqMembersAllowedRepositoryCreationType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsUpdateReqMembersAllowedRepositoryCreationType`, d.Next())
	}
}

// Encode encodes OrgsUpdateWebhookConfigForOrgReq as json.
func (o OptOrgsUpdateWebhookConfigForOrgReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes OrgsUpdateWebhookConfigForOrgReq from json.
func (o *OptOrgsUpdateWebhookConfigForOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsUpdateWebhookConfigForOrgReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsUpdateWebhookConfigForOrgReq`, d.Next())
	}
}

// Encode encodes OrgsUpdateWebhookReq as json.
func (o OptOrgsUpdateWebhookReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes OrgsUpdateWebhookReq from json.
func (o *OptOrgsUpdateWebhookReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsUpdateWebhookReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsUpdateWebhookReq`, d.Next())
	}
}

// Encode encodes OrgsUpdateWebhookReqConfig as json.
func (o OptOrgsUpdateWebhookReqConfig) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes OrgsUpdateWebhookReqConfig from json.
func (o *OptOrgsUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsUpdateWebhookReqConfig to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsUpdateWebhookReqConfig`, d.Next())
	}
}

// Encode encodes PackageVersionMetadata as json.
func (o OptPackageVersionMetadata) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes PackageVersionMetadata from json.
func (o *OptPackageVersionMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackageVersionMetadata to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackageVersionMetadata`, d.Next())
	}
}

// Encode encodes PackageVersionMetadataContainer as json.
func (o OptPackageVersionMetadataContainer) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes PackageVersionMetadataContainer from json.
func (o *OptPackageVersionMetadataContainer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackageVersionMetadataContainer to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackageVersionMetadataContainer`, d.Next())
	}
}

// Encode encodes PackageVersionMetadataDocker as json.
func (o OptPackageVersionMetadataDocker) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes PackageVersionMetadataDocker from json.
func (o *OptPackageVersionMetadataDocker) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackageVersionMetadataDocker to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackageVersionMetadataDocker`, d.Next())
	}
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState as json.
func (o OptPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState from json.
func (o *OptPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState`, d.Next())
	}
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgState as json.
func (o OptPackagesGetAllPackageVersionsForPackageOwnedByOrgState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgState from json.
func (o *OptPackagesGetAllPackageVersionsForPackageOwnedByOrgState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackagesGetAllPackageVersionsForPackageOwnedByOrgState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackagesGetAllPackageVersionsForPackageOwnedByOrgState`, d.Next())
	}
}

// Encode encodes PackagesListPackagesForAuthenticatedUserVisibility as json.
func (o OptPackagesListPackagesForAuthenticatedUserVisibility) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PackagesListPackagesForAuthenticatedUserVisibility from json.
func (o *OptPackagesListPackagesForAuthenticatedUserVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackagesListPackagesForAuthenticatedUserVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackagesListPackagesForAuthenticatedUserVisibility`, d.Next())
	}
}

// Encode encodes PackagesListPackagesForOrganizationVisibility as json.
func (o OptPackagesListPackagesForOrganizationVisibility) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PackagesListPackagesForOrganizationVisibility from json.
func (o *OptPackagesListPackagesForOrganizationVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackagesListPackagesForOrganizationVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackagesListPackagesForOrganizationVisibility`, d.Next())
	}
}

// Encode encodes PackagesListPackagesForUserVisibility as json.
func (o OptPackagesListPackagesForUserVisibility) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PackagesListPackagesForUserVisibility from json.
func (o *OptPackagesListPackagesForUserVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackagesListPackagesForUserVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackagesListPackagesForUserVisibility`, d.Next())
	}
}

// Encode encodes PagesHTTPSCertificate as json.
func (o OptPagesHTTPSCertificate) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes PagesHTTPSCertificate from json.
func (o *OptPagesHTTPSCertificate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPagesHTTPSCertificate to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPagesHTTPSCertificate`, d.Next())
	}
}

// Encode encodes PagesHealthCheckDomain as json.
func (o OptPagesHealthCheckDomain) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes PagesHealthCheckDomain from json.
func (o *OptPagesHealthCheckDomain) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPagesHealthCheckDomain to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPagesHealthCheckDomain`, d.Next())
	}
}

// Encode encodes PagesSourceHash as json.
func (o OptPagesSourceHash) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes PagesSourceHash from json.
func (o *OptPagesSourceHash) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPagesSourceHash to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPagesSourceHash`, d.Next())
	}
}

// Encode encodes PrivateUserPlan as json.
func (o OptPrivateUserPlan) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes PrivateUserPlan from json.
func (o *OptPrivateUserPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPrivateUserPlan to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPrivateUserPlan`, d.Next())
	}
}

// Encode encodes ProjectOrganizationPermission as json.
func (o OptProjectOrganizationPermission) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ProjectOrganizationPermission from json.
func (o *OptProjectOrganizationPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectOrganizationPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectOrganizationPermission`, d.Next())
	}
}

// Encode encodes ProjectsAddCollaboratorReq as json.
func (o OptProjectsAddCollaboratorReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ProjectsAddCollaboratorReq from json.
func (o *OptProjectsAddCollaboratorReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectsAddCollaboratorReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectsAddCollaboratorReq`, d.Next())
	}
}

// Encode encodes ProjectsAddCollaboratorReqPermission as json.
func (o OptProjectsAddCollaboratorReqPermission) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ProjectsAddCollaboratorReqPermission from json.
func (o *OptProjectsAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectsAddCollaboratorReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectsAddCollaboratorReqPermission`, d.Next())
	}
}

// Encode encodes ProjectsListCardsArchivedState as json.
func (o OptProjectsListCardsArchivedState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ProjectsListCardsArchivedState from json.
func (o *OptProjectsListCardsArchivedState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectsListCardsArchivedState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectsListCardsArchivedState`, d.Next())
	}
}

// Encode encodes ProjectsListCollaboratorsAffiliation as json.
func (o OptProjectsListCollaboratorsAffiliation) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ProjectsListCollaboratorsAffiliation from json.
func (o *OptProjectsListCollaboratorsAffiliation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectsListCollaboratorsAffiliation to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectsListCollaboratorsAffiliation`, d.Next())
	}
}

// Encode encodes ProjectsListForOrgState as json.
func (o OptProjectsListForOrgState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ProjectsListForOrgState from json.
func (o *OptProjectsListForOrgState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectsListForOrgState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectsListForOrgState`, d.Next())
	}
}

// Encode encodes ProjectsListForRepoState as json.
func (o OptProjectsListForRepoState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ProjectsListForRepoState from json.
func (o *OptProjectsListForRepoState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectsListForRepoState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectsListForRepoState`, d.Next())
	}
}

// Encode encodes ProjectsListForUserState as json.
func (o OptProjectsListForUserState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ProjectsListForUserState from json.
func (o *OptProjectsListForUserState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectsListForUserState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectsListForUserState`, d.Next())
	}
}

// Encode encodes ProjectsUpdateCardReq as json.
func (o OptProjectsUpdateCardReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ProjectsUpdateCardReq from json.
func (o *OptProjectsUpdateCardReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectsUpdateCardReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectsUpdateCardReq`, d.Next())
	}
}

// Encode encodes ProjectsUpdateReq as json.
func (o OptProjectsUpdateReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ProjectsUpdateReq from json.
func (o *OptProjectsUpdateReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectsUpdateReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectsUpdateReq`, d.Next())
	}
}

// Encode encodes ProjectsUpdateReqOrganizationPermission as json.
func (o OptProjectsUpdateReqOrganizationPermission) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ProjectsUpdateReqOrganizationPermission from json.
func (o *OptProjectsUpdateReqOrganizationPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectsUpdateReqOrganizationPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectsUpdateReqOrganizationPermission`, d.Next())
	}
}

// Encode encodes ProtectedBranchAdminEnforced as json.
func (o OptProtectedBranchAdminEnforced) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchAdminEnforced from json.
func (o *OptProtectedBranchAdminEnforced) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchAdminEnforced to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchAdminEnforced`, d.Next())
	}
}

// Encode encodes ProtectedBranchAllowDeletions as json.
func (o OptProtectedBranchAllowDeletions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchAllowDeletions from json.
func (o *OptProtectedBranchAllowDeletions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchAllowDeletions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchAllowDeletions`, d.Next())
	}
}

// Encode encodes ProtectedBranchAllowForcePushes as json.
func (o OptProtectedBranchAllowForcePushes) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchAllowForcePushes from json.
func (o *OptProtectedBranchAllowForcePushes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchAllowForcePushes to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchAllowForcePushes`, d.Next())
	}
}

// Encode encodes ProtectedBranchEnforceAdmins as json.
func (o OptProtectedBranchEnforceAdmins) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchEnforceAdmins from json.
func (o *OptProtectedBranchEnforceAdmins) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchEnforceAdmins to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchEnforceAdmins`, d.Next())
	}
}

// Encode encodes ProtectedBranchPullRequestReview as json.
func (o OptProtectedBranchPullRequestReview) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchPullRequestReview from json.
func (o *OptProtectedBranchPullRequestReview) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchPullRequestReview to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchPullRequestReview`, d.Next())
	}
}

// Encode encodes ProtectedBranchPullRequestReviewDismissalRestrictions as json.
func (o OptProtectedBranchPullRequestReviewDismissalRestrictions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchPullRequestReviewDismissalRestrictions from json.
func (o *OptProtectedBranchPullRequestReviewDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchPullRequestReviewDismissalRestrictions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchPullRequestReviewDismissalRestrictions`, d.Next())
	}
}

// Encode encodes ProtectedBranchRequiredConversationResolution as json.
func (o OptProtectedBranchRequiredConversationResolution) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredConversationResolution from json.
func (o *OptProtectedBranchRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchRequiredConversationResolution to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchRequiredConversationResolution`, d.Next())
	}
}

// Encode encodes ProtectedBranchRequiredLinearHistory as json.
func (o OptProtectedBranchRequiredLinearHistory) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredLinearHistory from json.
func (o *OptProtectedBranchRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchRequiredLinearHistory to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchRequiredLinearHistory`, d.Next())
	}
}

// Encode encodes ProtectedBranchRequiredPullRequestReviews as json.
func (o OptProtectedBranchRequiredPullRequestReviews) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredPullRequestReviews from json.
func (o *OptProtectedBranchRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchRequiredPullRequestReviews to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchRequiredPullRequestReviews`, d.Next())
	}
}

// Encode encodes ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions as json.
func (o OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions from json.
func (o *OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions`, d.Next())
	}
}

// Encode encodes ProtectedBranchRequiredSignatures as json.
func (o OptProtectedBranchRequiredSignatures) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredSignatures from json.
func (o *OptProtectedBranchRequiredSignatures) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchRequiredSignatures to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchRequiredSignatures`, d.Next())
	}
}

// Encode encodes PublicUser as json.
func (o OptPublicUser) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes PublicUser from json.
func (o *OptPublicUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPublicUser to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPublicUser`, d.Next())
	}
}

// Encode encodes PublicUserPlan as json.
func (o OptPublicUserPlan) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes PublicUserPlan from json.
func (o *OptPublicUserPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPublicUserPlan to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPublicUserPlan`, d.Next())
	}
}

// Encode encodes PullRequestBaseRepoPermissions as json.
func (o OptPullRequestBaseRepoPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes PullRequestBaseRepoPermissions from json.
func (o *OptPullRequestBaseRepoPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullRequestBaseRepoPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullRequestBaseRepoPermissions`, d.Next())
	}
}

// Encode encodes PullRequestHeadRepoPermissions as json.
func (o OptPullRequestHeadRepoPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes PullRequestHeadRepoPermissions from json.
func (o *OptPullRequestHeadRepoPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullRequestHeadRepoPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullRequestHeadRepoPermissions`, d.Next())
	}
}

// Encode encodes PullRequestReviewCommentSide as json.
func (o OptPullRequestReviewCommentSide) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PullRequestReviewCommentSide from json.
func (o *OptPullRequestReviewCommentSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullRequestReviewCommentSide to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullRequestReviewCommentSide`, d.Next())
	}
}

// Encode encodes PullsCreateReviewCommentReqSide as json.
func (o OptPullsCreateReviewCommentReqSide) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PullsCreateReviewCommentReqSide from json.
func (o *OptPullsCreateReviewCommentReqSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsCreateReviewCommentReqSide to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsCreateReviewCommentReqSide`, d.Next())
	}
}

// Encode encodes PullsCreateReviewCommentReqStartSide as json.
func (o OptPullsCreateReviewCommentReqStartSide) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PullsCreateReviewCommentReqStartSide from json.
func (o *OptPullsCreateReviewCommentReqStartSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsCreateReviewCommentReqStartSide to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsCreateReviewCommentReqStartSide`, d.Next())
	}
}

// Encode encodes PullsCreateReviewReq as json.
func (o OptPullsCreateReviewReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes PullsCreateReviewReq from json.
func (o *OptPullsCreateReviewReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsCreateReviewReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsCreateReviewReq`, d.Next())
	}
}

// Encode encodes PullsCreateReviewReqEvent as json.
func (o OptPullsCreateReviewReqEvent) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PullsCreateReviewReqEvent from json.
func (o *OptPullsCreateReviewReqEvent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsCreateReviewReqEvent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsCreateReviewReqEvent`, d.Next())
	}
}

// Encode encodes PullsListDirection as json.
func (o OptPullsListDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PullsListDirection from json.
func (o *OptPullsListDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsListDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsListDirection`, d.Next())
	}
}

// Encode encodes PullsListReviewCommentsDirection as json.
func (o OptPullsListReviewCommentsDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PullsListReviewCommentsDirection from json.
func (o *OptPullsListReviewCommentsDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsListReviewCommentsDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsListReviewCommentsDirection`, d.Next())
	}
}

// Encode encodes PullsListReviewCommentsForRepoDirection as json.
func (o OptPullsListReviewCommentsForRepoDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PullsListReviewCommentsForRepoDirection from json.
func (o *OptPullsListReviewCommentsForRepoDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsListReviewCommentsForRepoDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsListReviewCommentsForRepoDirection`, d.Next())
	}
}

// Encode encodes PullsListReviewCommentsForRepoSort as json.
func (o OptPullsListReviewCommentsForRepoSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PullsListReviewCommentsForRepoSort from json.
func (o *OptPullsListReviewCommentsForRepoSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsListReviewCommentsForRepoSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsListReviewCommentsForRepoSort`, d.Next())
	}
}

// Encode encodes PullsListReviewCommentsSort as json.
func (o OptPullsListReviewCommentsSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PullsListReviewCommentsSort from json.
func (o *OptPullsListReviewCommentsSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsListReviewCommentsSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsListReviewCommentsSort`, d.Next())
	}
}

// Encode encodes PullsListSort as json.
func (o OptPullsListSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PullsListSort from json.
func (o *OptPullsListSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsListSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsListSort`, d.Next())
	}
}

// Encode encodes PullsListState as json.
func (o OptPullsListState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PullsListState from json.
func (o *OptPullsListState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsListState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsListState`, d.Next())
	}
}

// Encode encodes PullsMergeReq as json.
func (o OptPullsMergeReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes PullsMergeReq from json.
func (o *OptPullsMergeReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsMergeReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsMergeReq`, d.Next())
	}
}

// Encode encodes PullsMergeReqMergeMethod as json.
func (o OptPullsMergeReqMergeMethod) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PullsMergeReqMergeMethod from json.
func (o *OptPullsMergeReqMergeMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsMergeReqMergeMethod to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsMergeReqMergeMethod`, d.Next())
	}
}

// Encode encodes PullsUpdateBranchReq as json.
func (o OptPullsUpdateBranchReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes PullsUpdateBranchReq from json.
func (o *OptPullsUpdateBranchReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsUpdateBranchReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsUpdateBranchReq`, d.Next())
	}
}

// Encode encodes PullsUpdateReq as json.
func (o OptPullsUpdateReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes PullsUpdateReq from json.
func (o *OptPullsUpdateReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsUpdateReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsUpdateReq`, d.Next())
	}
}

// Encode encodes PullsUpdateReqState as json.
func (o OptPullsUpdateReqState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes PullsUpdateReqState from json.
func (o *OptPullsUpdateReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsUpdateReqState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsUpdateReqState`, d.Next())
	}
}

// Encode encodes RateLimit as json.
func (o OptRateLimit) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes RateLimit from json.
func (o *OptRateLimit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptRateLimit to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptRateLimit`, d.Next())
	}
}

// Encode encodes ReactionRollup as json.
func (o OptReactionRollup) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReactionRollup from json.
func (o *OptReactionRollup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionRollup to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionRollup`, d.Next())
	}
}

// Encode encodes ReactionsListForCommitCommentContent as json.
func (o OptReactionsListForCommitCommentContent) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForCommitCommentContent from json.
func (o *OptReactionsListForCommitCommentContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForCommitCommentContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForCommitCommentContent`, d.Next())
	}
}

// Encode encodes ReactionsListForIssueCommentContent as json.
func (o OptReactionsListForIssueCommentContent) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForIssueCommentContent from json.
func (o *OptReactionsListForIssueCommentContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForIssueCommentContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForIssueCommentContent`, d.Next())
	}
}

// Encode encodes ReactionsListForIssueContent as json.
func (o OptReactionsListForIssueContent) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForIssueContent from json.
func (o *OptReactionsListForIssueContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForIssueContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForIssueContent`, d.Next())
	}
}

// Encode encodes ReactionsListForPullRequestReviewCommentContent as json.
func (o OptReactionsListForPullRequestReviewCommentContent) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForPullRequestReviewCommentContent from json.
func (o *OptReactionsListForPullRequestReviewCommentContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForPullRequestReviewCommentContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForPullRequestReviewCommentContent`, d.Next())
	}
}

// Encode encodes ReactionsListForTeamDiscussionCommentInOrgContent as json.
func (o OptReactionsListForTeamDiscussionCommentInOrgContent) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForTeamDiscussionCommentInOrgContent from json.
func (o *OptReactionsListForTeamDiscussionCommentInOrgContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForTeamDiscussionCommentInOrgContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForTeamDiscussionCommentInOrgContent`, d.Next())
	}
}

// Encode encodes ReactionsListForTeamDiscussionCommentLegacyContent as json.
func (o OptReactionsListForTeamDiscussionCommentLegacyContent) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForTeamDiscussionCommentLegacyContent from json.
func (o *OptReactionsListForTeamDiscussionCommentLegacyContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForTeamDiscussionCommentLegacyContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForTeamDiscussionCommentLegacyContent`, d.Next())
	}
}

// Encode encodes ReactionsListForTeamDiscussionInOrgContent as json.
func (o OptReactionsListForTeamDiscussionInOrgContent) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForTeamDiscussionInOrgContent from json.
func (o *OptReactionsListForTeamDiscussionInOrgContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForTeamDiscussionInOrgContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForTeamDiscussionInOrgContent`, d.Next())
	}
}

// Encode encodes ReactionsListForTeamDiscussionLegacyContent as json.
func (o OptReactionsListForTeamDiscussionLegacyContent) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForTeamDiscussionLegacyContent from json.
func (o *OptReactionsListForTeamDiscussionLegacyContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForTeamDiscussionLegacyContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForTeamDiscussionLegacyContent`, d.Next())
	}
}

// Encode encodes RepoSearchResultItemPermissions as json.
func (o OptRepoSearchResultItemPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes RepoSearchResultItemPermissions from json.
func (o *OptRepoSearchResultItemPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptRepoSearchResultItemPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptRepoSearchResultItemPermissions`, d.Next())
	}
}

// Encode encodes ReposAddAppAccessRestrictionsReq as json.
func (o OptReposAddAppAccessRestrictionsReq) Encode(e *jx.Writer) {
}

// Decode decodes ReposAddAppAccessRestrictionsReq from json.
func (o *OptReposAddAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposAddAppAccessRestrictionsReq to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposAddAppAccessRestrictionsReq`, d.Next())
	}
}

// Encode encodes ReposAddCollaboratorReq as json.
func (o OptReposAddCollaboratorReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposAddCollaboratorReq from json.
func (o *OptReposAddCollaboratorReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposAddCollaboratorReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposAddCollaboratorReq`, d.Next())
	}
}

// Encode encodes ReposAddCollaboratorReqPermission as json.
func (o OptReposAddCollaboratorReqPermission) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposAddCollaboratorReqPermission from json.
func (o *OptReposAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposAddCollaboratorReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposAddCollaboratorReqPermission`, d.Next())
	}
}

// Encode encodes ReposAddStatusCheckContextsReq as json.
func (o OptReposAddStatusCheckContextsReq) Encode(e *jx.Writer) {
}

// Decode decodes ReposAddStatusCheckContextsReq from json.
func (o *OptReposAddStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposAddStatusCheckContextsReq to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposAddStatusCheckContextsReq`, d.Next())
	}
}

// Encode encodes ReposAddTeamAccessRestrictionsReq as json.
func (o OptReposAddTeamAccessRestrictionsReq) Encode(e *jx.Writer) {
}

// Decode decodes ReposAddTeamAccessRestrictionsReq from json.
func (o *OptReposAddTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposAddTeamAccessRestrictionsReq to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposAddTeamAccessRestrictionsReq`, d.Next())
	}
}

// Encode encodes ReposAddUserAccessRestrictionsReq as json.
func (o OptReposAddUserAccessRestrictionsReq) Encode(e *jx.Writer) {
}

// Decode decodes ReposAddUserAccessRestrictionsReq from json.
func (o *OptReposAddUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposAddUserAccessRestrictionsReq to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposAddUserAccessRestrictionsReq`, d.Next())
	}
}

// Encode encodes ReposCreateDeploymentReqPayload as json.
func (o OptReposCreateDeploymentReqPayload) Encode(e *jx.Writer) {
}

// Decode decodes ReposCreateDeploymentReqPayload from json.
func (o *OptReposCreateDeploymentReqPayload) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreateDeploymentReqPayload to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreateDeploymentReqPayload`, d.Next())
	}
}

// Encode encodes ReposCreateDeploymentStatusReqEnvironment as json.
func (o OptReposCreateDeploymentStatusReqEnvironment) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposCreateDeploymentStatusReqEnvironment from json.
func (o *OptReposCreateDeploymentStatusReqEnvironment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreateDeploymentStatusReqEnvironment to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreateDeploymentStatusReqEnvironment`, d.Next())
	}
}

// Encode encodes ReposCreateForkReq as json.
func (o OptReposCreateForkReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposCreateForkReq from json.
func (o *OptReposCreateForkReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreateForkReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreateForkReq`, d.Next())
	}
}

// Encode encodes ReposCreateInOrgReqVisibility as json.
func (o OptReposCreateInOrgReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposCreateInOrgReqVisibility from json.
func (o *OptReposCreateInOrgReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreateInOrgReqVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreateInOrgReqVisibility`, d.Next())
	}
}

// Encode encodes ReposCreateOrUpdateEnvironmentReq as json.
func (o OptReposCreateOrUpdateEnvironmentReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposCreateOrUpdateEnvironmentReq from json.
func (o *OptReposCreateOrUpdateEnvironmentReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreateOrUpdateEnvironmentReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreateOrUpdateEnvironmentReq`, d.Next())
	}
}

// Encode encodes ReposCreateOrUpdateFileContentsReqAuthor as json.
func (o OptReposCreateOrUpdateFileContentsReqAuthor) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsReqAuthor from json.
func (o *OptReposCreateOrUpdateFileContentsReqAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreateOrUpdateFileContentsReqAuthor to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreateOrUpdateFileContentsReqAuthor`, d.Next())
	}
}

// Encode encodes ReposCreateOrUpdateFileContentsReqCommitter as json.
func (o OptReposCreateOrUpdateFileContentsReqCommitter) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsReqCommitter from json.
func (o *OptReposCreateOrUpdateFileContentsReqCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreateOrUpdateFileContentsReqCommitter to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreateOrUpdateFileContentsReqCommitter`, d.Next())
	}
}

// Encode encodes ReposCreatePagesSiteReqSourcePath as json.
func (o OptReposCreatePagesSiteReqSourcePath) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposCreatePagesSiteReqSourcePath from json.
func (o *OptReposCreatePagesSiteReqSourcePath) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreatePagesSiteReqSourcePath to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreatePagesSiteReqSourcePath`, d.Next())
	}
}

// Encode encodes ReposCreateWebhookReq as json.
func (o OptReposCreateWebhookReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposCreateWebhookReq from json.
func (o *OptReposCreateWebhookReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreateWebhookReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreateWebhookReq`, d.Next())
	}
}

// Encode encodes ReposCreateWebhookReqConfig as json.
func (o OptReposCreateWebhookReqConfig) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposCreateWebhookReqConfig from json.
func (o *OptReposCreateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreateWebhookReqConfig to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreateWebhookReqConfig`, d.Next())
	}
}

// Encode encodes ReposDeleteFileReqAuthor as json.
func (o OptReposDeleteFileReqAuthor) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposDeleteFileReqAuthor from json.
func (o *OptReposDeleteFileReqAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposDeleteFileReqAuthor to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposDeleteFileReqAuthor`, d.Next())
	}
}

// Encode encodes ReposDeleteFileReqCommitter as json.
func (o OptReposDeleteFileReqCommitter) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposDeleteFileReqCommitter from json.
func (o *OptReposDeleteFileReqCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposDeleteFileReqCommitter to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposDeleteFileReqCommitter`, d.Next())
	}
}

// Encode encodes ReposGetClonesPer as json.
func (o OptReposGetClonesPer) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposGetClonesPer from json.
func (o *OptReposGetClonesPer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposGetClonesPer to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposGetClonesPer`, d.Next())
	}
}

// Encode encodes ReposGetViewsPer as json.
func (o OptReposGetViewsPer) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposGetViewsPer from json.
func (o *OptReposGetViewsPer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposGetViewsPer to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposGetViewsPer`, d.Next())
	}
}

// Encode encodes ReposListCollaboratorsAffiliation as json.
func (o OptReposListCollaboratorsAffiliation) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListCollaboratorsAffiliation from json.
func (o *OptReposListCollaboratorsAffiliation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListCollaboratorsAffiliation to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListCollaboratorsAffiliation`, d.Next())
	}
}

// Encode encodes ReposListForAuthenticatedUserDirection as json.
func (o OptReposListForAuthenticatedUserDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForAuthenticatedUserDirection from json.
func (o *OptReposListForAuthenticatedUserDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForAuthenticatedUserDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForAuthenticatedUserDirection`, d.Next())
	}
}

// Encode encodes ReposListForAuthenticatedUserSort as json.
func (o OptReposListForAuthenticatedUserSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForAuthenticatedUserSort from json.
func (o *OptReposListForAuthenticatedUserSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForAuthenticatedUserSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForAuthenticatedUserSort`, d.Next())
	}
}

// Encode encodes ReposListForAuthenticatedUserType as json.
func (o OptReposListForAuthenticatedUserType) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForAuthenticatedUserType from json.
func (o *OptReposListForAuthenticatedUserType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForAuthenticatedUserType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForAuthenticatedUserType`, d.Next())
	}
}

// Encode encodes ReposListForAuthenticatedUserVisibility as json.
func (o OptReposListForAuthenticatedUserVisibility) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForAuthenticatedUserVisibility from json.
func (o *OptReposListForAuthenticatedUserVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForAuthenticatedUserVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForAuthenticatedUserVisibility`, d.Next())
	}
}

// Encode encodes ReposListForOrgDirection as json.
func (o OptReposListForOrgDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForOrgDirection from json.
func (o *OptReposListForOrgDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForOrgDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForOrgDirection`, d.Next())
	}
}

// Encode encodes ReposListForOrgSort as json.
func (o OptReposListForOrgSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForOrgSort from json.
func (o *OptReposListForOrgSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForOrgSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForOrgSort`, d.Next())
	}
}

// Encode encodes ReposListForOrgType as json.
func (o OptReposListForOrgType) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForOrgType from json.
func (o *OptReposListForOrgType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForOrgType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForOrgType`, d.Next())
	}
}

// Encode encodes ReposListForUserDirection as json.
func (o OptReposListForUserDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForUserDirection from json.
func (o *OptReposListForUserDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForUserDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForUserDirection`, d.Next())
	}
}

// Encode encodes ReposListForUserSort as json.
func (o OptReposListForUserSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForUserSort from json.
func (o *OptReposListForUserSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForUserSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForUserSort`, d.Next())
	}
}

// Encode encodes ReposListForUserType as json.
func (o OptReposListForUserType) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForUserType from json.
func (o *OptReposListForUserType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForUserType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForUserType`, d.Next())
	}
}

// Encode encodes ReposListForksSort as json.
func (o OptReposListForksSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForksSort from json.
func (o *OptReposListForksSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForksSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForksSort`, d.Next())
	}
}

// Encode encodes ReposRemoveAppAccessRestrictionsReq as json.
func (o OptReposRemoveAppAccessRestrictionsReq) Encode(e *jx.Writer) {
}

// Decode decodes ReposRemoveAppAccessRestrictionsReq from json.
func (o *OptReposRemoveAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposRemoveAppAccessRestrictionsReq to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposRemoveAppAccessRestrictionsReq`, d.Next())
	}
}

// Encode encodes ReposRemoveStatusCheckContextsReq as json.
func (o OptReposRemoveStatusCheckContextsReq) Encode(e *jx.Writer) {
}

// Decode decodes ReposRemoveStatusCheckContextsReq from json.
func (o *OptReposRemoveStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposRemoveStatusCheckContextsReq to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposRemoveStatusCheckContextsReq`, d.Next())
	}
}

// Encode encodes ReposRemoveTeamAccessRestrictionsReq as json.
func (o OptReposRemoveTeamAccessRestrictionsReq) Encode(e *jx.Writer) {
}

// Decode decodes ReposRemoveTeamAccessRestrictionsReq from json.
func (o *OptReposRemoveTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposRemoveTeamAccessRestrictionsReq to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposRemoveTeamAccessRestrictionsReq`, d.Next())
	}
}

// Encode encodes ReposRemoveUserAccessRestrictionsReq as json.
func (o OptReposRemoveUserAccessRestrictionsReq) Encode(e *jx.Writer) {
}

// Decode decodes ReposRemoveUserAccessRestrictionsReq from json.
func (o *OptReposRemoveUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposRemoveUserAccessRestrictionsReq to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposRemoveUserAccessRestrictionsReq`, d.Next())
	}
}

// Encode encodes ReposRenameBranchReq as json.
func (o OptReposRenameBranchReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposRenameBranchReq from json.
func (o *OptReposRenameBranchReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposRenameBranchReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposRenameBranchReq`, d.Next())
	}
}

// Encode encodes ReposSetAppAccessRestrictionsReq as json.
func (o OptReposSetAppAccessRestrictionsReq) Encode(e *jx.Writer) {
}

// Decode decodes ReposSetAppAccessRestrictionsReq from json.
func (o *OptReposSetAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposSetAppAccessRestrictionsReq to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposSetAppAccessRestrictionsReq`, d.Next())
	}
}

// Encode encodes ReposSetStatusCheckContextsReq as json.
func (o OptReposSetStatusCheckContextsReq) Encode(e *jx.Writer) {
}

// Decode decodes ReposSetStatusCheckContextsReq from json.
func (o *OptReposSetStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposSetStatusCheckContextsReq to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposSetStatusCheckContextsReq`, d.Next())
	}
}

// Encode encodes ReposSetTeamAccessRestrictionsReq as json.
func (o OptReposSetTeamAccessRestrictionsReq) Encode(e *jx.Writer) {
}

// Decode decodes ReposSetTeamAccessRestrictionsReq from json.
func (o *OptReposSetTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposSetTeamAccessRestrictionsReq to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposSetTeamAccessRestrictionsReq`, d.Next())
	}
}

// Encode encodes ReposSetUserAccessRestrictionsReq as json.
func (o OptReposSetUserAccessRestrictionsReq) Encode(e *jx.Writer) {
}

// Decode decodes ReposSetUserAccessRestrictionsReq from json.
func (o *OptReposSetUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposSetUserAccessRestrictionsReq to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposSetUserAccessRestrictionsReq`, d.Next())
	}
}

// Encode encodes ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions as json.
func (o OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions from json.
func (o *OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions`, d.Next())
	}
}

// Encode encodes ReposUpdateInvitationReq as json.
func (o OptReposUpdateInvitationReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateInvitationReq from json.
func (o *OptReposUpdateInvitationReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateInvitationReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateInvitationReq`, d.Next())
	}
}

// Encode encodes ReposUpdateInvitationReqPermissions as json.
func (o OptReposUpdateInvitationReqPermissions) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposUpdateInvitationReqPermissions from json.
func (o *OptReposUpdateInvitationReqPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateInvitationReqPermissions to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateInvitationReqPermissions`, d.Next())
	}
}

// Encode encodes ReposUpdatePullRequestReviewProtectionReq as json.
func (o OptReposUpdatePullRequestReviewProtectionReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdatePullRequestReviewProtectionReq from json.
func (o *OptReposUpdatePullRequestReviewProtectionReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdatePullRequestReviewProtectionReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdatePullRequestReviewProtectionReq`, d.Next())
	}
}

// Encode encodes ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions as json.
func (o OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions from json.
func (o *OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions`, d.Next())
	}
}

// Encode encodes ReposUpdateReleaseAssetReq as json.
func (o OptReposUpdateReleaseAssetReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReleaseAssetReq from json.
func (o *OptReposUpdateReleaseAssetReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateReleaseAssetReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateReleaseAssetReq`, d.Next())
	}
}

// Encode encodes ReposUpdateReleaseReq as json.
func (o OptReposUpdateReleaseReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReleaseReq from json.
func (o *OptReposUpdateReleaseReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateReleaseReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateReleaseReq`, d.Next())
	}
}

// Encode encodes ReposUpdateReq as json.
func (o OptReposUpdateReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReq from json.
func (o *OptReposUpdateReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateReq`, d.Next())
	}
}

// Encode encodes ReposUpdateReqSecurityAndAnalysisAdvancedSecurity as json.
func (o OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisAdvancedSecurity from json.
func (o *OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity`, d.Next())
	}
}

// Encode encodes ReposUpdateReqSecurityAndAnalysisSecretScanning as json.
func (o OptReposUpdateReqSecurityAndAnalysisSecretScanning) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisSecretScanning from json.
func (o *OptReposUpdateReqSecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateReqSecurityAndAnalysisSecretScanning to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateReqSecurityAndAnalysisSecretScanning`, d.Next())
	}
}

// Encode encodes ReposUpdateReqVisibility as json.
func (o OptReposUpdateReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReposUpdateReqVisibility from json.
func (o *OptReposUpdateReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateReqVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateReqVisibility`, d.Next())
	}
}

// Encode encodes ReposUpdateStatusCheckProtectionReq as json.
func (o OptReposUpdateStatusCheckProtectionReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateStatusCheckProtectionReq from json.
func (o *OptReposUpdateStatusCheckProtectionReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateStatusCheckProtectionReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateStatusCheckProtectionReq`, d.Next())
	}
}

// Encode encodes ReposUpdateWebhookConfigForRepoReq as json.
func (o OptReposUpdateWebhookConfigForRepoReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateWebhookConfigForRepoReq from json.
func (o *OptReposUpdateWebhookConfigForRepoReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateWebhookConfigForRepoReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateWebhookConfigForRepoReq`, d.Next())
	}
}

// Encode encodes ReposUpdateWebhookReq as json.
func (o OptReposUpdateWebhookReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateWebhookReq from json.
func (o *OptReposUpdateWebhookReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateWebhookReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateWebhookReq`, d.Next())
	}
}

// Encode encodes ReposUpdateWebhookReqConfig as json.
func (o OptReposUpdateWebhookReqConfig) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateWebhookReqConfig from json.
func (o *OptReposUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateWebhookReqConfig to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateWebhookReqConfig`, d.Next())
	}
}

// Encode encodes Repository as json.
func (o OptRepository) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes Repository from json.
func (o *OptRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptRepository to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptRepository`, d.Next())
	}
}

// Encode encodes RepositoryPermissions as json.
func (o OptRepositoryPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes RepositoryPermissions from json.
func (o *OptRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptRepositoryPermissions`, d.Next())
	}
}

// Encode encodes RepositoryTemplateRepositoryOwner as json.
func (o OptRepositoryTemplateRepositoryOwner) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes RepositoryTemplateRepositoryOwner from json.
func (o *OptRepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptRepositoryTemplateRepositoryOwner to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptRepositoryTemplateRepositoryOwner`, d.Next())
	}
}

// Encode encodes RepositoryTemplateRepositoryPermissions as json.
func (o OptRepositoryTemplateRepositoryPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes RepositoryTemplateRepositoryPermissions from json.
func (o *OptRepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptRepositoryTemplateRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptRepositoryTemplateRepositoryPermissions`, d.Next())
	}
}

// Encode encodes ReviewCommentSide as json.
func (o OptReviewCommentSide) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes ReviewCommentSide from json.
func (o *OptReviewCommentSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReviewCommentSide to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReviewCommentSide`, d.Next())
	}
}

// Encode encodes RunnerLabelsItemType as json.
func (o OptRunnerLabelsItemType) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes RunnerLabelsItemType from json.
func (o *OptRunnerLabelsItemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptRunnerLabelsItemType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptRunnerLabelsItemType`, d.Next())
	}
}

// Encode encodes ScimEnterpriseGroupMeta as json.
func (o OptScimEnterpriseGroupMeta) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ScimEnterpriseGroupMeta from json.
func (o *OptScimEnterpriseGroupMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptScimEnterpriseGroupMeta to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptScimEnterpriseGroupMeta`, d.Next())
	}
}

// Encode encodes ScimEnterpriseUserMeta as json.
func (o OptScimEnterpriseUserMeta) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ScimEnterpriseUserMeta from json.
func (o *OptScimEnterpriseUserMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptScimEnterpriseUserMeta to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptScimEnterpriseUserMeta`, d.Next())
	}
}

// Encode encodes ScimEnterpriseUserName as json.
func (o OptScimEnterpriseUserName) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ScimEnterpriseUserName from json.
func (o *OptScimEnterpriseUserName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptScimEnterpriseUserName to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptScimEnterpriseUserName`, d.Next())
	}
}

// Encode encodes ScimGroupListEnterpriseResourcesItemMeta as json.
func (o OptScimGroupListEnterpriseResourcesItemMeta) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ScimGroupListEnterpriseResourcesItemMeta from json.
func (o *OptScimGroupListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptScimGroupListEnterpriseResourcesItemMeta to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptScimGroupListEnterpriseResourcesItemMeta`, d.Next())
	}
}

// Encode encodes ScimUpdateAttributeForUserReqOperationsItemValue as json.
func (o OptScimUpdateAttributeForUserReqOperationsItemValue) Encode(e *jx.Writer) {
}

// Decode decodes ScimUpdateAttributeForUserReqOperationsItemValue from json.
func (o *OptScimUpdateAttributeForUserReqOperationsItemValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptScimUpdateAttributeForUserReqOperationsItemValue to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptScimUpdateAttributeForUserReqOperationsItemValue`, d.Next())
	}
}

// Encode encodes ScimUserListEnterpriseResourcesItemMeta as json.
func (o OptScimUserListEnterpriseResourcesItemMeta) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ScimUserListEnterpriseResourcesItemMeta from json.
func (o *OptScimUserListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptScimUserListEnterpriseResourcesItemMeta to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptScimUserListEnterpriseResourcesItemMeta`, d.Next())
	}
}

// Encode encodes ScimUserListEnterpriseResourcesItemName as json.
func (o OptScimUserListEnterpriseResourcesItemName) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes ScimUserListEnterpriseResourcesItemName from json.
func (o *OptScimUserListEnterpriseResourcesItemName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptScimUserListEnterpriseResourcesItemName to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptScimUserListEnterpriseResourcesItemName`, d.Next())
	}
}

// Encode encodes SearchCodeOrder as json.
func (o OptSearchCodeOrder) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes SearchCodeOrder from json.
func (o *OptSearchCodeOrder) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSearchCodeOrder to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSearchCodeOrder`, d.Next())
	}
}

// Encode encodes SearchCodeSort as json.
func (o OptSearchCodeSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes SearchCodeSort from json.
func (o *OptSearchCodeSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSearchCodeSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSearchCodeSort`, d.Next())
	}
}

// Encode encodes SearchCommitsOrder as json.
func (o OptSearchCommitsOrder) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes SearchCommitsOrder from json.
func (o *OptSearchCommitsOrder) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSearchCommitsOrder to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSearchCommitsOrder`, d.Next())
	}
}

// Encode encodes SearchCommitsSort as json.
func (o OptSearchCommitsSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes SearchCommitsSort from json.
func (o *OptSearchCommitsSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSearchCommitsSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSearchCommitsSort`, d.Next())
	}
}

// Encode encodes SearchIssuesAndPullRequestsOrder as json.
func (o OptSearchIssuesAndPullRequestsOrder) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes SearchIssuesAndPullRequestsOrder from json.
func (o *OptSearchIssuesAndPullRequestsOrder) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSearchIssuesAndPullRequestsOrder to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSearchIssuesAndPullRequestsOrder`, d.Next())
	}
}

// Encode encodes SearchIssuesAndPullRequestsSort as json.
func (o OptSearchIssuesAndPullRequestsSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes SearchIssuesAndPullRequestsSort from json.
func (o *OptSearchIssuesAndPullRequestsSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSearchIssuesAndPullRequestsSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSearchIssuesAndPullRequestsSort`, d.Next())
	}
}

// Encode encodes SearchLabelsOrder as json.
func (o OptSearchLabelsOrder) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes SearchLabelsOrder from json.
func (o *OptSearchLabelsOrder) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSearchLabelsOrder to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSearchLabelsOrder`, d.Next())
	}
}

// Encode encodes SearchLabelsSort as json.
func (o OptSearchLabelsSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes SearchLabelsSort from json.
func (o *OptSearchLabelsSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSearchLabelsSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSearchLabelsSort`, d.Next())
	}
}

// Encode encodes SearchReposOrder as json.
func (o OptSearchReposOrder) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes SearchReposOrder from json.
func (o *OptSearchReposOrder) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSearchReposOrder to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSearchReposOrder`, d.Next())
	}
}

// Encode encodes SearchReposSort as json.
func (o OptSearchReposSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes SearchReposSort from json.
func (o *OptSearchReposSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSearchReposSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSearchReposSort`, d.Next())
	}
}

// Encode encodes SearchUsersOrder as json.
func (o OptSearchUsersOrder) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes SearchUsersOrder from json.
func (o *OptSearchUsersOrder) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSearchUsersOrder to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSearchUsersOrder`, d.Next())
	}
}

// Encode encodes SearchUsersSort as json.
func (o OptSearchUsersSort) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes SearchUsersSort from json.
func (o *OptSearchUsersSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSearchUsersSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSearchUsersSort`, d.Next())
	}
}

// Encode encodes SecretScanningAlertState as json.
func (o OptSecretScanningAlertState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes SecretScanningAlertState from json.
func (o *OptSecretScanningAlertState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSecretScanningAlertState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSecretScanningAlertState`, d.Next())
	}
}

// Encode encodes SecretScanningListAlertsForOrgState as json.
func (o OptSecretScanningListAlertsForOrgState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes SecretScanningListAlertsForOrgState from json.
func (o *OptSecretScanningListAlertsForOrgState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSecretScanningListAlertsForOrgState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSecretScanningListAlertsForOrgState`, d.Next())
	}
}

// Encode encodes SecretScanningListAlertsForRepoState as json.
func (o OptSecretScanningListAlertsForRepoState) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes SecretScanningListAlertsForRepoState from json.
func (o *OptSecretScanningListAlertsForRepoState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSecretScanningListAlertsForRepoState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSecretScanningListAlertsForRepoState`, d.Next())
	}
}

// Encode encodes SelectedActions as json.
func (o OptSelectedActions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes SelectedActions from json.
func (o *OptSelectedActions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSelectedActions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSelectedActions`, d.Next())
	}
}

// Encode encodes SelectedActionsURL as json.
func (o OptSelectedActionsURL) Encode(e *jx.Writer) {
}

// Decode decodes SelectedActionsURL from json.
func (o *OptSelectedActionsURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSelectedActionsURL to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSelectedActionsURL`, d.Next())
	}
}

// Encode encodes SimpleUser as json.
func (o OptSimpleUser) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes SimpleUser from json.
func (o *OptSimpleUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSimpleUser to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSimpleUser`, d.Next())
	}
}

// Encode encodes StatusCheckPolicy as json.
func (o OptStatusCheckPolicy) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes StatusCheckPolicy from json.
func (o *OptStatusCheckPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptStatusCheckPolicy to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptStatusCheckPolicy`, d.Next())
	}
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptString to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptString`, d.Next())
	}
}

// Encode encodes Team as json.
func (o OptTeam) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes Team from json.
func (o *OptTeam) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeam to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeam`, d.Next())
	}
}

// Encode encodes TeamFullPrivacy as json.
func (o OptTeamFullPrivacy) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamFullPrivacy from json.
func (o *OptTeamFullPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamFullPrivacy to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamFullPrivacy`, d.Next())
	}
}

// Encode encodes TeamPermissions as json.
func (o OptTeamPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes TeamPermissions from json.
func (o *OptTeamPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamPermissions`, d.Next())
	}
}

// Encode encodes TeamRepositoryPermissions as json.
func (o OptTeamRepositoryPermissions) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes TeamRepositoryPermissions from json.
func (o *OptTeamRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamRepositoryPermissions`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateMembershipForUserInOrgReq as json.
func (o OptTeamsAddOrUpdateMembershipForUserInOrgReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgReq from json.
func (o *OptTeamsAddOrUpdateMembershipForUserInOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateMembershipForUserInOrgReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateMembershipForUserInOrgReq`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateMembershipForUserInOrgReqRole as json.
func (o OptTeamsAddOrUpdateMembershipForUserInOrgReqRole) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgReqRole from json.
func (o *OptTeamsAddOrUpdateMembershipForUserInOrgReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateMembershipForUserInOrgReqRole to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateMembershipForUserInOrgReqRole`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateMembershipForUserLegacyReq as json.
func (o OptTeamsAddOrUpdateMembershipForUserLegacyReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyReq from json.
func (o *OptTeamsAddOrUpdateMembershipForUserLegacyReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateMembershipForUserLegacyReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateMembershipForUserLegacyReq`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateMembershipForUserLegacyReqRole as json.
func (o OptTeamsAddOrUpdateMembershipForUserLegacyReqRole) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyReqRole from json.
func (o *OptTeamsAddOrUpdateMembershipForUserLegacyReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateMembershipForUserLegacyReqRole to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateMembershipForUserLegacyReqRole`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsInOrgReq as json.
func (o OptTeamsAddOrUpdateProjectPermissionsInOrgReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgReq from json.
func (o *OptTeamsAddOrUpdateProjectPermissionsInOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateProjectPermissionsInOrgReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateProjectPermissionsInOrgReq`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission as json.
func (o OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission from json.
func (o *OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsLegacyReq as json.
func (o OptTeamsAddOrUpdateProjectPermissionsLegacyReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyReq from json.
func (o *OptTeamsAddOrUpdateProjectPermissionsLegacyReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateProjectPermissionsLegacyReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateProjectPermissionsLegacyReq`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission as json.
func (o OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission from json.
func (o *OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsInOrgReq as json.
func (o OptTeamsAddOrUpdateRepoPermissionsInOrgReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgReq from json.
func (o *OptTeamsAddOrUpdateRepoPermissionsInOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateRepoPermissionsInOrgReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateRepoPermissionsInOrgReq`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission as json.
func (o OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission from json.
func (o *OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsLegacyReq as json.
func (o OptTeamsAddOrUpdateRepoPermissionsLegacyReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyReq from json.
func (o *OptTeamsAddOrUpdateRepoPermissionsLegacyReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateRepoPermissionsLegacyReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateRepoPermissionsLegacyReq`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission as json.
func (o OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission from json.
func (o *OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission`, d.Next())
	}
}

// Encode encodes TeamsCreateReqPermission as json.
func (o OptTeamsCreateReqPermission) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsCreateReqPermission from json.
func (o *OptTeamsCreateReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsCreateReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsCreateReqPermission`, d.Next())
	}
}

// Encode encodes TeamsCreateReqPrivacy as json.
func (o OptTeamsCreateReqPrivacy) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsCreateReqPrivacy from json.
func (o *OptTeamsCreateReqPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsCreateReqPrivacy to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsCreateReqPrivacy`, d.Next())
	}
}

// Encode encodes TeamsListDiscussionCommentsInOrgDirection as json.
func (o OptTeamsListDiscussionCommentsInOrgDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsListDiscussionCommentsInOrgDirection from json.
func (o *OptTeamsListDiscussionCommentsInOrgDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsListDiscussionCommentsInOrgDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsListDiscussionCommentsInOrgDirection`, d.Next())
	}
}

// Encode encodes TeamsListDiscussionCommentsLegacyDirection as json.
func (o OptTeamsListDiscussionCommentsLegacyDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsListDiscussionCommentsLegacyDirection from json.
func (o *OptTeamsListDiscussionCommentsLegacyDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsListDiscussionCommentsLegacyDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsListDiscussionCommentsLegacyDirection`, d.Next())
	}
}

// Encode encodes TeamsListDiscussionsInOrgDirection as json.
func (o OptTeamsListDiscussionsInOrgDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsListDiscussionsInOrgDirection from json.
func (o *OptTeamsListDiscussionsInOrgDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsListDiscussionsInOrgDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsListDiscussionsInOrgDirection`, d.Next())
	}
}

// Encode encodes TeamsListDiscussionsLegacyDirection as json.
func (o OptTeamsListDiscussionsLegacyDirection) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsListDiscussionsLegacyDirection from json.
func (o *OptTeamsListDiscussionsLegacyDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsListDiscussionsLegacyDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsListDiscussionsLegacyDirection`, d.Next())
	}
}

// Encode encodes TeamsListMembersInOrgRole as json.
func (o OptTeamsListMembersInOrgRole) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsListMembersInOrgRole from json.
func (o *OptTeamsListMembersInOrgRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsListMembersInOrgRole to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsListMembersInOrgRole`, d.Next())
	}
}

// Encode encodes TeamsListMembersLegacyRole as json.
func (o OptTeamsListMembersLegacyRole) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsListMembersLegacyRole from json.
func (o *OptTeamsListMembersLegacyRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsListMembersLegacyRole to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsListMembersLegacyRole`, d.Next())
	}
}

// Encode encodes TeamsUpdateDiscussionInOrgReq as json.
func (o OptTeamsUpdateDiscussionInOrgReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes TeamsUpdateDiscussionInOrgReq from json.
func (o *OptTeamsUpdateDiscussionInOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsUpdateDiscussionInOrgReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsUpdateDiscussionInOrgReq`, d.Next())
	}
}

// Encode encodes TeamsUpdateDiscussionLegacyReq as json.
func (o OptTeamsUpdateDiscussionLegacyReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes TeamsUpdateDiscussionLegacyReq from json.
func (o *OptTeamsUpdateDiscussionLegacyReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsUpdateDiscussionLegacyReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsUpdateDiscussionLegacyReq`, d.Next())
	}
}

// Encode encodes TeamsUpdateInOrgReq as json.
func (o OptTeamsUpdateInOrgReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes TeamsUpdateInOrgReq from json.
func (o *OptTeamsUpdateInOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsUpdateInOrgReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsUpdateInOrgReq`, d.Next())
	}
}

// Encode encodes TeamsUpdateInOrgReqPermission as json.
func (o OptTeamsUpdateInOrgReqPermission) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateInOrgReqPermission from json.
func (o *OptTeamsUpdateInOrgReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsUpdateInOrgReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsUpdateInOrgReqPermission`, d.Next())
	}
}

// Encode encodes TeamsUpdateInOrgReqPrivacy as json.
func (o OptTeamsUpdateInOrgReqPrivacy) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateInOrgReqPrivacy from json.
func (o *OptTeamsUpdateInOrgReqPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsUpdateInOrgReqPrivacy to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsUpdateInOrgReqPrivacy`, d.Next())
	}
}

// Encode encodes TeamsUpdateLegacyReqPermission as json.
func (o OptTeamsUpdateLegacyReqPermission) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateLegacyReqPermission from json.
func (o *OptTeamsUpdateLegacyReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsUpdateLegacyReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsUpdateLegacyReqPermission`, d.Next())
	}
}

// Encode encodes TeamsUpdateLegacyReqPrivacy as json.
func (o OptTeamsUpdateLegacyReqPrivacy) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateLegacyReqPrivacy from json.
func (o *OptTeamsUpdateLegacyReqPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsUpdateLegacyReqPrivacy to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsUpdateLegacyReqPrivacy`, d.Next())
	}
}

// Encode encodes time.Time as json.
func (o OptTime) Encode(e *jx.Writer, format func(*jx.Writer, time.Time)) {
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTime to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := format(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTime`, d.Next())
	}
}

// Encode encodes TopicSearchResultItemAliasesItemTopicRelation as json.
func (o OptTopicSearchResultItemAliasesItemTopicRelation) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes TopicSearchResultItemAliasesItemTopicRelation from json.
func (o *OptTopicSearchResultItemAliasesItemTopicRelation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTopicSearchResultItemAliasesItemTopicRelation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTopicSearchResultItemAliasesItemTopicRelation`, d.Next())
	}
}

// Encode encodes TopicSearchResultItemRelatedItemTopicRelation as json.
func (o OptTopicSearchResultItemRelatedItemTopicRelation) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes TopicSearchResultItemRelatedItemTopicRelation from json.
func (o *OptTopicSearchResultItemRelatedItemTopicRelation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTopicSearchResultItemRelatedItemTopicRelation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTopicSearchResultItemRelatedItemTopicRelation`, d.Next())
	}
}

// Encode encodes url.URL as json.
func (o OptURL) Encode(e *jx.Writer) {
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptURL to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := json.DecodeURI(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptURL`, d.Next())
	}
}

// Encode encodes UsersAddEmailForAuthenticatedReq as json.
func (o OptUsersAddEmailForAuthenticatedReq) Encode(e *jx.Writer) {
}

// Decode decodes UsersAddEmailForAuthenticatedReq from json.
func (o *OptUsersAddEmailForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptUsersAddEmailForAuthenticatedReq to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptUsersAddEmailForAuthenticatedReq`, d.Next())
	}
}

// Encode encodes UsersDeleteEmailForAuthenticatedReq as json.
func (o OptUsersDeleteEmailForAuthenticatedReq) Encode(e *jx.Writer) {
}

// Decode decodes UsersDeleteEmailForAuthenticatedReq from json.
func (o *OptUsersDeleteEmailForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptUsersDeleteEmailForAuthenticatedReq to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptUsersDeleteEmailForAuthenticatedReq`, d.Next())
	}
}

// Encode encodes UsersGetContextForUserSubjectType as json.
func (o OptUsersGetContextForUserSubjectType) Encode(e *jx.Writer) {
	e.Str(string(o.Value))
}

// Decode decodes UsersGetContextForUserSubjectType from json.
func (o *OptUsersGetContextForUserSubjectType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptUsersGetContextForUserSubjectType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptUsersGetContextForUserSubjectType`, d.Next())
	}
}

// Encode encodes UsersUpdateAuthenticatedReq as json.
func (o OptUsersUpdateAuthenticatedReq) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes UsersUpdateAuthenticatedReq from json.
func (o *OptUsersUpdateAuthenticatedReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptUsersUpdateAuthenticatedReq to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptUsersUpdateAuthenticatedReq`, d.Next())
	}
}

// Encode encodes ValidationErrorErrorsItemValue as json.
func (o OptValidationErrorErrorsItemValue) Encode(e *jx.Writer) {
}

// Decode decodes ValidationErrorErrorsItemValue from json.
func (o *OptValidationErrorErrorsItemValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptValidationErrorErrorsItemValue to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptValidationErrorErrorsItemValue`, d.Next())
	}
}

// Encode encodes Verification as json.
func (o OptVerification) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes Verification from json.
func (o *OptVerification) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVerification to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVerification`, d.Next())
	}
}

// Encode encodes WaitTimer as json.
func (o OptWaitTimer) Encode(e *jx.Writer) {
}

// Decode decodes WaitTimer from json.
func (o *OptWaitTimer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWaitTimer to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWaitTimer`, d.Next())
	}
}

// Encode encodes WebhookConfigContentType as json.
func (o OptWebhookConfigContentType) Encode(e *jx.Writer) {
}

// Decode decodes WebhookConfigContentType from json.
func (o *OptWebhookConfigContentType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWebhookConfigContentType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWebhookConfigContentType`, d.Next())
	}
}

// Encode encodes WebhookConfigInsecureSsl as json.
func (o OptWebhookConfigInsecureSsl) Encode(e *jx.Writer) {
}

// Decode decodes WebhookConfigInsecureSsl from json.
func (o *OptWebhookConfigInsecureSsl) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWebhookConfigInsecureSsl to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWebhookConfigInsecureSsl`, d.Next())
	}
}

// Encode encodes WebhookConfigSecret as json.
func (o OptWebhookConfigSecret) Encode(e *jx.Writer) {
}

// Decode decodes WebhookConfigSecret from json.
func (o *OptWebhookConfigSecret) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWebhookConfigSecret to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWebhookConfigSecret`, d.Next())
	}
}

// Encode encodes WebhookConfigURL as json.
func (o OptWebhookConfigURL) Encode(e *jx.Writer) {
}

// Decode decodes WebhookConfigURL from json.
func (o *OptWebhookConfigURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWebhookConfigURL to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWebhookConfigURL`, d.Next())
	}
}

// Encode encodes WorkflowRunUsageBillableMACOS as json.
func (o OptWorkflowRunUsageBillableMACOS) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes WorkflowRunUsageBillableMACOS from json.
func (o *OptWorkflowRunUsageBillableMACOS) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWorkflowRunUsageBillableMACOS to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWorkflowRunUsageBillableMACOS`, d.Next())
	}
}

// Encode encodes WorkflowRunUsageBillableUBUNTU as json.
func (o OptWorkflowRunUsageBillableUBUNTU) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes WorkflowRunUsageBillableUBUNTU from json.
func (o *OptWorkflowRunUsageBillableUBUNTU) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWorkflowRunUsageBillableUBUNTU to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWorkflowRunUsageBillableUBUNTU`, d.Next())
	}
}

// Encode encodes WorkflowRunUsageBillableWINDOWS as json.
func (o OptWorkflowRunUsageBillableWINDOWS) Encode(e *jx.Writer) {
	o.Value.Encode(e)
}

// Decode decodes WorkflowRunUsageBillableWINDOWS from json.
func (o *OptWorkflowRunUsageBillableWINDOWS) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWorkflowRunUsageBillableWINDOWS to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWorkflowRunUsageBillableWINDOWS`, d.Next())
	}
}

// Encode implements json.Marshaler.
func (s OrgHook) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"ping_url\"" + ":")
		json.EncodeURI(e, s.PingURL)
	}
	{
		if s.DeliveriesURL.Set {
			e.Comma()
		}
		if s.DeliveriesURL.Set {
			e.RawStr("\"deliveries_url\"" + ":")
			s.DeliveriesURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"events\"" + ":")
		e.ArrStart()
		if len(s.Events) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Events[0]
				e.Str(elem)
			}
			for _, elem := range s.Events[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"active\"" + ":")
		e.Bool(s.Active)
	}
	{
		e.Comma()

		e.RawStr("\"config\"" + ":")
		s.Config.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

// Decode decodes OrgHook from json.
func (s *OrgHook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgHook to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "ping_url":
			v, err := json.DecodeURI(d)
			s.PingURL = v
			if err != nil {
				return err
			}
		case "deliveries_url":
			s.DeliveriesURL.Reset()
			if err := s.DeliveriesURL.Decode(d); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			v, err := d.Bool()
			s.Active = bool(v)
			if err != nil {
				return err
			}
		case "config":
			if err := s.Config.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgHookConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OrgHookConfig from json.
func (s *OrgHookConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgHookConfig to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl.Reset()
			if err := s.InsecureSsl.Decode(d); err != nil {
				return err
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgMembership) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"role\"" + ":")
		s.Role.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"organization_url\"" + ":")
		json.EncodeURI(e, s.OrganizationURL)
	}
	{
		e.Comma()

		e.RawStr("\"organization\"" + ":")
		s.Organization.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OrgMembership from json.
func (s *OrgMembership) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgMembership to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "role":
			if err := s.Role.Decode(d); err != nil {
				return err
			}
		case "organization_url":
			v, err := json.DecodeURI(d)
			s.OrganizationURL = v
			if err != nil {
				return err
			}
		case "organization":
			if err := s.Organization.Decode(d); err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgMembershipPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"can_create_repository\"" + ":")
		e.Bool(s.CanCreateRepository)
	}
	e.ObjEnd()
}

// Decode decodes OrgMembershipPermissions from json.
func (s *OrgMembershipPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgMembershipPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "can_create_repository":
			v, err := d.Bool()
			s.CanCreateRepository = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgMembershipRole as json.
func (s OrgMembershipRole) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgMembershipRole from json.
func (s *OrgMembershipRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgMembershipRole to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgMembershipRole(v) {
	case OrgMembershipRoleAdmin:
		*s = OrgMembershipRoleAdmin
	case OrgMembershipRoleMember:
		*s = OrgMembershipRoleMember
	case OrgMembershipRoleBillingManager:
		*s = OrgMembershipRoleBillingManager
	default:
		*s = OrgMembershipRole(v)
	}

	return nil
}

// Encode encodes OrgMembershipState as json.
func (s OrgMembershipState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgMembershipState from json.
func (s *OrgMembershipState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgMembershipState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgMembershipState(v) {
	case OrgMembershipStateActive:
		*s = OrgMembershipStateActive
	case OrgMembershipStatePending:
		*s = OrgMembershipStatePending
	default:
		*s = OrgMembershipState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrganizationActionsSecret) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"visibility\"" + ":")
		s.Visibility.Encode(e)
	}
	{
		if s.SelectedRepositoriesURL.Set {
			e.Comma()
		}
		if s.SelectedRepositoriesURL.Set {
			e.RawStr("\"selected_repositories_url\"" + ":")
			s.SelectedRepositoriesURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OrganizationActionsSecret from json.
func (s *OrganizationActionsSecret) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrganizationActionsSecret to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "visibility":
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "selected_repositories_url":
			s.SelectedRepositoriesURL.Reset()
			if err := s.SelectedRepositoriesURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrganizationActionsSecretVisibility as json.
func (s OrganizationActionsSecretVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrganizationActionsSecretVisibility from json.
func (s *OrganizationActionsSecretVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrganizationActionsSecretVisibility to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrganizationActionsSecretVisibility(v) {
	case OrganizationActionsSecretVisibilityAll:
		*s = OrganizationActionsSecretVisibilityAll
	case OrganizationActionsSecretVisibilityPrivate:
		*s = OrganizationActionsSecretVisibilityPrivate
	case OrganizationActionsSecretVisibilitySelected:
		*s = OrganizationActionsSecretVisibilitySelected
	default:
		*s = OrganizationActionsSecretVisibility(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrganizationFull) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		e.Str(s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"members_url\"" + ":")
		e.Str(s.MembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"public_members_url\"" + ":")
		e.Str(s.PublicMembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		e.Str(s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Company.Set {
			e.Comma()
		}
		if s.Company.Set {
			e.RawStr("\"company\"" + ":")
			s.Company.Encode(e)
		}
	}
	{
		if s.Blog.Set {
			e.Comma()
		}
		if s.Blog.Set {
			e.RawStr("\"blog\"" + ":")
			s.Blog.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.Comma()
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.Comma()
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.TwitterUsername.Set {
			e.Comma()
		}
		if s.TwitterUsername.Set {
			e.RawStr("\"twitter_username\"" + ":")
			s.TwitterUsername.Encode(e)
		}
	}
	{
		if s.IsVerified.Set {
			e.Comma()
		}
		if s.IsVerified.Set {
			e.RawStr("\"is_verified\"" + ":")
			s.IsVerified.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"has_organization_projects\"" + ":")
		e.Bool(s.HasOrganizationProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_repository_projects\"" + ":")
		e.Bool(s.HasRepositoryProjects)
	}
	{
		e.Comma()

		e.RawStr("\"public_repos\"" + ":")
		e.Int(s.PublicRepos)
	}
	{
		e.Comma()

		e.RawStr("\"public_gists\"" + ":")
		e.Int(s.PublicGists)
	}
	{
		e.Comma()

		e.RawStr("\"followers\"" + ":")
		e.Int(s.Followers)
	}
	{
		e.Comma()

		e.RawStr("\"following\"" + ":")
		e.Int(s.Following)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		if s.TotalPrivateRepos.Set {
			e.Comma()
		}
		if s.TotalPrivateRepos.Set {
			e.RawStr("\"total_private_repos\"" + ":")
			s.TotalPrivateRepos.Encode(e)
		}
	}
	{
		if s.OwnedPrivateRepos.Set {
			e.Comma()
		}
		if s.OwnedPrivateRepos.Set {
			e.RawStr("\"owned_private_repos\"" + ":")
			s.OwnedPrivateRepos.Encode(e)
		}
	}
	{
		if s.PrivateGists.Set {
			e.Comma()
		}
		if s.PrivateGists.Set {
			e.RawStr("\"private_gists\"" + ":")
			s.PrivateGists.Encode(e)
		}
	}
	{
		if s.DiskUsage.Set {
			e.Comma()
		}
		if s.DiskUsage.Set {
			e.RawStr("\"disk_usage\"" + ":")
			s.DiskUsage.Encode(e)
		}
	}
	{
		if s.Collaborators.Set {
			e.Comma()
		}
		if s.Collaborators.Set {
			e.RawStr("\"collaborators\"" + ":")
			s.Collaborators.Encode(e)
		}
	}
	{
		if s.BillingEmail.Set {
			e.Comma()
		}
		if s.BillingEmail.Set {
			e.RawStr("\"billing_email\"" + ":")
			s.BillingEmail.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.Comma()
		}
		if s.Plan.Set {
			e.RawStr("\"plan\"" + ":")
			s.Plan.Encode(e)
		}
	}
	{
		if s.DefaultRepositoryPermission.Set {
			e.Comma()
		}
		if s.DefaultRepositoryPermission.Set {
			e.RawStr("\"default_repository_permission\"" + ":")
			s.DefaultRepositoryPermission.Encode(e)
		}
	}
	{
		if s.MembersCanCreateRepositories.Set {
			e.Comma()
		}
		if s.MembersCanCreateRepositories.Set {
			e.RawStr("\"members_can_create_repositories\"" + ":")
			s.MembersCanCreateRepositories.Encode(e)
		}
	}
	{
		if s.TwoFactorRequirementEnabled.Set {
			e.Comma()
		}
		if s.TwoFactorRequirementEnabled.Set {
			e.RawStr("\"two_factor_requirement_enabled\"" + ":")
			s.TwoFactorRequirementEnabled.Encode(e)
		}
	}
	{
		if s.MembersAllowedRepositoryCreationType.Set {
			e.Comma()
		}
		if s.MembersAllowedRepositoryCreationType.Set {
			e.RawStr("\"members_allowed_repository_creation_type\"" + ":")
			s.MembersAllowedRepositoryCreationType.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePublicRepositories.Set {
			e.Comma()
		}
		if s.MembersCanCreatePublicRepositories.Set {
			e.RawStr("\"members_can_create_public_repositories\"" + ":")
			s.MembersCanCreatePublicRepositories.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePrivateRepositories.Set {
			e.Comma()
		}
		if s.MembersCanCreatePrivateRepositories.Set {
			e.RawStr("\"members_can_create_private_repositories\"" + ":")
			s.MembersCanCreatePrivateRepositories.Encode(e)
		}
	}
	{
		if s.MembersCanCreateInternalRepositories.Set {
			e.Comma()
		}
		if s.MembersCanCreateInternalRepositories.Set {
			e.RawStr("\"members_can_create_internal_repositories\"" + ":")
			s.MembersCanCreateInternalRepositories.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePages.Set {
			e.Comma()
		}
		if s.MembersCanCreatePages.Set {
			e.RawStr("\"members_can_create_pages\"" + ":")
			s.MembersCanCreatePages.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePublicPages.Set {
			e.Comma()
		}
		if s.MembersCanCreatePublicPages.Set {
			e.RawStr("\"members_can_create_public_pages\"" + ":")
			s.MembersCanCreatePublicPages.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePrivatePages.Set {
			e.Comma()
		}
		if s.MembersCanCreatePrivatePages.Set {
			e.RawStr("\"members_can_create_private_pages\"" + ":")
			s.MembersCanCreatePrivatePages.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	e.ObjEnd()
}

// Decode decodes OrganizationFull from json.
func (s *OrganizationFull) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrganizationFull to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "hooks_url":
			v, err := d.Str()
			s.HooksURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "members_url":
			v, err := d.Str()
			s.MembersURL = string(v)
			if err != nil {
				return err
			}
		case "public_members_url":
			v, err := d.Str()
			s.PublicMembersURL = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := d.Str()
			s.AvatarURL = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "company":
			s.Company.Reset()
			if err := s.Company.Decode(d); err != nil {
				return err
			}
		case "blog":
			s.Blog.Reset()
			if err := s.Blog.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "twitter_username":
			s.TwitterUsername.Reset()
			if err := s.TwitterUsername.Decode(d); err != nil {
				return err
			}
		case "is_verified":
			s.IsVerified.Reset()
			if err := s.IsVerified.Decode(d); err != nil {
				return err
			}
		case "has_organization_projects":
			v, err := d.Bool()
			s.HasOrganizationProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_repository_projects":
			v, err := d.Bool()
			s.HasRepositoryProjects = bool(v)
			if err != nil {
				return err
			}
		case "public_repos":
			v, err := d.Int()
			s.PublicRepos = int(v)
			if err != nil {
				return err
			}
		case "public_gists":
			v, err := d.Int()
			s.PublicGists = int(v)
			if err != nil {
				return err
			}
		case "followers":
			v, err := d.Int()
			s.Followers = int(v)
			if err != nil {
				return err
			}
		case "following":
			v, err := d.Int()
			s.Following = int(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "total_private_repos":
			s.TotalPrivateRepos.Reset()
			if err := s.TotalPrivateRepos.Decode(d); err != nil {
				return err
			}
		case "owned_private_repos":
			s.OwnedPrivateRepos.Reset()
			if err := s.OwnedPrivateRepos.Decode(d); err != nil {
				return err
			}
		case "private_gists":
			s.PrivateGists.Reset()
			if err := s.PrivateGists.Decode(d); err != nil {
				return err
			}
		case "disk_usage":
			s.DiskUsage.Reset()
			if err := s.DiskUsage.Decode(d); err != nil {
				return err
			}
		case "collaborators":
			s.Collaborators.Reset()
			if err := s.Collaborators.Decode(d); err != nil {
				return err
			}
		case "billing_email":
			s.BillingEmail.Reset()
			if err := s.BillingEmail.Decode(d); err != nil {
				return err
			}
		case "plan":
			s.Plan.Reset()
			if err := s.Plan.Decode(d); err != nil {
				return err
			}
		case "default_repository_permission":
			s.DefaultRepositoryPermission.Reset()
			if err := s.DefaultRepositoryPermission.Decode(d); err != nil {
				return err
			}
		case "members_can_create_repositories":
			s.MembersCanCreateRepositories.Reset()
			if err := s.MembersCanCreateRepositories.Decode(d); err != nil {
				return err
			}
		case "two_factor_requirement_enabled":
			s.TwoFactorRequirementEnabled.Reset()
			if err := s.TwoFactorRequirementEnabled.Decode(d); err != nil {
				return err
			}
		case "members_allowed_repository_creation_type":
			s.MembersAllowedRepositoryCreationType.Reset()
			if err := s.MembersAllowedRepositoryCreationType.Decode(d); err != nil {
				return err
			}
		case "members_can_create_public_repositories":
			s.MembersCanCreatePublicRepositories.Reset()
			if err := s.MembersCanCreatePublicRepositories.Decode(d); err != nil {
				return err
			}
		case "members_can_create_private_repositories":
			s.MembersCanCreatePrivateRepositories.Reset()
			if err := s.MembersCanCreatePrivateRepositories.Decode(d); err != nil {
				return err
			}
		case "members_can_create_internal_repositories":
			s.MembersCanCreateInternalRepositories.Reset()
			if err := s.MembersCanCreateInternalRepositories.Decode(d); err != nil {
				return err
			}
		case "members_can_create_pages":
			s.MembersCanCreatePages.Reset()
			if err := s.MembersCanCreatePages.Decode(d); err != nil {
				return err
			}
		case "members_can_create_public_pages":
			s.MembersCanCreatePublicPages.Reset()
			if err := s.MembersCanCreatePublicPages.Decode(d); err != nil {
				return err
			}
		case "members_can_create_private_pages":
			s.MembersCanCreatePrivatePages.Reset()
			if err := s.MembersCanCreatePrivatePages.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrganizationFullPlan) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"space\"" + ":")
		e.Int(s.Space)
	}
	{
		e.Comma()

		e.RawStr("\"private_repos\"" + ":")
		e.Int(s.PrivateRepos)
	}
	{
		if s.FilledSeats.Set {
			e.Comma()
		}
		if s.FilledSeats.Set {
			e.RawStr("\"filled_seats\"" + ":")
			s.FilledSeats.Encode(e)
		}
	}
	{
		if s.Seats.Set {
			e.Comma()
		}
		if s.Seats.Set {
			e.RawStr("\"seats\"" + ":")
			s.Seats.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OrganizationFullPlan from json.
func (s *OrganizationFullPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrganizationFullPlan to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "space":
			v, err := d.Int()
			s.Space = int(v)
			if err != nil {
				return err
			}
		case "private_repos":
			v, err := d.Int()
			s.PrivateRepos = int(v)
			if err != nil {
				return err
			}
		case "filled_seats":
			s.FilledSeats.Reset()
			if err := s.FilledSeats.Decode(d); err != nil {
				return err
			}
		case "seats":
			s.Seats.Reset()
			if err := s.Seats.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrganizationInvitation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		s.Login.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		s.Email.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"role\"" + ":")
		e.Str(s.Role)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		e.Str(s.CreatedAt)
	}
	{
		if s.FailedAt.Set {
			e.Comma()
		}
		if s.FailedAt.Set {
			e.RawStr("\"failed_at\"" + ":")
			s.FailedAt.Encode(e)
		}
	}
	{
		if s.FailedReason.Set {
			e.Comma()
		}
		if s.FailedReason.Set {
			e.RawStr("\"failed_reason\"" + ":")
			s.FailedReason.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"inviter\"" + ":")
		s.Inviter.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"team_count\"" + ":")
		e.Int(s.TeamCount)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"invitation_teams_url\"" + ":")
		e.Str(s.InvitationTeamsURL)
	}
	e.ObjEnd()
}

// Decode decodes OrganizationInvitation from json.
func (s *OrganizationInvitation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrganizationInvitation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "login":
			if err := s.Login.Decode(d); err != nil {
				return err
			}
		case "email":
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "role":
			v, err := d.Str()
			s.Role = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := d.Str()
			s.CreatedAt = string(v)
			if err != nil {
				return err
			}
		case "failed_at":
			s.FailedAt.Reset()
			if err := s.FailedAt.Decode(d); err != nil {
				return err
			}
		case "failed_reason":
			s.FailedReason.Reset()
			if err := s.FailedReason.Decode(d); err != nil {
				return err
			}
		case "inviter":
			if err := s.Inviter.Decode(d); err != nil {
				return err
			}
		case "team_count":
			v, err := d.Int()
			s.TeamCount = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "invitation_teams_url":
			v, err := d.Str()
			s.InvitationTeamsURL = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrganizationSecretScanningAlert) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Number.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Number.Set {
			e.RawStr("\"number\"" + ":")
			s.Number.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.LocationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LocationsURL.Set {
			e.RawStr("\"locations_url\"" + ":")
			s.LocationsURL.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.Resolution.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resolution.Set {
			e.RawStr("\"resolution\"" + ":")
			s.Resolution.Encode(e)
		}
	}
	{
		if s.ResolvedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResolvedAt.Set {
			e.RawStr("\"resolved_at\"" + ":")
			s.ResolvedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ResolvedBy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResolvedBy.Set {
			e.RawStr("\"resolved_by\"" + ":")
			s.ResolvedBy.Encode(e)
		}
	}
	{
		if s.SecretType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretType.Set {
			e.RawStr("\"secret_type\"" + ":")
			s.SecretType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Repository.Set {
			e.RawStr("\"repository\"" + ":")
			s.Repository.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OrganizationSecretScanningAlert from json.
func (s *OrganizationSecretScanningAlert) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrganizationSecretScanningAlert to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			s.Number.Reset()
			if err := s.Number.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "locations_url":
			s.LocationsURL.Reset()
			if err := s.LocationsURL.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "resolution":
			s.Resolution.Reset()
			if err := s.Resolution.Decode(d); err != nil {
				return err
			}
		case "resolved_at":
			s.ResolvedAt.Reset()
			if err := s.ResolvedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "resolved_by":
			s.ResolvedBy.Reset()
			if err := s.ResolvedBy.Decode(d); err != nil {
				return err
			}
		case "secret_type":
			s.SecretType.Reset()
			if err := s.SecretType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "repository":
			s.Repository.Reset()
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrganizationSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		e.Str(s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"members_url\"" + ":")
		e.Str(s.MembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"public_members_url\"" + ":")
		e.Str(s.PublicMembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		e.Str(s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrganizationSimple from json.
func (s *OrganizationSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrganizationSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "hooks_url":
			v, err := d.Str()
			s.HooksURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "members_url":
			v, err := d.Str()
			s.MembersURL = string(v)
			if err != nil {
				return err
			}
		case "public_members_url":
			v, err := d.Str()
			s.PublicMembersURL = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := d.Str()
			s.AvatarURL = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsBlockUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsBlockUserNoContent from json.
func (s *OrgsBlockUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsBlockUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCancelInvitationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsCancelInvitationNoContent from json.
func (s *OrgsCancelInvitationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCancelInvitationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCheckBlockedUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsCheckBlockedUserNoContent from json.
func (s *OrgsCheckBlockedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCheckBlockedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCheckMembershipForUserFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsCheckMembershipForUserFound from json.
func (s *OrgsCheckMembershipForUserFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCheckMembershipForUserFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCheckMembershipForUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsCheckMembershipForUserNoContent from json.
func (s *OrgsCheckMembershipForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCheckMembershipForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCheckMembershipForUserNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsCheckMembershipForUserNotFound from json.
func (s *OrgsCheckMembershipForUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCheckMembershipForUserNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCheckPublicMembershipForUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsCheckPublicMembershipForUserNoContent from json.
func (s *OrgsCheckPublicMembershipForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCheckPublicMembershipForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCheckPublicMembershipForUserNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsCheckPublicMembershipForUserNotFound from json.
func (s *OrgsCheckPublicMembershipForUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCheckPublicMembershipForUserNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsConvertMemberToOutsideCollaboratorAccepted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsConvertMemberToOutsideCollaboratorAccepted from json.
func (s *OrgsConvertMemberToOutsideCollaboratorAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsConvertMemberToOutsideCollaboratorAccepted to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsConvertMemberToOutsideCollaboratorForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsConvertMemberToOutsideCollaboratorForbidden from json.
func (s *OrgsConvertMemberToOutsideCollaboratorForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsConvertMemberToOutsideCollaboratorForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsConvertMemberToOutsideCollaboratorNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsConvertMemberToOutsideCollaboratorNoContent from json.
func (s *OrgsConvertMemberToOutsideCollaboratorNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsConvertMemberToOutsideCollaboratorNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCreateInvitationReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.InviteeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InviteeID.Set {
			e.RawStr("\"invitee_id\"" + ":")
			s.InviteeID.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Role.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Role.Set {
			e.RawStr("\"role\"" + ":")
			s.Role.Encode(e)
		}
	}
	{
		if s.TeamIds != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TeamIds != nil {
			e.RawStr("\"team_ids\"" + ":")
			e.ArrStart()
			if len(s.TeamIds) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TeamIds[0]
					e.Int(elem)
				}
				for _, elem := range s.TeamIds[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes OrgsCreateInvitationReq from json.
func (s *OrgsCreateInvitationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCreateInvitationReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "invitee_id":
			s.InviteeID.Reset()
			if err := s.InviteeID.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "role":
			s.Role.Reset()
			if err := s.Role.Decode(d); err != nil {
				return err
			}
		case "team_ids":
			s.TeamIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.TeamIds = append(s.TeamIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgsCreateInvitationReqRole as json.
func (s OrgsCreateInvitationReqRole) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsCreateInvitationReqRole from json.
func (s *OrgsCreateInvitationReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCreateInvitationReqRole to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsCreateInvitationReqRole(v) {
	case OrgsCreateInvitationReqRoleAdmin:
		*s = OrgsCreateInvitationReqRoleAdmin
	case OrgsCreateInvitationReqRoleDirectMember:
		*s = OrgsCreateInvitationReqRoleDirectMember
	case OrgsCreateInvitationReqRoleBillingManager:
		*s = OrgsCreateInvitationReqRoleBillingManager
	default:
		*s = OrgsCreateInvitationReqRole(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgsCreateWebhookReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"config\"" + ":")
		s.Config.Encode(e)
	}
	{
		if s.Events != nil {
			e.Comma()
		}
		if s.Events != nil {
			e.RawStr("\"events\"" + ":")
			e.ArrStart()
			if len(s.Events) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Events[0]
					e.Str(elem)
				}
				for _, elem := range s.Events[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.Comma()
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OrgsCreateWebhookReq from json.
func (s *OrgsCreateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCreateWebhookReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "config":
			if err := s.Config.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCreateWebhookReqConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		if s.ContentType.Set {
			e.Comma()
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.Comma()
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.Comma()
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.Comma()
		}
		if s.Username.Set {
			e.RawStr("\"username\"" + ":")
			s.Username.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.Comma()
		}
		if s.Password.Set {
			e.RawStr("\"password\"" + ":")
			s.Password.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OrgsCreateWebhookReqConfig from json.
func (s *OrgsCreateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCreateWebhookReqConfig to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.URL = WebhookConfigURL(unwrapped)
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl.Reset()
			if err := s.InsecureSsl.Decode(d); err != nil {
				return err
			}
		case "username":
			s.Username.Reset()
			if err := s.Username.Decode(d); err != nil {
				return err
			}
		case "password":
			s.Password.Reset()
			if err := s.Password.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsDeleteWebhookNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsDeleteWebhookNoContent from json.
func (s *OrgsDeleteWebhookNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsDeleteWebhookNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgsGetAuditLogInclude as json.
func (s OrgsGetAuditLogInclude) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsGetAuditLogInclude from json.
func (s *OrgsGetAuditLogInclude) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsGetAuditLogInclude to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsGetAuditLogInclude(v) {
	case OrgsGetAuditLogIncludeWeb:
		*s = OrgsGetAuditLogIncludeWeb
	case OrgsGetAuditLogIncludeGit:
		*s = OrgsGetAuditLogIncludeGit
	case OrgsGetAuditLogIncludeAll:
		*s = OrgsGetAuditLogIncludeAll
	default:
		*s = OrgsGetAuditLogInclude(v)
	}

	return nil
}

// Encode encodes OrgsGetAuditLogOrder as json.
func (s OrgsGetAuditLogOrder) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsGetAuditLogOrder from json.
func (s *OrgsGetAuditLogOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsGetAuditLogOrder to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsGetAuditLogOrder(v) {
	case OrgsGetAuditLogOrderDesc:
		*s = OrgsGetAuditLogOrderDesc
	case OrgsGetAuditLogOrderAsc:
		*s = OrgsGetAuditLogOrderAsc
	default:
		*s = OrgsGetAuditLogOrder(v)
	}

	return nil
}

// Encode encodes OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden as json.
func (s OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden from json.
func (s *OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound as json.
func (s OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound from json.
func (s *OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes OrgsGetMembershipForUserApplicationJSONForbidden as json.
func (s OrgsGetMembershipForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForUserApplicationJSONForbidden from json.
func (s *OrgsGetMembershipForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsGetMembershipForUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsGetMembershipForUserApplicationJSONNotFound as json.
func (s OrgsGetMembershipForUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForUserApplicationJSONNotFound from json.
func (s *OrgsGetMembershipForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsGetMembershipForUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes OrgsListBlockedUsersOKApplicationJSON as json.
func (s OrgsListBlockedUsersOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListBlockedUsersOKApplicationJSON from json.
func (s *OrgsListBlockedUsersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListBlockedUsersOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListBlockedUsersOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListFailedInvitationsOKApplicationJSON as json.
func (s OrgsListFailedInvitationsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []OrganizationInvitation(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListFailedInvitationsOKApplicationJSON from json.
func (s *OrgsListFailedInvitationsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListFailedInvitationsOKApplicationJSON to nil`)
	}
	var unwrapped []OrganizationInvitation
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationInvitation
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListFailedInvitationsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListForAuthenticatedUserApplicationJSONForbidden as json.
func (s OrgsListForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsListForAuthenticatedUserApplicationJSONForbidden from json.
func (s *OrgsListForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsListForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s OrgsListForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsListForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *OrgsListForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OrgsListForAuthenticatedUserOKApplicationJSON as json.
func (s OrgsListForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []OrganizationSimple(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListForAuthenticatedUserOKApplicationJSON from json.
func (s *OrgsListForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []OrganizationSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListInvitationTeamsOKApplicationJSON as json.
func (s OrgsListInvitationTeamsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Team(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListInvitationTeamsOKApplicationJSON from json.
func (s *OrgsListInvitationTeamsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListInvitationTeamsOKApplicationJSON to nil`)
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListInvitationTeamsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListMembersFilter as json.
func (s OrgsListMembersFilter) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsListMembersFilter from json.
func (s *OrgsListMembersFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListMembersFilter to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsListMembersFilter(v) {
	case OrgsListMembersFilter2FADisabled:
		*s = OrgsListMembersFilter2FADisabled
	case OrgsListMembersFilterAll:
		*s = OrgsListMembersFilterAll
	default:
		*s = OrgsListMembersFilter(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgsListMembersFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsListMembersFound from json.
func (s *OrgsListMembersFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListMembersFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgsListMembersOKApplicationJSON as json.
func (s OrgsListMembersOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListMembersOKApplicationJSON from json.
func (s *OrgsListMembersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListMembersOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListMembersOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListMembersRole as json.
func (s OrgsListMembersRole) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsListMembersRole from json.
func (s *OrgsListMembersRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListMembersRole to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsListMembersRole(v) {
	case OrgsListMembersRoleAll:
		*s = OrgsListMembersRoleAll
	case OrgsListMembersRoleAdmin:
		*s = OrgsListMembersRoleAdmin
	case OrgsListMembersRoleMember:
		*s = OrgsListMembersRoleMember
	default:
		*s = OrgsListMembersRole(v)
	}

	return nil
}

// Encode encodes OrgsListMembershipsForAuthenticatedUserApplicationJSONForbidden as json.
func (s OrgsListMembershipsForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsListMembershipsForAuthenticatedUserApplicationJSONForbidden from json.
func (s *OrgsListMembershipsForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListMembershipsForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListMembershipsForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsListMembershipsForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s OrgsListMembershipsForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsListMembershipsForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *OrgsListMembershipsForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListMembershipsForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListMembershipsForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OrgsListMembershipsForAuthenticatedUserOKApplicationJSON as json.
func (s OrgsListMembershipsForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []OrgMembership(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListMembershipsForAuthenticatedUserOKApplicationJSON from json.
func (s *OrgsListMembershipsForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListMembershipsForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []OrgMembership
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrgMembership
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListMembershipsForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListMembershipsForAuthenticatedUserState as json.
func (s OrgsListMembershipsForAuthenticatedUserState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsListMembershipsForAuthenticatedUserState from json.
func (s *OrgsListMembershipsForAuthenticatedUserState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListMembershipsForAuthenticatedUserState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsListMembershipsForAuthenticatedUserState(v) {
	case OrgsListMembershipsForAuthenticatedUserStateActive:
		*s = OrgsListMembershipsForAuthenticatedUserStateActive
	case OrgsListMembershipsForAuthenticatedUserStatePending:
		*s = OrgsListMembershipsForAuthenticatedUserStatePending
	default:
		*s = OrgsListMembershipsForAuthenticatedUserState(v)
	}

	return nil
}

// Encode encodes OrgsListOKApplicationJSON as json.
func (s OrgsListOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []OrganizationSimple(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListOKApplicationJSON from json.
func (s *OrgsListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListOKApplicationJSON to nil`)
	}
	var unwrapped []OrganizationSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListOutsideCollaboratorsFilter as json.
func (s OrgsListOutsideCollaboratorsFilter) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsListOutsideCollaboratorsFilter from json.
func (s *OrgsListOutsideCollaboratorsFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListOutsideCollaboratorsFilter to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsListOutsideCollaboratorsFilter(v) {
	case OrgsListOutsideCollaboratorsFilter2FADisabled:
		*s = OrgsListOutsideCollaboratorsFilter2FADisabled
	case OrgsListOutsideCollaboratorsFilterAll:
		*s = OrgsListOutsideCollaboratorsFilterAll
	default:
		*s = OrgsListOutsideCollaboratorsFilter(v)
	}

	return nil
}

// Encode encodes OrgsListPendingInvitationsOKApplicationJSON as json.
func (s OrgsListPendingInvitationsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []OrganizationInvitation(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListPendingInvitationsOKApplicationJSON from json.
func (s *OrgsListPendingInvitationsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListPendingInvitationsOKApplicationJSON to nil`)
	}
	var unwrapped []OrganizationInvitation
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationInvitation
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListPendingInvitationsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListWebhookDeliveriesOKApplicationJSON as json.
func (s OrgsListWebhookDeliveriesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []HookDeliveryItem(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListWebhookDeliveriesOKApplicationJSON from json.
func (s *OrgsListWebhookDeliveriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListWebhookDeliveriesOKApplicationJSON to nil`)
	}
	var unwrapped []HookDeliveryItem
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HookDeliveryItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListWebhookDeliveriesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListWebhooksOKApplicationJSON as json.
func (s OrgsListWebhooksOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []OrgHook(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListWebhooksOKApplicationJSON from json.
func (s *OrgsListWebhooksOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListWebhooksOKApplicationJSON to nil`)
	}
	var unwrapped []OrgHook
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrgHook
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListWebhooksOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OrgsPingWebhookNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsPingWebhookNoContent from json.
func (s *OrgsPingWebhookNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsPingWebhookNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsRemoveMemberNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsRemoveMemberNoContent from json.
func (s *OrgsRemoveMemberNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemoveMemberNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgsRemoveMembershipForUserApplicationJSONForbidden as json.
func (s OrgsRemoveMembershipForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsRemoveMembershipForUserApplicationJSONForbidden from json.
func (s *OrgsRemoveMembershipForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemoveMembershipForUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsRemoveMembershipForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsRemoveMembershipForUserApplicationJSONNotFound as json.
func (s OrgsRemoveMembershipForUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsRemoveMembershipForUserApplicationJSONNotFound from json.
func (s *OrgsRemoveMembershipForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemoveMembershipForUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsRemoveMembershipForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OrgsRemoveMembershipForUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsRemoveMembershipForUserNoContent from json.
func (s *OrgsRemoveMembershipForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemoveMembershipForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsRemoveOutsideCollaboratorNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsRemoveOutsideCollaboratorNoContent from json.
func (s *OrgsRemoveOutsideCollaboratorNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemoveOutsideCollaboratorNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsRemoveOutsideCollaboratorUnprocessableEntity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OrgsRemoveOutsideCollaboratorUnprocessableEntity from json.
func (s *OrgsRemoveOutsideCollaboratorUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemoveOutsideCollaboratorUnprocessableEntity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsRemovePublicMembershipForAuthenticatedUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsRemovePublicMembershipForAuthenticatedUserNoContent from json.
func (s *OrgsRemovePublicMembershipForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemovePublicMembershipForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsRemoveSamlSSOAuthorizationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsRemoveSamlSSOAuthorizationNoContent from json.
func (s *OrgsRemoveSamlSSOAuthorizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemoveSamlSSOAuthorizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsSetMembershipForUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Role.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Role.Set {
			e.RawStr("\"role\"" + ":")
			s.Role.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OrgsSetMembershipForUserReq from json.
func (s *OrgsSetMembershipForUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsSetMembershipForUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			s.Role.Reset()
			if err := s.Role.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgsSetMembershipForUserReqRole as json.
func (s OrgsSetMembershipForUserReqRole) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsSetMembershipForUserReqRole from json.
func (s *OrgsSetMembershipForUserReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsSetMembershipForUserReqRole to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsSetMembershipForUserReqRole(v) {
	case OrgsSetMembershipForUserReqRoleAdmin:
		*s = OrgsSetMembershipForUserReqRoleAdmin
	case OrgsSetMembershipForUserReqRoleMember:
		*s = OrgsSetMembershipForUserReqRoleMember
	default:
		*s = OrgsSetMembershipForUserReqRole(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgsSetPublicMembershipForAuthenticatedUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsSetPublicMembershipForAuthenticatedUserNoContent from json.
func (s *OrgsSetPublicMembershipForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsSetPublicMembershipForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsUnblockUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes OrgsUnblockUserNoContent from json.
func (s *OrgsUnblockUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUnblockUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgsUpdateMembershipForAuthenticatedUserApplicationJSONForbidden as json.
func (s OrgsUpdateMembershipForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsUpdateMembershipForAuthenticatedUserApplicationJSONForbidden from json.
func (s *OrgsUpdateMembershipForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateMembershipForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsUpdateMembershipForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsUpdateMembershipForAuthenticatedUserApplicationJSONNotFound as json.
func (s OrgsUpdateMembershipForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsUpdateMembershipForAuthenticatedUserApplicationJSONNotFound from json.
func (s *OrgsUpdateMembershipForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateMembershipForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsUpdateMembershipForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OrgsUpdateMembershipForAuthenticatedUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrgsUpdateMembershipForAuthenticatedUserReq from json.
func (s *OrgsUpdateMembershipForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateMembershipForAuthenticatedUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgsUpdateMembershipForAuthenticatedUserReqState as json.
func (s OrgsUpdateMembershipForAuthenticatedUserReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsUpdateMembershipForAuthenticatedUserReqState from json.
func (s *OrgsUpdateMembershipForAuthenticatedUserReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateMembershipForAuthenticatedUserReqState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsUpdateMembershipForAuthenticatedUserReqState(v) {
	case OrgsUpdateMembershipForAuthenticatedUserReqStateActive:
		*s = OrgsUpdateMembershipForAuthenticatedUserReqStateActive
	default:
		*s = OrgsUpdateMembershipForAuthenticatedUserReqState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgsUpdateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.BillingEmail.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BillingEmail.Set {
			e.RawStr("\"billing_email\"" + ":")
			s.BillingEmail.Encode(e)
		}
	}
	{
		if s.Company.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Company.Set {
			e.RawStr("\"company\"" + ":")
			s.Company.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.TwitterUsername.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TwitterUsername.Set {
			e.RawStr("\"twitter_username\"" + ":")
			s.TwitterUsername.Encode(e)
		}
	}
	{
		if s.Location.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.HasOrganizationProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasOrganizationProjects.Set {
			e.RawStr("\"has_organization_projects\"" + ":")
			s.HasOrganizationProjects.Encode(e)
		}
	}
	{
		if s.HasRepositoryProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasRepositoryProjects.Set {
			e.RawStr("\"has_repository_projects\"" + ":")
			s.HasRepositoryProjects.Encode(e)
		}
	}
	{
		if s.DefaultRepositoryPermission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultRepositoryPermission.Set {
			e.RawStr("\"default_repository_permission\"" + ":")
			s.DefaultRepositoryPermission.Encode(e)
		}
	}
	{
		if s.MembersCanCreateRepositories.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersCanCreateRepositories.Set {
			e.RawStr("\"members_can_create_repositories\"" + ":")
			s.MembersCanCreateRepositories.Encode(e)
		}
	}
	{
		if s.MembersCanCreateInternalRepositories.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersCanCreateInternalRepositories.Set {
			e.RawStr("\"members_can_create_internal_repositories\"" + ":")
			s.MembersCanCreateInternalRepositories.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePrivateRepositories.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersCanCreatePrivateRepositories.Set {
			e.RawStr("\"members_can_create_private_repositories\"" + ":")
			s.MembersCanCreatePrivateRepositories.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePublicRepositories.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersCanCreatePublicRepositories.Set {
			e.RawStr("\"members_can_create_public_repositories\"" + ":")
			s.MembersCanCreatePublicRepositories.Encode(e)
		}
	}
	{
		if s.MembersAllowedRepositoryCreationType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersAllowedRepositoryCreationType.Set {
			e.RawStr("\"members_allowed_repository_creation_type\"" + ":")
			s.MembersAllowedRepositoryCreationType.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersCanCreatePages.Set {
			e.RawStr("\"members_can_create_pages\"" + ":")
			s.MembersCanCreatePages.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePublicPages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersCanCreatePublicPages.Set {
			e.RawStr("\"members_can_create_public_pages\"" + ":")
			s.MembersCanCreatePublicPages.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePrivatePages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersCanCreatePrivatePages.Set {
			e.RawStr("\"members_can_create_private_pages\"" + ":")
			s.MembersCanCreatePrivatePages.Encode(e)
		}
	}
	{
		if s.Blog.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Blog.Set {
			e.RawStr("\"blog\"" + ":")
			s.Blog.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OrgsUpdateReq from json.
func (s *OrgsUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billing_email":
			s.BillingEmail.Reset()
			if err := s.BillingEmail.Decode(d); err != nil {
				return err
			}
		case "company":
			s.Company.Reset()
			if err := s.Company.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "twitter_username":
			s.TwitterUsername.Reset()
			if err := s.TwitterUsername.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "has_organization_projects":
			s.HasOrganizationProjects.Reset()
			if err := s.HasOrganizationProjects.Decode(d); err != nil {
				return err
			}
		case "has_repository_projects":
			s.HasRepositoryProjects.Reset()
			if err := s.HasRepositoryProjects.Decode(d); err != nil {
				return err
			}
		case "default_repository_permission":
			s.DefaultRepositoryPermission.Reset()
			if err := s.DefaultRepositoryPermission.Decode(d); err != nil {
				return err
			}
		case "members_can_create_repositories":
			s.MembersCanCreateRepositories.Reset()
			if err := s.MembersCanCreateRepositories.Decode(d); err != nil {
				return err
			}
		case "members_can_create_internal_repositories":
			s.MembersCanCreateInternalRepositories.Reset()
			if err := s.MembersCanCreateInternalRepositories.Decode(d); err != nil {
				return err
			}
		case "members_can_create_private_repositories":
			s.MembersCanCreatePrivateRepositories.Reset()
			if err := s.MembersCanCreatePrivateRepositories.Decode(d); err != nil {
				return err
			}
		case "members_can_create_public_repositories":
			s.MembersCanCreatePublicRepositories.Reset()
			if err := s.MembersCanCreatePublicRepositories.Decode(d); err != nil {
				return err
			}
		case "members_allowed_repository_creation_type":
			s.MembersAllowedRepositoryCreationType.Reset()
			if err := s.MembersAllowedRepositoryCreationType.Decode(d); err != nil {
				return err
			}
		case "members_can_create_pages":
			s.MembersCanCreatePages.Reset()
			if err := s.MembersCanCreatePages.Decode(d); err != nil {
				return err
			}
		case "members_can_create_public_pages":
			s.MembersCanCreatePublicPages.Reset()
			if err := s.MembersCanCreatePublicPages.Decode(d); err != nil {
				return err
			}
		case "members_can_create_private_pages":
			s.MembersCanCreatePrivatePages.Reset()
			if err := s.MembersCanCreatePrivatePages.Decode(d); err != nil {
				return err
			}
		case "blog":
			s.Blog.Reset()
			if err := s.Blog.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgsUpdateReqDefaultRepositoryPermission as json.
func (s OrgsUpdateReqDefaultRepositoryPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsUpdateReqDefaultRepositoryPermission from json.
func (s *OrgsUpdateReqDefaultRepositoryPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateReqDefaultRepositoryPermission to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsUpdateReqDefaultRepositoryPermission(v) {
	case OrgsUpdateReqDefaultRepositoryPermissionRead:
		*s = OrgsUpdateReqDefaultRepositoryPermissionRead
	case OrgsUpdateReqDefaultRepositoryPermissionWrite:
		*s = OrgsUpdateReqDefaultRepositoryPermissionWrite
	case OrgsUpdateReqDefaultRepositoryPermissionAdmin:
		*s = OrgsUpdateReqDefaultRepositoryPermissionAdmin
	case OrgsUpdateReqDefaultRepositoryPermissionNone:
		*s = OrgsUpdateReqDefaultRepositoryPermissionNone
	default:
		*s = OrgsUpdateReqDefaultRepositoryPermission(v)
	}

	return nil
}

// Encode encodes OrgsUpdateReqMembersAllowedRepositoryCreationType as json.
func (s OrgsUpdateReqMembersAllowedRepositoryCreationType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsUpdateReqMembersAllowedRepositoryCreationType from json.
func (s *OrgsUpdateReqMembersAllowedRepositoryCreationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateReqMembersAllowedRepositoryCreationType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsUpdateReqMembersAllowedRepositoryCreationType(v) {
	case OrgsUpdateReqMembersAllowedRepositoryCreationTypeAll:
		*s = OrgsUpdateReqMembersAllowedRepositoryCreationTypeAll
	case OrgsUpdateReqMembersAllowedRepositoryCreationTypePrivate:
		*s = OrgsUpdateReqMembersAllowedRepositoryCreationTypePrivate
	case OrgsUpdateReqMembersAllowedRepositoryCreationTypeNone:
		*s = OrgsUpdateReqMembersAllowedRepositoryCreationTypeNone
	default:
		*s = OrgsUpdateReqMembersAllowedRepositoryCreationType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgsUpdateWebhookConfigForOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OrgsUpdateWebhookConfigForOrgReq from json.
func (s *OrgsUpdateWebhookConfigForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateWebhookConfigForOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl.Reset()
			if err := s.InsecureSsl.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsUpdateWebhookReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Config.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Config.Set {
			e.RawStr("\"config\"" + ":")
			s.Config.Encode(e)
		}
	}
	{
		if s.Events != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Events != nil {
			e.RawStr("\"events\"" + ":")
			e.ArrStart()
			if len(s.Events) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Events[0]
					e.Str(elem)
				}
				for _, elem := range s.Events[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OrgsUpdateWebhookReq from json.
func (s *OrgsUpdateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateWebhookReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			s.Config.Reset()
			if err := s.Config.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsUpdateWebhookReqConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		if s.ContentType.Set {
			e.Comma()
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.Comma()
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.Comma()
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes OrgsUpdateWebhookReqConfig from json.
func (s *OrgsUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateWebhookReqConfig to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.URL = WebhookConfigURL(unwrapped)
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl.Reset()
			if err := s.InsecureSsl.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Package) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"package_type\"" + ":")
		s.PackageType.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		e.Str(s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"version_count\"" + ":")
		e.Int(s.VersionCount)
	}
	{
		e.Comma()

		e.RawStr("\"visibility\"" + ":")
		s.Visibility.Encode(e)
	}
	{
		if s.Owner.Set {
			e.Comma()
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			e.Comma()
		}
		if s.Repository.Set {
			e.RawStr("\"repository\"" + ":")
			s.Repository.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	e.ObjEnd()
}

// Decode decodes Package from json.
func (s *Package) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Package to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "package_type":
			if err := s.PackageType.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := d.Str()
			s.HTMLURL = string(v)
			if err != nil {
				return err
			}
		case "version_count":
			v, err := d.Int()
			s.VersionCount = int(v)
			if err != nil {
				return err
			}
		case "visibility":
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "repository":
			s.Repository.Reset()
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagePackageType as json.
func (s PackagePackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagePackageType from json.
func (s *PackagePackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagePackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagePackageType(v) {
	case PackagePackageTypeNpm:
		*s = PackagePackageTypeNpm
	case PackagePackageTypeMaven:
		*s = PackagePackageTypeMaven
	case PackagePackageTypeRubygems:
		*s = PackagePackageTypeRubygems
	case PackagePackageTypeDocker:
		*s = PackagePackageTypeDocker
	case PackagePackageTypeNuget:
		*s = PackagePackageTypeNuget
	case PackagePackageTypeContainer:
		*s = PackagePackageTypeContainer
	default:
		*s = PackagePackageType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PackageVersion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"package_html_url\"" + ":")
		e.Str(s.PackageHTMLURL)
	}
	{
		if s.HTMLURL.Set {
			e.Comma()
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.License.Set {
			e.Comma()
		}
		if s.License.Set {
			e.RawStr("\"license\"" + ":")
			s.License.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.DeletedAt.Set {
			e.Comma()
		}
		if s.DeletedAt.Set {
			e.RawStr("\"deleted_at\"" + ":")
			s.DeletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PackageVersion from json.
func (s *PackageVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackageVersion to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "package_html_url":
			v, err := d.Str()
			s.PackageHTMLURL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "license":
			s.License.Reset()
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "deleted_at":
			s.DeletedAt.Reset()
			if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PackageVersionMetadata) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"package_type\"" + ":")
		s.PackageType.Encode(e)
	}
	{
		if s.Container.Set {
			e.Comma()
		}
		if s.Container.Set {
			e.RawStr("\"container\"" + ":")
			s.Container.Encode(e)
		}
	}
	{
		if s.Docker.Set {
			e.Comma()
		}
		if s.Docker.Set {
			e.RawStr("\"docker\"" + ":")
			s.Docker.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PackageVersionMetadata from json.
func (s *PackageVersionMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackageVersionMetadata to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "package_type":
			if err := s.PackageType.Decode(d); err != nil {
				return err
			}
		case "container":
			s.Container.Reset()
			if err := s.Container.Decode(d); err != nil {
				return err
			}
		case "docker":
			s.Docker.Reset()
			if err := s.Docker.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PackageVersionMetadataContainer) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"tags\"" + ":")
		e.ArrStart()
		if len(s.Tags) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Tags[0]
				e.Str(elem)
			}
			for _, elem := range s.Tags[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes PackageVersionMetadataContainer from json.
func (s *PackageVersionMetadataContainer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackageVersionMetadataContainer to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			s.Tags = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Tags = append(s.Tags, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PackageVersionMetadataDocker) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Tag != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Tag != nil {
			e.RawStr("\"tag\"" + ":")
			e.ArrStart()
			if len(s.Tag) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Tag[0]
					e.Str(elem)
				}
				for _, elem := range s.Tag[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes PackageVersionMetadataDocker from json.
func (s *PackageVersionMetadataDocker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackageVersionMetadataDocker to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			s.Tag = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Tag = append(s.Tag, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackageVersionMetadataPackageType as json.
func (s PackageVersionMetadataPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackageVersionMetadataPackageType from json.
func (s *PackageVersionMetadataPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackageVersionMetadataPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackageVersionMetadataPackageType(v) {
	case PackageVersionMetadataPackageTypeNpm:
		*s = PackageVersionMetadataPackageTypeNpm
	case PackageVersionMetadataPackageTypeMaven:
		*s = PackageVersionMetadataPackageTypeMaven
	case PackageVersionMetadataPackageTypeRubygems:
		*s = PackageVersionMetadataPackageTypeRubygems
	case PackageVersionMetadataPackageTypeDocker:
		*s = PackageVersionMetadataPackageTypeDocker
	case PackageVersionMetadataPackageTypeNuget:
		*s = PackageVersionMetadataPackageTypeNuget
	case PackageVersionMetadataPackageTypeContainer:
		*s = PackageVersionMetadataPackageTypeContainer
	default:
		*s = PackageVersionMetadataPackageType(v)
	}

	return nil
}

// Encode encodes PackageVisibility as json.
func (s PackageVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackageVisibility from json.
func (s *PackageVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackageVisibility to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackageVisibility(v) {
	case PackageVisibilityPrivate:
		*s = PackageVisibilityPrivate
	case PackageVisibilityPublic:
		*s = PackageVisibilityPublic
	default:
		*s = PackageVisibility(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PackagesBillingUsage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_gigabytes_bandwidth_used\"" + ":")
		e.Int(s.TotalGigabytesBandwidthUsed)
	}
	{
		e.Comma()

		e.RawStr("\"total_paid_gigabytes_bandwidth_used\"" + ":")
		e.Int(s.TotalPaidGigabytesBandwidthUsed)
	}
	{
		e.Comma()

		e.RawStr("\"included_gigabytes_bandwidth\"" + ":")
		e.Int(s.IncludedGigabytesBandwidth)
	}
	e.ObjEnd()
}

// Decode decodes PackagesBillingUsage from json.
func (s *PackagesBillingUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesBillingUsage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_gigabytes_bandwidth_used":
			v, err := d.Int()
			s.TotalGigabytesBandwidthUsed = int(v)
			if err != nil {
				return err
			}
		case "total_paid_gigabytes_bandwidth_used":
			v, err := d.Int()
			s.TotalPaidGigabytesBandwidthUsed = int(v)
			if err != nil {
				return err
			}
		case "included_gigabytes_bandwidth":
			v, err := d.Int()
			s.IncludedGigabytesBandwidth = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden as json.
func (s PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden from json.
func (s *PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound as json.
func (s PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound from json.
func (s *PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesDeletePackageForAuthenticatedUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserNoContent from json.
func (s *PackagesDeletePackageForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesDeletePackageForAuthenticatedUserPackageType as json.
func (s PackagesDeletePackageForAuthenticatedUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserPackageType from json.
func (s *PackagesDeletePackageForAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForAuthenticatedUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesDeletePackageForAuthenticatedUserPackageType(v) {
	case PackagesDeletePackageForAuthenticatedUserPackageTypeNpm:
		*s = PackagesDeletePackageForAuthenticatedUserPackageTypeNpm
	case PackagesDeletePackageForAuthenticatedUserPackageTypeMaven:
		*s = PackagesDeletePackageForAuthenticatedUserPackageTypeMaven
	case PackagesDeletePackageForAuthenticatedUserPackageTypeRubygems:
		*s = PackagesDeletePackageForAuthenticatedUserPackageTypeRubygems
	case PackagesDeletePackageForAuthenticatedUserPackageTypeDocker:
		*s = PackagesDeletePackageForAuthenticatedUserPackageTypeDocker
	case PackagesDeletePackageForAuthenticatedUserPackageTypeNuget:
		*s = PackagesDeletePackageForAuthenticatedUserPackageTypeNuget
	case PackagesDeletePackageForAuthenticatedUserPackageTypeContainer:
		*s = PackagesDeletePackageForAuthenticatedUserPackageTypeContainer
	default:
		*s = PackagesDeletePackageForAuthenticatedUserPackageType(v)
	}

	return nil
}

// Encode encodes PackagesDeletePackageForOrgApplicationJSONForbidden as json.
func (s PackagesDeletePackageForOrgApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForOrgApplicationJSONForbidden from json.
func (s *PackagesDeletePackageForOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForOrgApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForOrgApplicationJSONNotFound as json.
func (s PackagesDeletePackageForOrgApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForOrgApplicationJSONNotFound from json.
func (s *PackagesDeletePackageForOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForOrgApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForOrgApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageForOrgApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForOrgApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageForOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForOrgApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesDeletePackageForOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes PackagesDeletePackageForOrgNoContent from json.
func (s *PackagesDeletePackageForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesDeletePackageForOrgPackageType as json.
func (s PackagesDeletePackageForOrgPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesDeletePackageForOrgPackageType from json.
func (s *PackagesDeletePackageForOrgPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForOrgPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesDeletePackageForOrgPackageType(v) {
	case PackagesDeletePackageForOrgPackageTypeNpm:
		*s = PackagesDeletePackageForOrgPackageTypeNpm
	case PackagesDeletePackageForOrgPackageTypeMaven:
		*s = PackagesDeletePackageForOrgPackageTypeMaven
	case PackagesDeletePackageForOrgPackageTypeRubygems:
		*s = PackagesDeletePackageForOrgPackageTypeRubygems
	case PackagesDeletePackageForOrgPackageTypeDocker:
		*s = PackagesDeletePackageForOrgPackageTypeDocker
	case PackagesDeletePackageForOrgPackageTypeNuget:
		*s = PackagesDeletePackageForOrgPackageTypeNuget
	case PackagesDeletePackageForOrgPackageTypeContainer:
		*s = PackagesDeletePackageForOrgPackageTypeContainer
	default:
		*s = PackagesDeletePackageForOrgPackageType(v)
	}

	return nil
}

// Encode encodes PackagesDeletePackageForUserApplicationJSONForbidden as json.
func (s PackagesDeletePackageForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForUserApplicationJSONForbidden from json.
func (s *PackagesDeletePackageForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForUserApplicationJSONNotFound as json.
func (s PackagesDeletePackageForUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForUserApplicationJSONNotFound from json.
func (s *PackagesDeletePackageForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForUserApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageForUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForUserApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesDeletePackageForUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes PackagesDeletePackageForUserNoContent from json.
func (s *PackagesDeletePackageForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesDeletePackageForUserPackageType as json.
func (s PackagesDeletePackageForUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesDeletePackageForUserPackageType from json.
func (s *PackagesDeletePackageForUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesDeletePackageForUserPackageType(v) {
	case PackagesDeletePackageForUserPackageTypeNpm:
		*s = PackagesDeletePackageForUserPackageTypeNpm
	case PackagesDeletePackageForUserPackageTypeMaven:
		*s = PackagesDeletePackageForUserPackageTypeMaven
	case PackagesDeletePackageForUserPackageTypeRubygems:
		*s = PackagesDeletePackageForUserPackageTypeRubygems
	case PackagesDeletePackageForUserPackageTypeDocker:
		*s = PackagesDeletePackageForUserPackageTypeDocker
	case PackagesDeletePackageForUserPackageTypeNuget:
		*s = PackagesDeletePackageForUserPackageTypeNuget
	case PackagesDeletePackageForUserPackageTypeContainer:
		*s = PackagesDeletePackageForUserPackageTypeContainer
	default:
		*s = PackagesDeletePackageForUserPackageType(v)
	}

	return nil
}

// Encode encodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden as json.
func (s PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound as json.
func (s PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesDeletePackageVersionForAuthenticatedUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserNoContent from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesDeletePackageVersionForAuthenticatedUserPackageType as json.
func (s PackagesDeletePackageVersionForAuthenticatedUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserPackageType from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesDeletePackageVersionForAuthenticatedUserPackageType(v) {
	case PackagesDeletePackageVersionForAuthenticatedUserPackageTypeNpm:
		*s = PackagesDeletePackageVersionForAuthenticatedUserPackageTypeNpm
	case PackagesDeletePackageVersionForAuthenticatedUserPackageTypeMaven:
		*s = PackagesDeletePackageVersionForAuthenticatedUserPackageTypeMaven
	case PackagesDeletePackageVersionForAuthenticatedUserPackageTypeRubygems:
		*s = PackagesDeletePackageVersionForAuthenticatedUserPackageTypeRubygems
	case PackagesDeletePackageVersionForAuthenticatedUserPackageTypeDocker:
		*s = PackagesDeletePackageVersionForAuthenticatedUserPackageTypeDocker
	case PackagesDeletePackageVersionForAuthenticatedUserPackageTypeNuget:
		*s = PackagesDeletePackageVersionForAuthenticatedUserPackageTypeNuget
	case PackagesDeletePackageVersionForAuthenticatedUserPackageTypeContainer:
		*s = PackagesDeletePackageVersionForAuthenticatedUserPackageTypeContainer
	default:
		*s = PackagesDeletePackageVersionForAuthenticatedUserPackageType(v)
	}

	return nil
}

// Encode encodes PackagesDeletePackageVersionForOrgApplicationJSONForbidden as json.
func (s PackagesDeletePackageVersionForOrgApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForOrgApplicationJSONForbidden from json.
func (s *PackagesDeletePackageVersionForOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForOrgApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForOrgApplicationJSONNotFound as json.
func (s PackagesDeletePackageVersionForOrgApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForOrgApplicationJSONNotFound from json.
func (s *PackagesDeletePackageVersionForOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForOrgApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesDeletePackageVersionForOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes PackagesDeletePackageVersionForOrgNoContent from json.
func (s *PackagesDeletePackageVersionForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesDeletePackageVersionForOrgPackageType as json.
func (s PackagesDeletePackageVersionForOrgPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesDeletePackageVersionForOrgPackageType from json.
func (s *PackagesDeletePackageVersionForOrgPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForOrgPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesDeletePackageVersionForOrgPackageType(v) {
	case PackagesDeletePackageVersionForOrgPackageTypeNpm:
		*s = PackagesDeletePackageVersionForOrgPackageTypeNpm
	case PackagesDeletePackageVersionForOrgPackageTypeMaven:
		*s = PackagesDeletePackageVersionForOrgPackageTypeMaven
	case PackagesDeletePackageVersionForOrgPackageTypeRubygems:
		*s = PackagesDeletePackageVersionForOrgPackageTypeRubygems
	case PackagesDeletePackageVersionForOrgPackageTypeDocker:
		*s = PackagesDeletePackageVersionForOrgPackageTypeDocker
	case PackagesDeletePackageVersionForOrgPackageTypeNuget:
		*s = PackagesDeletePackageVersionForOrgPackageTypeNuget
	case PackagesDeletePackageVersionForOrgPackageTypeContainer:
		*s = PackagesDeletePackageVersionForOrgPackageTypeContainer
	default:
		*s = PackagesDeletePackageVersionForOrgPackageType(v)
	}

	return nil
}

// Encode encodes PackagesDeletePackageVersionForUserApplicationJSONForbidden as json.
func (s PackagesDeletePackageVersionForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForUserApplicationJSONForbidden from json.
func (s *PackagesDeletePackageVersionForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForUserApplicationJSONNotFound as json.
func (s PackagesDeletePackageVersionForUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForUserApplicationJSONNotFound from json.
func (s *PackagesDeletePackageVersionForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForUserApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageVersionForUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForUserApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageVersionForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesDeletePackageVersionForUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes PackagesDeletePackageVersionForUserNoContent from json.
func (s *PackagesDeletePackageVersionForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesDeletePackageVersionForUserPackageType as json.
func (s PackagesDeletePackageVersionForUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesDeletePackageVersionForUserPackageType from json.
func (s *PackagesDeletePackageVersionForUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesDeletePackageVersionForUserPackageType(v) {
	case PackagesDeletePackageVersionForUserPackageTypeNpm:
		*s = PackagesDeletePackageVersionForUserPackageTypeNpm
	case PackagesDeletePackageVersionForUserPackageTypeMaven:
		*s = PackagesDeletePackageVersionForUserPackageTypeMaven
	case PackagesDeletePackageVersionForUserPackageTypeRubygems:
		*s = PackagesDeletePackageVersionForUserPackageTypeRubygems
	case PackagesDeletePackageVersionForUserPackageTypeDocker:
		*s = PackagesDeletePackageVersionForUserPackageTypeDocker
	case PackagesDeletePackageVersionForUserPackageTypeNuget:
		*s = PackagesDeletePackageVersionForUserPackageTypeNuget
	case PackagesDeletePackageVersionForUserPackageTypeContainer:
		*s = PackagesDeletePackageVersionForUserPackageTypeContainer
	default:
		*s = PackagesDeletePackageVersionForUserPackageType(v)
	}

	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PackageVersion(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []PackageVersion
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PackageVersion
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType(v) {
	case PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageTypeNpm:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageTypeNpm
	case PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageTypeMaven:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageTypeMaven
	case PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageTypeRubygems:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageTypeRubygems
	case PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageTypeDocker:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageTypeDocker
	case PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageTypeNuget:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageTypeNuget
	case PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageTypeContainer:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageTypeContainer
	default:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType(v)
	}

	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState(v) {
	case PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserStateActive:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserStateActive
	case PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserStateDeleted:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserStateDeleted
	default:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState(v)
	}

	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PackageVersion(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON to nil`)
	}
	var unwrapped []PackageVersion
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PackageVersion
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType(v) {
	case PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageTypeNpm:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageTypeNpm
	case PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageTypeMaven:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageTypeMaven
	case PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageTypeRubygems:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageTypeRubygems
	case PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageTypeDocker:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageTypeDocker
	case PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageTypeNuget:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageTypeNuget
	case PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageTypeContainer:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageTypeContainer
	default:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType(v)
	}

	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgState as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgState from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesGetAllPackageVersionsForPackageOwnedByOrgState(v) {
	case PackagesGetAllPackageVersionsForPackageOwnedByOrgStateActive:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgStateActive
	case PackagesGetAllPackageVersionsForPackageOwnedByOrgStateDeleted:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgStateDeleted
	default:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgState(v)
	}

	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PackageVersion(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON to nil`)
	}
	var unwrapped []PackageVersion
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PackageVersion
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType(v) {
	case PackagesGetAllPackageVersionsForPackageOwnedByUserPackageTypeNpm:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByUserPackageTypeNpm
	case PackagesGetAllPackageVersionsForPackageOwnedByUserPackageTypeMaven:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByUserPackageTypeMaven
	case PackagesGetAllPackageVersionsForPackageOwnedByUserPackageTypeRubygems:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByUserPackageTypeRubygems
	case PackagesGetAllPackageVersionsForPackageOwnedByUserPackageTypeDocker:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByUserPackageTypeDocker
	case PackagesGetAllPackageVersionsForPackageOwnedByUserPackageTypeNuget:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByUserPackageTypeNuget
	case PackagesGetAllPackageVersionsForPackageOwnedByUserPackageTypeContainer:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByUserPackageTypeContainer
	default:
		*s = PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType(v)
	}

	return nil
}

// Encode encodes PackagesGetPackageForAuthenticatedUserPackageType as json.
func (s PackagesGetPackageForAuthenticatedUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesGetPackageForAuthenticatedUserPackageType from json.
func (s *PackagesGetPackageForAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetPackageForAuthenticatedUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesGetPackageForAuthenticatedUserPackageType(v) {
	case PackagesGetPackageForAuthenticatedUserPackageTypeNpm:
		*s = PackagesGetPackageForAuthenticatedUserPackageTypeNpm
	case PackagesGetPackageForAuthenticatedUserPackageTypeMaven:
		*s = PackagesGetPackageForAuthenticatedUserPackageTypeMaven
	case PackagesGetPackageForAuthenticatedUserPackageTypeRubygems:
		*s = PackagesGetPackageForAuthenticatedUserPackageTypeRubygems
	case PackagesGetPackageForAuthenticatedUserPackageTypeDocker:
		*s = PackagesGetPackageForAuthenticatedUserPackageTypeDocker
	case PackagesGetPackageForAuthenticatedUserPackageTypeNuget:
		*s = PackagesGetPackageForAuthenticatedUserPackageTypeNuget
	case PackagesGetPackageForAuthenticatedUserPackageTypeContainer:
		*s = PackagesGetPackageForAuthenticatedUserPackageTypeContainer
	default:
		*s = PackagesGetPackageForAuthenticatedUserPackageType(v)
	}

	return nil
}

// Encode encodes PackagesGetPackageForOrganizationPackageType as json.
func (s PackagesGetPackageForOrganizationPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesGetPackageForOrganizationPackageType from json.
func (s *PackagesGetPackageForOrganizationPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetPackageForOrganizationPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesGetPackageForOrganizationPackageType(v) {
	case PackagesGetPackageForOrganizationPackageTypeNpm:
		*s = PackagesGetPackageForOrganizationPackageTypeNpm
	case PackagesGetPackageForOrganizationPackageTypeMaven:
		*s = PackagesGetPackageForOrganizationPackageTypeMaven
	case PackagesGetPackageForOrganizationPackageTypeRubygems:
		*s = PackagesGetPackageForOrganizationPackageTypeRubygems
	case PackagesGetPackageForOrganizationPackageTypeDocker:
		*s = PackagesGetPackageForOrganizationPackageTypeDocker
	case PackagesGetPackageForOrganizationPackageTypeNuget:
		*s = PackagesGetPackageForOrganizationPackageTypeNuget
	case PackagesGetPackageForOrganizationPackageTypeContainer:
		*s = PackagesGetPackageForOrganizationPackageTypeContainer
	default:
		*s = PackagesGetPackageForOrganizationPackageType(v)
	}

	return nil
}

// Encode encodes PackagesGetPackageForUserPackageType as json.
func (s PackagesGetPackageForUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesGetPackageForUserPackageType from json.
func (s *PackagesGetPackageForUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetPackageForUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesGetPackageForUserPackageType(v) {
	case PackagesGetPackageForUserPackageTypeNpm:
		*s = PackagesGetPackageForUserPackageTypeNpm
	case PackagesGetPackageForUserPackageTypeMaven:
		*s = PackagesGetPackageForUserPackageTypeMaven
	case PackagesGetPackageForUserPackageTypeRubygems:
		*s = PackagesGetPackageForUserPackageTypeRubygems
	case PackagesGetPackageForUserPackageTypeDocker:
		*s = PackagesGetPackageForUserPackageTypeDocker
	case PackagesGetPackageForUserPackageTypeNuget:
		*s = PackagesGetPackageForUserPackageTypeNuget
	case PackagesGetPackageForUserPackageTypeContainer:
		*s = PackagesGetPackageForUserPackageTypeContainer
	default:
		*s = PackagesGetPackageForUserPackageType(v)
	}

	return nil
}

// Encode encodes PackagesGetPackageVersionForAuthenticatedUserPackageType as json.
func (s PackagesGetPackageVersionForAuthenticatedUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesGetPackageVersionForAuthenticatedUserPackageType from json.
func (s *PackagesGetPackageVersionForAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetPackageVersionForAuthenticatedUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesGetPackageVersionForAuthenticatedUserPackageType(v) {
	case PackagesGetPackageVersionForAuthenticatedUserPackageTypeNpm:
		*s = PackagesGetPackageVersionForAuthenticatedUserPackageTypeNpm
	case PackagesGetPackageVersionForAuthenticatedUserPackageTypeMaven:
		*s = PackagesGetPackageVersionForAuthenticatedUserPackageTypeMaven
	case PackagesGetPackageVersionForAuthenticatedUserPackageTypeRubygems:
		*s = PackagesGetPackageVersionForAuthenticatedUserPackageTypeRubygems
	case PackagesGetPackageVersionForAuthenticatedUserPackageTypeDocker:
		*s = PackagesGetPackageVersionForAuthenticatedUserPackageTypeDocker
	case PackagesGetPackageVersionForAuthenticatedUserPackageTypeNuget:
		*s = PackagesGetPackageVersionForAuthenticatedUserPackageTypeNuget
	case PackagesGetPackageVersionForAuthenticatedUserPackageTypeContainer:
		*s = PackagesGetPackageVersionForAuthenticatedUserPackageTypeContainer
	default:
		*s = PackagesGetPackageVersionForAuthenticatedUserPackageType(v)
	}

	return nil
}

// Encode encodes PackagesGetPackageVersionForOrganizationPackageType as json.
func (s PackagesGetPackageVersionForOrganizationPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesGetPackageVersionForOrganizationPackageType from json.
func (s *PackagesGetPackageVersionForOrganizationPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetPackageVersionForOrganizationPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesGetPackageVersionForOrganizationPackageType(v) {
	case PackagesGetPackageVersionForOrganizationPackageTypeNpm:
		*s = PackagesGetPackageVersionForOrganizationPackageTypeNpm
	case PackagesGetPackageVersionForOrganizationPackageTypeMaven:
		*s = PackagesGetPackageVersionForOrganizationPackageTypeMaven
	case PackagesGetPackageVersionForOrganizationPackageTypeRubygems:
		*s = PackagesGetPackageVersionForOrganizationPackageTypeRubygems
	case PackagesGetPackageVersionForOrganizationPackageTypeDocker:
		*s = PackagesGetPackageVersionForOrganizationPackageTypeDocker
	case PackagesGetPackageVersionForOrganizationPackageTypeNuget:
		*s = PackagesGetPackageVersionForOrganizationPackageTypeNuget
	case PackagesGetPackageVersionForOrganizationPackageTypeContainer:
		*s = PackagesGetPackageVersionForOrganizationPackageTypeContainer
	default:
		*s = PackagesGetPackageVersionForOrganizationPackageType(v)
	}

	return nil
}

// Encode encodes PackagesGetPackageVersionForUserPackageType as json.
func (s PackagesGetPackageVersionForUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesGetPackageVersionForUserPackageType from json.
func (s *PackagesGetPackageVersionForUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetPackageVersionForUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesGetPackageVersionForUserPackageType(v) {
	case PackagesGetPackageVersionForUserPackageTypeNpm:
		*s = PackagesGetPackageVersionForUserPackageTypeNpm
	case PackagesGetPackageVersionForUserPackageTypeMaven:
		*s = PackagesGetPackageVersionForUserPackageTypeMaven
	case PackagesGetPackageVersionForUserPackageTypeRubygems:
		*s = PackagesGetPackageVersionForUserPackageTypeRubygems
	case PackagesGetPackageVersionForUserPackageTypeDocker:
		*s = PackagesGetPackageVersionForUserPackageTypeDocker
	case PackagesGetPackageVersionForUserPackageTypeNuget:
		*s = PackagesGetPackageVersionForUserPackageTypeNuget
	case PackagesGetPackageVersionForUserPackageTypeContainer:
		*s = PackagesGetPackageVersionForUserPackageTypeContainer
	default:
		*s = PackagesGetPackageVersionForUserPackageType(v)
	}

	return nil
}

// Encode encodes PackagesListPackagesForAuthenticatedUserPackageType as json.
func (s PackagesListPackagesForAuthenticatedUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesListPackagesForAuthenticatedUserPackageType from json.
func (s *PackagesListPackagesForAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForAuthenticatedUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesListPackagesForAuthenticatedUserPackageType(v) {
	case PackagesListPackagesForAuthenticatedUserPackageTypeNpm:
		*s = PackagesListPackagesForAuthenticatedUserPackageTypeNpm
	case PackagesListPackagesForAuthenticatedUserPackageTypeMaven:
		*s = PackagesListPackagesForAuthenticatedUserPackageTypeMaven
	case PackagesListPackagesForAuthenticatedUserPackageTypeRubygems:
		*s = PackagesListPackagesForAuthenticatedUserPackageTypeRubygems
	case PackagesListPackagesForAuthenticatedUserPackageTypeDocker:
		*s = PackagesListPackagesForAuthenticatedUserPackageTypeDocker
	case PackagesListPackagesForAuthenticatedUserPackageTypeNuget:
		*s = PackagesListPackagesForAuthenticatedUserPackageTypeNuget
	case PackagesListPackagesForAuthenticatedUserPackageTypeContainer:
		*s = PackagesListPackagesForAuthenticatedUserPackageTypeContainer
	default:
		*s = PackagesListPackagesForAuthenticatedUserPackageType(v)
	}

	return nil
}

// Encode encodes PackagesListPackagesForAuthenticatedUserVisibility as json.
func (s PackagesListPackagesForAuthenticatedUserVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesListPackagesForAuthenticatedUserVisibility from json.
func (s *PackagesListPackagesForAuthenticatedUserVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForAuthenticatedUserVisibility to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesListPackagesForAuthenticatedUserVisibility(v) {
	case PackagesListPackagesForAuthenticatedUserVisibilityPublic:
		*s = PackagesListPackagesForAuthenticatedUserVisibilityPublic
	case PackagesListPackagesForAuthenticatedUserVisibilityPrivate:
		*s = PackagesListPackagesForAuthenticatedUserVisibilityPrivate
	case PackagesListPackagesForAuthenticatedUserVisibilityInternal:
		*s = PackagesListPackagesForAuthenticatedUserVisibilityInternal
	default:
		*s = PackagesListPackagesForAuthenticatedUserVisibility(v)
	}

	return nil
}

// Encode encodes PackagesListPackagesForOrganizationApplicationJSONForbidden as json.
func (s PackagesListPackagesForOrganizationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForOrganizationApplicationJSONForbidden from json.
func (s *PackagesListPackagesForOrganizationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForOrganizationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForOrganizationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForOrganizationApplicationJSONUnauthorized as json.
func (s PackagesListPackagesForOrganizationApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForOrganizationApplicationJSONUnauthorized from json.
func (s *PackagesListPackagesForOrganizationApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForOrganizationApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForOrganizationApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForOrganizationOKApplicationJSON as json.
func (s PackagesListPackagesForOrganizationOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Package(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PackagesListPackagesForOrganizationOKApplicationJSON from json.
func (s *PackagesListPackagesForOrganizationOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForOrganizationOKApplicationJSON to nil`)
	}
	var unwrapped []Package
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Package
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForOrganizationOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForOrganizationPackageType as json.
func (s PackagesListPackagesForOrganizationPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesListPackagesForOrganizationPackageType from json.
func (s *PackagesListPackagesForOrganizationPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForOrganizationPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesListPackagesForOrganizationPackageType(v) {
	case PackagesListPackagesForOrganizationPackageTypeNpm:
		*s = PackagesListPackagesForOrganizationPackageTypeNpm
	case PackagesListPackagesForOrganizationPackageTypeMaven:
		*s = PackagesListPackagesForOrganizationPackageTypeMaven
	case PackagesListPackagesForOrganizationPackageTypeRubygems:
		*s = PackagesListPackagesForOrganizationPackageTypeRubygems
	case PackagesListPackagesForOrganizationPackageTypeDocker:
		*s = PackagesListPackagesForOrganizationPackageTypeDocker
	case PackagesListPackagesForOrganizationPackageTypeNuget:
		*s = PackagesListPackagesForOrganizationPackageTypeNuget
	case PackagesListPackagesForOrganizationPackageTypeContainer:
		*s = PackagesListPackagesForOrganizationPackageTypeContainer
	default:
		*s = PackagesListPackagesForOrganizationPackageType(v)
	}

	return nil
}

// Encode encodes PackagesListPackagesForOrganizationVisibility as json.
func (s PackagesListPackagesForOrganizationVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesListPackagesForOrganizationVisibility from json.
func (s *PackagesListPackagesForOrganizationVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForOrganizationVisibility to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesListPackagesForOrganizationVisibility(v) {
	case PackagesListPackagesForOrganizationVisibilityPublic:
		*s = PackagesListPackagesForOrganizationVisibilityPublic
	case PackagesListPackagesForOrganizationVisibilityPrivate:
		*s = PackagesListPackagesForOrganizationVisibilityPrivate
	case PackagesListPackagesForOrganizationVisibilityInternal:
		*s = PackagesListPackagesForOrganizationVisibilityInternal
	default:
		*s = PackagesListPackagesForOrganizationVisibility(v)
	}

	return nil
}

// Encode encodes PackagesListPackagesForUserApplicationJSONForbidden as json.
func (s PackagesListPackagesForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForUserApplicationJSONForbidden from json.
func (s *PackagesListPackagesForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForUserApplicationJSONUnauthorized as json.
func (s PackagesListPackagesForUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForUserApplicationJSONUnauthorized from json.
func (s *PackagesListPackagesForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForUserOKApplicationJSON as json.
func (s PackagesListPackagesForUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Package(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PackagesListPackagesForUserOKApplicationJSON from json.
func (s *PackagesListPackagesForUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForUserOKApplicationJSON to nil`)
	}
	var unwrapped []Package
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Package
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForUserPackageType as json.
func (s PackagesListPackagesForUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesListPackagesForUserPackageType from json.
func (s *PackagesListPackagesForUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesListPackagesForUserPackageType(v) {
	case PackagesListPackagesForUserPackageTypeNpm:
		*s = PackagesListPackagesForUserPackageTypeNpm
	case PackagesListPackagesForUserPackageTypeMaven:
		*s = PackagesListPackagesForUserPackageTypeMaven
	case PackagesListPackagesForUserPackageTypeRubygems:
		*s = PackagesListPackagesForUserPackageTypeRubygems
	case PackagesListPackagesForUserPackageTypeDocker:
		*s = PackagesListPackagesForUserPackageTypeDocker
	case PackagesListPackagesForUserPackageTypeNuget:
		*s = PackagesListPackagesForUserPackageTypeNuget
	case PackagesListPackagesForUserPackageTypeContainer:
		*s = PackagesListPackagesForUserPackageTypeContainer
	default:
		*s = PackagesListPackagesForUserPackageType(v)
	}

	return nil
}

// Encode encodes PackagesListPackagesForUserVisibility as json.
func (s PackagesListPackagesForUserVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesListPackagesForUserVisibility from json.
func (s *PackagesListPackagesForUserVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForUserVisibility to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesListPackagesForUserVisibility(v) {
	case PackagesListPackagesForUserVisibilityPublic:
		*s = PackagesListPackagesForUserVisibilityPublic
	case PackagesListPackagesForUserVisibilityPrivate:
		*s = PackagesListPackagesForUserVisibilityPrivate
	case PackagesListPackagesForUserVisibilityInternal:
		*s = PackagesListPackagesForUserVisibilityInternal
	default:
		*s = PackagesListPackagesForUserVisibility(v)
	}

	return nil
}

// Encode encodes PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden as json.
func (s PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden from json.
func (s *PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound as json.
func (s PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound from json.
func (s *PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesRestorePackageForAuthenticatedUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserNoContent from json.
func (s *PackagesRestorePackageForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesRestorePackageForAuthenticatedUserPackageType as json.
func (s PackagesRestorePackageForAuthenticatedUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserPackageType from json.
func (s *PackagesRestorePackageForAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForAuthenticatedUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesRestorePackageForAuthenticatedUserPackageType(v) {
	case PackagesRestorePackageForAuthenticatedUserPackageTypeNpm:
		*s = PackagesRestorePackageForAuthenticatedUserPackageTypeNpm
	case PackagesRestorePackageForAuthenticatedUserPackageTypeMaven:
		*s = PackagesRestorePackageForAuthenticatedUserPackageTypeMaven
	case PackagesRestorePackageForAuthenticatedUserPackageTypeRubygems:
		*s = PackagesRestorePackageForAuthenticatedUserPackageTypeRubygems
	case PackagesRestorePackageForAuthenticatedUserPackageTypeDocker:
		*s = PackagesRestorePackageForAuthenticatedUserPackageTypeDocker
	case PackagesRestorePackageForAuthenticatedUserPackageTypeNuget:
		*s = PackagesRestorePackageForAuthenticatedUserPackageTypeNuget
	case PackagesRestorePackageForAuthenticatedUserPackageTypeContainer:
		*s = PackagesRestorePackageForAuthenticatedUserPackageTypeContainer
	default:
		*s = PackagesRestorePackageForAuthenticatedUserPackageType(v)
	}

	return nil
}

// Encode encodes PackagesRestorePackageForOrgApplicationJSONForbidden as json.
func (s PackagesRestorePackageForOrgApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForOrgApplicationJSONForbidden from json.
func (s *PackagesRestorePackageForOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForOrgApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForOrgApplicationJSONNotFound as json.
func (s PackagesRestorePackageForOrgApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForOrgApplicationJSONNotFound from json.
func (s *PackagesRestorePackageForOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForOrgApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForOrgApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageForOrgApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForOrgApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageForOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForOrgApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesRestorePackageForOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes PackagesRestorePackageForOrgNoContent from json.
func (s *PackagesRestorePackageForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesRestorePackageForOrgPackageType as json.
func (s PackagesRestorePackageForOrgPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesRestorePackageForOrgPackageType from json.
func (s *PackagesRestorePackageForOrgPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForOrgPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesRestorePackageForOrgPackageType(v) {
	case PackagesRestorePackageForOrgPackageTypeNpm:
		*s = PackagesRestorePackageForOrgPackageTypeNpm
	case PackagesRestorePackageForOrgPackageTypeMaven:
		*s = PackagesRestorePackageForOrgPackageTypeMaven
	case PackagesRestorePackageForOrgPackageTypeRubygems:
		*s = PackagesRestorePackageForOrgPackageTypeRubygems
	case PackagesRestorePackageForOrgPackageTypeDocker:
		*s = PackagesRestorePackageForOrgPackageTypeDocker
	case PackagesRestorePackageForOrgPackageTypeNuget:
		*s = PackagesRestorePackageForOrgPackageTypeNuget
	case PackagesRestorePackageForOrgPackageTypeContainer:
		*s = PackagesRestorePackageForOrgPackageTypeContainer
	default:
		*s = PackagesRestorePackageForOrgPackageType(v)
	}

	return nil
}

// Encode encodes PackagesRestorePackageForUserApplicationJSONForbidden as json.
func (s PackagesRestorePackageForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForUserApplicationJSONForbidden from json.
func (s *PackagesRestorePackageForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForUserApplicationJSONNotFound as json.
func (s PackagesRestorePackageForUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForUserApplicationJSONNotFound from json.
func (s *PackagesRestorePackageForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForUserApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageForUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForUserApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesRestorePackageForUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes PackagesRestorePackageForUserNoContent from json.
func (s *PackagesRestorePackageForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesRestorePackageForUserPackageType as json.
func (s PackagesRestorePackageForUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesRestorePackageForUserPackageType from json.
func (s *PackagesRestorePackageForUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesRestorePackageForUserPackageType(v) {
	case PackagesRestorePackageForUserPackageTypeNpm:
		*s = PackagesRestorePackageForUserPackageTypeNpm
	case PackagesRestorePackageForUserPackageTypeMaven:
		*s = PackagesRestorePackageForUserPackageTypeMaven
	case PackagesRestorePackageForUserPackageTypeRubygems:
		*s = PackagesRestorePackageForUserPackageTypeRubygems
	case PackagesRestorePackageForUserPackageTypeDocker:
		*s = PackagesRestorePackageForUserPackageTypeDocker
	case PackagesRestorePackageForUserPackageTypeNuget:
		*s = PackagesRestorePackageForUserPackageTypeNuget
	case PackagesRestorePackageForUserPackageTypeContainer:
		*s = PackagesRestorePackageForUserPackageTypeContainer
	default:
		*s = PackagesRestorePackageForUserPackageType(v)
	}

	return nil
}

// Encode encodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden as json.
func (s PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound as json.
func (s PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesRestorePackageVersionForAuthenticatedUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserNoContent from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesRestorePackageVersionForAuthenticatedUserPackageType as json.
func (s PackagesRestorePackageVersionForAuthenticatedUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserPackageType from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesRestorePackageVersionForAuthenticatedUserPackageType(v) {
	case PackagesRestorePackageVersionForAuthenticatedUserPackageTypeNpm:
		*s = PackagesRestorePackageVersionForAuthenticatedUserPackageTypeNpm
	case PackagesRestorePackageVersionForAuthenticatedUserPackageTypeMaven:
		*s = PackagesRestorePackageVersionForAuthenticatedUserPackageTypeMaven
	case PackagesRestorePackageVersionForAuthenticatedUserPackageTypeRubygems:
		*s = PackagesRestorePackageVersionForAuthenticatedUserPackageTypeRubygems
	case PackagesRestorePackageVersionForAuthenticatedUserPackageTypeDocker:
		*s = PackagesRestorePackageVersionForAuthenticatedUserPackageTypeDocker
	case PackagesRestorePackageVersionForAuthenticatedUserPackageTypeNuget:
		*s = PackagesRestorePackageVersionForAuthenticatedUserPackageTypeNuget
	case PackagesRestorePackageVersionForAuthenticatedUserPackageTypeContainer:
		*s = PackagesRestorePackageVersionForAuthenticatedUserPackageTypeContainer
	default:
		*s = PackagesRestorePackageVersionForAuthenticatedUserPackageType(v)
	}

	return nil
}

// Encode encodes PackagesRestorePackageVersionForOrgApplicationJSONForbidden as json.
func (s PackagesRestorePackageVersionForOrgApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForOrgApplicationJSONForbidden from json.
func (s *PackagesRestorePackageVersionForOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForOrgApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForOrgApplicationJSONNotFound as json.
func (s PackagesRestorePackageVersionForOrgApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForOrgApplicationJSONNotFound from json.
func (s *PackagesRestorePackageVersionForOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForOrgApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesRestorePackageVersionForOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes PackagesRestorePackageVersionForOrgNoContent from json.
func (s *PackagesRestorePackageVersionForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesRestorePackageVersionForOrgPackageType as json.
func (s PackagesRestorePackageVersionForOrgPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesRestorePackageVersionForOrgPackageType from json.
func (s *PackagesRestorePackageVersionForOrgPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForOrgPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesRestorePackageVersionForOrgPackageType(v) {
	case PackagesRestorePackageVersionForOrgPackageTypeNpm:
		*s = PackagesRestorePackageVersionForOrgPackageTypeNpm
	case PackagesRestorePackageVersionForOrgPackageTypeMaven:
		*s = PackagesRestorePackageVersionForOrgPackageTypeMaven
	case PackagesRestorePackageVersionForOrgPackageTypeRubygems:
		*s = PackagesRestorePackageVersionForOrgPackageTypeRubygems
	case PackagesRestorePackageVersionForOrgPackageTypeDocker:
		*s = PackagesRestorePackageVersionForOrgPackageTypeDocker
	case PackagesRestorePackageVersionForOrgPackageTypeNuget:
		*s = PackagesRestorePackageVersionForOrgPackageTypeNuget
	case PackagesRestorePackageVersionForOrgPackageTypeContainer:
		*s = PackagesRestorePackageVersionForOrgPackageTypeContainer
	default:
		*s = PackagesRestorePackageVersionForOrgPackageType(v)
	}

	return nil
}

// Encode encodes PackagesRestorePackageVersionForUserApplicationJSONForbidden as json.
func (s PackagesRestorePackageVersionForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForUserApplicationJSONForbidden from json.
func (s *PackagesRestorePackageVersionForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForUserApplicationJSONNotFound as json.
func (s PackagesRestorePackageVersionForUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForUserApplicationJSONNotFound from json.
func (s *PackagesRestorePackageVersionForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForUserApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageVersionForUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForUserApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageVersionForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesRestorePackageVersionForUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes PackagesRestorePackageVersionForUserNoContent from json.
func (s *PackagesRestorePackageVersionForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesRestorePackageVersionForUserPackageType as json.
func (s PackagesRestorePackageVersionForUserPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagesRestorePackageVersionForUserPackageType from json.
func (s *PackagesRestorePackageVersionForUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForUserPackageType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagesRestorePackageVersionForUserPackageType(v) {
	case PackagesRestorePackageVersionForUserPackageTypeNpm:
		*s = PackagesRestorePackageVersionForUserPackageTypeNpm
	case PackagesRestorePackageVersionForUserPackageTypeMaven:
		*s = PackagesRestorePackageVersionForUserPackageTypeMaven
	case PackagesRestorePackageVersionForUserPackageTypeRubygems:
		*s = PackagesRestorePackageVersionForUserPackageTypeRubygems
	case PackagesRestorePackageVersionForUserPackageTypeDocker:
		*s = PackagesRestorePackageVersionForUserPackageTypeDocker
	case PackagesRestorePackageVersionForUserPackageTypeNuget:
		*s = PackagesRestorePackageVersionForUserPackageTypeNuget
	case PackagesRestorePackageVersionForUserPackageTypeContainer:
		*s = PackagesRestorePackageVersionForUserPackageTypeContainer
	default:
		*s = PackagesRestorePackageVersionForUserPackageType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Page) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"cname\"" + ":")
		s.Cname.Encode(e)
	}
	{
		if s.ProtectedDomainState.Set {
			e.Comma()
		}
		if s.ProtectedDomainState.Set {
			e.RawStr("\"protected_domain_state\"" + ":")
			s.ProtectedDomainState.Encode(e)
		}
	}
	{
		if s.PendingDomainUnverifiedAt.Set {
			e.Comma()
		}
		if s.PendingDomainUnverifiedAt.Set {
			e.RawStr("\"pending_domain_unverified_at\"" + ":")
			s.PendingDomainUnverifiedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.Comma()

		e.RawStr("\"custom_404\"" + ":")
		e.Bool(s.Custom404)
	}
	{
		if s.HTMLURL.Set {
			e.Comma()
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.Comma()
		}
		if s.Source.Set {
			e.RawStr("\"source\"" + ":")
			s.Source.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"public\"" + ":")
		e.Bool(s.Public)
	}
	{
		if s.HTTPSCertificate.Set {
			e.Comma()
		}
		if s.HTTPSCertificate.Set {
			e.RawStr("\"https_certificate\"" + ":")
			s.HTTPSCertificate.Encode(e)
		}
	}
	{
		if s.HTTPSEnforced.Set {
			e.Comma()
		}
		if s.HTTPSEnforced.Set {
			e.RawStr("\"https_enforced\"" + ":")
			s.HTTPSEnforced.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes Page from json.
func (s *Page) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Page to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "cname":
			if err := s.Cname.Decode(d); err != nil {
				return err
			}
		case "protected_domain_state":
			s.ProtectedDomainState.Reset()
			if err := s.ProtectedDomainState.Decode(d); err != nil {
				return err
			}
		case "pending_domain_unverified_at":
			s.PendingDomainUnverifiedAt.Reset()
			if err := s.PendingDomainUnverifiedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "custom_404":
			v, err := d.Bool()
			s.Custom404 = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "source":
			s.Source.Reset()
			if err := s.Source.Decode(d); err != nil {
				return err
			}
		case "public":
			v, err := d.Bool()
			s.Public = bool(v)
			if err != nil {
				return err
			}
		case "https_certificate":
			s.HTTPSCertificate.Reset()
			if err := s.HTTPSCertificate.Decode(d); err != nil {
				return err
			}
		case "https_enforced":
			s.HTTPSEnforced.Reset()
			if err := s.HTTPSEnforced.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PageBuild) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"error\"" + ":")
		s.Error.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pusher\"" + ":")
		s.Pusher.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		e.Str(s.Commit)
	}
	{
		e.Comma()

		e.RawStr("\"duration\"" + ":")
		e.Int(s.Duration)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	e.ObjEnd()
}

// Decode decodes PageBuild from json.
func (s *PageBuild) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PageBuild to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "error":
			if err := s.Error.Decode(d); err != nil {
				return err
			}
		case "pusher":
			if err := s.Pusher.Decode(d); err != nil {
				return err
			}
		case "commit":
			v, err := d.Str()
			s.Commit = string(v)
			if err != nil {
				return err
			}
		case "duration":
			v, err := d.Int()
			s.Duration = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PageBuildError) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		s.Message.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PageBuildError from json.
func (s *PageBuildError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PageBuildError to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PageBuildStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	e.ObjEnd()
}

// Decode decodes PageBuildStatus from json.
func (s *PageBuildStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PageBuildStatus to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PageProtectedDomainState as json.
func (s PageProtectedDomainState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PageProtectedDomainState from json.
func (s *PageProtectedDomainState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PageProtectedDomainState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PageProtectedDomainState(v) {
	case PageProtectedDomainStatePending:
		*s = PageProtectedDomainStatePending
	case PageProtectedDomainStateVerified:
		*s = PageProtectedDomainStateVerified
	case PageProtectedDomainStateUnverified:
		*s = PageProtectedDomainStateUnverified
	default:
		*s = PageProtectedDomainState(v)
	}

	return nil
}

// Encode encodes PageStatus as json.
func (s PageStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PageStatus from json.
func (s *PageStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PageStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PageStatus(v) {
	case PageStatusBuilt:
		*s = PageStatusBuilt
	case PageStatusBuilding:
		*s = PageStatusBuilding
	case PageStatusErrored:
		*s = PageStatusErrored
	default:
		*s = PageStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PagesHTTPSCertificate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"domains\"" + ":")
		e.ArrStart()
		if len(s.Domains) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Domains[0]
				e.Str(elem)
			}
			for _, elem := range s.Domains[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.ExpiresAt.Set {
			e.Comma()
		}
		if s.ExpiresAt.Set {
			e.RawStr("\"expires_at\"" + ":")
			s.ExpiresAt.Encode(e, json.EncodeDate)
		}
	}
	e.ObjEnd()
}

// Decode decodes PagesHTTPSCertificate from json.
func (s *PagesHTTPSCertificate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PagesHTTPSCertificate to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "description":
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "domains":
			s.Domains = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Domains = append(s.Domains, elem)
				return nil
			}); err != nil {
				return err
			}
		case "expires_at":
			s.ExpiresAt.Reset()
			if err := s.ExpiresAt.Decode(d, json.DecodeDate); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PagesHTTPSCertificateState as json.
func (s PagesHTTPSCertificateState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PagesHTTPSCertificateState from json.
func (s *PagesHTTPSCertificateState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PagesHTTPSCertificateState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PagesHTTPSCertificateState(v) {
	case PagesHTTPSCertificateStateNew:
		*s = PagesHTTPSCertificateStateNew
	case PagesHTTPSCertificateStateAuthorizationCreated:
		*s = PagesHTTPSCertificateStateAuthorizationCreated
	case PagesHTTPSCertificateStateAuthorizationPending:
		*s = PagesHTTPSCertificateStateAuthorizationPending
	case PagesHTTPSCertificateStateAuthorized:
		*s = PagesHTTPSCertificateStateAuthorized
	case PagesHTTPSCertificateStateAuthorizationRevoked:
		*s = PagesHTTPSCertificateStateAuthorizationRevoked
	case PagesHTTPSCertificateStateIssued:
		*s = PagesHTTPSCertificateStateIssued
	case PagesHTTPSCertificateStateUploaded:
		*s = PagesHTTPSCertificateStateUploaded
	case PagesHTTPSCertificateStateApproved:
		*s = PagesHTTPSCertificateStateApproved
	case PagesHTTPSCertificateStateErrored:
		*s = PagesHTTPSCertificateStateErrored
	case PagesHTTPSCertificateStateBadAuthz:
		*s = PagesHTTPSCertificateStateBadAuthz
	case PagesHTTPSCertificateStateDestroyPending:
		*s = PagesHTTPSCertificateStateDestroyPending
	case PagesHTTPSCertificateStateDNSChanged:
		*s = PagesHTTPSCertificateStateDNSChanged
	default:
		*s = PagesHTTPSCertificateState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PagesHealthCheck) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Domain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Domain.Set {
			e.RawStr("\"domain\"" + ":")
			s.Domain.Encode(e)
		}
	}
	{
		if s.AltDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AltDomain.Set {
			e.RawStr("\"alt_domain\"" + ":")
			s.AltDomain.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PagesHealthCheck from json.
func (s *PagesHealthCheck) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PagesHealthCheck to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domain":
			s.Domain.Reset()
			if err := s.Domain.Decode(d); err != nil {
				return err
			}
		case "alt_domain":
			s.AltDomain.Reset()
			if err := s.AltDomain.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PagesHealthCheckAltDomain) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Host.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Host.Set {
			e.RawStr("\"host\"" + ":")
			s.Host.Encode(e)
		}
	}
	{
		if s.URI.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URI.Set {
			e.RawStr("\"uri\"" + ":")
			s.URI.Encode(e)
		}
	}
	{
		if s.Nameservers.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Nameservers.Set {
			e.RawStr("\"nameservers\"" + ":")
			s.Nameservers.Encode(e)
		}
	}
	{
		if s.DNSResolves.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DNSResolves.Set {
			e.RawStr("\"dns_resolves\"" + ":")
			s.DNSResolves.Encode(e)
		}
	}
	{
		if s.IsProxied.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsProxied.Set {
			e.RawStr("\"is_proxied\"" + ":")
			s.IsProxied.Encode(e)
		}
	}
	{
		if s.IsCloudflareIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCloudflareIP.Set {
			e.RawStr("\"is_cloudflare_ip\"" + ":")
			s.IsCloudflareIP.Encode(e)
		}
	}
	{
		if s.IsFastlyIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsFastlyIP.Set {
			e.RawStr("\"is_fastly_ip\"" + ":")
			s.IsFastlyIP.Encode(e)
		}
	}
	{
		if s.IsOldIPAddress.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsOldIPAddress.Set {
			e.RawStr("\"is_old_ip_address\"" + ":")
			s.IsOldIPAddress.Encode(e)
		}
	}
	{
		if s.IsARecord.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsARecord.Set {
			e.RawStr("\"is_a_record\"" + ":")
			s.IsARecord.Encode(e)
		}
	}
	{
		if s.HasCnameRecord.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasCnameRecord.Set {
			e.RawStr("\"has_cname_record\"" + ":")
			s.HasCnameRecord.Encode(e)
		}
	}
	{
		if s.HasMxRecordsPresent.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasMxRecordsPresent.Set {
			e.RawStr("\"has_mx_records_present\"" + ":")
			s.HasMxRecordsPresent.Encode(e)
		}
	}
	{
		if s.IsValidDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsValidDomain.Set {
			e.RawStr("\"is_valid_domain\"" + ":")
			s.IsValidDomain.Encode(e)
		}
	}
	{
		if s.IsApexDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsApexDomain.Set {
			e.RawStr("\"is_apex_domain\"" + ":")
			s.IsApexDomain.Encode(e)
		}
	}
	{
		if s.ShouldBeARecord.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ShouldBeARecord.Set {
			e.RawStr("\"should_be_a_record\"" + ":")
			s.ShouldBeARecord.Encode(e)
		}
	}
	{
		if s.IsCnameToGithubUserDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCnameToGithubUserDomain.Set {
			e.RawStr("\"is_cname_to_github_user_domain\"" + ":")
			s.IsCnameToGithubUserDomain.Encode(e)
		}
	}
	{
		if s.IsCnameToPagesDotGithubDotCom.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCnameToPagesDotGithubDotCom.Set {
			e.RawStr("\"is_cname_to_pages_dot_github_dot_com\"" + ":")
			s.IsCnameToPagesDotGithubDotCom.Encode(e)
		}
	}
	{
		if s.IsCnameToFastly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCnameToFastly.Set {
			e.RawStr("\"is_cname_to_fastly\"" + ":")
			s.IsCnameToFastly.Encode(e)
		}
	}
	{
		if s.IsPointedToGithubPagesIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsPointedToGithubPagesIP.Set {
			e.RawStr("\"is_pointed_to_github_pages_ip\"" + ":")
			s.IsPointedToGithubPagesIP.Encode(e)
		}
	}
	{
		if s.IsNonGithubPagesIPPresent.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsNonGithubPagesIPPresent.Set {
			e.RawStr("\"is_non_github_pages_ip_present\"" + ":")
			s.IsNonGithubPagesIPPresent.Encode(e)
		}
	}
	{
		if s.IsPagesDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsPagesDomain.Set {
			e.RawStr("\"is_pages_domain\"" + ":")
			s.IsPagesDomain.Encode(e)
		}
	}
	{
		if s.IsServedByPages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsServedByPages.Set {
			e.RawStr("\"is_served_by_pages\"" + ":")
			s.IsServedByPages.Encode(e)
		}
	}
	{
		if s.IsValid.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsValid.Set {
			e.RawStr("\"is_valid\"" + ":")
			s.IsValid.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.RespondsToHTTPS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RespondsToHTTPS.Set {
			e.RawStr("\"responds_to_https\"" + ":")
			s.RespondsToHTTPS.Encode(e)
		}
	}
	{
		if s.EnforcesHTTPS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EnforcesHTTPS.Set {
			e.RawStr("\"enforces_https\"" + ":")
			s.EnforcesHTTPS.Encode(e)
		}
	}
	{
		if s.HTTPSError.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTTPSError.Set {
			e.RawStr("\"https_error\"" + ":")
			s.HTTPSError.Encode(e)
		}
	}
	{
		if s.IsHTTPSEligible.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsHTTPSEligible.Set {
			e.RawStr("\"is_https_eligible\"" + ":")
			s.IsHTTPSEligible.Encode(e)
		}
	}
	{
		if s.CaaError.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CaaError.Set {
			e.RawStr("\"caa_error\"" + ":")
			s.CaaError.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PagesHealthCheckAltDomain from json.
func (s *PagesHealthCheckAltDomain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PagesHealthCheckAltDomain to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			s.Host.Reset()
			if err := s.Host.Decode(d); err != nil {
				return err
			}
		case "uri":
			s.URI.Reset()
			if err := s.URI.Decode(d); err != nil {
				return err
			}
		case "nameservers":
			s.Nameservers.Reset()
			if err := s.Nameservers.Decode(d); err != nil {
				return err
			}
		case "dns_resolves":
			s.DNSResolves.Reset()
			if err := s.DNSResolves.Decode(d); err != nil {
				return err
			}
		case "is_proxied":
			s.IsProxied.Reset()
			if err := s.IsProxied.Decode(d); err != nil {
				return err
			}
		case "is_cloudflare_ip":
			s.IsCloudflareIP.Reset()
			if err := s.IsCloudflareIP.Decode(d); err != nil {
				return err
			}
		case "is_fastly_ip":
			s.IsFastlyIP.Reset()
			if err := s.IsFastlyIP.Decode(d); err != nil {
				return err
			}
		case "is_old_ip_address":
			s.IsOldIPAddress.Reset()
			if err := s.IsOldIPAddress.Decode(d); err != nil {
				return err
			}
		case "is_a_record":
			s.IsARecord.Reset()
			if err := s.IsARecord.Decode(d); err != nil {
				return err
			}
		case "has_cname_record":
			s.HasCnameRecord.Reset()
			if err := s.HasCnameRecord.Decode(d); err != nil {
				return err
			}
		case "has_mx_records_present":
			s.HasMxRecordsPresent.Reset()
			if err := s.HasMxRecordsPresent.Decode(d); err != nil {
				return err
			}
		case "is_valid_domain":
			s.IsValidDomain.Reset()
			if err := s.IsValidDomain.Decode(d); err != nil {
				return err
			}
		case "is_apex_domain":
			s.IsApexDomain.Reset()
			if err := s.IsApexDomain.Decode(d); err != nil {
				return err
			}
		case "should_be_a_record":
			s.ShouldBeARecord.Reset()
			if err := s.ShouldBeARecord.Decode(d); err != nil {
				return err
			}
		case "is_cname_to_github_user_domain":
			s.IsCnameToGithubUserDomain.Reset()
			if err := s.IsCnameToGithubUserDomain.Decode(d); err != nil {
				return err
			}
		case "is_cname_to_pages_dot_github_dot_com":
			s.IsCnameToPagesDotGithubDotCom.Reset()
			if err := s.IsCnameToPagesDotGithubDotCom.Decode(d); err != nil {
				return err
			}
		case "is_cname_to_fastly":
			s.IsCnameToFastly.Reset()
			if err := s.IsCnameToFastly.Decode(d); err != nil {
				return err
			}
		case "is_pointed_to_github_pages_ip":
			s.IsPointedToGithubPagesIP.Reset()
			if err := s.IsPointedToGithubPagesIP.Decode(d); err != nil {
				return err
			}
		case "is_non_github_pages_ip_present":
			s.IsNonGithubPagesIPPresent.Reset()
			if err := s.IsNonGithubPagesIPPresent.Decode(d); err != nil {
				return err
			}
		case "is_pages_domain":
			s.IsPagesDomain.Reset()
			if err := s.IsPagesDomain.Decode(d); err != nil {
				return err
			}
		case "is_served_by_pages":
			s.IsServedByPages.Reset()
			if err := s.IsServedByPages.Decode(d); err != nil {
				return err
			}
		case "is_valid":
			s.IsValid.Reset()
			if err := s.IsValid.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "responds_to_https":
			s.RespondsToHTTPS.Reset()
			if err := s.RespondsToHTTPS.Decode(d); err != nil {
				return err
			}
		case "enforces_https":
			s.EnforcesHTTPS.Reset()
			if err := s.EnforcesHTTPS.Decode(d); err != nil {
				return err
			}
		case "https_error":
			s.HTTPSError.Reset()
			if err := s.HTTPSError.Decode(d); err != nil {
				return err
			}
		case "is_https_eligible":
			s.IsHTTPSEligible.Reset()
			if err := s.IsHTTPSEligible.Decode(d); err != nil {
				return err
			}
		case "caa_error":
			s.CaaError.Reset()
			if err := s.CaaError.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PagesHealthCheckDomain) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Host.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Host.Set {
			e.RawStr("\"host\"" + ":")
			s.Host.Encode(e)
		}
	}
	{
		if s.URI.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URI.Set {
			e.RawStr("\"uri\"" + ":")
			s.URI.Encode(e)
		}
	}
	{
		if s.Nameservers.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Nameservers.Set {
			e.RawStr("\"nameservers\"" + ":")
			s.Nameservers.Encode(e)
		}
	}
	{
		if s.DNSResolves.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DNSResolves.Set {
			e.RawStr("\"dns_resolves\"" + ":")
			s.DNSResolves.Encode(e)
		}
	}
	{
		if s.IsProxied.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsProxied.Set {
			e.RawStr("\"is_proxied\"" + ":")
			s.IsProxied.Encode(e)
		}
	}
	{
		if s.IsCloudflareIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCloudflareIP.Set {
			e.RawStr("\"is_cloudflare_ip\"" + ":")
			s.IsCloudflareIP.Encode(e)
		}
	}
	{
		if s.IsFastlyIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsFastlyIP.Set {
			e.RawStr("\"is_fastly_ip\"" + ":")
			s.IsFastlyIP.Encode(e)
		}
	}
	{
		if s.IsOldIPAddress.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsOldIPAddress.Set {
			e.RawStr("\"is_old_ip_address\"" + ":")
			s.IsOldIPAddress.Encode(e)
		}
	}
	{
		if s.IsARecord.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsARecord.Set {
			e.RawStr("\"is_a_record\"" + ":")
			s.IsARecord.Encode(e)
		}
	}
	{
		if s.HasCnameRecord.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasCnameRecord.Set {
			e.RawStr("\"has_cname_record\"" + ":")
			s.HasCnameRecord.Encode(e)
		}
	}
	{
		if s.HasMxRecordsPresent.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasMxRecordsPresent.Set {
			e.RawStr("\"has_mx_records_present\"" + ":")
			s.HasMxRecordsPresent.Encode(e)
		}
	}
	{
		if s.IsValidDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsValidDomain.Set {
			e.RawStr("\"is_valid_domain\"" + ":")
			s.IsValidDomain.Encode(e)
		}
	}
	{
		if s.IsApexDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsApexDomain.Set {
			e.RawStr("\"is_apex_domain\"" + ":")
			s.IsApexDomain.Encode(e)
		}
	}
	{
		if s.ShouldBeARecord.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ShouldBeARecord.Set {
			e.RawStr("\"should_be_a_record\"" + ":")
			s.ShouldBeARecord.Encode(e)
		}
	}
	{
		if s.IsCnameToGithubUserDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCnameToGithubUserDomain.Set {
			e.RawStr("\"is_cname_to_github_user_domain\"" + ":")
			s.IsCnameToGithubUserDomain.Encode(e)
		}
	}
	{
		if s.IsCnameToPagesDotGithubDotCom.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCnameToPagesDotGithubDotCom.Set {
			e.RawStr("\"is_cname_to_pages_dot_github_dot_com\"" + ":")
			s.IsCnameToPagesDotGithubDotCom.Encode(e)
		}
	}
	{
		if s.IsCnameToFastly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCnameToFastly.Set {
			e.RawStr("\"is_cname_to_fastly\"" + ":")
			s.IsCnameToFastly.Encode(e)
		}
	}
	{
		if s.IsPointedToGithubPagesIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsPointedToGithubPagesIP.Set {
			e.RawStr("\"is_pointed_to_github_pages_ip\"" + ":")
			s.IsPointedToGithubPagesIP.Encode(e)
		}
	}
	{
		if s.IsNonGithubPagesIPPresent.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsNonGithubPagesIPPresent.Set {
			e.RawStr("\"is_non_github_pages_ip_present\"" + ":")
			s.IsNonGithubPagesIPPresent.Encode(e)
		}
	}
	{
		if s.IsPagesDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsPagesDomain.Set {
			e.RawStr("\"is_pages_domain\"" + ":")
			s.IsPagesDomain.Encode(e)
		}
	}
	{
		if s.IsServedByPages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsServedByPages.Set {
			e.RawStr("\"is_served_by_pages\"" + ":")
			s.IsServedByPages.Encode(e)
		}
	}
	{
		if s.IsValid.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsValid.Set {
			e.RawStr("\"is_valid\"" + ":")
			s.IsValid.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.RespondsToHTTPS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RespondsToHTTPS.Set {
			e.RawStr("\"responds_to_https\"" + ":")
			s.RespondsToHTTPS.Encode(e)
		}
	}
	{
		if s.EnforcesHTTPS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EnforcesHTTPS.Set {
			e.RawStr("\"enforces_https\"" + ":")
			s.EnforcesHTTPS.Encode(e)
		}
	}
	{
		if s.HTTPSError.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTTPSError.Set {
			e.RawStr("\"https_error\"" + ":")
			s.HTTPSError.Encode(e)
		}
	}
	{
		if s.IsHTTPSEligible.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsHTTPSEligible.Set {
			e.RawStr("\"is_https_eligible\"" + ":")
			s.IsHTTPSEligible.Encode(e)
		}
	}
	{
		if s.CaaError.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CaaError.Set {
			e.RawStr("\"caa_error\"" + ":")
			s.CaaError.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PagesHealthCheckDomain from json.
func (s *PagesHealthCheckDomain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PagesHealthCheckDomain to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			s.Host.Reset()
			if err := s.Host.Decode(d); err != nil {
				return err
			}
		case "uri":
			s.URI.Reset()
			if err := s.URI.Decode(d); err != nil {
				return err
			}
		case "nameservers":
			s.Nameservers.Reset()
			if err := s.Nameservers.Decode(d); err != nil {
				return err
			}
		case "dns_resolves":
			s.DNSResolves.Reset()
			if err := s.DNSResolves.Decode(d); err != nil {
				return err
			}
		case "is_proxied":
			s.IsProxied.Reset()
			if err := s.IsProxied.Decode(d); err != nil {
				return err
			}
		case "is_cloudflare_ip":
			s.IsCloudflareIP.Reset()
			if err := s.IsCloudflareIP.Decode(d); err != nil {
				return err
			}
		case "is_fastly_ip":
			s.IsFastlyIP.Reset()
			if err := s.IsFastlyIP.Decode(d); err != nil {
				return err
			}
		case "is_old_ip_address":
			s.IsOldIPAddress.Reset()
			if err := s.IsOldIPAddress.Decode(d); err != nil {
				return err
			}
		case "is_a_record":
			s.IsARecord.Reset()
			if err := s.IsARecord.Decode(d); err != nil {
				return err
			}
		case "has_cname_record":
			s.HasCnameRecord.Reset()
			if err := s.HasCnameRecord.Decode(d); err != nil {
				return err
			}
		case "has_mx_records_present":
			s.HasMxRecordsPresent.Reset()
			if err := s.HasMxRecordsPresent.Decode(d); err != nil {
				return err
			}
		case "is_valid_domain":
			s.IsValidDomain.Reset()
			if err := s.IsValidDomain.Decode(d); err != nil {
				return err
			}
		case "is_apex_domain":
			s.IsApexDomain.Reset()
			if err := s.IsApexDomain.Decode(d); err != nil {
				return err
			}
		case "should_be_a_record":
			s.ShouldBeARecord.Reset()
			if err := s.ShouldBeARecord.Decode(d); err != nil {
				return err
			}
		case "is_cname_to_github_user_domain":
			s.IsCnameToGithubUserDomain.Reset()
			if err := s.IsCnameToGithubUserDomain.Decode(d); err != nil {
				return err
			}
		case "is_cname_to_pages_dot_github_dot_com":
			s.IsCnameToPagesDotGithubDotCom.Reset()
			if err := s.IsCnameToPagesDotGithubDotCom.Decode(d); err != nil {
				return err
			}
		case "is_cname_to_fastly":
			s.IsCnameToFastly.Reset()
			if err := s.IsCnameToFastly.Decode(d); err != nil {
				return err
			}
		case "is_pointed_to_github_pages_ip":
			s.IsPointedToGithubPagesIP.Reset()
			if err := s.IsPointedToGithubPagesIP.Decode(d); err != nil {
				return err
			}
		case "is_non_github_pages_ip_present":
			s.IsNonGithubPagesIPPresent.Reset()
			if err := s.IsNonGithubPagesIPPresent.Decode(d); err != nil {
				return err
			}
		case "is_pages_domain":
			s.IsPagesDomain.Reset()
			if err := s.IsPagesDomain.Decode(d); err != nil {
				return err
			}
		case "is_served_by_pages":
			s.IsServedByPages.Reset()
			if err := s.IsServedByPages.Decode(d); err != nil {
				return err
			}
		case "is_valid":
			s.IsValid.Reset()
			if err := s.IsValid.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "responds_to_https":
			s.RespondsToHTTPS.Reset()
			if err := s.RespondsToHTTPS.Decode(d); err != nil {
				return err
			}
		case "enforces_https":
			s.EnforcesHTTPS.Reset()
			if err := s.EnforcesHTTPS.Decode(d); err != nil {
				return err
			}
		case "https_error":
			s.HTTPSError.Reset()
			if err := s.HTTPSError.Decode(d); err != nil {
				return err
			}
		case "is_https_eligible":
			s.IsHTTPSEligible.Reset()
			if err := s.IsHTTPSEligible.Decode(d); err != nil {
				return err
			}
		case "caa_error":
			s.CaaError.Reset()
			if err := s.CaaError.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PagesSourceHash) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"branch\"" + ":")
		e.Str(s.Branch)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	e.ObjEnd()
}

// Decode decodes PagesSourceHash from json.
func (s *PagesSourceHash) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PagesSourceHash to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "branch":
			v, err := d.Str()
			s.Branch = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ParticipationStats) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"all\"" + ":")
		e.ArrStart()
		if len(s.All) >= 1 {
			// Encode first element without comma.
			{
				elem := s.All[0]
				e.Int(elem)
			}
			for _, elem := range s.All[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		e.ArrStart()
		if len(s.Owner) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Owner[0]
				e.Int(elem)
			}
			for _, elem := range s.Owner[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ParticipationStats from json.
func (s *ParticipationStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ParticipationStats to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "all":
			s.All = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.All = append(s.All, elem)
				return nil
			}); err != nil {
				return err
			}
		case "owner":
			s.Owner = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Owner = append(s.Owner, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PorterAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"remote_id\"" + ":")
		e.Str(s.RemoteID)
	}
	{
		e.Comma()

		e.RawStr("\"remote_name\"" + ":")
		e.Str(s.RemoteName)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"import_url\"" + ":")
		json.EncodeURI(e, s.ImportURL)
	}
	e.ObjEnd()
}

// Decode decodes PorterAuthor from json.
func (s *PorterAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PorterAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "remote_id":
			v, err := d.Str()
			s.RemoteID = string(v)
			if err != nil {
				return err
			}
		case "remote_name":
			v, err := d.Str()
			s.RemoteName = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "import_url":
			v, err := json.DecodeURI(d)
			s.ImportURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PorterLargeFile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ref_name\"" + ":")
		e.Str(s.RefName)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"oid\"" + ":")
		e.Str(s.Oid)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	e.ObjEnd()
}

// Decode decodes PorterLargeFile from json.
func (s *PorterLargeFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PorterLargeFile to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref_name":
			v, err := d.Str()
			s.RefName = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "oid":
			v, err := d.Str()
			s.Oid = string(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PreviewHeaderMissing) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"documentation_url\"" + ":")
		e.Str(s.DocumentationURL)
	}
	e.ObjEnd()
}

// Decode decodes PreviewHeaderMissing from json.
func (s *PreviewHeaderMissing) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PreviewHeaderMissing to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "documentation_url":
			v, err := d.Str()
			s.DocumentationURL = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PrivateUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		s.Name.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"company\"" + ":")
		s.Company.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"blog\"" + ":")
		s.Blog.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"location\"" + ":")
		s.Location.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		s.Email.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"hireable\"" + ":")
		s.Hireable.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"bio\"" + ":")
		s.Bio.Encode(e)
	}
	{
		if s.TwitterUsername.Set {
			e.Comma()
		}
		if s.TwitterUsername.Set {
			e.RawStr("\"twitter_username\"" + ":")
			s.TwitterUsername.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"public_repos\"" + ":")
		e.Int(s.PublicRepos)
	}
	{
		e.Comma()

		e.RawStr("\"public_gists\"" + ":")
		e.Int(s.PublicGists)
	}
	{
		e.Comma()

		e.RawStr("\"followers\"" + ":")
		e.Int(s.Followers)
	}
	{
		e.Comma()

		e.RawStr("\"following\"" + ":")
		e.Int(s.Following)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"private_gists\"" + ":")
		e.Int(s.PrivateGists)
	}
	{
		e.Comma()

		e.RawStr("\"total_private_repos\"" + ":")
		e.Int(s.TotalPrivateRepos)
	}
	{
		e.Comma()

		e.RawStr("\"owned_private_repos\"" + ":")
		e.Int(s.OwnedPrivateRepos)
	}
	{
		e.Comma()

		e.RawStr("\"disk_usage\"" + ":")
		e.Int(s.DiskUsage)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators\"" + ":")
		e.Int(s.Collaborators)
	}
	{
		e.Comma()

		e.RawStr("\"two_factor_authentication\"" + ":")
		e.Bool(s.TwoFactorAuthentication)
	}
	{
		if s.Plan.Set {
			e.Comma()
		}
		if s.Plan.Set {
			e.RawStr("\"plan\"" + ":")
			s.Plan.Encode(e)
		}
	}
	{
		if s.SuspendedAt.Set {
			e.Comma()
		}
		if s.SuspendedAt.Set {
			e.RawStr("\"suspended_at\"" + ":")
			s.SuspendedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.BusinessPlus.Set {
			e.Comma()
		}
		if s.BusinessPlus.Set {
			e.RawStr("\"business_plus\"" + ":")
			s.BusinessPlus.Encode(e)
		}
	}
	{
		if s.LdapDn.Set {
			e.Comma()
		}
		if s.LdapDn.Set {
			e.RawStr("\"ldap_dn\"" + ":")
			s.LdapDn.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PrivateUser from json.
func (s *PrivateUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PrivateUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "company":
			if err := s.Company.Decode(d); err != nil {
				return err
			}
		case "blog":
			if err := s.Blog.Decode(d); err != nil {
				return err
			}
		case "location":
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "email":
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "hireable":
			if err := s.Hireable.Decode(d); err != nil {
				return err
			}
		case "bio":
			if err := s.Bio.Decode(d); err != nil {
				return err
			}
		case "twitter_username":
			s.TwitterUsername.Reset()
			if err := s.TwitterUsername.Decode(d); err != nil {
				return err
			}
		case "public_repos":
			v, err := d.Int()
			s.PublicRepos = int(v)
			if err != nil {
				return err
			}
		case "public_gists":
			v, err := d.Int()
			s.PublicGists = int(v)
			if err != nil {
				return err
			}
		case "followers":
			v, err := d.Int()
			s.Followers = int(v)
			if err != nil {
				return err
			}
		case "following":
			v, err := d.Int()
			s.Following = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "private_gists":
			v, err := d.Int()
			s.PrivateGists = int(v)
			if err != nil {
				return err
			}
		case "total_private_repos":
			v, err := d.Int()
			s.TotalPrivateRepos = int(v)
			if err != nil {
				return err
			}
		case "owned_private_repos":
			v, err := d.Int()
			s.OwnedPrivateRepos = int(v)
			if err != nil {
				return err
			}
		case "disk_usage":
			v, err := d.Int()
			s.DiskUsage = int(v)
			if err != nil {
				return err
			}
		case "collaborators":
			v, err := d.Int()
			s.Collaborators = int(v)
			if err != nil {
				return err
			}
		case "two_factor_authentication":
			v, err := d.Bool()
			s.TwoFactorAuthentication = bool(v)
			if err != nil {
				return err
			}
		case "plan":
			s.Plan.Reset()
			if err := s.Plan.Decode(d); err != nil {
				return err
			}
		case "suspended_at":
			s.SuspendedAt.Reset()
			if err := s.SuspendedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "business_plus":
			s.BusinessPlus.Reset()
			if err := s.BusinessPlus.Decode(d); err != nil {
				return err
			}
		case "ldap_dn":
			s.LdapDn.Reset()
			if err := s.LdapDn.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PrivateUserPlan) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"collaborators\"" + ":")
		e.Int(s.Collaborators)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"space\"" + ":")
		e.Int(s.Space)
	}
	{
		e.Comma()

		e.RawStr("\"private_repos\"" + ":")
		e.Int(s.PrivateRepos)
	}
	e.ObjEnd()
}

// Decode decodes PrivateUserPlan from json.
func (s *PrivateUserPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PrivateUserPlan to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collaborators":
			v, err := d.Int()
			s.Collaborators = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "space":
			v, err := d.Int()
			s.Space = int(v)
			if err != nil {
				return err
			}
		case "private_repos":
			v, err := d.Int()
			s.PrivateRepos = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Project) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"owner_url\"" + ":")
		json.EncodeURI(e, s.OwnerURL)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"columns_url\"" + ":")
		json.EncodeURI(e, s.ColumnsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		s.Body.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.OrganizationPermission.Set {
			e.Comma()
		}
		if s.OrganizationPermission.Set {
			e.RawStr("\"organization_permission\"" + ":")
			s.OrganizationPermission.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.Comma()
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes Project from json.
func (s *Project) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Project to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "owner_url":
			v, err := json.DecodeURI(d)
			s.OwnerURL = v
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "columns_url":
			v, err := json.DecodeURI(d)
			s.ColumnsURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "body":
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "creator":
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "organization_permission":
			s.OrganizationPermission.Reset()
			if err := s.OrganizationPermission.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectCard) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"note\"" + ":")
		s.Note.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.Archived.Set {
			e.Comma()
		}
		if s.Archived.Set {
			e.RawStr("\"archived\"" + ":")
			s.Archived.Encode(e)
		}
	}
	{
		if s.ColumnName.Set {
			e.Comma()
		}
		if s.ColumnName.Set {
			e.RawStr("\"column_name\"" + ":")
			s.ColumnName.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.Comma()
		}
		if s.ProjectID.Set {
			e.RawStr("\"project_id\"" + ":")
			s.ProjectID.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"column_url\"" + ":")
		json.EncodeURI(e, s.ColumnURL)
	}
	{
		if s.ContentURL.Set {
			e.Comma()
		}
		if s.ContentURL.Set {
			e.RawStr("\"content_url\"" + ":")
			s.ContentURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"project_url\"" + ":")
		json.EncodeURI(e, s.ProjectURL)
	}
	e.ObjEnd()
}

// Decode decodes ProjectCard from json.
func (s *ProjectCard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectCard to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "note":
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "creator":
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "archived":
			s.Archived.Reset()
			if err := s.Archived.Decode(d); err != nil {
				return err
			}
		case "column_name":
			s.ColumnName.Reset()
			if err := s.ColumnName.Decode(d); err != nil {
				return err
			}
		case "project_id":
			s.ProjectID.Reset()
			if err := s.ProjectID.Decode(d); err != nil {
				return err
			}
		case "column_url":
			v, err := json.DecodeURI(d)
			s.ColumnURL = v
			if err != nil {
				return err
			}
		case "content_url":
			s.ContentURL.Reset()
			if err := s.ContentURL.Decode(d); err != nil {
				return err
			}
		case "project_url":
			v, err := json.DecodeURI(d)
			s.ProjectURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectColumn) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"project_url\"" + ":")
		json.EncodeURI(e, s.ProjectURL)
	}
	{
		e.Comma()

		e.RawStr("\"cards_url\"" + ":")
		json.EncodeURI(e, s.CardsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	e.ObjEnd()
}

// Decode decodes ProjectColumn from json.
func (s *ProjectColumn) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectColumn to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "project_url":
			v, err := json.DecodeURI(d)
			s.ProjectURL = v
			if err != nil {
				return err
			}
		case "cards_url":
			v, err := json.DecodeURI(d)
			s.CardsURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectOrganizationPermission as json.
func (s ProjectOrganizationPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ProjectOrganizationPermission from json.
func (s *ProjectOrganizationPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectOrganizationPermission to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectOrganizationPermission(v) {
	case ProjectOrganizationPermissionRead:
		*s = ProjectOrganizationPermissionRead
	case ProjectOrganizationPermissionWrite:
		*s = ProjectOrganizationPermissionWrite
	case ProjectOrganizationPermissionAdmin:
		*s = ProjectOrganizationPermissionAdmin
	case ProjectOrganizationPermissionNone:
		*s = ProjectOrganizationPermissionNone
	default:
		*s = ProjectOrganizationPermission(v)
	}

	return nil
}

// Encode encodes ProjectsAddCollaboratorApplicationJSONForbidden as json.
func (s ProjectsAddCollaboratorApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsAddCollaboratorApplicationJSONForbidden from json.
func (s *ProjectsAddCollaboratorApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsAddCollaboratorApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsAddCollaboratorApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsAddCollaboratorApplicationJSONNotFound as json.
func (s ProjectsAddCollaboratorApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsAddCollaboratorApplicationJSONNotFound from json.
func (s *ProjectsAddCollaboratorApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsAddCollaboratorApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsAddCollaboratorApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsAddCollaboratorApplicationJSONUnauthorized as json.
func (s ProjectsAddCollaboratorApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsAddCollaboratorApplicationJSONUnauthorized from json.
func (s *ProjectsAddCollaboratorApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsAddCollaboratorApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsAddCollaboratorApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsAddCollaboratorNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ProjectsAddCollaboratorNoContent from json.
func (s *ProjectsAddCollaboratorNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsAddCollaboratorNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsAddCollaboratorReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ProjectsAddCollaboratorReq from json.
func (s *ProjectsAddCollaboratorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsAddCollaboratorReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsAddCollaboratorReqPermission as json.
func (s ProjectsAddCollaboratorReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ProjectsAddCollaboratorReqPermission from json.
func (s *ProjectsAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsAddCollaboratorReqPermission to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectsAddCollaboratorReqPermission(v) {
	case ProjectsAddCollaboratorReqPermissionRead:
		*s = ProjectsAddCollaboratorReqPermissionRead
	case ProjectsAddCollaboratorReqPermissionWrite:
		*s = ProjectsAddCollaboratorReqPermissionWrite
	case ProjectsAddCollaboratorReqPermissionAdmin:
		*s = ProjectsAddCollaboratorReqPermissionAdmin
	default:
		*s = ProjectsAddCollaboratorReqPermission(v)
	}

	return nil
}

// Encode encodes ProjectsCreateCardReq as json.
func (s ProjectsCreateCardReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ProjectsCreateCardReq0ProjectsCreateCardReq:
		s.ProjectsCreateCardReq0.Encode(e)
	case ProjectsCreateCardReq1ProjectsCreateCardReq:
		s.ProjectsCreateCardReq1.Encode(e)
	}
}

// Decode decodes ProjectsCreateCardReq from json.
func (s *ProjectsCreateCardReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateCardReq to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "note":
				found = true
				s.Type = ProjectsCreateCardReq0ProjectsCreateCardReq
			case "content_id":
				found = true
				s.Type = ProjectsCreateCardReq1ProjectsCreateCardReq
			case "content_type":
				found = true
				s.Type = ProjectsCreateCardReq1ProjectsCreateCardReq
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ProjectsCreateCardReq0ProjectsCreateCardReq:
		if err := s.ProjectsCreateCardReq0.Decode(d); err != nil {
			return err
		}
	case ProjectsCreateCardReq1ProjectsCreateCardReq:
		if err := s.ProjectsCreateCardReq1.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateCardReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"note\"" + ":")
		s.Note.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ProjectsCreateCardReq0 from json.
func (s *ProjectsCreateCardReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateCardReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "note":
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsCreateCardReq1) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content_id\"" + ":")
		e.Int(s.ContentID)
	}
	{
		e.Comma()

		e.RawStr("\"content_type\"" + ":")
		e.Str(s.ContentType)
	}
	e.ObjEnd()
}

// Decode decodes ProjectsCreateCardReq1 from json.
func (s *ProjectsCreateCardReq1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateCardReq1 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content_id":
			v, err := d.Int()
			s.ContentID = int(v)
			if err != nil {
				return err
			}
		case "content_type":
			v, err := d.Str()
			s.ContentType = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsCreateColumnApplicationJSONForbidden as json.
func (s ProjectsCreateColumnApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateColumnApplicationJSONForbidden from json.
func (s *ProjectsCreateColumnApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateColumnApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateColumnApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateColumnApplicationJSONUnauthorized as json.
func (s ProjectsCreateColumnApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateColumnApplicationJSONUnauthorized from json.
func (s *ProjectsCreateColumnApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateColumnApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateColumnApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateColumnReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

// Decode decodes ProjectsCreateColumnReq from json.
func (s *ProjectsCreateColumnReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateColumnReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsCreateForAuthenticatedUserApplicationJSONForbidden as json.
func (s ProjectsCreateForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ProjectsCreateForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateForAuthenticatedUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ProjectsCreateForAuthenticatedUserReq from json.
func (s *ProjectsCreateForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForAuthenticatedUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsCreateForOrgApplicationJSONForbidden as json.
func (s ProjectsCreateForOrgApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgApplicationJSONForbidden from json.
func (s *ProjectsCreateForOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForOrgApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForOrgApplicationJSONGone as json.
func (s ProjectsCreateForOrgApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgApplicationJSONGone from json.
func (s *ProjectsCreateForOrgApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForOrgApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForOrgApplicationJSONNotFound as json.
func (s ProjectsCreateForOrgApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgApplicationJSONNotFound from json.
func (s *ProjectsCreateForOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForOrgApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForOrgApplicationJSONUnauthorized as json.
func (s ProjectsCreateForOrgApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgApplicationJSONUnauthorized from json.
func (s *ProjectsCreateForOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForOrgApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateForOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ProjectsCreateForOrgReq from json.
func (s *ProjectsCreateForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsCreateForRepoApplicationJSONForbidden as json.
func (s ProjectsCreateForRepoApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoApplicationJSONForbidden from json.
func (s *ProjectsCreateForRepoApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForRepoApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForRepoApplicationJSONGone as json.
func (s ProjectsCreateForRepoApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoApplicationJSONGone from json.
func (s *ProjectsCreateForRepoApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForRepoApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForRepoApplicationJSONNotFound as json.
func (s ProjectsCreateForRepoApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoApplicationJSONNotFound from json.
func (s *ProjectsCreateForRepoApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForRepoApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForRepoApplicationJSONUnauthorized as json.
func (s ProjectsCreateForRepoApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoApplicationJSONUnauthorized from json.
func (s *ProjectsCreateForRepoApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForRepoApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateForRepoReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ProjectsCreateForRepoReq from json.
func (s *ProjectsCreateForRepoReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForRepoReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsDeleteApplicationJSONGone as json.
func (s ProjectsDeleteApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteApplicationJSONGone from json.
func (s *ProjectsDeleteApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ProjectsDeleteApplicationJSONNotFound as json.
func (s ProjectsDeleteApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteApplicationJSONNotFound from json.
func (s *ProjectsDeleteApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsDeleteApplicationJSONUnauthorized as json.
func (s ProjectsDeleteApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteApplicationJSONUnauthorized from json.
func (s *ProjectsDeleteApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsDeleteCardApplicationJSONNotFound as json.
func (s ProjectsDeleteCardApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteCardApplicationJSONNotFound from json.
func (s *ProjectsDeleteCardApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteCardApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteCardApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsDeleteCardApplicationJSONUnauthorized as json.
func (s ProjectsDeleteCardApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteCardApplicationJSONUnauthorized from json.
func (s *ProjectsDeleteCardApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteCardApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteCardApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsDeleteCardForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Errors != nil {
			e.RawStr("\"errors\"" + ":")
			e.ArrStart()
			if len(s.Errors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Errors[0]
					e.Str(elem)
				}
				for _, elem := range s.Errors[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ProjectsDeleteCardForbidden from json.
func (s *ProjectsDeleteCardForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteCardForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		case "errors":
			s.Errors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Errors = append(s.Errors, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsDeleteCardNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ProjectsDeleteCardNoContent from json.
func (s *ProjectsDeleteCardNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteCardNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsDeleteColumnApplicationJSONForbidden as json.
func (s ProjectsDeleteColumnApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteColumnApplicationJSONForbidden from json.
func (s *ProjectsDeleteColumnApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteColumnApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteColumnApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsDeleteColumnApplicationJSONUnauthorized as json.
func (s ProjectsDeleteColumnApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteColumnApplicationJSONUnauthorized from json.
func (s *ProjectsDeleteColumnApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteColumnApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteColumnApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsDeleteColumnNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ProjectsDeleteColumnNoContent from json.
func (s *ProjectsDeleteColumnNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteColumnNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsDeleteForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Errors != nil {
			e.RawStr("\"errors\"" + ":")
			e.ArrStart()
			if len(s.Errors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Errors[0]
					e.Str(elem)
				}
				for _, elem := range s.Errors[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ProjectsDeleteForbidden from json.
func (s *ProjectsDeleteForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		case "errors":
			s.Errors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Errors = append(s.Errors, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsDeleteNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ProjectsDeleteNoContent from json.
func (s *ProjectsDeleteNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsGetApplicationJSONForbidden as json.
func (s ProjectsGetApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetApplicationJSONForbidden from json.
func (s *ProjectsGetApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsGetApplicationJSONUnauthorized as json.
func (s ProjectsGetApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetApplicationJSONUnauthorized from json.
func (s *ProjectsGetApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsGetCardApplicationJSONForbidden as json.
func (s ProjectsGetCardApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetCardApplicationJSONForbidden from json.
func (s *ProjectsGetCardApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetCardApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetCardApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsGetCardApplicationJSONNotFound as json.
func (s ProjectsGetCardApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetCardApplicationJSONNotFound from json.
func (s *ProjectsGetCardApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetCardApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetCardApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsGetCardApplicationJSONUnauthorized as json.
func (s ProjectsGetCardApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetCardApplicationJSONUnauthorized from json.
func (s *ProjectsGetCardApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetCardApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetCardApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsGetColumnApplicationJSONForbidden as json.
func (s ProjectsGetColumnApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetColumnApplicationJSONForbidden from json.
func (s *ProjectsGetColumnApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetColumnApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetColumnApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsGetColumnApplicationJSONNotFound as json.
func (s ProjectsGetColumnApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetColumnApplicationJSONNotFound from json.
func (s *ProjectsGetColumnApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetColumnApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetColumnApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsGetColumnApplicationJSONUnauthorized as json.
func (s ProjectsGetColumnApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetColumnApplicationJSONUnauthorized from json.
func (s *ProjectsGetColumnApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetColumnApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetColumnApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsGetPermissionForUserApplicationJSONForbidden as json.
func (s ProjectsGetPermissionForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetPermissionForUserApplicationJSONForbidden from json.
func (s *ProjectsGetPermissionForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetPermissionForUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetPermissionForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsGetPermissionForUserApplicationJSONNotFound as json.
func (s ProjectsGetPermissionForUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetPermissionForUserApplicationJSONNotFound from json.
func (s *ProjectsGetPermissionForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetPermissionForUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetPermissionForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsGetPermissionForUserApplicationJSONUnauthorized as json.
func (s ProjectsGetPermissionForUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetPermissionForUserApplicationJSONUnauthorized from json.
func (s *ProjectsGetPermissionForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetPermissionForUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetPermissionForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsListCardsApplicationJSONForbidden as json.
func (s ProjectsListCardsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCardsApplicationJSONForbidden from json.
func (s *ProjectsListCardsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListCardsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCardsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsListCardsApplicationJSONUnauthorized as json.
func (s ProjectsListCardsApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCardsApplicationJSONUnauthorized from json.
func (s *ProjectsListCardsApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListCardsApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCardsApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsListCardsArchivedState as json.
func (s ProjectsListCardsArchivedState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ProjectsListCardsArchivedState from json.
func (s *ProjectsListCardsArchivedState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListCardsArchivedState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectsListCardsArchivedState(v) {
	case ProjectsListCardsArchivedStateAll:
		*s = ProjectsListCardsArchivedStateAll
	case ProjectsListCardsArchivedStateArchived:
		*s = ProjectsListCardsArchivedStateArchived
	case ProjectsListCardsArchivedStateNotArchived:
		*s = ProjectsListCardsArchivedStateNotArchived
	default:
		*s = ProjectsListCardsArchivedState(v)
	}

	return nil
}

// Encode encodes ProjectsListCardsOKApplicationJSON as json.
func (s ProjectsListCardsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ProjectCard(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListCardsOKApplicationJSON from json.
func (s *ProjectsListCardsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListCardsOKApplicationJSON to nil`)
	}
	var unwrapped []ProjectCard
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ProjectCard
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCardsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ProjectsListCollaboratorsAffiliation as json.
func (s ProjectsListCollaboratorsAffiliation) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ProjectsListCollaboratorsAffiliation from json.
func (s *ProjectsListCollaboratorsAffiliation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListCollaboratorsAffiliation to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectsListCollaboratorsAffiliation(v) {
	case ProjectsListCollaboratorsAffiliationOutside:
		*s = ProjectsListCollaboratorsAffiliationOutside
	case ProjectsListCollaboratorsAffiliationDirect:
		*s = ProjectsListCollaboratorsAffiliationDirect
	case ProjectsListCollaboratorsAffiliationAll:
		*s = ProjectsListCollaboratorsAffiliationAll
	default:
		*s = ProjectsListCollaboratorsAffiliation(v)
	}

	return nil
}

// Encode encodes ProjectsListCollaboratorsApplicationJSONForbidden as json.
func (s ProjectsListCollaboratorsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCollaboratorsApplicationJSONForbidden from json.
func (s *ProjectsListCollaboratorsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListCollaboratorsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCollaboratorsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsListCollaboratorsApplicationJSONNotFound as json.
func (s ProjectsListCollaboratorsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCollaboratorsApplicationJSONNotFound from json.
func (s *ProjectsListCollaboratorsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListCollaboratorsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCollaboratorsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsListCollaboratorsApplicationJSONUnauthorized as json.
func (s ProjectsListCollaboratorsApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCollaboratorsApplicationJSONUnauthorized from json.
func (s *ProjectsListCollaboratorsApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListCollaboratorsApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCollaboratorsApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsListCollaboratorsOKApplicationJSON as json.
func (s ProjectsListCollaboratorsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListCollaboratorsOKApplicationJSON from json.
func (s *ProjectsListCollaboratorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListCollaboratorsOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCollaboratorsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ProjectsListColumnsApplicationJSONForbidden as json.
func (s ProjectsListColumnsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListColumnsApplicationJSONForbidden from json.
func (s *ProjectsListColumnsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListColumnsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListColumnsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsListColumnsApplicationJSONUnauthorized as json.
func (s ProjectsListColumnsApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListColumnsApplicationJSONUnauthorized from json.
func (s *ProjectsListColumnsApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListColumnsApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListColumnsApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsListColumnsOKApplicationJSON as json.
func (s ProjectsListColumnsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ProjectColumn(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListColumnsOKApplicationJSON from json.
func (s *ProjectsListColumnsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListColumnsOKApplicationJSON to nil`)
	}
	var unwrapped []ProjectColumn
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ProjectColumn
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListColumnsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ProjectsListForOrgOKApplicationJSON as json.
func (s ProjectsListForOrgOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Project(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListForOrgOKApplicationJSON from json.
func (s *ProjectsListForOrgOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForOrgOKApplicationJSON to nil`)
	}
	var unwrapped []Project
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Project
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForOrgOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ProjectsListForOrgState as json.
func (s ProjectsListForOrgState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ProjectsListForOrgState from json.
func (s *ProjectsListForOrgState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForOrgState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectsListForOrgState(v) {
	case ProjectsListForOrgStateOpen:
		*s = ProjectsListForOrgStateOpen
	case ProjectsListForOrgStateClosed:
		*s = ProjectsListForOrgStateClosed
	case ProjectsListForOrgStateAll:
		*s = ProjectsListForOrgStateAll
	default:
		*s = ProjectsListForOrgState(v)
	}

	return nil
}

// Encode encodes ProjectsListForRepoApplicationJSONForbidden as json.
func (s ProjectsListForRepoApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoApplicationJSONForbidden from json.
func (s *ProjectsListForRepoApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForRepoApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsListForRepoApplicationJSONGone as json.
func (s ProjectsListForRepoApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoApplicationJSONGone from json.
func (s *ProjectsListForRepoApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForRepoApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ProjectsListForRepoApplicationJSONNotFound as json.
func (s ProjectsListForRepoApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoApplicationJSONNotFound from json.
func (s *ProjectsListForRepoApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForRepoApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsListForRepoApplicationJSONUnauthorized as json.
func (s ProjectsListForRepoApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoApplicationJSONUnauthorized from json.
func (s *ProjectsListForRepoApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForRepoApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsListForRepoOKApplicationJSON as json.
func (s ProjectsListForRepoOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Project(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListForRepoOKApplicationJSON from json.
func (s *ProjectsListForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForRepoOKApplicationJSON to nil`)
	}
	var unwrapped []Project
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Project
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ProjectsListForRepoState as json.
func (s ProjectsListForRepoState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ProjectsListForRepoState from json.
func (s *ProjectsListForRepoState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForRepoState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectsListForRepoState(v) {
	case ProjectsListForRepoStateOpen:
		*s = ProjectsListForRepoStateOpen
	case ProjectsListForRepoStateClosed:
		*s = ProjectsListForRepoStateClosed
	case ProjectsListForRepoStateAll:
		*s = ProjectsListForRepoStateAll
	default:
		*s = ProjectsListForRepoState(v)
	}

	return nil
}

// Encode encodes ProjectsListForUserOKApplicationJSON as json.
func (s ProjectsListForUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Project(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListForUserOKApplicationJSON from json.
func (s *ProjectsListForUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForUserOKApplicationJSON to nil`)
	}
	var unwrapped []Project
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Project
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ProjectsListForUserState as json.
func (s ProjectsListForUserState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ProjectsListForUserState from json.
func (s *ProjectsListForUserState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForUserState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectsListForUserState(v) {
	case ProjectsListForUserStateOpen:
		*s = ProjectsListForUserStateOpen
	case ProjectsListForUserStateClosed:
		*s = ProjectsListForUserStateClosed
	case ProjectsListForUserStateAll:
		*s = ProjectsListForUserStateAll
	default:
		*s = ProjectsListForUserState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardCreated) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ProjectsMoveCardCreated from json.
func (s *ProjectsMoveCardCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveCardCreated to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Errors != nil {
			e.RawStr("\"errors\"" + ":")
			e.ArrStart()
			if len(s.Errors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Errors[0]
					elem.Encode(e)
				}
				for _, elem := range s.Errors[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ProjectsMoveCardForbidden from json.
func (s *ProjectsMoveCardForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveCardForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		case "errors":
			s.Errors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ProjectsMoveCardForbiddenErrorsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Errors = append(s.Errors, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardForbiddenErrorsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Code.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Code.Set {
			e.RawStr("\"code\"" + ":")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resource.Set {
			e.RawStr("\"resource\"" + ":")
			s.Resource.Encode(e)
		}
	}
	{
		if s.Field.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Field.Set {
			e.RawStr("\"field\"" + ":")
			s.Field.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ProjectsMoveCardForbiddenErrorsItem from json.
func (s *ProjectsMoveCardForbiddenErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveCardForbiddenErrorsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			s.Code.Reset()
			if err := s.Code.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "resource":
			s.Resource.Reset()
			if err := s.Resource.Decode(d); err != nil {
				return err
			}
		case "field":
			s.Field.Reset()
			if err := s.Field.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"position\"" + ":")
		e.Str(s.Position)
	}
	{
		if s.ColumnID.Set {
			e.Comma()
		}
		if s.ColumnID.Set {
			e.RawStr("\"column_id\"" + ":")
			s.ColumnID.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ProjectsMoveCardReq from json.
func (s *ProjectsMoveCardReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveCardReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "position":
			v, err := d.Str()
			s.Position = string(v)
			if err != nil {
				return err
			}
		case "column_id":
			s.ColumnID.Reset()
			if err := s.ColumnID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardServiceUnavailable) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Code.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Code.Set {
			e.RawStr("\"code\"" + ":")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Errors != nil {
			e.RawStr("\"errors\"" + ":")
			e.ArrStart()
			if len(s.Errors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Errors[0]
					elem.Encode(e)
				}
				for _, elem := range s.Errors[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ProjectsMoveCardServiceUnavailable from json.
func (s *ProjectsMoveCardServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveCardServiceUnavailable to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			s.Code.Reset()
			if err := s.Code.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		case "errors":
			s.Errors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ProjectsMoveCardServiceUnavailableErrorsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Errors = append(s.Errors, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardServiceUnavailableErrorsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Code.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Code.Set {
			e.RawStr("\"code\"" + ":")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ProjectsMoveCardServiceUnavailableErrorsItem from json.
func (s *ProjectsMoveCardServiceUnavailableErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveCardServiceUnavailableErrorsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			s.Code.Reset()
			if err := s.Code.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsMoveColumnApplicationJSONForbidden as json.
func (s ProjectsMoveColumnApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsMoveColumnApplicationJSONForbidden from json.
func (s *ProjectsMoveColumnApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveColumnApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsMoveColumnApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsMoveColumnApplicationJSONUnauthorized as json.
func (s ProjectsMoveColumnApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsMoveColumnApplicationJSONUnauthorized from json.
func (s *ProjectsMoveColumnApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveColumnApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsMoveColumnApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsMoveColumnCreated) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ProjectsMoveColumnCreated from json.
func (s *ProjectsMoveColumnCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveColumnCreated to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsMoveColumnReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"position\"" + ":")
		e.Str(s.Position)
	}
	e.ObjEnd()
}

// Decode decodes ProjectsMoveColumnReq from json.
func (s *ProjectsMoveColumnReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveColumnReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "position":
			v, err := d.Str()
			s.Position = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsRemoveCollaboratorApplicationJSONForbidden as json.
func (s ProjectsRemoveCollaboratorApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsRemoveCollaboratorApplicationJSONForbidden from json.
func (s *ProjectsRemoveCollaboratorApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsRemoveCollaboratorApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsRemoveCollaboratorApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsRemoveCollaboratorApplicationJSONNotFound as json.
func (s ProjectsRemoveCollaboratorApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsRemoveCollaboratorApplicationJSONNotFound from json.
func (s *ProjectsRemoveCollaboratorApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsRemoveCollaboratorApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsRemoveCollaboratorApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsRemoveCollaboratorApplicationJSONUnauthorized as json.
func (s ProjectsRemoveCollaboratorApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsRemoveCollaboratorApplicationJSONUnauthorized from json.
func (s *ProjectsRemoveCollaboratorApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsRemoveCollaboratorApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsRemoveCollaboratorApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsRemoveCollaboratorNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ProjectsRemoveCollaboratorNoContent from json.
func (s *ProjectsRemoveCollaboratorNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsRemoveCollaboratorNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsUpdateApplicationJSONGone as json.
func (s ProjectsUpdateApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateApplicationJSONGone from json.
func (s *ProjectsUpdateApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateApplicationJSONUnauthorized as json.
func (s ProjectsUpdateApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateApplicationJSONUnauthorized from json.
func (s *ProjectsUpdateApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateCardApplicationJSONForbidden as json.
func (s ProjectsUpdateCardApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateCardApplicationJSONForbidden from json.
func (s *ProjectsUpdateCardApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateCardApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateCardApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateCardApplicationJSONNotFound as json.
func (s ProjectsUpdateCardApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateCardApplicationJSONNotFound from json.
func (s *ProjectsUpdateCardApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateCardApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateCardApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateCardApplicationJSONUnauthorized as json.
func (s ProjectsUpdateCardApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateCardApplicationJSONUnauthorized from json.
func (s *ProjectsUpdateCardApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateCardApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateCardApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsUpdateCardReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Note.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Note.Set {
			e.RawStr("\"note\"" + ":")
			s.Note.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Archived.Set {
			e.RawStr("\"archived\"" + ":")
			s.Archived.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ProjectsUpdateCardReq from json.
func (s *ProjectsUpdateCardReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateCardReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "note":
			s.Note.Reset()
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "archived":
			s.Archived.Reset()
			if err := s.Archived.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsUpdateColumnApplicationJSONForbidden as json.
func (s ProjectsUpdateColumnApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateColumnApplicationJSONForbidden from json.
func (s *ProjectsUpdateColumnApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateColumnApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateColumnApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateColumnApplicationJSONUnauthorized as json.
func (s ProjectsUpdateColumnApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateColumnApplicationJSONUnauthorized from json.
func (s *ProjectsUpdateColumnApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateColumnApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateColumnApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsUpdateColumnReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

// Decode decodes ProjectsUpdateColumnReq from json.
func (s *ProjectsUpdateColumnReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateColumnReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsUpdateForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Errors != nil {
			e.RawStr("\"errors\"" + ":")
			e.ArrStart()
			if len(s.Errors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Errors[0]
					e.Str(elem)
				}
				for _, elem := range s.Errors[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ProjectsUpdateForbidden from json.
func (s *ProjectsUpdateForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		case "errors":
			s.Errors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Errors = append(s.Errors, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsUpdateNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ProjectsUpdateNotFound from json.
func (s *ProjectsUpdateNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsUpdateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.OrganizationPermission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationPermission.Set {
			e.RawStr("\"organization_permission\"" + ":")
			s.OrganizationPermission.Encode(e)
		}
	}
	{
		if s.Private.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ProjectsUpdateReq from json.
func (s *ProjectsUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "organization_permission":
			s.OrganizationPermission.Reset()
			if err := s.OrganizationPermission.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsUpdateReqOrganizationPermission as json.
func (s ProjectsUpdateReqOrganizationPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ProjectsUpdateReqOrganizationPermission from json.
func (s *ProjectsUpdateReqOrganizationPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateReqOrganizationPermission to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectsUpdateReqOrganizationPermission(v) {
	case ProjectsUpdateReqOrganizationPermissionRead:
		*s = ProjectsUpdateReqOrganizationPermissionRead
	case ProjectsUpdateReqOrganizationPermissionWrite:
		*s = ProjectsUpdateReqOrganizationPermissionWrite
	case ProjectsUpdateReqOrganizationPermissionAdmin:
		*s = ProjectsUpdateReqOrganizationPermissionAdmin
	case ProjectsUpdateReqOrganizationPermissionNone:
		*s = ProjectsUpdateReqOrganizationPermissionNone
	default:
		*s = ProjectsUpdateReqOrganizationPermission(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProtectedBranch) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.RequiredStatusChecks.Set {
			e.Comma()
		}
		if s.RequiredStatusChecks.Set {
			e.RawStr("\"required_status_checks\"" + ":")
			s.RequiredStatusChecks.Encode(e)
		}
	}
	{
		if s.RequiredPullRequestReviews.Set {
			e.Comma()
		}
		if s.RequiredPullRequestReviews.Set {
			e.RawStr("\"required_pull_request_reviews\"" + ":")
			s.RequiredPullRequestReviews.Encode(e)
		}
	}
	{
		if s.RequiredSignatures.Set {
			e.Comma()
		}
		if s.RequiredSignatures.Set {
			e.RawStr("\"required_signatures\"" + ":")
			s.RequiredSignatures.Encode(e)
		}
	}
	{
		if s.EnforceAdmins.Set {
			e.Comma()
		}
		if s.EnforceAdmins.Set {
			e.RawStr("\"enforce_admins\"" + ":")
			s.EnforceAdmins.Encode(e)
		}
	}
	{
		if s.RequiredLinearHistory.Set {
			e.Comma()
		}
		if s.RequiredLinearHistory.Set {
			e.RawStr("\"required_linear_history\"" + ":")
			s.RequiredLinearHistory.Encode(e)
		}
	}
	{
		if s.AllowForcePushes.Set {
			e.Comma()
		}
		if s.AllowForcePushes.Set {
			e.RawStr("\"allow_force_pushes\"" + ":")
			s.AllowForcePushes.Encode(e)
		}
	}
	{
		if s.AllowDeletions.Set {
			e.Comma()
		}
		if s.AllowDeletions.Set {
			e.RawStr("\"allow_deletions\"" + ":")
			s.AllowDeletions.Encode(e)
		}
	}
	{
		if s.Restrictions.Set {
			e.Comma()
		}
		if s.Restrictions.Set {
			e.RawStr("\"restrictions\"" + ":")
			s.Restrictions.Encode(e)
		}
	}
	{
		if s.RequiredConversationResolution.Set {
			e.Comma()
		}
		if s.RequiredConversationResolution.Set {
			e.RawStr("\"required_conversation_resolution\"" + ":")
			s.RequiredConversationResolution.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranch from json.
func (s *ProtectedBranch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranch to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "required_status_checks":
			s.RequiredStatusChecks.Reset()
			if err := s.RequiredStatusChecks.Decode(d); err != nil {
				return err
			}
		case "required_pull_request_reviews":
			s.RequiredPullRequestReviews.Reset()
			if err := s.RequiredPullRequestReviews.Decode(d); err != nil {
				return err
			}
		case "required_signatures":
			s.RequiredSignatures.Reset()
			if err := s.RequiredSignatures.Decode(d); err != nil {
				return err
			}
		case "enforce_admins":
			s.EnforceAdmins.Reset()
			if err := s.EnforceAdmins.Decode(d); err != nil {
				return err
			}
		case "required_linear_history":
			s.RequiredLinearHistory.Reset()
			if err := s.RequiredLinearHistory.Decode(d); err != nil {
				return err
			}
		case "allow_force_pushes":
			s.AllowForcePushes.Reset()
			if err := s.AllowForcePushes.Decode(d); err != nil {
				return err
			}
		case "allow_deletions":
			s.AllowDeletions.Reset()
			if err := s.AllowDeletions.Decode(d); err != nil {
				return err
			}
		case "restrictions":
			s.Restrictions.Reset()
			if err := s.Restrictions.Decode(d); err != nil {
				return err
			}
		case "required_conversation_resolution":
			s.RequiredConversationResolution.Reset()
			if err := s.RequiredConversationResolution.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchAdminEnforced) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"enabled\"" + ":")
		e.Bool(s.Enabled)
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranchAdminEnforced from json.
func (s *ProtectedBranchAdminEnforced) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchAdminEnforced to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "enabled":
			v, err := d.Bool()
			s.Enabled = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchAllowDeletions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled\"" + ":")
		e.Bool(s.Enabled)
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranchAllowDeletions from json.
func (s *ProtectedBranchAllowDeletions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchAllowDeletions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			v, err := d.Bool()
			s.Enabled = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchAllowForcePushes) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled\"" + ":")
		e.Bool(s.Enabled)
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranchAllowForcePushes from json.
func (s *ProtectedBranchAllowForcePushes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchAllowForcePushes to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			v, err := d.Bool()
			s.Enabled = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchEnforceAdmins) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"enabled\"" + ":")
		e.Bool(s.Enabled)
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranchEnforceAdmins from json.
func (s *ProtectedBranchEnforceAdmins) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchEnforceAdmins to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "enabled":
			v, err := d.Bool()
			s.Enabled = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchPullRequestReview) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.DismissalRestrictions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DismissalRestrictions.Set {
			e.RawStr("\"dismissal_restrictions\"" + ":")
			s.DismissalRestrictions.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"dismiss_stale_reviews\"" + ":")
		e.Bool(s.DismissStaleReviews)
	}
	{
		e.Comma()

		e.RawStr("\"require_code_owner_reviews\"" + ":")
		e.Bool(s.RequireCodeOwnerReviews)
	}
	{
		if s.RequiredApprovingReviewCount.Set {
			e.Comma()
		}
		if s.RequiredApprovingReviewCount.Set {
			e.RawStr("\"required_approving_review_count\"" + ":")
			s.RequiredApprovingReviewCount.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranchPullRequestReview from json.
func (s *ProtectedBranchPullRequestReview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchPullRequestReview to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "dismissal_restrictions":
			s.DismissalRestrictions.Reset()
			if err := s.DismissalRestrictions.Decode(d); err != nil {
				return err
			}
		case "dismiss_stale_reviews":
			v, err := d.Bool()
			s.DismissStaleReviews = bool(v)
			if err != nil {
				return err
			}
		case "require_code_owner_reviews":
			v, err := d.Bool()
			s.RequireCodeOwnerReviews = bool(v)
			if err != nil {
				return err
			}
		case "required_approving_review_count":
			s.RequiredApprovingReviewCount.Reset()
			if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchPullRequestReviewDismissalRestrictions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Users != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Users != nil {
			e.RawStr("\"users\"" + ":")
			e.ArrStart()
			if len(s.Users) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Users[0]
					elem.Encode(e)
				}
				for _, elem := range s.Users[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Teams != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Teams != nil {
			e.RawStr("\"teams\"" + ":")
			e.ArrStart()
			if len(s.Teams) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Teams[0]
					elem.Encode(e)
				}
				for _, elem := range s.Teams[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.UsersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UsersURL.Set {
			e.RawStr("\"users_url\"" + ":")
			s.UsersURL.Encode(e)
		}
	}
	{
		if s.TeamsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TeamsURL.Set {
			e.RawStr("\"teams_url\"" + ":")
			s.TeamsURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranchPullRequestReviewDismissalRestrictions from json.
func (s *ProtectedBranchPullRequestReviewDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchPullRequestReviewDismissalRestrictions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem SimpleUser
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Team
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "users_url":
			s.UsersURL.Reset()
			if err := s.UsersURL.Decode(d); err != nil {
				return err
			}
		case "teams_url":
			s.TeamsURL.Reset()
			if err := s.TeamsURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchRequiredConversationResolution) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Enabled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Enabled.Set {
			e.RawStr("\"enabled\"" + ":")
			s.Enabled.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranchRequiredConversationResolution from json.
func (s *ProtectedBranchRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchRequiredConversationResolution to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			s.Enabled.Reset()
			if err := s.Enabled.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchRequiredLinearHistory) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled\"" + ":")
		e.Bool(s.Enabled)
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranchRequiredLinearHistory from json.
func (s *ProtectedBranchRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchRequiredLinearHistory to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			v, err := d.Bool()
			s.Enabled = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchRequiredPullRequestReviews) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.DismissStaleReviews.Set {
			e.Comma()
		}
		if s.DismissStaleReviews.Set {
			e.RawStr("\"dismiss_stale_reviews\"" + ":")
			s.DismissStaleReviews.Encode(e)
		}
	}
	{
		if s.RequireCodeOwnerReviews.Set {
			e.Comma()
		}
		if s.RequireCodeOwnerReviews.Set {
			e.RawStr("\"require_code_owner_reviews\"" + ":")
			s.RequireCodeOwnerReviews.Encode(e)
		}
	}
	{
		if s.RequiredApprovingReviewCount.Set {
			e.Comma()
		}
		if s.RequiredApprovingReviewCount.Set {
			e.RawStr("\"required_approving_review_count\"" + ":")
			s.RequiredApprovingReviewCount.Encode(e)
		}
	}
	{
		if s.DismissalRestrictions.Set {
			e.Comma()
		}
		if s.DismissalRestrictions.Set {
			e.RawStr("\"dismissal_restrictions\"" + ":")
			s.DismissalRestrictions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranchRequiredPullRequestReviews from json.
func (s *ProtectedBranchRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchRequiredPullRequestReviews to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "dismiss_stale_reviews":
			s.DismissStaleReviews.Reset()
			if err := s.DismissStaleReviews.Decode(d); err != nil {
				return err
			}
		case "require_code_owner_reviews":
			s.RequireCodeOwnerReviews.Reset()
			if err := s.RequireCodeOwnerReviews.Decode(d); err != nil {
				return err
			}
		case "required_approving_review_count":
			s.RequiredApprovingReviewCount.Reset()
			if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
				return err
			}
		case "dismissal_restrictions":
			s.DismissalRestrictions.Reset()
			if err := s.DismissalRestrictions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"users_url\"" + ":")
		json.EncodeURI(e, s.UsersURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"users\"" + ":")
		e.ArrStart()
		if len(s.Users) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Users[0]
				elem.Encode(e)
			}
			for _, elem := range s.Users[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"teams\"" + ":")
		e.ArrStart()
		if len(s.Teams) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Teams[0]
				elem.Encode(e)
			}
			for _, elem := range s.Teams[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions from json.
func (s *ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "users_url":
			v, err := json.DecodeURI(d)
			s.UsersURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem SimpleUser
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Team
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchRequiredSignatures) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"enabled\"" + ":")
		e.Bool(s.Enabled)
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranchRequiredSignatures from json.
func (s *ProtectedBranchRequiredSignatures) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchRequiredSignatures to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "enabled":
			v, err := d.Bool()
			s.Enabled = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PublicUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		s.Name.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"company\"" + ":")
		s.Company.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"blog\"" + ":")
		s.Blog.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"location\"" + ":")
		s.Location.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		s.Email.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"hireable\"" + ":")
		s.Hireable.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"bio\"" + ":")
		s.Bio.Encode(e)
	}
	{
		if s.TwitterUsername.Set {
			e.Comma()
		}
		if s.TwitterUsername.Set {
			e.RawStr("\"twitter_username\"" + ":")
			s.TwitterUsername.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"public_repos\"" + ":")
		e.Int(s.PublicRepos)
	}
	{
		e.Comma()

		e.RawStr("\"public_gists\"" + ":")
		e.Int(s.PublicGists)
	}
	{
		e.Comma()

		e.RawStr("\"followers\"" + ":")
		e.Int(s.Followers)
	}
	{
		e.Comma()

		e.RawStr("\"following\"" + ":")
		e.Int(s.Following)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.Plan.Set {
			e.Comma()
		}
		if s.Plan.Set {
			e.RawStr("\"plan\"" + ":")
			s.Plan.Encode(e)
		}
	}
	{
		if s.SuspendedAt.Set {
			e.Comma()
		}
		if s.SuspendedAt.Set {
			e.RawStr("\"suspended_at\"" + ":")
			s.SuspendedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PrivateGists.Set {
			e.Comma()
		}
		if s.PrivateGists.Set {
			e.RawStr("\"private_gists\"" + ":")
			s.PrivateGists.Encode(e)
		}
	}
	{
		if s.TotalPrivateRepos.Set {
			e.Comma()
		}
		if s.TotalPrivateRepos.Set {
			e.RawStr("\"total_private_repos\"" + ":")
			s.TotalPrivateRepos.Encode(e)
		}
	}
	{
		if s.OwnedPrivateRepos.Set {
			e.Comma()
		}
		if s.OwnedPrivateRepos.Set {
			e.RawStr("\"owned_private_repos\"" + ":")
			s.OwnedPrivateRepos.Encode(e)
		}
	}
	{
		if s.DiskUsage.Set {
			e.Comma()
		}
		if s.DiskUsage.Set {
			e.RawStr("\"disk_usage\"" + ":")
			s.DiskUsage.Encode(e)
		}
	}
	{
		if s.Collaborators.Set {
			e.Comma()
		}
		if s.Collaborators.Set {
			e.RawStr("\"collaborators\"" + ":")
			s.Collaborators.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PublicUser from json.
func (s *PublicUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PublicUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "company":
			if err := s.Company.Decode(d); err != nil {
				return err
			}
		case "blog":
			if err := s.Blog.Decode(d); err != nil {
				return err
			}
		case "location":
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "email":
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "hireable":
			if err := s.Hireable.Decode(d); err != nil {
				return err
			}
		case "bio":
			if err := s.Bio.Decode(d); err != nil {
				return err
			}
		case "twitter_username":
			s.TwitterUsername.Reset()
			if err := s.TwitterUsername.Decode(d); err != nil {
				return err
			}
		case "public_repos":
			v, err := d.Int()
			s.PublicRepos = int(v)
			if err != nil {
				return err
			}
		case "public_gists":
			v, err := d.Int()
			s.PublicGists = int(v)
			if err != nil {
				return err
			}
		case "followers":
			v, err := d.Int()
			s.Followers = int(v)
			if err != nil {
				return err
			}
		case "following":
			v, err := d.Int()
			s.Following = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "plan":
			s.Plan.Reset()
			if err := s.Plan.Decode(d); err != nil {
				return err
			}
		case "suspended_at":
			s.SuspendedAt.Reset()
			if err := s.SuspendedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "private_gists":
			s.PrivateGists.Reset()
			if err := s.PrivateGists.Decode(d); err != nil {
				return err
			}
		case "total_private_repos":
			s.TotalPrivateRepos.Reset()
			if err := s.TotalPrivateRepos.Decode(d); err != nil {
				return err
			}
		case "owned_private_repos":
			s.OwnedPrivateRepos.Reset()
			if err := s.OwnedPrivateRepos.Decode(d); err != nil {
				return err
			}
		case "disk_usage":
			s.DiskUsage.Reset()
			if err := s.DiskUsage.Decode(d); err != nil {
				return err
			}
		case "collaborators":
			s.Collaborators.Reset()
			if err := s.Collaborators.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PublicUserPlan) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"collaborators\"" + ":")
		e.Int(s.Collaborators)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"space\"" + ":")
		e.Int(s.Space)
	}
	{
		e.Comma()

		e.RawStr("\"private_repos\"" + ":")
		e.Int(s.PrivateRepos)
	}
	e.ObjEnd()
}

// Decode decodes PublicUserPlan from json.
func (s *PublicUserPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PublicUserPlan to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collaborators":
			v, err := d.Int()
			s.Collaborators = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "space":
			v, err := d.Int()
			s.Space = int(v)
			if err != nil {
				return err
			}
		case "private_repos":
			v, err := d.Int()
			s.PrivateRepos = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"diff_url\"" + ":")
		json.EncodeURI(e, s.DiffURL)
	}
	{
		e.Comma()

		e.RawStr("\"patch_url\"" + ":")
		json.EncodeURI(e, s.PatchURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_url\"" + ":")
		json.EncodeURI(e, s.IssueURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		json.EncodeURI(e, s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"review_comments_url\"" + ":")
		json.EncodeURI(e, s.ReviewCommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"review_comment_url\"" + ":")
		e.Str(s.ReviewCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		json.EncodeURI(e, s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"locked\"" + ":")
		e.Bool(s.Locked)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		s.Body.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"labels\"" + ":")
		e.ArrStart()
		if len(s.Labels) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Labels[0]
				elem.Encode(e)
			}
			for _, elem := range s.Labels[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"milestone\"" + ":")
		s.Milestone.Encode(e)
	}
	{
		if s.ActiveLockReason.Set {
			e.Comma()
		}
		if s.ActiveLockReason.Set {
			e.RawStr("\"active_lock_reason\"" + ":")
			s.ActiveLockReason.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"closed_at\"" + ":")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"merged_at\"" + ":")
		s.MergedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"merge_commit_sha\"" + ":")
		s.MergeCommitSha.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"assignee\"" + ":")
		s.Assignee.Encode(e)
	}
	{
		if s.Assignees.Set {
			e.Comma()
		}
		if s.Assignees.Set {
			e.RawStr("\"assignees\"" + ":")
			s.Assignees.Encode(e)
		}
	}
	{
		if s.RequestedReviewers.Set {
			e.Comma()
		}
		if s.RequestedReviewers.Set {
			e.RawStr("\"requested_reviewers\"" + ":")
			s.RequestedReviewers.Encode(e)
		}
	}
	{
		if s.RequestedTeams.Set {
			e.Comma()
		}
		if s.RequestedTeams.Set {
			e.RawStr("\"requested_teams\"" + ":")
			s.RequestedTeams.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"head\"" + ":")
		s.Head.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"base\"" + ":")
		s.Base.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"auto_merge\"" + ":")
		s.AutoMerge.Encode(e)
	}
	{
		if s.Draft.Set {
			e.Comma()
		}
		if s.Draft.Set {
			e.RawStr("\"draft\"" + ":")
			s.Draft.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"merged\"" + ":")
		e.Bool(s.Merged)
	}
	{
		e.Comma()

		e.RawStr("\"mergeable\"" + ":")
		s.Mergeable.Encode(e)
	}
	{
		if s.Rebaseable.Set {
			e.Comma()
		}
		if s.Rebaseable.Set {
			e.RawStr("\"rebaseable\"" + ":")
			s.Rebaseable.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"mergeable_state\"" + ":")
		e.Str(s.MergeableState)
	}
	{
		e.Comma()

		e.RawStr("\"merged_by\"" + ":")
		s.MergedBy.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comments\"" + ":")
		e.Int(s.Comments)
	}
	{
		e.Comma()

		e.RawStr("\"review_comments\"" + ":")
		e.Int(s.ReviewComments)
	}
	{
		e.Comma()

		e.RawStr("\"maintainer_can_modify\"" + ":")
		e.Bool(s.MaintainerCanModify)
	}
	{
		e.Comma()

		e.RawStr("\"commits\"" + ":")
		e.Int(s.Commits)
	}
	{
		e.Comma()

		e.RawStr("\"additions\"" + ":")
		e.Int(s.Additions)
	}
	{
		e.Comma()

		e.RawStr("\"deletions\"" + ":")
		e.Int(s.Deletions)
	}
	{
		e.Comma()

		e.RawStr("\"changed_files\"" + ":")
		e.Int(s.ChangedFiles)
	}
	e.ObjEnd()
}

// Decode decodes PullRequest from json.
func (s *PullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "diff_url":
			v, err := json.DecodeURI(d)
			s.DiffURL = v
			if err != nil {
				return err
			}
		case "patch_url":
			v, err := json.DecodeURI(d)
			s.PatchURL = v
			if err != nil {
				return err
			}
		case "issue_url":
			v, err := json.DecodeURI(d)
			s.IssueURL = v
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := json.DecodeURI(d)
			s.CommitsURL = v
			if err != nil {
				return err
			}
		case "review_comments_url":
			v, err := json.DecodeURI(d)
			s.ReviewCommentsURL = v
			if err != nil {
				return err
			}
		case "review_comment_url":
			v, err := d.Str()
			s.ReviewCommentURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := json.DecodeURI(d)
			s.StatusesURL = v
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "locked":
			v, err := d.Bool()
			s.Locked = bool(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "body":
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "labels":
			s.Labels = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PullRequestLabelsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Labels = append(s.Labels, elem)
				return nil
			}); err != nil {
				return err
			}
		case "milestone":
			if err := s.Milestone.Decode(d); err != nil {
				return err
			}
		case "active_lock_reason":
			s.ActiveLockReason.Reset()
			if err := s.ActiveLockReason.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "closed_at":
			if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "merged_at":
			if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "merge_commit_sha":
			if err := s.MergeCommitSha.Decode(d); err != nil {
				return err
			}
		case "assignee":
			if err := s.Assignee.Decode(d); err != nil {
				return err
			}
		case "assignees":
			s.Assignees.Reset()
			if err := s.Assignees.Decode(d); err != nil {
				return err
			}
		case "requested_reviewers":
			s.RequestedReviewers.Reset()
			if err := s.RequestedReviewers.Decode(d); err != nil {
				return err
			}
		case "requested_teams":
			s.RequestedTeams.Reset()
			if err := s.RequestedTeams.Decode(d); err != nil {
				return err
			}
		case "head":
			if err := s.Head.Decode(d); err != nil {
				return err
			}
		case "base":
			if err := s.Base.Decode(d); err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "auto_merge":
			if err := s.AutoMerge.Decode(d); err != nil {
				return err
			}
		case "draft":
			s.Draft.Reset()
			if err := s.Draft.Decode(d); err != nil {
				return err
			}
		case "merged":
			v, err := d.Bool()
			s.Merged = bool(v)
			if err != nil {
				return err
			}
		case "mergeable":
			if err := s.Mergeable.Decode(d); err != nil {
				return err
			}
		case "rebaseable":
			s.Rebaseable.Reset()
			if err := s.Rebaseable.Decode(d); err != nil {
				return err
			}
		case "mergeable_state":
			v, err := d.Str()
			s.MergeableState = string(v)
			if err != nil {
				return err
			}
		case "merged_by":
			if err := s.MergedBy.Decode(d); err != nil {
				return err
			}
		case "comments":
			v, err := d.Int()
			s.Comments = int(v)
			if err != nil {
				return err
			}
		case "review_comments":
			v, err := d.Int()
			s.ReviewComments = int(v)
			if err != nil {
				return err
			}
		case "maintainer_can_modify":
			v, err := d.Bool()
			s.MaintainerCanModify = bool(v)
			if err != nil {
				return err
			}
		case "commits":
			v, err := d.Int()
			s.Commits = int(v)
			if err != nil {
				return err
			}
		case "additions":
			v, err := d.Int()
			s.Additions = int(v)
			if err != nil {
				return err
			}
		case "deletions":
			v, err := d.Int()
			s.Deletions = int(v)
			if err != nil {
				return err
			}
		case "changed_files":
			v, err := d.Int()
			s.ChangedFiles = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestBase) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"label\"" + ":")
		e.Str(s.Label)
	}
	{
		e.Comma()

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"repo\"" + ":")
		s.Repo.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestBase from json.
func (s *PullRequestBase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestBase to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			v, err := d.Str()
			s.Label = string(v)
			if err != nil {
				return err
			}
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "repo":
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestBaseRepo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"clone_url\"" + ":")
		e.Str(s.CloneURL)
	}
	{
		e.Comma()

		e.RawStr("\"default_branch\"" + ":")
		e.Str(s.DefaultBranch)
	}
	{
		e.Comma()

		e.RawStr("\"forks\"" + ":")
		e.Int(s.Forks)
	}
	{
		e.Comma()

		e.RawStr("\"forks_count\"" + ":")
		e.Int(s.ForksCount)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		e.Str(s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"has_downloads\"" + ":")
		e.Bool(s.HasDownloads)
	}
	{
		e.Comma()

		e.RawStr("\"has_issues\"" + ":")
		e.Bool(s.HasIssues)
	}
	{
		e.Comma()

		e.RawStr("\"has_projects\"" + ":")
		e.Bool(s.HasProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_wiki\"" + ":")
		e.Bool(s.HasWiki)
	}
	{
		e.Comma()

		e.RawStr("\"has_pages\"" + ":")
		e.Bool(s.HasPages)
	}
	{
		e.Comma()

		e.RawStr("\"homepage\"" + ":")
		s.Homepage.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"language\"" + ":")
		s.Language.Encode(e)
	}
	{
		if s.MasterBranch.Set {
			e.Comma()
		}
		if s.MasterBranch.Set {
			e.RawStr("\"master_branch\"" + ":")
			s.MasterBranch.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"archived\"" + ":")
		e.Bool(s.Archived)
	}
	{
		e.Comma()

		e.RawStr("\"disabled\"" + ":")
		e.Bool(s.Disabled)
	}
	{
		e.Comma()

		e.RawStr("\"mirror_url\"" + ":")
		s.MirrorURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues_count\"" + ":")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pushed_at\"" + ":")
		json.EncodeDateTime(e, s.PushedAt)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"ssh_url\"" + ":")
		e.Str(s.SSHURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_count\"" + ":")
		e.Int(s.StargazersCount)
	}
	{
		e.Comma()

		e.RawStr("\"svn_url\"" + ":")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"watchers\"" + ":")
		e.Int(s.Watchers)
	}
	{
		e.Comma()

		e.RawStr("\"watchers_count\"" + ":")
		e.Int(s.WatchersCount)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullRequestBaseRepo from json.
func (s *PullRequestBaseRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestBaseRepo to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "clone_url":
			v, err := d.Str()
			s.CloneURL = string(v)
			if err != nil {
				return err
			}
		case "default_branch":
			v, err := d.Str()
			s.DefaultBranch = string(v)
			if err != nil {
				return err
			}
		case "forks":
			v, err := d.Int()
			s.Forks = int(v)
			if err != nil {
				return err
			}
		case "forks_count":
			v, err := d.Int()
			s.ForksCount = int(v)
			if err != nil {
				return err
			}
		case "git_url":
			v, err := d.Str()
			s.GitURL = string(v)
			if err != nil {
				return err
			}
		case "has_downloads":
			v, err := d.Bool()
			s.HasDownloads = bool(v)
			if err != nil {
				return err
			}
		case "has_issues":
			v, err := d.Bool()
			s.HasIssues = bool(v)
			if err != nil {
				return err
			}
		case "has_projects":
			v, err := d.Bool()
			s.HasProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_wiki":
			v, err := d.Bool()
			s.HasWiki = bool(v)
			if err != nil {
				return err
			}
		case "has_pages":
			v, err := d.Bool()
			s.HasPages = bool(v)
			if err != nil {
				return err
			}
		case "homepage":
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "master_branch":
			s.MasterBranch.Reset()
			if err := s.MasterBranch.Decode(d); err != nil {
				return err
			}
		case "archived":
			v, err := d.Bool()
			s.Archived = bool(v)
			if err != nil {
				return err
			}
		case "disabled":
			v, err := d.Bool()
			s.Disabled = bool(v)
			if err != nil {
				return err
			}
		case "mirror_url":
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "open_issues_count":
			v, err := d.Int()
			s.OpenIssuesCount = int(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			v, err := json.DecodeDateTime(d)
			s.PushedAt = v
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			v, err := d.Str()
			s.SSHURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_count":
			v, err := d.Int()
			s.StargazersCount = int(v)
			if err != nil {
				return err
			}
		case "svn_url":
			v, err := json.DecodeURI(d)
			s.SvnURL = v
			if err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "watchers":
			v, err := d.Int()
			s.Watchers = int(v)
			if err != nil {
				return err
			}
		case "watchers_count":
			v, err := d.Int()
			s.WatchersCount = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestBaseRepoOwner) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestBaseRepoOwner from json.
func (s *PullRequestBaseRepoOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestBaseRepoOwner to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestBaseRepoPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestBaseRepoPermissions from json.
func (s *PullRequestBaseRepoPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestBaseRepoPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestBaseUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestBaseUser from json.
func (s *PullRequestBaseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestBaseUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestHead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"label\"" + ":")
		e.Str(s.Label)
	}
	{
		e.Comma()

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"repo\"" + ":")
		s.Repo.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestHead from json.
func (s *PullRequestHead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestHead to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			v, err := d.Str()
			s.Label = string(v)
			if err != nil {
				return err
			}
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "repo":
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestHeadRepo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"clone_url\"" + ":")
		e.Str(s.CloneURL)
	}
	{
		e.Comma()

		e.RawStr("\"default_branch\"" + ":")
		e.Str(s.DefaultBranch)
	}
	{
		e.Comma()

		e.RawStr("\"forks\"" + ":")
		e.Int(s.Forks)
	}
	{
		e.Comma()

		e.RawStr("\"forks_count\"" + ":")
		e.Int(s.ForksCount)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		e.Str(s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"has_downloads\"" + ":")
		e.Bool(s.HasDownloads)
	}
	{
		e.Comma()

		e.RawStr("\"has_issues\"" + ":")
		e.Bool(s.HasIssues)
	}
	{
		e.Comma()

		e.RawStr("\"has_projects\"" + ":")
		e.Bool(s.HasProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_wiki\"" + ":")
		e.Bool(s.HasWiki)
	}
	{
		e.Comma()

		e.RawStr("\"has_pages\"" + ":")
		e.Bool(s.HasPages)
	}
	{
		e.Comma()

		e.RawStr("\"homepage\"" + ":")
		s.Homepage.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"language\"" + ":")
		s.Language.Encode(e)
	}
	{
		if s.MasterBranch.Set {
			e.Comma()
		}
		if s.MasterBranch.Set {
			e.RawStr("\"master_branch\"" + ":")
			s.MasterBranch.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"archived\"" + ":")
		e.Bool(s.Archived)
	}
	{
		e.Comma()

		e.RawStr("\"disabled\"" + ":")
		e.Bool(s.Disabled)
	}
	{
		e.Comma()

		e.RawStr("\"mirror_url\"" + ":")
		s.MirrorURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues_count\"" + ":")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pushed_at\"" + ":")
		json.EncodeDateTime(e, s.PushedAt)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"ssh_url\"" + ":")
		e.Str(s.SSHURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_count\"" + ":")
		e.Int(s.StargazersCount)
	}
	{
		e.Comma()

		e.RawStr("\"svn_url\"" + ":")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"watchers\"" + ":")
		e.Int(s.Watchers)
	}
	{
		e.Comma()

		e.RawStr("\"watchers_count\"" + ":")
		e.Int(s.WatchersCount)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullRequestHeadRepo from json.
func (s *PullRequestHeadRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestHeadRepo to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "clone_url":
			v, err := d.Str()
			s.CloneURL = string(v)
			if err != nil {
				return err
			}
		case "default_branch":
			v, err := d.Str()
			s.DefaultBranch = string(v)
			if err != nil {
				return err
			}
		case "forks":
			v, err := d.Int()
			s.Forks = int(v)
			if err != nil {
				return err
			}
		case "forks_count":
			v, err := d.Int()
			s.ForksCount = int(v)
			if err != nil {
				return err
			}
		case "git_url":
			v, err := d.Str()
			s.GitURL = string(v)
			if err != nil {
				return err
			}
		case "has_downloads":
			v, err := d.Bool()
			s.HasDownloads = bool(v)
			if err != nil {
				return err
			}
		case "has_issues":
			v, err := d.Bool()
			s.HasIssues = bool(v)
			if err != nil {
				return err
			}
		case "has_projects":
			v, err := d.Bool()
			s.HasProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_wiki":
			v, err := d.Bool()
			s.HasWiki = bool(v)
			if err != nil {
				return err
			}
		case "has_pages":
			v, err := d.Bool()
			s.HasPages = bool(v)
			if err != nil {
				return err
			}
		case "homepage":
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "master_branch":
			s.MasterBranch.Reset()
			if err := s.MasterBranch.Decode(d); err != nil {
				return err
			}
		case "archived":
			v, err := d.Bool()
			s.Archived = bool(v)
			if err != nil {
				return err
			}
		case "disabled":
			v, err := d.Bool()
			s.Disabled = bool(v)
			if err != nil {
				return err
			}
		case "mirror_url":
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "open_issues_count":
			v, err := d.Int()
			s.OpenIssuesCount = int(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			v, err := json.DecodeDateTime(d)
			s.PushedAt = v
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			v, err := d.Str()
			s.SSHURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_count":
			v, err := d.Int()
			s.StargazersCount = int(v)
			if err != nil {
				return err
			}
		case "svn_url":
			v, err := json.DecodeURI(d)
			s.SvnURL = v
			if err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "watchers":
			v, err := d.Int()
			s.Watchers = int(v)
			if err != nil {
				return err
			}
		case "watchers_count":
			v, err := d.Int()
			s.WatchersCount = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestHeadRepoLicense) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"spdx_id\"" + ":")
		s.SpdxID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestHeadRepoLicense from json.
func (s *PullRequestHeadRepoLicense) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestHeadRepoLicense to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "spdx_id":
			if err := s.SpdxID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestHeadRepoOwner) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestHeadRepoOwner from json.
func (s *PullRequestHeadRepoOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestHeadRepoOwner to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestHeadRepoPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestHeadRepoPermissions from json.
func (s *PullRequestHeadRepoPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestHeadRepoPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestHeadUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestHeadUser from json.
func (s *PullRequestHeadUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestHeadUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestLabelsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Color.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	{
		if s.Default.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Default.Set {
			e.RawStr("\"default\"" + ":")
			s.Default.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullRequestLabelsItem from json.
func (s *PullRequestLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestLabelsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "color":
			s.Color.Reset()
			if err := s.Color.Decode(d); err != nil {
				return err
			}
		case "default":
			s.Default.Reset()
			if err := s.Default.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"comments\"" + ":")
		s.Comments.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commits\"" + ":")
		s.Commits.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"statuses\"" + ":")
		s.Statuses.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html\"" + ":")
		s.HTML.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"issue\"" + ":")
		s.Issue.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"review_comments\"" + ":")
		s.ReviewComments.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"review_comment\"" + ":")
		s.ReviewComment.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"self\"" + ":")
		s.Self.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestLinks from json.
func (s *PullRequestLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "comments":
			if err := s.Comments.Decode(d); err != nil {
				return err
			}
		case "commits":
			if err := s.Commits.Decode(d); err != nil {
				return err
			}
		case "statuses":
			if err := s.Statuses.Decode(d); err != nil {
				return err
			}
		case "html":
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		case "issue":
			if err := s.Issue.Decode(d); err != nil {
				return err
			}
		case "review_comments":
			if err := s.ReviewComments.Decode(d); err != nil {
				return err
			}
		case "review_comment":
			if err := s.ReviewComment.Decode(d); err != nil {
				return err
			}
		case "self":
			if err := s.Self.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestMergeResult) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"merged\"" + ":")
		e.Bool(s.Merged)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestMergeResult from json.
func (s *PullRequestMergeResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestMergeResult to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "merged":
			v, err := d.Bool()
			s.Merged = bool(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestMinimal) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"head\"" + ":")
		s.Head.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"base\"" + ":")
		s.Base.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestMinimal from json.
func (s *PullRequestMinimal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestMinimal to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "head":
			if err := s.Head.Decode(d); err != nil {
				return err
			}
		case "base":
			if err := s.Base.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestMinimalBase) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"repo\"" + ":")
		s.Repo.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestMinimalBase from json.
func (s *PullRequestMinimalBase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestMinimalBase to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "repo":
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestMinimalBaseRepo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestMinimalBaseRepo from json.
func (s *PullRequestMinimalBaseRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestMinimalBaseRepo to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestMinimalHead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"repo\"" + ":")
		s.Repo.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestMinimalHead from json.
func (s *PullRequestMinimalHead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestMinimalHead to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "repo":
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestMinimalHeadRepo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestMinimalHeadRepo from json.
func (s *PullRequestMinimalHeadRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestMinimalHeadRepo to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReview) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request_url\"" + ":")
		json.EncodeURI(e, s.PullRequestURL)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		if s.SubmittedAt.Set {
			e.Comma()
		}
		if s.SubmittedAt.Set {
			e.RawStr("\"submitted_at\"" + ":")
			s.SubmittedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.Comma()

		e.RawStr("\"commit_id\"" + ":")
		e.Str(s.CommitID)
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestReview from json.
func (s *PullRequestReview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReview to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "pull_request_url":
			v, err := json.DecodeURI(d)
			s.PullRequestURL = v
			if err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "submitted_at":
			s.SubmittedAt.Reset()
			if err := s.SubmittedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "commit_id":
			v, err := d.Str()
			s.CommitID = string(v)
			if err != nil {
				return err
			}
		case "body_html":
			s.BodyHTML.Reset()
			if err := s.BodyHTML.Decode(d); err != nil {
				return err
			}
		case "body_text":
			s.BodyText.Reset()
			if err := s.BodyText.Decode(d); err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewComment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request_review_id\"" + ":")
		s.PullRequestReviewID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"diff_hunk\"" + ":")
		e.Str(s.DiffHunk)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"position\"" + ":")
		e.Int(s.Position)
	}
	{
		e.Comma()

		e.RawStr("\"original_position\"" + ":")
		e.Int(s.OriginalPosition)
	}
	{
		e.Comma()

		e.RawStr("\"commit_id\"" + ":")
		e.Str(s.CommitID)
	}
	{
		e.Comma()

		e.RawStr("\"original_commit_id\"" + ":")
		e.Str(s.OriginalCommitID)
	}
	{
		if s.InReplyToID.Set {
			e.Comma()
		}
		if s.InReplyToID.Set {
			e.RawStr("\"in_reply_to_id\"" + ":")
			s.InReplyToID.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request_url\"" + ":")
		json.EncodeURI(e, s.PullRequestURL)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		if s.StartLine.Set {
			e.Comma()
		}
		if s.StartLine.Set {
			e.RawStr("\"start_line\"" + ":")
			s.StartLine.Encode(e)
		}
	}
	{
		if s.OriginalStartLine.Set {
			e.Comma()
		}
		if s.OriginalStartLine.Set {
			e.RawStr("\"original_start_line\"" + ":")
			s.OriginalStartLine.Encode(e)
		}
	}
	{
		if s.StartSide.Set {
			e.Comma()
		}
		if s.StartSide.Set {
			e.RawStr("\"start_side\"" + ":")
			s.StartSide.Encode(e)
		}
	}
	{
		if s.Line.Set {
			e.Comma()
		}
		if s.Line.Set {
			e.RawStr("\"line\"" + ":")
			s.Line.Encode(e)
		}
	}
	{
		if s.OriginalLine.Set {
			e.Comma()
		}
		if s.OriginalLine.Set {
			e.RawStr("\"original_line\"" + ":")
			s.OriginalLine.Encode(e)
		}
	}
	{
		if s.Side.Set {
			e.Comma()
		}
		if s.Side.Set {
			e.RawStr("\"side\"" + ":")
			s.Side.Encode(e)
		}
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullRequestReviewComment from json.
func (s *PullRequestReviewComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewComment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "pull_request_review_id":
			if err := s.PullRequestReviewID.Decode(d); err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "diff_hunk":
			v, err := d.Str()
			s.DiffHunk = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "position":
			v, err := d.Int()
			s.Position = int(v)
			if err != nil {
				return err
			}
		case "original_position":
			v, err := d.Int()
			s.OriginalPosition = int(v)
			if err != nil {
				return err
			}
		case "commit_id":
			v, err := d.Str()
			s.CommitID = string(v)
			if err != nil {
				return err
			}
		case "original_commit_id":
			v, err := d.Str()
			s.OriginalCommitID = string(v)
			if err != nil {
				return err
			}
		case "in_reply_to_id":
			s.InReplyToID.Reset()
			if err := s.InReplyToID.Decode(d); err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "pull_request_url":
			v, err := json.DecodeURI(d)
			s.PullRequestURL = v
			if err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "start_line":
			s.StartLine.Reset()
			if err := s.StartLine.Decode(d); err != nil {
				return err
			}
		case "original_start_line":
			s.OriginalStartLine.Reset()
			if err := s.OriginalStartLine.Decode(d); err != nil {
				return err
			}
		case "start_side":
			s.StartSide.Reset()
			if err := s.StartSide.Decode(d); err != nil {
				return err
			}
		case "line":
			s.Line.Reset()
			if err := s.Line.Decode(d); err != nil {
				return err
			}
		case "original_line":
			s.OriginalLine.Reset()
			if err := s.OriginalLine.Decode(d); err != nil {
				return err
			}
		case "side":
			s.Side.Reset()
			if err := s.Side.Decode(d); err != nil {
				return err
			}
		case "reactions":
			s.Reactions.Reset()
			if err := s.Reactions.Decode(d); err != nil {
				return err
			}
		case "body_html":
			s.BodyHTML.Reset()
			if err := s.BodyHTML.Decode(d); err != nil {
				return err
			}
		case "body_text":
			s.BodyText.Reset()
			if err := s.BodyText.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewCommentLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"self\"" + ":")
		s.Self.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html\"" + ":")
		s.HTML.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request\"" + ":")
		s.PullRequest.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestReviewCommentLinks from json.
func (s *PullRequestReviewCommentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewCommentLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			if err := s.Self.Decode(d); err != nil {
				return err
			}
		case "html":
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		case "pull_request":
			if err := s.PullRequest.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewCommentLinksHTML) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"href\"" + ":")
		json.EncodeURI(e, s.Href)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestReviewCommentLinksHTML from json.
func (s *PullRequestReviewCommentLinksHTML) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewCommentLinksHTML to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			v, err := json.DecodeURI(d)
			s.Href = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewCommentLinksPullRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"href\"" + ":")
		json.EncodeURI(e, s.Href)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestReviewCommentLinksPullRequest from json.
func (s *PullRequestReviewCommentLinksPullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewCommentLinksPullRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			v, err := json.DecodeURI(d)
			s.Href = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewCommentLinksSelf) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"href\"" + ":")
		json.EncodeURI(e, s.Href)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestReviewCommentLinksSelf from json.
func (s *PullRequestReviewCommentLinksSelf) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewCommentLinksSelf to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			v, err := json.DecodeURI(d)
			s.Href = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullRequestReviewCommentSide as json.
func (s PullRequestReviewCommentSide) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullRequestReviewCommentSide from json.
func (s *PullRequestReviewCommentSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewCommentSide to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullRequestReviewCommentSide(v) {
	case PullRequestReviewCommentSideLEFT:
		*s = PullRequestReviewCommentSideLEFT
	case PullRequestReviewCommentSideRIGHT:
		*s = PullRequestReviewCommentSideRIGHT
	default:
		*s = PullRequestReviewCommentSide(v)
	}

	return nil
}

// Encode encodes PullRequestReviewCommentStartSide as json.
func (s PullRequestReviewCommentStartSide) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullRequestReviewCommentStartSide from json.
func (s *PullRequestReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewCommentStartSide to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullRequestReviewCommentStartSide(v) {
	case PullRequestReviewCommentStartSideLEFT:
		*s = PullRequestReviewCommentStartSideLEFT
	case PullRequestReviewCommentStartSideRIGHT:
		*s = PullRequestReviewCommentStartSideRIGHT
	default:
		*s = PullRequestReviewCommentStartSide(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestReviewLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"html\"" + ":")
		s.HTML.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request\"" + ":")
		s.PullRequest.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestReviewLinks from json.
func (s *PullRequestReviewLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "html":
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		case "pull_request":
			if err := s.PullRequest.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewLinksHTML) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"href\"" + ":")
		e.Str(s.Href)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestReviewLinksHTML from json.
func (s *PullRequestReviewLinksHTML) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewLinksHTML to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			v, err := d.Str()
			s.Href = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewLinksPullRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"href\"" + ":")
		e.Str(s.Href)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestReviewLinksPullRequest from json.
func (s *PullRequestReviewLinksPullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewLinksPullRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			v, err := d.Str()
			s.Href = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"users\"" + ":")
		e.ArrStart()
		if len(s.Users) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Users[0]
				elem.Encode(e)
			}
			for _, elem := range s.Users[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"teams\"" + ":")
		e.ArrStart()
		if len(s.Teams) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Teams[0]
				elem.Encode(e)
			}
			for _, elem := range s.Teams[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes PullRequestReviewRequest from json.
func (s *PullRequestReviewRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem SimpleUser
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Team
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"diff_url\"" + ":")
		json.EncodeURI(e, s.DiffURL)
	}
	{
		e.Comma()

		e.RawStr("\"patch_url\"" + ":")
		json.EncodeURI(e, s.PatchURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_url\"" + ":")
		json.EncodeURI(e, s.IssueURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		json.EncodeURI(e, s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"review_comments_url\"" + ":")
		json.EncodeURI(e, s.ReviewCommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"review_comment_url\"" + ":")
		e.Str(s.ReviewCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		json.EncodeURI(e, s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"locked\"" + ":")
		e.Bool(s.Locked)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		s.Body.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"labels\"" + ":")
		e.ArrStart()
		if len(s.Labels) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Labels[0]
				elem.Encode(e)
			}
			for _, elem := range s.Labels[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"milestone\"" + ":")
		s.Milestone.Encode(e)
	}
	{
		if s.ActiveLockReason.Set {
			e.Comma()
		}
		if s.ActiveLockReason.Set {
			e.RawStr("\"active_lock_reason\"" + ":")
			s.ActiveLockReason.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"closed_at\"" + ":")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"merged_at\"" + ":")
		s.MergedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"merge_commit_sha\"" + ":")
		s.MergeCommitSha.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"assignee\"" + ":")
		s.Assignee.Encode(e)
	}
	{
		if s.Assignees.Set {
			e.Comma()
		}
		if s.Assignees.Set {
			e.RawStr("\"assignees\"" + ":")
			s.Assignees.Encode(e)
		}
	}
	{
		if s.RequestedReviewers.Set {
			e.Comma()
		}
		if s.RequestedReviewers.Set {
			e.RawStr("\"requested_reviewers\"" + ":")
			s.RequestedReviewers.Encode(e)
		}
	}
	{
		if s.RequestedTeams.Set {
			e.Comma()
		}
		if s.RequestedTeams.Set {
			e.RawStr("\"requested_teams\"" + ":")
			s.RequestedTeams.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"head\"" + ":")
		s.Head.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"base\"" + ":")
		s.Base.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"auto_merge\"" + ":")
		s.AutoMerge.Encode(e)
	}
	{
		if s.Draft.Set {
			e.Comma()
		}
		if s.Draft.Set {
			e.RawStr("\"draft\"" + ":")
			s.Draft.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullRequestSimple from json.
func (s *PullRequestSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "diff_url":
			v, err := json.DecodeURI(d)
			s.DiffURL = v
			if err != nil {
				return err
			}
		case "patch_url":
			v, err := json.DecodeURI(d)
			s.PatchURL = v
			if err != nil {
				return err
			}
		case "issue_url":
			v, err := json.DecodeURI(d)
			s.IssueURL = v
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := json.DecodeURI(d)
			s.CommitsURL = v
			if err != nil {
				return err
			}
		case "review_comments_url":
			v, err := json.DecodeURI(d)
			s.ReviewCommentsURL = v
			if err != nil {
				return err
			}
		case "review_comment_url":
			v, err := d.Str()
			s.ReviewCommentURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := json.DecodeURI(d)
			s.StatusesURL = v
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "locked":
			v, err := d.Bool()
			s.Locked = bool(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "body":
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "labels":
			s.Labels = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PullRequestSimpleLabelsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Labels = append(s.Labels, elem)
				return nil
			}); err != nil {
				return err
			}
		case "milestone":
			if err := s.Milestone.Decode(d); err != nil {
				return err
			}
		case "active_lock_reason":
			s.ActiveLockReason.Reset()
			if err := s.ActiveLockReason.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "closed_at":
			if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "merged_at":
			if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "merge_commit_sha":
			if err := s.MergeCommitSha.Decode(d); err != nil {
				return err
			}
		case "assignee":
			if err := s.Assignee.Decode(d); err != nil {
				return err
			}
		case "assignees":
			s.Assignees.Reset()
			if err := s.Assignees.Decode(d); err != nil {
				return err
			}
		case "requested_reviewers":
			s.RequestedReviewers.Reset()
			if err := s.RequestedReviewers.Decode(d); err != nil {
				return err
			}
		case "requested_teams":
			s.RequestedTeams.Reset()
			if err := s.RequestedTeams.Decode(d); err != nil {
				return err
			}
		case "head":
			if err := s.Head.Decode(d); err != nil {
				return err
			}
		case "base":
			if err := s.Base.Decode(d); err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "auto_merge":
			if err := s.AutoMerge.Decode(d); err != nil {
				return err
			}
		case "draft":
			s.Draft.Reset()
			if err := s.Draft.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestSimpleBase) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"label\"" + ":")
		e.Str(s.Label)
	}
	{
		e.Comma()

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"repo\"" + ":")
		s.Repo.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestSimpleBase from json.
func (s *PullRequestSimpleBase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestSimpleBase to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			v, err := d.Str()
			s.Label = string(v)
			if err != nil {
				return err
			}
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "repo":
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestSimpleHead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"label\"" + ":")
		e.Str(s.Label)
	}
	{
		e.Comma()

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"repo\"" + ":")
		s.Repo.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestSimpleHead from json.
func (s *PullRequestSimpleHead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestSimpleHead to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			v, err := d.Str()
			s.Label = string(v)
			if err != nil {
				return err
			}
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "repo":
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestSimpleLabelsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Color.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	{
		if s.Default.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Default.Set {
			e.RawStr("\"default\"" + ":")
			s.Default.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullRequestSimpleLabelsItem from json.
func (s *PullRequestSimpleLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestSimpleLabelsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "color":
			s.Color.Reset()
			if err := s.Color.Decode(d); err != nil {
				return err
			}
		case "default":
			s.Default.Reset()
			if err := s.Default.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestSimpleLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"comments\"" + ":")
		s.Comments.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commits\"" + ":")
		s.Commits.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"statuses\"" + ":")
		s.Statuses.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html\"" + ":")
		s.HTML.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"issue\"" + ":")
		s.Issue.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"review_comments\"" + ":")
		s.ReviewComments.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"review_comment\"" + ":")
		s.ReviewComment.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"self\"" + ":")
		s.Self.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestSimpleLinks from json.
func (s *PullRequestSimpleLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestSimpleLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "comments":
			if err := s.Comments.Decode(d); err != nil {
				return err
			}
		case "commits":
			if err := s.Commits.Decode(d); err != nil {
				return err
			}
		case "statuses":
			if err := s.Statuses.Decode(d); err != nil {
				return err
			}
		case "html":
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		case "issue":
			if err := s.Issue.Decode(d); err != nil {
				return err
			}
		case "review_comments":
			if err := s.ReviewComments.Decode(d); err != nil {
				return err
			}
		case "review_comment":
			if err := s.ReviewComment.Decode(d); err != nil {
				return err
			}
		case "self":
			if err := s.Self.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullRequestState as json.
func (s PullRequestState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullRequestState from json.
func (s *PullRequestState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullRequestState(v) {
	case PullRequestStateOpen:
		*s = PullRequestStateOpen
	case PullRequestStateClosed:
		*s = PullRequestStateClosed
	default:
		*s = PullRequestState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsCheckIfMergedNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes PullsCheckIfMergedNoContent from json.
func (s *PullsCheckIfMergedNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCheckIfMergedNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsCheckIfMergedNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes PullsCheckIfMergedNotFound from json.
func (s *PullsCheckIfMergedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCheckIfMergedNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsCreateReplyForReviewCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

// Decode decodes PullsCreateReplyForReviewCommentReq from json.
func (s *PullsCreateReplyForReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReplyForReviewCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsCreateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"head\"" + ":")
		e.Str(s.Head)
	}
	{
		e.Comma()

		e.RawStr("\"base\"" + ":")
		e.Str(s.Base)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.MaintainerCanModify.Set {
			e.Comma()
		}
		if s.MaintainerCanModify.Set {
			e.RawStr("\"maintainer_can_modify\"" + ":")
			s.MaintainerCanModify.Encode(e)
		}
	}
	{
		if s.Draft.Set {
			e.Comma()
		}
		if s.Draft.Set {
			e.RawStr("\"draft\"" + ":")
			s.Draft.Encode(e)
		}
	}
	{
		if s.Issue.Set {
			e.Comma()
		}
		if s.Issue.Set {
			e.RawStr("\"issue\"" + ":")
			s.Issue.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullsCreateReq from json.
func (s *PullsCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "head":
			v, err := d.Str()
			s.Head = string(v)
			if err != nil {
				return err
			}
		case "base":
			v, err := d.Str()
			s.Base = string(v)
			if err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "maintainer_can_modify":
			s.MaintainerCanModify.Reset()
			if err := s.MaintainerCanModify.Decode(d); err != nil {
				return err
			}
		case "draft":
			s.Draft.Reset()
			if err := s.Draft.Decode(d); err != nil {
				return err
			}
		case "issue":
			s.Issue.Reset()
			if err := s.Issue.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsCreateReviewCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		if s.CommitID.Set {
			e.Comma()
		}
		if s.CommitID.Set {
			e.RawStr("\"commit_id\"" + ":")
			s.CommitID.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Position.Set {
			e.Comma()
		}
		if s.Position.Set {
			e.RawStr("\"position\"" + ":")
			s.Position.Encode(e)
		}
	}
	{
		if s.Side.Set {
			e.Comma()
		}
		if s.Side.Set {
			e.RawStr("\"side\"" + ":")
			s.Side.Encode(e)
		}
	}
	{
		if s.Line.Set {
			e.Comma()
		}
		if s.Line.Set {
			e.RawStr("\"line\"" + ":")
			s.Line.Encode(e)
		}
	}
	{
		if s.StartLine.Set {
			e.Comma()
		}
		if s.StartLine.Set {
			e.RawStr("\"start_line\"" + ":")
			s.StartLine.Encode(e)
		}
	}
	{
		if s.StartSide.Set {
			e.Comma()
		}
		if s.StartSide.Set {
			e.RawStr("\"start_side\"" + ":")
			s.StartSide.Encode(e)
		}
	}
	{
		if s.InReplyTo.Set {
			e.Comma()
		}
		if s.InReplyTo.Set {
			e.RawStr("\"in_reply_to\"" + ":")
			s.InReplyTo.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullsCreateReviewCommentReq from json.
func (s *PullsCreateReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReviewCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "commit_id":
			s.CommitID.Reset()
			if err := s.CommitID.Decode(d); err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "position":
			s.Position.Reset()
			if err := s.Position.Decode(d); err != nil {
				return err
			}
		case "side":
			s.Side.Reset()
			if err := s.Side.Decode(d); err != nil {
				return err
			}
		case "line":
			s.Line.Reset()
			if err := s.Line.Decode(d); err != nil {
				return err
			}
		case "start_line":
			s.StartLine.Reset()
			if err := s.StartLine.Decode(d); err != nil {
				return err
			}
		case "start_side":
			s.StartSide.Reset()
			if err := s.StartSide.Decode(d); err != nil {
				return err
			}
		case "in_reply_to":
			s.InReplyTo.Reset()
			if err := s.InReplyTo.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullsCreateReviewCommentReqSide as json.
func (s PullsCreateReviewCommentReqSide) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsCreateReviewCommentReqSide from json.
func (s *PullsCreateReviewCommentReqSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReviewCommentReqSide to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsCreateReviewCommentReqSide(v) {
	case PullsCreateReviewCommentReqSideLEFT:
		*s = PullsCreateReviewCommentReqSideLEFT
	case PullsCreateReviewCommentReqSideRIGHT:
		*s = PullsCreateReviewCommentReqSideRIGHT
	default:
		*s = PullsCreateReviewCommentReqSide(v)
	}

	return nil
}

// Encode encodes PullsCreateReviewCommentReqStartSide as json.
func (s PullsCreateReviewCommentReqStartSide) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsCreateReviewCommentReqStartSide from json.
func (s *PullsCreateReviewCommentReqStartSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReviewCommentReqStartSide to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsCreateReviewCommentReqStartSide(v) {
	case PullsCreateReviewCommentReqStartSideLEFT:
		*s = PullsCreateReviewCommentReqStartSideLEFT
	case PullsCreateReviewCommentReqStartSideRIGHT:
		*s = PullsCreateReviewCommentReqStartSideRIGHT
	case PullsCreateReviewCommentReqStartSideSide:
		*s = PullsCreateReviewCommentReqStartSideSide
	default:
		*s = PullsCreateReviewCommentReqStartSide(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsCreateReviewReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CommitID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommitID.Set {
			e.RawStr("\"commit_id\"" + ":")
			s.CommitID.Encode(e)
		}
	}
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.Event.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Event.Set {
			e.RawStr("\"event\"" + ":")
			s.Event.Encode(e)
		}
	}
	{
		if s.Comments != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Comments != nil {
			e.RawStr("\"comments\"" + ":")
			e.ArrStart()
			if len(s.Comments) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Comments[0]
					elem.Encode(e)
				}
				for _, elem := range s.Comments[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes PullsCreateReviewReq from json.
func (s *PullsCreateReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReviewReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commit_id":
			s.CommitID.Reset()
			if err := s.CommitID.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "event":
			s.Event.Reset()
			if err := s.Event.Decode(d); err != nil {
				return err
			}
		case "comments":
			s.Comments = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PullsCreateReviewReqCommentsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Comments = append(s.Comments, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsCreateReviewReqCommentsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		if s.Position.Set {
			e.Comma()
		}
		if s.Position.Set {
			e.RawStr("\"position\"" + ":")
			s.Position.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		if s.Line.Set {
			e.Comma()
		}
		if s.Line.Set {
			e.RawStr("\"line\"" + ":")
			s.Line.Encode(e)
		}
	}
	{
		if s.Side.Set {
			e.Comma()
		}
		if s.Side.Set {
			e.RawStr("\"side\"" + ":")
			s.Side.Encode(e)
		}
	}
	{
		if s.StartLine.Set {
			e.Comma()
		}
		if s.StartLine.Set {
			e.RawStr("\"start_line\"" + ":")
			s.StartLine.Encode(e)
		}
	}
	{
		if s.StartSide.Set {
			e.Comma()
		}
		if s.StartSide.Set {
			e.RawStr("\"start_side\"" + ":")
			s.StartSide.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullsCreateReviewReqCommentsItem from json.
func (s *PullsCreateReviewReqCommentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReviewReqCommentsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "position":
			s.Position.Reset()
			if err := s.Position.Decode(d); err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "line":
			s.Line.Reset()
			if err := s.Line.Decode(d); err != nil {
				return err
			}
		case "side":
			s.Side.Reset()
			if err := s.Side.Decode(d); err != nil {
				return err
			}
		case "start_line":
			s.StartLine.Reset()
			if err := s.StartLine.Decode(d); err != nil {
				return err
			}
		case "start_side":
			s.StartSide.Reset()
			if err := s.StartSide.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullsCreateReviewReqEvent as json.
func (s PullsCreateReviewReqEvent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsCreateReviewReqEvent from json.
func (s *PullsCreateReviewReqEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReviewReqEvent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsCreateReviewReqEvent(v) {
	case PullsCreateReviewReqEventAPPROVE:
		*s = PullsCreateReviewReqEventAPPROVE
	case PullsCreateReviewReqEventREQUESTCHANGES:
		*s = PullsCreateReviewReqEventREQUESTCHANGES
	case PullsCreateReviewReqEventCOMMENT:
		*s = PullsCreateReviewReqEventCOMMENT
	default:
		*s = PullsCreateReviewReqEvent(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsDeleteReviewCommentNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes PullsDeleteReviewCommentNoContent from json.
func (s *PullsDeleteReviewCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsDeleteReviewCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsDismissReviewReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		if s.Event.Set {
			e.Comma()
		}
		if s.Event.Set {
			e.RawStr("\"event\"" + ":")
			s.Event.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullsDismissReviewReq from json.
func (s *PullsDismissReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsDismissReviewReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "event":
			s.Event.Reset()
			if err := s.Event.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullsGetApplicationJSONInternalServerError as json.
func (s PullsGetApplicationJSONInternalServerError) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsGetApplicationJSONInternalServerError from json.
func (s *PullsGetApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsGetApplicationJSONInternalServerError to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsGetApplicationJSONInternalServerError(unwrapped)
	return nil
}

// Encode encodes PullsGetApplicationJSONNotFound as json.
func (s PullsGetApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsGetApplicationJSONNotFound from json.
func (s *PullsGetApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsGetApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsGetApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PullsListCommentsForReviewOKApplicationJSON as json.
func (s PullsListCommentsForReviewOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ReviewComment(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PullsListCommentsForReviewOKApplicationJSON from json.
func (s *PullsListCommentsForReviewOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListCommentsForReviewOKApplicationJSON to nil`)
	}
	var unwrapped []ReviewComment
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ReviewComment
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsListCommentsForReviewOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PullsListDirection as json.
func (s PullsListDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsListDirection from json.
func (s *PullsListDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsListDirection(v) {
	case PullsListDirectionAsc:
		*s = PullsListDirectionAsc
	case PullsListDirectionDesc:
		*s = PullsListDirectionDesc
	default:
		*s = PullsListDirection(v)
	}

	return nil
}

// Encode encodes PullsListFilesOKApplicationJSON as json.
func (s PullsListFilesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []DiffEntry(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PullsListFilesOKApplicationJSON from json.
func (s *PullsListFilesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListFilesOKApplicationJSON to nil`)
	}
	var unwrapped []DiffEntry
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem DiffEntry
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsListFilesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PullsListOKApplicationJSON as json.
func (s PullsListOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PullRequestSimple(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PullsListOKApplicationJSON from json.
func (s *PullsListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListOKApplicationJSON to nil`)
	}
	var unwrapped []PullRequestSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PullRequestSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PullsListReviewCommentsDirection as json.
func (s PullsListReviewCommentsDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsListReviewCommentsDirection from json.
func (s *PullsListReviewCommentsDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListReviewCommentsDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsListReviewCommentsDirection(v) {
	case PullsListReviewCommentsDirectionAsc:
		*s = PullsListReviewCommentsDirectionAsc
	case PullsListReviewCommentsDirectionDesc:
		*s = PullsListReviewCommentsDirectionDesc
	default:
		*s = PullsListReviewCommentsDirection(v)
	}

	return nil
}

// Encode encodes PullsListReviewCommentsForRepoDirection as json.
func (s PullsListReviewCommentsForRepoDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsListReviewCommentsForRepoDirection from json.
func (s *PullsListReviewCommentsForRepoDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListReviewCommentsForRepoDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsListReviewCommentsForRepoDirection(v) {
	case PullsListReviewCommentsForRepoDirectionAsc:
		*s = PullsListReviewCommentsForRepoDirectionAsc
	case PullsListReviewCommentsForRepoDirectionDesc:
		*s = PullsListReviewCommentsForRepoDirectionDesc
	default:
		*s = PullsListReviewCommentsForRepoDirection(v)
	}

	return nil
}

// Encode encodes PullsListReviewCommentsForRepoSort as json.
func (s PullsListReviewCommentsForRepoSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsListReviewCommentsForRepoSort from json.
func (s *PullsListReviewCommentsForRepoSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListReviewCommentsForRepoSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsListReviewCommentsForRepoSort(v) {
	case PullsListReviewCommentsForRepoSortCreated:
		*s = PullsListReviewCommentsForRepoSortCreated
	case PullsListReviewCommentsForRepoSortUpdated:
		*s = PullsListReviewCommentsForRepoSortUpdated
	case PullsListReviewCommentsForRepoSortCreatedAt:
		*s = PullsListReviewCommentsForRepoSortCreatedAt
	default:
		*s = PullsListReviewCommentsForRepoSort(v)
	}

	return nil
}

// Encode encodes PullsListReviewCommentsSort as json.
func (s PullsListReviewCommentsSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsListReviewCommentsSort from json.
func (s *PullsListReviewCommentsSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListReviewCommentsSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsListReviewCommentsSort(v) {
	case PullsListReviewCommentsSortCreated:
		*s = PullsListReviewCommentsSortCreated
	case PullsListReviewCommentsSortUpdated:
		*s = PullsListReviewCommentsSortUpdated
	default:
		*s = PullsListReviewCommentsSort(v)
	}

	return nil
}

// Encode encodes PullsListSort as json.
func (s PullsListSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsListSort from json.
func (s *PullsListSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsListSort(v) {
	case PullsListSortCreated:
		*s = PullsListSortCreated
	case PullsListSortUpdated:
		*s = PullsListSortUpdated
	case PullsListSortPopularity:
		*s = PullsListSortPopularity
	case PullsListSortLongMinusRunning:
		*s = PullsListSortLongMinusRunning
	default:
		*s = PullsListSort(v)
	}

	return nil
}

// Encode encodes PullsListState as json.
func (s PullsListState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsListState from json.
func (s *PullsListState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsListState(v) {
	case PullsListStateOpen:
		*s = PullsListStateOpen
	case PullsListStateClosed:
		*s = PullsListStateClosed
	case PullsListStateAll:
		*s = PullsListStateAll
	default:
		*s = PullsListState(v)
	}

	return nil
}

// Encode encodes PullsMergeApplicationJSONForbidden as json.
func (s PullsMergeApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsMergeApplicationJSONForbidden from json.
func (s *PullsMergeApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsMergeApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsMergeApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PullsMergeApplicationJSONNotFound as json.
func (s PullsMergeApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsMergeApplicationJSONNotFound from json.
func (s *PullsMergeApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsMergeApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsMergeApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PullsMergeConflict) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullsMergeConflict from json.
func (s *PullsMergeConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsMergeConflict to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsMergeMethodNotAllowed) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullsMergeMethodNotAllowed from json.
func (s *PullsMergeMethodNotAllowed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsMergeMethodNotAllowed to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsMergeReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CommitTitle.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommitTitle.Set {
			e.RawStr("\"commit_title\"" + ":")
			s.CommitTitle.Encode(e)
		}
	}
	{
		if s.CommitMessage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommitMessage.Set {
			e.RawStr("\"commit_message\"" + ":")
			s.CommitMessage.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.MergeMethod.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MergeMethod.Set {
			e.RawStr("\"merge_method\"" + ":")
			s.MergeMethod.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullsMergeReq from json.
func (s *PullsMergeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsMergeReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commit_title":
			s.CommitTitle.Reset()
			if err := s.CommitTitle.Decode(d); err != nil {
				return err
			}
		case "commit_message":
			s.CommitMessage.Reset()
			if err := s.CommitMessage.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "merge_method":
			s.MergeMethod.Reset()
			if err := s.MergeMethod.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullsMergeReqMergeMethod as json.
func (s PullsMergeReqMergeMethod) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsMergeReqMergeMethod from json.
func (s *PullsMergeReqMergeMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsMergeReqMergeMethod to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsMergeReqMergeMethod(v) {
	case PullsMergeReqMergeMethodMerge:
		*s = PullsMergeReqMergeMethodMerge
	case PullsMergeReqMergeMethodSquash:
		*s = PullsMergeReqMergeMethodSquash
	case PullsMergeReqMergeMethodRebase:
		*s = PullsMergeReqMergeMethodRebase
	default:
		*s = PullsMergeReqMergeMethod(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsRemoveRequestedReviewersReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"reviewers\"" + ":")
		e.ArrStart()
		if len(s.Reviewers) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Reviewers[0]
				e.Str(elem)
			}
			for _, elem := range s.Reviewers[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.TeamReviewers != nil {
			e.Comma()
		}
		if s.TeamReviewers != nil {
			e.RawStr("\"team_reviewers\"" + ":")
			e.ArrStart()
			if len(s.TeamReviewers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TeamReviewers[0]
					e.Str(elem)
				}
				for _, elem := range s.TeamReviewers[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes PullsRemoveRequestedReviewersReq from json.
func (s *PullsRemoveRequestedReviewersReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsRemoveRequestedReviewersReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reviewers":
			s.Reviewers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Reviewers = append(s.Reviewers, elem)
				return nil
			}); err != nil {
				return err
			}
		case "team_reviewers":
			s.TeamReviewers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.TeamReviewers = append(s.TeamReviewers, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullsSubmitReviewApplicationJSONForbidden as json.
func (s PullsSubmitReviewApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsSubmitReviewApplicationJSONForbidden from json.
func (s *PullsSubmitReviewApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsSubmitReviewApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsSubmitReviewApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PullsSubmitReviewApplicationJSONNotFound as json.
func (s PullsSubmitReviewApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsSubmitReviewApplicationJSONNotFound from json.
func (s *PullsSubmitReviewApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsSubmitReviewApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsSubmitReviewApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PullsSubmitReviewReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"event\"" + ":")
		s.Event.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullsSubmitReviewReq from json.
func (s *PullsSubmitReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsSubmitReviewReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "event":
			if err := s.Event.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullsSubmitReviewReqEvent as json.
func (s PullsSubmitReviewReqEvent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsSubmitReviewReqEvent from json.
func (s *PullsSubmitReviewReqEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsSubmitReviewReqEvent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsSubmitReviewReqEvent(v) {
	case PullsSubmitReviewReqEventAPPROVE:
		*s = PullsSubmitReviewReqEventAPPROVE
	case PullsSubmitReviewReqEventREQUESTCHANGES:
		*s = PullsSubmitReviewReqEventREQUESTCHANGES
	case PullsSubmitReviewReqEventCOMMENT:
		*s = PullsSubmitReviewReqEventCOMMENT
	default:
		*s = PullsSubmitReviewReqEvent(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsUpdateBranchAccepted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullsUpdateBranchAccepted from json.
func (s *PullsUpdateBranchAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsUpdateBranchAccepted to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsUpdateBranchReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ExpectedHeadSha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExpectedHeadSha.Set {
			e.RawStr("\"expected_head_sha\"" + ":")
			s.ExpectedHeadSha.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullsUpdateBranchReq from json.
func (s *PullsUpdateBranchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsUpdateBranchReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "expected_head_sha":
			s.ExpectedHeadSha.Reset()
			if err := s.ExpectedHeadSha.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsUpdateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.Base.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Base.Set {
			e.RawStr("\"base\"" + ":")
			s.Base.Encode(e)
		}
	}
	{
		if s.MaintainerCanModify.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaintainerCanModify.Set {
			e.RawStr("\"maintainer_can_modify\"" + ":")
			s.MaintainerCanModify.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PullsUpdateReq from json.
func (s *PullsUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsUpdateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "base":
			s.Base.Reset()
			if err := s.Base.Decode(d); err != nil {
				return err
			}
		case "maintainer_can_modify":
			s.MaintainerCanModify.Reset()
			if err := s.MaintainerCanModify.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullsUpdateReqState as json.
func (s PullsUpdateReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsUpdateReqState from json.
func (s *PullsUpdateReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsUpdateReqState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsUpdateReqState(v) {
	case PullsUpdateReqStateOpen:
		*s = PullsUpdateReqStateOpen
	case PullsUpdateReqStateClosed:
		*s = PullsUpdateReqStateClosed
	default:
		*s = PullsUpdateReqState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsUpdateReviewCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

// Decode decodes PullsUpdateReviewCommentReq from json.
func (s *PullsUpdateReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsUpdateReviewCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsUpdateReviewReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

// Decode decodes PullsUpdateReviewReq from json.
func (s *PullsUpdateReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsUpdateReviewReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RateLimit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"limit\"" + ":")
		e.Int(s.Limit)
	}
	{
		e.Comma()

		e.RawStr("\"remaining\"" + ":")
		e.Int(s.Remaining)
	}
	{
		e.Comma()

		e.RawStr("\"reset\"" + ":")
		e.Int(s.Reset)
	}
	{
		e.Comma()

		e.RawStr("\"used\"" + ":")
		e.Int(s.Used)
	}
	e.ObjEnd()
}

// Decode decodes RateLimit from json.
func (s *RateLimit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RateLimit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			v, err := d.Int()
			s.Limit = int(v)
			if err != nil {
				return err
			}
		case "remaining":
			v, err := d.Int()
			s.Remaining = int(v)
			if err != nil {
				return err
			}
		case "reset":
			v, err := d.Int()
			s.Reset = int(v)
			if err != nil {
				return err
			}
		case "used":
			v, err := d.Int()
			s.Used = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RateLimitOverview) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"resources\"" + ":")
		s.Resources.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"rate\"" + ":")
		s.Rate.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes RateLimitOverview from json.
func (s *RateLimitOverview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RateLimitOverview to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resources":
			if err := s.Resources.Decode(d); err != nil {
				return err
			}
		case "rate":
			if err := s.Rate.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RateLimitOverviewResources) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"core\"" + ":")
		s.Core.Encode(e)
	}
	{
		if s.Graphql.Set {
			e.Comma()
		}
		if s.Graphql.Set {
			e.RawStr("\"graphql\"" + ":")
			s.Graphql.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"search\"" + ":")
		s.Search.Encode(e)
	}
	{
		if s.SourceImport.Set {
			e.Comma()
		}
		if s.SourceImport.Set {
			e.RawStr("\"source_import\"" + ":")
			s.SourceImport.Encode(e)
		}
	}
	{
		if s.IntegrationManifest.Set {
			e.Comma()
		}
		if s.IntegrationManifest.Set {
			e.RawStr("\"integration_manifest\"" + ":")
			s.IntegrationManifest.Encode(e)
		}
	}
	{
		if s.CodeScanningUpload.Set {
			e.Comma()
		}
		if s.CodeScanningUpload.Set {
			e.RawStr("\"code_scanning_upload\"" + ":")
			s.CodeScanningUpload.Encode(e)
		}
	}
	{
		if s.ActionsRunnerRegistration.Set {
			e.Comma()
		}
		if s.ActionsRunnerRegistration.Set {
			e.RawStr("\"actions_runner_registration\"" + ":")
			s.ActionsRunnerRegistration.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes RateLimitOverviewResources from json.
func (s *RateLimitOverviewResources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RateLimitOverviewResources to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "core":
			if err := s.Core.Decode(d); err != nil {
				return err
			}
		case "graphql":
			s.Graphql.Reset()
			if err := s.Graphql.Decode(d); err != nil {
				return err
			}
		case "search":
			if err := s.Search.Decode(d); err != nil {
				return err
			}
		case "source_import":
			s.SourceImport.Reset()
			if err := s.SourceImport.Decode(d); err != nil {
				return err
			}
		case "integration_manifest":
			s.IntegrationManifest.Reset()
			if err := s.IntegrationManifest.Decode(d); err != nil {
				return err
			}
		case "code_scanning_upload":
			s.CodeScanningUpload.Reset()
			if err := s.CodeScanningUpload.Decode(d); err != nil {
				return err
			}
		case "actions_runner_registration":
			s.ActionsRunnerRegistration.Reset()
			if err := s.ActionsRunnerRegistration.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Reaction) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

// Decode decodes Reaction from json.
func (s *Reaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Reaction to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionContent as json.
func (s ReactionContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionContent from json.
func (s *ReactionContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionContent(v) {
	case ReactionContentPlus1:
		*s = ReactionContentPlus1
	case ReactionContentMinus1:
		*s = ReactionContentMinus1
	case ReactionContentLaugh:
		*s = ReactionContentLaugh
	case ReactionContentConfused:
		*s = ReactionContentConfused
	case ReactionContentHeart:
		*s = ReactionContentHeart
	case ReactionContentHooray:
		*s = ReactionContentHooray
	case ReactionContentRocket:
		*s = ReactionContentRocket
	case ReactionContentEyes:
		*s = ReactionContentEyes
	default:
		*s = ReactionContent(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReactionRollup) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"+1\"" + ":")
		e.Int(s.Plus1)
	}
	{
		e.Comma()

		e.RawStr("\"-1\"" + ":")
		e.Int(s.Minus1)
	}
	{
		e.Comma()

		e.RawStr("\"laugh\"" + ":")
		e.Int(s.Laugh)
	}
	{
		e.Comma()

		e.RawStr("\"confused\"" + ":")
		e.Int(s.Confused)
	}
	{
		e.Comma()

		e.RawStr("\"heart\"" + ":")
		e.Int(s.Heart)
	}
	{
		e.Comma()

		e.RawStr("\"hooray\"" + ":")
		e.Int(s.Hooray)
	}
	{
		e.Comma()

		e.RawStr("\"eyes\"" + ":")
		e.Int(s.Eyes)
	}
	{
		e.Comma()

		e.RawStr("\"rocket\"" + ":")
		e.Int(s.Rocket)
	}
	e.ObjEnd()
}

// Decode decodes ReactionRollup from json.
func (s *ReactionRollup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionRollup to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "+1":
			v, err := d.Int()
			s.Plus1 = int(v)
			if err != nil {
				return err
			}
		case "-1":
			v, err := d.Int()
			s.Minus1 = int(v)
			if err != nil {
				return err
			}
		case "laugh":
			v, err := d.Int()
			s.Laugh = int(v)
			if err != nil {
				return err
			}
		case "confused":
			v, err := d.Int()
			s.Confused = int(v)
			if err != nil {
				return err
			}
		case "heart":
			v, err := d.Int()
			s.Heart = int(v)
			if err != nil {
				return err
			}
		case "hooray":
			v, err := d.Int()
			s.Hooray = int(v)
			if err != nil {
				return err
			}
		case "eyes":
			v, err := d.Int()
			s.Eyes = int(v)
			if err != nil {
				return err
			}
		case "rocket":
			v, err := d.Int()
			s.Rocket = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForCommitCommentApplicationJSONCreated as json.
func (s ReactionsCreateForCommitCommentApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForCommitCommentApplicationJSONCreated from json.
func (s *ReactionsCreateForCommitCommentApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForCommitCommentApplicationJSONCreated to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForCommitCommentApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForCommitCommentApplicationJSONOK as json.
func (s ReactionsCreateForCommitCommentApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForCommitCommentApplicationJSONOK from json.
func (s *ReactionsCreateForCommitCommentApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForCommitCommentApplicationJSONOK to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForCommitCommentApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForCommitCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForCommitCommentReq from json.
func (s *ReactionsCreateForCommitCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForCommitCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForCommitCommentReqContent as json.
func (s ReactionsCreateForCommitCommentReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForCommitCommentReqContent from json.
func (s *ReactionsCreateForCommitCommentReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForCommitCommentReqContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForCommitCommentReqContent(v) {
	case ReactionsCreateForCommitCommentReqContentPlus1:
		*s = ReactionsCreateForCommitCommentReqContentPlus1
	case ReactionsCreateForCommitCommentReqContentMinus1:
		*s = ReactionsCreateForCommitCommentReqContentMinus1
	case ReactionsCreateForCommitCommentReqContentLaugh:
		*s = ReactionsCreateForCommitCommentReqContentLaugh
	case ReactionsCreateForCommitCommentReqContentConfused:
		*s = ReactionsCreateForCommitCommentReqContentConfused
	case ReactionsCreateForCommitCommentReqContentHeart:
		*s = ReactionsCreateForCommitCommentReqContentHeart
	case ReactionsCreateForCommitCommentReqContentHooray:
		*s = ReactionsCreateForCommitCommentReqContentHooray
	case ReactionsCreateForCommitCommentReqContentRocket:
		*s = ReactionsCreateForCommitCommentReqContentRocket
	case ReactionsCreateForCommitCommentReqContentEyes:
		*s = ReactionsCreateForCommitCommentReqContentEyes
	default:
		*s = ReactionsCreateForCommitCommentReqContent(v)
	}

	return nil
}

// Encode encodes ReactionsCreateForIssueApplicationJSONCreated as json.
func (s ReactionsCreateForIssueApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForIssueApplicationJSONCreated from json.
func (s *ReactionsCreateForIssueApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForIssueApplicationJSONCreated to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForIssueApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForIssueApplicationJSONOK as json.
func (s ReactionsCreateForIssueApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForIssueApplicationJSONOK from json.
func (s *ReactionsCreateForIssueApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForIssueApplicationJSONOK to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForIssueApplicationJSONOK(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForIssueCommentApplicationJSONCreated as json.
func (s ReactionsCreateForIssueCommentApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForIssueCommentApplicationJSONCreated from json.
func (s *ReactionsCreateForIssueCommentApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForIssueCommentApplicationJSONCreated to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForIssueCommentApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForIssueCommentApplicationJSONOK as json.
func (s ReactionsCreateForIssueCommentApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForIssueCommentApplicationJSONOK from json.
func (s *ReactionsCreateForIssueCommentApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForIssueCommentApplicationJSONOK to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForIssueCommentApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForIssueCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForIssueCommentReq from json.
func (s *ReactionsCreateForIssueCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForIssueCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForIssueCommentReqContent as json.
func (s ReactionsCreateForIssueCommentReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForIssueCommentReqContent from json.
func (s *ReactionsCreateForIssueCommentReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForIssueCommentReqContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForIssueCommentReqContent(v) {
	case ReactionsCreateForIssueCommentReqContentPlus1:
		*s = ReactionsCreateForIssueCommentReqContentPlus1
	case ReactionsCreateForIssueCommentReqContentMinus1:
		*s = ReactionsCreateForIssueCommentReqContentMinus1
	case ReactionsCreateForIssueCommentReqContentLaugh:
		*s = ReactionsCreateForIssueCommentReqContentLaugh
	case ReactionsCreateForIssueCommentReqContentConfused:
		*s = ReactionsCreateForIssueCommentReqContentConfused
	case ReactionsCreateForIssueCommentReqContentHeart:
		*s = ReactionsCreateForIssueCommentReqContentHeart
	case ReactionsCreateForIssueCommentReqContentHooray:
		*s = ReactionsCreateForIssueCommentReqContentHooray
	case ReactionsCreateForIssueCommentReqContentRocket:
		*s = ReactionsCreateForIssueCommentReqContentRocket
	case ReactionsCreateForIssueCommentReqContentEyes:
		*s = ReactionsCreateForIssueCommentReqContentEyes
	default:
		*s = ReactionsCreateForIssueCommentReqContent(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForIssueReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForIssueReq from json.
func (s *ReactionsCreateForIssueReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForIssueReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForIssueReqContent as json.
func (s ReactionsCreateForIssueReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForIssueReqContent from json.
func (s *ReactionsCreateForIssueReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForIssueReqContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForIssueReqContent(v) {
	case ReactionsCreateForIssueReqContentPlus1:
		*s = ReactionsCreateForIssueReqContentPlus1
	case ReactionsCreateForIssueReqContentMinus1:
		*s = ReactionsCreateForIssueReqContentMinus1
	case ReactionsCreateForIssueReqContentLaugh:
		*s = ReactionsCreateForIssueReqContentLaugh
	case ReactionsCreateForIssueReqContentConfused:
		*s = ReactionsCreateForIssueReqContentConfused
	case ReactionsCreateForIssueReqContentHeart:
		*s = ReactionsCreateForIssueReqContentHeart
	case ReactionsCreateForIssueReqContentHooray:
		*s = ReactionsCreateForIssueReqContentHooray
	case ReactionsCreateForIssueReqContentRocket:
		*s = ReactionsCreateForIssueReqContentRocket
	case ReactionsCreateForIssueReqContentEyes:
		*s = ReactionsCreateForIssueReqContentEyes
	default:
		*s = ReactionsCreateForIssueReqContent(v)
	}

	return nil
}

// Encode encodes ReactionsCreateForPullRequestReviewCommentApplicationJSONCreated as json.
func (s ReactionsCreateForPullRequestReviewCommentApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForPullRequestReviewCommentApplicationJSONCreated from json.
func (s *ReactionsCreateForPullRequestReviewCommentApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForPullRequestReviewCommentApplicationJSONCreated to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForPullRequestReviewCommentApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForPullRequestReviewCommentApplicationJSONOK as json.
func (s ReactionsCreateForPullRequestReviewCommentApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForPullRequestReviewCommentApplicationJSONOK from json.
func (s *ReactionsCreateForPullRequestReviewCommentApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForPullRequestReviewCommentApplicationJSONOK to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForPullRequestReviewCommentApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForPullRequestReviewCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForPullRequestReviewCommentReq from json.
func (s *ReactionsCreateForPullRequestReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForPullRequestReviewCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForPullRequestReviewCommentReqContent as json.
func (s ReactionsCreateForPullRequestReviewCommentReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForPullRequestReviewCommentReqContent from json.
func (s *ReactionsCreateForPullRequestReviewCommentReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForPullRequestReviewCommentReqContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForPullRequestReviewCommentReqContent(v) {
	case ReactionsCreateForPullRequestReviewCommentReqContentPlus1:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentPlus1
	case ReactionsCreateForPullRequestReviewCommentReqContentMinus1:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentMinus1
	case ReactionsCreateForPullRequestReviewCommentReqContentLaugh:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentLaugh
	case ReactionsCreateForPullRequestReviewCommentReqContentConfused:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentConfused
	case ReactionsCreateForPullRequestReviewCommentReqContentHeart:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentHeart
	case ReactionsCreateForPullRequestReviewCommentReqContentHooray:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentHooray
	case ReactionsCreateForPullRequestReviewCommentReqContentRocket:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentRocket
	case ReactionsCreateForPullRequestReviewCommentReqContentEyes:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentEyes
	default:
		*s = ReactionsCreateForPullRequestReviewCommentReqContent(v)
	}

	return nil
}

// Encode encodes ReactionsCreateForReleaseApplicationJSONCreated as json.
func (s ReactionsCreateForReleaseApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForReleaseApplicationJSONCreated from json.
func (s *ReactionsCreateForReleaseApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForReleaseApplicationJSONCreated to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForReleaseApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForReleaseApplicationJSONOK as json.
func (s ReactionsCreateForReleaseApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForReleaseApplicationJSONOK from json.
func (s *ReactionsCreateForReleaseApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForReleaseApplicationJSONOK to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForReleaseApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForReleaseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForReleaseReq from json.
func (s *ReactionsCreateForReleaseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForReleaseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForReleaseReqContent as json.
func (s ReactionsCreateForReleaseReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForReleaseReqContent from json.
func (s *ReactionsCreateForReleaseReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForReleaseReqContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForReleaseReqContent(v) {
	case ReactionsCreateForReleaseReqContentPlus1:
		*s = ReactionsCreateForReleaseReqContentPlus1
	case ReactionsCreateForReleaseReqContentLaugh:
		*s = ReactionsCreateForReleaseReqContentLaugh
	case ReactionsCreateForReleaseReqContentHeart:
		*s = ReactionsCreateForReleaseReqContentHeart
	case ReactionsCreateForReleaseReqContentHooray:
		*s = ReactionsCreateForReleaseReqContentHooray
	case ReactionsCreateForReleaseReqContentRocket:
		*s = ReactionsCreateForReleaseReqContentRocket
	case ReactionsCreateForReleaseReqContentEyes:
		*s = ReactionsCreateForReleaseReqContentEyes
	default:
		*s = ReactionsCreateForReleaseReqContent(v)
	}

	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated as json.
func (s ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK as json.
func (s ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForTeamDiscussionCommentInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgReq from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentInOrgReqContent as json.
func (s ReactionsCreateForTeamDiscussionCommentInOrgReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgReqContent from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgReqContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForTeamDiscussionCommentInOrgReqContent(v) {
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentPlus1:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentPlus1
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentMinus1:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentMinus1
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentLaugh:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentLaugh
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentConfused:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentConfused
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentHeart:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentHeart
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentHooray:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentHooray
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentRocket:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentRocket
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentEyes:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentEyes
	default:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContent(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForTeamDiscussionCommentLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentLegacyReq from json.
func (s *ReactionsCreateForTeamDiscussionCommentLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionCommentLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentLegacyReqContent as json.
func (s ReactionsCreateForTeamDiscussionCommentLegacyReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentLegacyReqContent from json.
func (s *ReactionsCreateForTeamDiscussionCommentLegacyReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionCommentLegacyReqContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForTeamDiscussionCommentLegacyReqContent(v) {
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentPlus1:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentPlus1
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentMinus1:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentMinus1
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentLaugh:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentLaugh
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentConfused:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentConfused
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentHeart:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentHeart
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentHooray:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentHooray
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentRocket:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentRocket
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentEyes:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentEyes
	default:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContent(v)
	}

	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated as json.
func (s ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated from json.
func (s *ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK as json.
func (s ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK from json.
func (s *ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForTeamDiscussionInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgReq from json.
func (s *ReactionsCreateForTeamDiscussionInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForTeamDiscussionInOrgReqContent as json.
func (s ReactionsCreateForTeamDiscussionInOrgReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgReqContent from json.
func (s *ReactionsCreateForTeamDiscussionInOrgReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgReqContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForTeamDiscussionInOrgReqContent(v) {
	case ReactionsCreateForTeamDiscussionInOrgReqContentPlus1:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentPlus1
	case ReactionsCreateForTeamDiscussionInOrgReqContentMinus1:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentMinus1
	case ReactionsCreateForTeamDiscussionInOrgReqContentLaugh:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentLaugh
	case ReactionsCreateForTeamDiscussionInOrgReqContentConfused:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentConfused
	case ReactionsCreateForTeamDiscussionInOrgReqContentHeart:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentHeart
	case ReactionsCreateForTeamDiscussionInOrgReqContentHooray:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentHooray
	case ReactionsCreateForTeamDiscussionInOrgReqContentRocket:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentRocket
	case ReactionsCreateForTeamDiscussionInOrgReqContentEyes:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentEyes
	default:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContent(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForTeamDiscussionLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForTeamDiscussionLegacyReq from json.
func (s *ReactionsCreateForTeamDiscussionLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForTeamDiscussionLegacyReqContent as json.
func (s ReactionsCreateForTeamDiscussionLegacyReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionLegacyReqContent from json.
func (s *ReactionsCreateForTeamDiscussionLegacyReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionLegacyReqContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForTeamDiscussionLegacyReqContent(v) {
	case ReactionsCreateForTeamDiscussionLegacyReqContentPlus1:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentPlus1
	case ReactionsCreateForTeamDiscussionLegacyReqContentMinus1:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentMinus1
	case ReactionsCreateForTeamDiscussionLegacyReqContentLaugh:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentLaugh
	case ReactionsCreateForTeamDiscussionLegacyReqContentConfused:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentConfused
	case ReactionsCreateForTeamDiscussionLegacyReqContentHeart:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentHeart
	case ReactionsCreateForTeamDiscussionLegacyReqContentHooray:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentHooray
	case ReactionsCreateForTeamDiscussionLegacyReqContentRocket:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentRocket
	case ReactionsCreateForTeamDiscussionLegacyReqContentEyes:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentEyes
	default:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContent(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsDeleteForCommitCommentNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReactionsDeleteForCommitCommentNoContent from json.
func (s *ReactionsDeleteForCommitCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteForCommitCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReactionsDeleteForIssueCommentNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReactionsDeleteForIssueCommentNoContent from json.
func (s *ReactionsDeleteForIssueCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteForIssueCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReactionsDeleteForIssueNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReactionsDeleteForIssueNoContent from json.
func (s *ReactionsDeleteForIssueNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteForIssueNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReactionsDeleteForPullRequestCommentNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReactionsDeleteForPullRequestCommentNoContent from json.
func (s *ReactionsDeleteForPullRequestCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteForPullRequestCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReactionsDeleteForTeamDiscussionCommentNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReactionsDeleteForTeamDiscussionCommentNoContent from json.
func (s *ReactionsDeleteForTeamDiscussionCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteForTeamDiscussionCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReactionsDeleteForTeamDiscussionNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReactionsDeleteForTeamDiscussionNoContent from json.
func (s *ReactionsDeleteForTeamDiscussionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteForTeamDiscussionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsDeleteLegacyApplicationJSONForbidden as json.
func (s ReactionsDeleteLegacyApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsDeleteLegacyApplicationJSONForbidden from json.
func (s *ReactionsDeleteLegacyApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteLegacyApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsDeleteLegacyApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReactionsDeleteLegacyApplicationJSONGone as json.
func (s ReactionsDeleteLegacyApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsDeleteLegacyApplicationJSONGone from json.
func (s *ReactionsDeleteLegacyApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteLegacyApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsDeleteLegacyApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ReactionsDeleteLegacyApplicationJSONUnauthorized as json.
func (s ReactionsDeleteLegacyApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsDeleteLegacyApplicationJSONUnauthorized from json.
func (s *ReactionsDeleteLegacyApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteLegacyApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsDeleteLegacyApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsDeleteLegacyNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReactionsDeleteLegacyNoContent from json.
func (s *ReactionsDeleteLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsListForCommitCommentContent as json.
func (s ReactionsListForCommitCommentContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForCommitCommentContent from json.
func (s *ReactionsListForCommitCommentContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForCommitCommentContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsListForCommitCommentContent(v) {
	case ReactionsListForCommitCommentContentPlus1:
		*s = ReactionsListForCommitCommentContentPlus1
	case ReactionsListForCommitCommentContentMinus1:
		*s = ReactionsListForCommitCommentContentMinus1
	case ReactionsListForCommitCommentContentLaugh:
		*s = ReactionsListForCommitCommentContentLaugh
	case ReactionsListForCommitCommentContentConfused:
		*s = ReactionsListForCommitCommentContentConfused
	case ReactionsListForCommitCommentContentHeart:
		*s = ReactionsListForCommitCommentContentHeart
	case ReactionsListForCommitCommentContentHooray:
		*s = ReactionsListForCommitCommentContentHooray
	case ReactionsListForCommitCommentContentRocket:
		*s = ReactionsListForCommitCommentContentRocket
	case ReactionsListForCommitCommentContentEyes:
		*s = ReactionsListForCommitCommentContentEyes
	default:
		*s = ReactionsListForCommitCommentContent(v)
	}

	return nil
}

// Encode encodes ReactionsListForCommitCommentOKApplicationJSON as json.
func (s ReactionsListForCommitCommentOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Reaction(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReactionsListForCommitCommentOKApplicationJSON from json.
func (s *ReactionsListForCommitCommentOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForCommitCommentOKApplicationJSON to nil`)
	}
	var unwrapped []Reaction
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Reaction
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForCommitCommentOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReactionsListForIssueApplicationJSONGone as json.
func (s ReactionsListForIssueApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsListForIssueApplicationJSONGone from json.
func (s *ReactionsListForIssueApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForIssueApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForIssueApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ReactionsListForIssueApplicationJSONNotFound as json.
func (s ReactionsListForIssueApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsListForIssueApplicationJSONNotFound from json.
func (s *ReactionsListForIssueApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForIssueApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForIssueApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReactionsListForIssueCommentContent as json.
func (s ReactionsListForIssueCommentContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForIssueCommentContent from json.
func (s *ReactionsListForIssueCommentContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForIssueCommentContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsListForIssueCommentContent(v) {
	case ReactionsListForIssueCommentContentPlus1:
		*s = ReactionsListForIssueCommentContentPlus1
	case ReactionsListForIssueCommentContentMinus1:
		*s = ReactionsListForIssueCommentContentMinus1
	case ReactionsListForIssueCommentContentLaugh:
		*s = ReactionsListForIssueCommentContentLaugh
	case ReactionsListForIssueCommentContentConfused:
		*s = ReactionsListForIssueCommentContentConfused
	case ReactionsListForIssueCommentContentHeart:
		*s = ReactionsListForIssueCommentContentHeart
	case ReactionsListForIssueCommentContentHooray:
		*s = ReactionsListForIssueCommentContentHooray
	case ReactionsListForIssueCommentContentRocket:
		*s = ReactionsListForIssueCommentContentRocket
	case ReactionsListForIssueCommentContentEyes:
		*s = ReactionsListForIssueCommentContentEyes
	default:
		*s = ReactionsListForIssueCommentContent(v)
	}

	return nil
}

// Encode encodes ReactionsListForIssueCommentOKApplicationJSON as json.
func (s ReactionsListForIssueCommentOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Reaction(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReactionsListForIssueCommentOKApplicationJSON from json.
func (s *ReactionsListForIssueCommentOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForIssueCommentOKApplicationJSON to nil`)
	}
	var unwrapped []Reaction
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Reaction
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForIssueCommentOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReactionsListForIssueContent as json.
func (s ReactionsListForIssueContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForIssueContent from json.
func (s *ReactionsListForIssueContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForIssueContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsListForIssueContent(v) {
	case ReactionsListForIssueContentPlus1:
		*s = ReactionsListForIssueContentPlus1
	case ReactionsListForIssueContentMinus1:
		*s = ReactionsListForIssueContentMinus1
	case ReactionsListForIssueContentLaugh:
		*s = ReactionsListForIssueContentLaugh
	case ReactionsListForIssueContentConfused:
		*s = ReactionsListForIssueContentConfused
	case ReactionsListForIssueContentHeart:
		*s = ReactionsListForIssueContentHeart
	case ReactionsListForIssueContentHooray:
		*s = ReactionsListForIssueContentHooray
	case ReactionsListForIssueContentRocket:
		*s = ReactionsListForIssueContentRocket
	case ReactionsListForIssueContentEyes:
		*s = ReactionsListForIssueContentEyes
	default:
		*s = ReactionsListForIssueContent(v)
	}

	return nil
}

// Encode encodes ReactionsListForIssueOKApplicationJSON as json.
func (s ReactionsListForIssueOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Reaction(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReactionsListForIssueOKApplicationJSON from json.
func (s *ReactionsListForIssueOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForIssueOKApplicationJSON to nil`)
	}
	var unwrapped []Reaction
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Reaction
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForIssueOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReactionsListForPullRequestReviewCommentContent as json.
func (s ReactionsListForPullRequestReviewCommentContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForPullRequestReviewCommentContent from json.
func (s *ReactionsListForPullRequestReviewCommentContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForPullRequestReviewCommentContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsListForPullRequestReviewCommentContent(v) {
	case ReactionsListForPullRequestReviewCommentContentPlus1:
		*s = ReactionsListForPullRequestReviewCommentContentPlus1
	case ReactionsListForPullRequestReviewCommentContentMinus1:
		*s = ReactionsListForPullRequestReviewCommentContentMinus1
	case ReactionsListForPullRequestReviewCommentContentLaugh:
		*s = ReactionsListForPullRequestReviewCommentContentLaugh
	case ReactionsListForPullRequestReviewCommentContentConfused:
		*s = ReactionsListForPullRequestReviewCommentContentConfused
	case ReactionsListForPullRequestReviewCommentContentHeart:
		*s = ReactionsListForPullRequestReviewCommentContentHeart
	case ReactionsListForPullRequestReviewCommentContentHooray:
		*s = ReactionsListForPullRequestReviewCommentContentHooray
	case ReactionsListForPullRequestReviewCommentContentRocket:
		*s = ReactionsListForPullRequestReviewCommentContentRocket
	case ReactionsListForPullRequestReviewCommentContentEyes:
		*s = ReactionsListForPullRequestReviewCommentContentEyes
	default:
		*s = ReactionsListForPullRequestReviewCommentContent(v)
	}

	return nil
}

// Encode encodes ReactionsListForPullRequestReviewCommentOKApplicationJSON as json.
func (s ReactionsListForPullRequestReviewCommentOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Reaction(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReactionsListForPullRequestReviewCommentOKApplicationJSON from json.
func (s *ReactionsListForPullRequestReviewCommentOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForPullRequestReviewCommentOKApplicationJSON to nil`)
	}
	var unwrapped []Reaction
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Reaction
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForPullRequestReviewCommentOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReactionsListForTeamDiscussionCommentInOrgContent as json.
func (s ReactionsListForTeamDiscussionCommentInOrgContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForTeamDiscussionCommentInOrgContent from json.
func (s *ReactionsListForTeamDiscussionCommentInOrgContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForTeamDiscussionCommentInOrgContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsListForTeamDiscussionCommentInOrgContent(v) {
	case ReactionsListForTeamDiscussionCommentInOrgContentPlus1:
		*s = ReactionsListForTeamDiscussionCommentInOrgContentPlus1
	case ReactionsListForTeamDiscussionCommentInOrgContentMinus1:
		*s = ReactionsListForTeamDiscussionCommentInOrgContentMinus1
	case ReactionsListForTeamDiscussionCommentInOrgContentLaugh:
		*s = ReactionsListForTeamDiscussionCommentInOrgContentLaugh
	case ReactionsListForTeamDiscussionCommentInOrgContentConfused:
		*s = ReactionsListForTeamDiscussionCommentInOrgContentConfused
	case ReactionsListForTeamDiscussionCommentInOrgContentHeart:
		*s = ReactionsListForTeamDiscussionCommentInOrgContentHeart
	case ReactionsListForTeamDiscussionCommentInOrgContentHooray:
		*s = ReactionsListForTeamDiscussionCommentInOrgContentHooray
	case ReactionsListForTeamDiscussionCommentInOrgContentRocket:
		*s = ReactionsListForTeamDiscussionCommentInOrgContentRocket
	case ReactionsListForTeamDiscussionCommentInOrgContentEyes:
		*s = ReactionsListForTeamDiscussionCommentInOrgContentEyes
	default:
		*s = ReactionsListForTeamDiscussionCommentInOrgContent(v)
	}

	return nil
}

// Encode encodes ReactionsListForTeamDiscussionCommentLegacyContent as json.
func (s ReactionsListForTeamDiscussionCommentLegacyContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForTeamDiscussionCommentLegacyContent from json.
func (s *ReactionsListForTeamDiscussionCommentLegacyContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForTeamDiscussionCommentLegacyContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsListForTeamDiscussionCommentLegacyContent(v) {
	case ReactionsListForTeamDiscussionCommentLegacyContentPlus1:
		*s = ReactionsListForTeamDiscussionCommentLegacyContentPlus1
	case ReactionsListForTeamDiscussionCommentLegacyContentMinus1:
		*s = ReactionsListForTeamDiscussionCommentLegacyContentMinus1
	case ReactionsListForTeamDiscussionCommentLegacyContentLaugh:
		*s = ReactionsListForTeamDiscussionCommentLegacyContentLaugh
	case ReactionsListForTeamDiscussionCommentLegacyContentConfused:
		*s = ReactionsListForTeamDiscussionCommentLegacyContentConfused
	case ReactionsListForTeamDiscussionCommentLegacyContentHeart:
		*s = ReactionsListForTeamDiscussionCommentLegacyContentHeart
	case ReactionsListForTeamDiscussionCommentLegacyContentHooray:
		*s = ReactionsListForTeamDiscussionCommentLegacyContentHooray
	case ReactionsListForTeamDiscussionCommentLegacyContentRocket:
		*s = ReactionsListForTeamDiscussionCommentLegacyContentRocket
	case ReactionsListForTeamDiscussionCommentLegacyContentEyes:
		*s = ReactionsListForTeamDiscussionCommentLegacyContentEyes
	default:
		*s = ReactionsListForTeamDiscussionCommentLegacyContent(v)
	}

	return nil
}

// Encode encodes ReactionsListForTeamDiscussionInOrgContent as json.
func (s ReactionsListForTeamDiscussionInOrgContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForTeamDiscussionInOrgContent from json.
func (s *ReactionsListForTeamDiscussionInOrgContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForTeamDiscussionInOrgContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsListForTeamDiscussionInOrgContent(v) {
	case ReactionsListForTeamDiscussionInOrgContentPlus1:
		*s = ReactionsListForTeamDiscussionInOrgContentPlus1
	case ReactionsListForTeamDiscussionInOrgContentMinus1:
		*s = ReactionsListForTeamDiscussionInOrgContentMinus1
	case ReactionsListForTeamDiscussionInOrgContentLaugh:
		*s = ReactionsListForTeamDiscussionInOrgContentLaugh
	case ReactionsListForTeamDiscussionInOrgContentConfused:
		*s = ReactionsListForTeamDiscussionInOrgContentConfused
	case ReactionsListForTeamDiscussionInOrgContentHeart:
		*s = ReactionsListForTeamDiscussionInOrgContentHeart
	case ReactionsListForTeamDiscussionInOrgContentHooray:
		*s = ReactionsListForTeamDiscussionInOrgContentHooray
	case ReactionsListForTeamDiscussionInOrgContentRocket:
		*s = ReactionsListForTeamDiscussionInOrgContentRocket
	case ReactionsListForTeamDiscussionInOrgContentEyes:
		*s = ReactionsListForTeamDiscussionInOrgContentEyes
	default:
		*s = ReactionsListForTeamDiscussionInOrgContent(v)
	}

	return nil
}

// Encode encodes ReactionsListForTeamDiscussionLegacyContent as json.
func (s ReactionsListForTeamDiscussionLegacyContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForTeamDiscussionLegacyContent from json.
func (s *ReactionsListForTeamDiscussionLegacyContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForTeamDiscussionLegacyContent to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsListForTeamDiscussionLegacyContent(v) {
	case ReactionsListForTeamDiscussionLegacyContentPlus1:
		*s = ReactionsListForTeamDiscussionLegacyContentPlus1
	case ReactionsListForTeamDiscussionLegacyContentMinus1:
		*s = ReactionsListForTeamDiscussionLegacyContentMinus1
	case ReactionsListForTeamDiscussionLegacyContentLaugh:
		*s = ReactionsListForTeamDiscussionLegacyContentLaugh
	case ReactionsListForTeamDiscussionLegacyContentConfused:
		*s = ReactionsListForTeamDiscussionLegacyContentConfused
	case ReactionsListForTeamDiscussionLegacyContentHeart:
		*s = ReactionsListForTeamDiscussionLegacyContentHeart
	case ReactionsListForTeamDiscussionLegacyContentHooray:
		*s = ReactionsListForTeamDiscussionLegacyContentHooray
	case ReactionsListForTeamDiscussionLegacyContentRocket:
		*s = ReactionsListForTeamDiscussionLegacyContentRocket
	case ReactionsListForTeamDiscussionLegacyContentEyes:
		*s = ReactionsListForTeamDiscussionLegacyContentEyes
	default:
		*s = ReactionsListForTeamDiscussionLegacyContent(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReferrerTraffic) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"referrer\"" + ":")
		e.Str(s.Referrer)
	}
	{
		e.Comma()

		e.RawStr("\"count\"" + ":")
		e.Int(s.Count)
	}
	{
		e.Comma()

		e.RawStr("\"uniques\"" + ":")
		e.Int(s.Uniques)
	}
	e.ObjEnd()
}

// Decode decodes ReferrerTraffic from json.
func (s *ReferrerTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReferrerTraffic to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referrer":
			v, err := d.Str()
			s.Referrer = string(v)
			if err != nil {
				return err
			}
		case "count":
			v, err := d.Int()
			s.Count = int(v)
			if err != nil {
				return err
			}
		case "uniques":
			v, err := d.Int()
			s.Uniques = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Release) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"assets_url\"" + ":")
		json.EncodeURI(e, s.AssetsURL)
	}
	{
		e.Comma()

		e.RawStr("\"upload_url\"" + ":")
		e.Str(s.UploadURL)
	}
	{
		e.Comma()

		e.RawStr("\"tarball_url\"" + ":")
		s.TarballURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"zipball_url\"" + ":")
		s.ZipballURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"tag_name\"" + ":")
		e.Str(s.TagName)
	}
	{
		e.Comma()

		e.RawStr("\"target_commitish\"" + ":")
		e.Str(s.TargetCommitish)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		s.Name.Encode(e)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"draft\"" + ":")
		e.Bool(s.Draft)
	}
	{
		e.Comma()

		e.RawStr("\"prerelease\"" + ":")
		e.Bool(s.Prerelease)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"published_at\"" + ":")
		s.PublishedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"assets\"" + ":")
		e.ArrStart()
		if len(s.Assets) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Assets[0]
				elem.Encode(e)
			}
			for _, elem := range s.Assets[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.MentionsCount.Set {
			e.Comma()
		}
		if s.MentionsCount.Set {
			e.RawStr("\"mentions_count\"" + ":")
			s.MentionsCount.Encode(e)
		}
	}
	{
		if s.DiscussionURL.Set {
			e.Comma()
		}
		if s.DiscussionURL.Set {
			e.RawStr("\"discussion_url\"" + ":")
			s.DiscussionURL.Encode(e)
		}
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes Release from json.
func (s *Release) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Release to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "assets_url":
			v, err := json.DecodeURI(d)
			s.AssetsURL = v
			if err != nil {
				return err
			}
		case "upload_url":
			v, err := d.Str()
			s.UploadURL = string(v)
			if err != nil {
				return err
			}
		case "tarball_url":
			if err := s.TarballURL.Decode(d); err != nil {
				return err
			}
		case "zipball_url":
			if err := s.ZipballURL.Decode(d); err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "tag_name":
			v, err := d.Str()
			s.TagName = string(v)
			if err != nil {
				return err
			}
		case "target_commitish":
			v, err := d.Str()
			s.TargetCommitish = string(v)
			if err != nil {
				return err
			}
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "draft":
			v, err := d.Bool()
			s.Draft = bool(v)
			if err != nil {
				return err
			}
		case "prerelease":
			v, err := d.Bool()
			s.Prerelease = bool(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "published_at":
			if err := s.PublishedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "assets":
			s.Assets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ReleaseAsset
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Assets = append(s.Assets, elem)
				return nil
			}); err != nil {
				return err
			}
		case "body_html":
			s.BodyHTML.Reset()
			if err := s.BodyHTML.Decode(d); err != nil {
				return err
			}
		case "body_text":
			s.BodyText.Reset()
			if err := s.BodyText.Decode(d); err != nil {
				return err
			}
		case "mentions_count":
			s.MentionsCount.Reset()
			if err := s.MentionsCount.Decode(d); err != nil {
				return err
			}
		case "discussion_url":
			s.DiscussionURL.Reset()
			if err := s.DiscussionURL.Decode(d); err != nil {
				return err
			}
		case "reactions":
			s.Reactions.Reset()
			if err := s.Reactions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReleaseAsset) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"browser_download_url\"" + ":")
		json.EncodeURI(e, s.BrowserDownloadURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"label\"" + ":")
		s.Label.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"content_type\"" + ":")
		e.Str(s.ContentType)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"download_count\"" + ":")
		e.Int(s.DownloadCount)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"uploader\"" + ":")
		s.Uploader.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReleaseAsset from json.
func (s *ReleaseAsset) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReleaseAsset to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "browser_download_url":
			v, err := json.DecodeURI(d)
			s.BrowserDownloadURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "label":
			if err := s.Label.Decode(d); err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "content_type":
			v, err := d.Str()
			s.ContentType = string(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "download_count":
			v, err := d.Int()
			s.DownloadCount = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "uploader":
			if err := s.Uploader.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReleaseAssetState as json.
func (s ReleaseAssetState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReleaseAssetState from json.
func (s *ReleaseAssetState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReleaseAssetState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReleaseAssetState(v) {
	case ReleaseAssetStateUploaded:
		*s = ReleaseAssetStateUploaded
	case ReleaseAssetStateOpen:
		*s = ReleaseAssetStateOpen
	default:
		*s = ReleaseAssetState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RepoSearchResultItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"pushed_at\"" + ":")
		json.EncodeDateTime(e, s.PushedAt)
	}
	{
		e.Comma()

		e.RawStr("\"homepage\"" + ":")
		s.Homepage.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_count\"" + ":")
		e.Int(s.StargazersCount)
	}
	{
		e.Comma()

		e.RawStr("\"watchers_count\"" + ":")
		e.Int(s.WatchersCount)
	}
	{
		e.Comma()

		e.RawStr("\"language\"" + ":")
		s.Language.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"forks_count\"" + ":")
		e.Int(s.ForksCount)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues_count\"" + ":")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.MasterBranch.Set {
			e.Comma()
		}
		if s.MasterBranch.Set {
			e.RawStr("\"master_branch\"" + ":")
			s.MasterBranch.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"default_branch\"" + ":")
		e.Str(s.DefaultBranch)
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Float64(s.Score)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		e.Str(s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"ssh_url\"" + ":")
		e.Str(s.SSHURL)
	}
	{
		e.Comma()

		e.RawStr("\"clone_url\"" + ":")
		e.Str(s.CloneURL)
	}
	{
		e.Comma()

		e.RawStr("\"svn_url\"" + ":")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		e.Comma()

		e.RawStr("\"forks\"" + ":")
		e.Int(s.Forks)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"watchers\"" + ":")
		e.Int(s.Watchers)
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"mirror_url\"" + ":")
		s.MirrorURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"has_issues\"" + ":")
		e.Bool(s.HasIssues)
	}
	{
		e.Comma()

		e.RawStr("\"has_projects\"" + ":")
		e.Bool(s.HasProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_pages\"" + ":")
		e.Bool(s.HasPages)
	}
	{
		e.Comma()

		e.RawStr("\"has_wiki\"" + ":")
		e.Bool(s.HasWiki)
	}
	{
		e.Comma()

		e.RawStr("\"has_downloads\"" + ":")
		e.Bool(s.HasDownloads)
	}
	{
		e.Comma()

		e.RawStr("\"archived\"" + ":")
		e.Bool(s.Archived)
	}
	{
		e.Comma()

		e.RawStr("\"disabled\"" + ":")
		e.Bool(s.Disabled)
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.TextMatches != nil {
			e.Comma()
		}
		if s.TextMatches != nil {
			e.RawStr("\"text_matches\"" + ":")
			s.TextMatches.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.Comma()
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes RepoSearchResultItem from json.
func (s *RepoSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepoSearchResultItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "pushed_at":
			v, err := json.DecodeDateTime(d)
			s.PushedAt = v
			if err != nil {
				return err
			}
		case "homepage":
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "stargazers_count":
			v, err := d.Int()
			s.StargazersCount = int(v)
			if err != nil {
				return err
			}
		case "watchers_count":
			v, err := d.Int()
			s.WatchersCount = int(v)
			if err != nil {
				return err
			}
		case "language":
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			v, err := d.Int()
			s.ForksCount = int(v)
			if err != nil {
				return err
			}
		case "open_issues_count":
			v, err := d.Int()
			s.OpenIssuesCount = int(v)
			if err != nil {
				return err
			}
		case "master_branch":
			s.MasterBranch.Reset()
			if err := s.MasterBranch.Decode(d); err != nil {
				return err
			}
		case "default_branch":
			v, err := d.Str()
			s.DefaultBranch = string(v)
			if err != nil {
				return err
			}
		case "score":
			v, err := d.Float64()
			s.Score = float64(v)
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "git_url":
			v, err := d.Str()
			s.GitURL = string(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			v, err := d.Str()
			s.SSHURL = string(v)
			if err != nil {
				return err
			}
		case "clone_url":
			v, err := d.Str()
			s.CloneURL = string(v)
			if err != nil {
				return err
			}
		case "svn_url":
			v, err := json.DecodeURI(d)
			s.SvnURL = v
			if err != nil {
				return err
			}
		case "forks":
			v, err := d.Int()
			s.Forks = int(v)
			if err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "watchers":
			v, err := d.Int()
			s.Watchers = int(v)
			if err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "mirror_url":
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "has_issues":
			v, err := d.Bool()
			s.HasIssues = bool(v)
			if err != nil {
				return err
			}
		case "has_projects":
			v, err := d.Bool()
			s.HasProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_pages":
			v, err := d.Bool()
			s.HasPages = bool(v)
			if err != nil {
				return err
			}
		case "has_wiki":
			v, err := d.Bool()
			s.HasWiki = bool(v)
			if err != nil {
				return err
			}
		case "has_downloads":
			v, err := d.Bool()
			s.HasDownloads = bool(v)
			if err != nil {
				return err
			}
		case "archived":
			v, err := d.Bool()
			s.Archived = bool(v)
			if err != nil {
				return err
			}
		case "disabled":
			v, err := d.Bool()
			s.Disabled = bool(v)
			if err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "text_matches":
			s.TextMatches = nil
			var elem SearchResultTextMatches
			{
				var unwrapped []SearchResultTextMatchesItem
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = SearchResultTextMatches(unwrapped)
			}
			s.TextMatches = &elem
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RepoSearchResultItemPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	e.ObjEnd()
}

// Decode decodes RepoSearchResultItemPermissions from json.
func (s *RepoSearchResultItemPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepoSearchResultItemPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposAcceptInvitationApplicationJSONConflict as json.
func (s ReposAcceptInvitationApplicationJSONConflict) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposAcceptInvitationApplicationJSONConflict from json.
func (s *ReposAcceptInvitationApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAcceptInvitationApplicationJSONConflict to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAcceptInvitationApplicationJSONConflict(unwrapped)
	return nil
}

// Encode encodes ReposAcceptInvitationApplicationJSONForbidden as json.
func (s ReposAcceptInvitationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposAcceptInvitationApplicationJSONForbidden from json.
func (s *ReposAcceptInvitationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAcceptInvitationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAcceptInvitationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposAcceptInvitationApplicationJSONNotFound as json.
func (s ReposAcceptInvitationApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposAcceptInvitationApplicationJSONNotFound from json.
func (s *ReposAcceptInvitationApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAcceptInvitationApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAcceptInvitationApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposAcceptInvitationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposAcceptInvitationNoContent from json.
func (s *ReposAcceptInvitationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAcceptInvitationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposAddAppAccessRestrictionsOKApplicationJSON as json.
func (s ReposAddAppAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Integration(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposAddAppAccessRestrictionsOKApplicationJSON from json.
func (s *ReposAddAppAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddAppAccessRestrictionsOKApplicationJSON to nil`)
	}
	var unwrapped []Integration
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Integration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddAppAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposAddAppAccessRestrictionsReq as json.
func (s ReposAddAppAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposAddAppAccessRestrictionsReq0ReposAddAppAccessRestrictionsReq:
		s.ReposAddAppAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposAddAppAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposAddAppAccessRestrictionsReq from json.
func (s *ReposAddAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddAppAccessRestrictionsReq to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposAddAppAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposAddAppAccessRestrictionsReq0ReposAddAppAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposAddAppAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposAddAppAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"apps\"" + ":")
		e.ArrStart()
		if len(s.Apps) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Apps[0]
				e.Str(elem)
			}
			for _, elem := range s.Apps[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposAddAppAccessRestrictionsReq0 from json.
func (s *ReposAddAppAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddAppAccessRestrictionsReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apps":
			s.Apps = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Apps = append(s.Apps, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposAddCollaboratorNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposAddCollaboratorNoContent from json.
func (s *ReposAddCollaboratorNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddCollaboratorNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposAddCollaboratorReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	{
		if s.Permissions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposAddCollaboratorReq from json.
func (s *ReposAddCollaboratorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddCollaboratorReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposAddCollaboratorReqPermission as json.
func (s ReposAddCollaboratorReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposAddCollaboratorReqPermission from json.
func (s *ReposAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddCollaboratorReqPermission to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposAddCollaboratorReqPermission(v) {
	case ReposAddCollaboratorReqPermissionPull:
		*s = ReposAddCollaboratorReqPermissionPull
	case ReposAddCollaboratorReqPermissionPush:
		*s = ReposAddCollaboratorReqPermissionPush
	case ReposAddCollaboratorReqPermissionAdmin:
		*s = ReposAddCollaboratorReqPermissionAdmin
	case ReposAddCollaboratorReqPermissionMaintain:
		*s = ReposAddCollaboratorReqPermissionMaintain
	case ReposAddCollaboratorReqPermissionTriage:
		*s = ReposAddCollaboratorReqPermissionTriage
	default:
		*s = ReposAddCollaboratorReqPermission(v)
	}

	return nil
}

// Encode encodes ReposAddStatusCheckContextsApplicationJSONForbidden as json.
func (s ReposAddStatusCheckContextsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposAddStatusCheckContextsApplicationJSONForbidden from json.
func (s *ReposAddStatusCheckContextsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddStatusCheckContextsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddStatusCheckContextsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposAddStatusCheckContextsApplicationJSONNotFound as json.
func (s ReposAddStatusCheckContextsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposAddStatusCheckContextsApplicationJSONNotFound from json.
func (s *ReposAddStatusCheckContextsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddStatusCheckContextsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddStatusCheckContextsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposAddStatusCheckContextsOKApplicationJSON as json.
func (s ReposAddStatusCheckContextsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []string(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			e.Str(elem)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			e.Str(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposAddStatusCheckContextsOKApplicationJSON from json.
func (s *ReposAddStatusCheckContextsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddStatusCheckContextsOKApplicationJSON to nil`)
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddStatusCheckContextsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposAddStatusCheckContextsReq as json.
func (s ReposAddStatusCheckContextsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposAddStatusCheckContextsReq0ReposAddStatusCheckContextsReq:
		s.ReposAddStatusCheckContextsReq0.Encode(e)
	case ArrayStringReposAddStatusCheckContextsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposAddStatusCheckContextsReq from json.
func (s *ReposAddStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddStatusCheckContextsReq to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposAddStatusCheckContextsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposAddStatusCheckContextsReq0ReposAddStatusCheckContextsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposAddStatusCheckContextsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposAddStatusCheckContextsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"contexts\"" + ":")
		e.ArrStart()
		if len(s.Contexts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Contexts[0]
				e.Str(elem)
			}
			for _, elem := range s.Contexts[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposAddStatusCheckContextsReq0 from json.
func (s *ReposAddStatusCheckContextsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddStatusCheckContextsReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contexts":
			s.Contexts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Contexts = append(s.Contexts, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposAddTeamAccessRestrictionsOKApplicationJSON as json.
func (s ReposAddTeamAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Team(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposAddTeamAccessRestrictionsOKApplicationJSON from json.
func (s *ReposAddTeamAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddTeamAccessRestrictionsOKApplicationJSON to nil`)
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddTeamAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposAddTeamAccessRestrictionsReq as json.
func (s ReposAddTeamAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposAddTeamAccessRestrictionsReq0ReposAddTeamAccessRestrictionsReq:
		s.ReposAddTeamAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposAddTeamAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposAddTeamAccessRestrictionsReq from json.
func (s *ReposAddTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddTeamAccessRestrictionsReq to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposAddTeamAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposAddTeamAccessRestrictionsReq0ReposAddTeamAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposAddTeamAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposAddTeamAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"teams\"" + ":")
		e.ArrStart()
		if len(s.Teams) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Teams[0]
				e.Str(elem)
			}
			for _, elem := range s.Teams[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposAddTeamAccessRestrictionsReq0 from json.
func (s *ReposAddTeamAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddTeamAccessRestrictionsReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposAddUserAccessRestrictionsOKApplicationJSON as json.
func (s ReposAddUserAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposAddUserAccessRestrictionsOKApplicationJSON from json.
func (s *ReposAddUserAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddUserAccessRestrictionsOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddUserAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposAddUserAccessRestrictionsReq as json.
func (s ReposAddUserAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposAddUserAccessRestrictionsReq0ReposAddUserAccessRestrictionsReq:
		s.ReposAddUserAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposAddUserAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposAddUserAccessRestrictionsReq from json.
func (s *ReposAddUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddUserAccessRestrictionsReq to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposAddUserAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposAddUserAccessRestrictionsReq0ReposAddUserAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposAddUserAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposAddUserAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"users\"" + ":")
		e.ArrStart()
		if len(s.Users) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Users[0]
				e.Str(elem)
			}
			for _, elem := range s.Users[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposAddUserAccessRestrictionsReq0 from json.
func (s *ReposAddUserAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddUserAccessRestrictionsReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCheckCollaboratorNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposCheckCollaboratorNoContent from json.
func (s *ReposCheckCollaboratorNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCheckCollaboratorNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCheckCollaboratorNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposCheckCollaboratorNotFound from json.
func (s *ReposCheckCollaboratorNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCheckCollaboratorNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCheckVulnerabilityAlertsNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposCheckVulnerabilityAlertsNoContent from json.
func (s *ReposCheckVulnerabilityAlertsNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCheckVulnerabilityAlertsNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCheckVulnerabilityAlertsNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposCheckVulnerabilityAlertsNotFound from json.
func (s *ReposCheckVulnerabilityAlertsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCheckVulnerabilityAlertsNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposCompareCommitsApplicationJSONInternalServerError as json.
func (s ReposCompareCommitsApplicationJSONInternalServerError) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCompareCommitsApplicationJSONInternalServerError from json.
func (s *ReposCompareCommitsApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCompareCommitsApplicationJSONInternalServerError to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCompareCommitsApplicationJSONInternalServerError(unwrapped)
	return nil
}

// Encode encodes ReposCompareCommitsApplicationJSONNotFound as json.
func (s ReposCompareCommitsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCompareCommitsApplicationJSONNotFound from json.
func (s *ReposCompareCommitsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCompareCommitsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCompareCommitsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateAutolinkReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key_prefix\"" + ":")
		e.Str(s.KeyPrefix)
	}
	{
		e.Comma()

		e.RawStr("\"url_template\"" + ":")
		e.Str(s.URLTemplate)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateAutolinkReq from json.
func (s *ReposCreateAutolinkReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateAutolinkReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key_prefix":
			v, err := d.Str()
			s.KeyPrefix = string(v)
			if err != nil {
				return err
			}
		case "url_template":
			v, err := d.Str()
			s.URLTemplate = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateCommitCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Position.Set {
			e.Comma()
		}
		if s.Position.Set {
			e.RawStr("\"position\"" + ":")
			s.Position.Encode(e)
		}
	}
	{
		if s.Line.Set {
			e.Comma()
		}
		if s.Line.Set {
			e.RawStr("\"line\"" + ":")
			s.Line.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateCommitCommentReq from json.
func (s *ReposCreateCommitCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateCommitCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "position":
			s.Position.Reset()
			if err := s.Position.Decode(d); err != nil {
				return err
			}
		case "line":
			s.Line.Reset()
			if err := s.Line.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateCommitStatusReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		if s.TargetURL.Set {
			e.Comma()
		}
		if s.TargetURL.Set {
			e.RawStr("\"target_url\"" + ":")
			s.TargetURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Context.Set {
			e.Comma()
		}
		if s.Context.Set {
			e.RawStr("\"context\"" + ":")
			s.Context.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateCommitStatusReq from json.
func (s *ReposCreateCommitStatusReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateCommitStatusReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "target_url":
			s.TargetURL.Reset()
			if err := s.TargetURL.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "context":
			s.Context.Reset()
			if err := s.Context.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposCreateCommitStatusReqState as json.
func (s ReposCreateCommitStatusReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposCreateCommitStatusReqState from json.
func (s *ReposCreateCommitStatusReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateCommitStatusReqState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposCreateCommitStatusReqState(v) {
	case ReposCreateCommitStatusReqStateError:
		*s = ReposCreateCommitStatusReqStateError
	case ReposCreateCommitStatusReqStateFailure:
		*s = ReposCreateCommitStatusReqStateFailure
	case ReposCreateCommitStatusReqStatePending:
		*s = ReposCreateCommitStatusReqStatePending
	case ReposCreateCommitStatusReqStateSuccess:
		*s = ReposCreateCommitStatusReqStateSuccess
	default:
		*s = ReposCreateCommitStatusReqState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateDeployKeyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"read_only\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateDeployKeyReq from json.
func (s *ReposCreateDeployKeyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDeployKeyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "read_only":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateDeploymentAccepted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateDeploymentAccepted from json.
func (s *ReposCreateDeploymentAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDeploymentAccepted to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateDeploymentConflict) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposCreateDeploymentConflict from json.
func (s *ReposCreateDeploymentConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDeploymentConflict to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateDeploymentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		if s.Task.Set {
			e.Comma()
		}
		if s.Task.Set {
			e.RawStr("\"task\"" + ":")
			s.Task.Encode(e)
		}
	}
	{
		if s.AutoMerge.Set {
			e.Comma()
		}
		if s.AutoMerge.Set {
			e.RawStr("\"auto_merge\"" + ":")
			s.AutoMerge.Encode(e)
		}
	}
	{
		if s.RequiredContexts != nil {
			e.Comma()
		}
		if s.RequiredContexts != nil {
			e.RawStr("\"required_contexts\"" + ":")
			e.ArrStart()
			if len(s.RequiredContexts) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RequiredContexts[0]
					e.Str(elem)
				}
				for _, elem := range s.RequiredContexts[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Payload.Set {
			e.Comma()
		}
		if s.Payload.Set {
			e.RawStr("\"payload\"" + ":")
			s.Payload.Encode(e)
		}
	}
	{
		if s.Environment.Set {
			e.Comma()
		}
		if s.Environment.Set {
			e.RawStr("\"environment\"" + ":")
			s.Environment.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.TransientEnvironment.Set {
			e.Comma()
		}
		if s.TransientEnvironment.Set {
			e.RawStr("\"transient_environment\"" + ":")
			s.TransientEnvironment.Encode(e)
		}
	}
	{
		if s.ProductionEnvironment.Set {
			e.Comma()
		}
		if s.ProductionEnvironment.Set {
			e.RawStr("\"production_environment\"" + ":")
			s.ProductionEnvironment.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateDeploymentReq from json.
func (s *ReposCreateDeploymentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDeploymentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "task":
			s.Task.Reset()
			if err := s.Task.Decode(d); err != nil {
				return err
			}
		case "auto_merge":
			s.AutoMerge.Reset()
			if err := s.AutoMerge.Decode(d); err != nil {
				return err
			}
		case "required_contexts":
			s.RequiredContexts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.RequiredContexts = append(s.RequiredContexts, elem)
				return nil
			}); err != nil {
				return err
			}
		case "payload":
			s.Payload.Reset()
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		case "environment":
			s.Environment.Reset()
			if err := s.Environment.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "transient_environment":
			s.TransientEnvironment.Reset()
			if err := s.TransientEnvironment.Decode(d); err != nil {
				return err
			}
		case "production_environment":
			s.ProductionEnvironment.Reset()
			if err := s.ProductionEnvironment.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposCreateDeploymentReqPayload as json.
func (s ReposCreateDeploymentReqPayload) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposCreateDeploymentReqPayload0ReposCreateDeploymentReqPayload:
		s.ReposCreateDeploymentReqPayload0.Encode(e)
	case StringReposCreateDeploymentReqPayload:
		e.Str(s.String)
	}
}

// Decode decodes ReposCreateDeploymentReqPayload from json.
func (s *ReposCreateDeploymentReqPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDeploymentReqPayload to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposCreateDeploymentReqPayload0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposCreateDeploymentReqPayload0ReposCreateDeploymentReqPayload
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringReposCreateDeploymentReqPayload
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateDeploymentReqPayload0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposCreateDeploymentReqPayload0 from json.
func (s *ReposCreateDeploymentReqPayload0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDeploymentReqPayload0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateDeploymentStatusReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		if s.TargetURL.Set {
			e.Comma()
		}
		if s.TargetURL.Set {
			e.RawStr("\"target_url\"" + ":")
			s.TargetURL.Encode(e)
		}
	}
	{
		if s.LogURL.Set {
			e.Comma()
		}
		if s.LogURL.Set {
			e.RawStr("\"log_url\"" + ":")
			s.LogURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Environment.Set {
			e.Comma()
		}
		if s.Environment.Set {
			e.RawStr("\"environment\"" + ":")
			s.Environment.Encode(e)
		}
	}
	{
		if s.EnvironmentURL.Set {
			e.Comma()
		}
		if s.EnvironmentURL.Set {
			e.RawStr("\"environment_url\"" + ":")
			s.EnvironmentURL.Encode(e)
		}
	}
	{
		if s.AutoInactive.Set {
			e.Comma()
		}
		if s.AutoInactive.Set {
			e.RawStr("\"auto_inactive\"" + ":")
			s.AutoInactive.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateDeploymentStatusReq from json.
func (s *ReposCreateDeploymentStatusReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDeploymentStatusReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "target_url":
			s.TargetURL.Reset()
			if err := s.TargetURL.Decode(d); err != nil {
				return err
			}
		case "log_url":
			s.LogURL.Reset()
			if err := s.LogURL.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "environment":
			s.Environment.Reset()
			if err := s.Environment.Decode(d); err != nil {
				return err
			}
		case "environment_url":
			s.EnvironmentURL.Reset()
			if err := s.EnvironmentURL.Decode(d); err != nil {
				return err
			}
		case "auto_inactive":
			s.AutoInactive.Reset()
			if err := s.AutoInactive.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposCreateDeploymentStatusReqEnvironment as json.
func (s ReposCreateDeploymentStatusReqEnvironment) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposCreateDeploymentStatusReqEnvironment from json.
func (s *ReposCreateDeploymentStatusReqEnvironment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDeploymentStatusReqEnvironment to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposCreateDeploymentStatusReqEnvironment(v) {
	case ReposCreateDeploymentStatusReqEnvironmentProduction:
		*s = ReposCreateDeploymentStatusReqEnvironmentProduction
	case ReposCreateDeploymentStatusReqEnvironmentStaging:
		*s = ReposCreateDeploymentStatusReqEnvironmentStaging
	case ReposCreateDeploymentStatusReqEnvironmentQa:
		*s = ReposCreateDeploymentStatusReqEnvironmentQa
	default:
		*s = ReposCreateDeploymentStatusReqEnvironment(v)
	}

	return nil
}

// Encode encodes ReposCreateDeploymentStatusReqState as json.
func (s ReposCreateDeploymentStatusReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposCreateDeploymentStatusReqState from json.
func (s *ReposCreateDeploymentStatusReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDeploymentStatusReqState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposCreateDeploymentStatusReqState(v) {
	case ReposCreateDeploymentStatusReqStateError:
		*s = ReposCreateDeploymentStatusReqStateError
	case ReposCreateDeploymentStatusReqStateFailure:
		*s = ReposCreateDeploymentStatusReqStateFailure
	case ReposCreateDeploymentStatusReqStateInactive:
		*s = ReposCreateDeploymentStatusReqStateInactive
	case ReposCreateDeploymentStatusReqStateInProgress:
		*s = ReposCreateDeploymentStatusReqStateInProgress
	case ReposCreateDeploymentStatusReqStateQueued:
		*s = ReposCreateDeploymentStatusReqStateQueued
	case ReposCreateDeploymentStatusReqStatePending:
		*s = ReposCreateDeploymentStatusReqStatePending
	case ReposCreateDeploymentStatusReqStateSuccess:
		*s = ReposCreateDeploymentStatusReqStateSuccess
	default:
		*s = ReposCreateDeploymentStatusReqState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateDispatchEventNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposCreateDispatchEventNoContent from json.
func (s *ReposCreateDispatchEventNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDispatchEventNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateDispatchEventReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"event_type\"" + ":")
		e.Str(s.EventType)
	}
	{
		if s.ClientPayload != nil {
			e.Comma()
		}
		if s.ClientPayload != nil {
			e.RawStr("\"client_payload\"" + ":")
			s.ClientPayload.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateDispatchEventReq from json.
func (s *ReposCreateDispatchEventReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDispatchEventReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			v, err := d.Str()
			s.EventType = string(v)
			if err != nil {
				return err
			}
		case "client_payload":
			s.ClientPayload = nil
			var elem ReposCreateDispatchEventReqClientPayload
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ClientPayload = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateDispatchEventReqClientPayload) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposCreateDispatchEventReqClientPayload from json.
func (s *ReposCreateDispatchEventReqClientPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDispatchEventReqClientPayload to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposCreateForAuthenticatedUserApplicationJSONBadRequest as json.
func (s ReposCreateForAuthenticatedUserApplicationJSONBadRequest) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForAuthenticatedUserApplicationJSONBadRequest from json.
func (s *ReposCreateForAuthenticatedUserApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateForAuthenticatedUserApplicationJSONBadRequest to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForAuthenticatedUserApplicationJSONBadRequest(unwrapped)
	return nil
}

// Encode encodes ReposCreateForAuthenticatedUserApplicationJSONForbidden as json.
func (s ReposCreateForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ReposCreateForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposCreateForAuthenticatedUserApplicationJSONNotFound as json.
func (s ReposCreateForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForAuthenticatedUserApplicationJSONNotFound from json.
func (s *ReposCreateForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposCreateForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ReposCreateForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ReposCreateForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateForAuthenticatedUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			e.Comma()
		}
		if s.Homepage.Set {
			e.RawStr("\"homepage\"" + ":")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.Comma()
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	{
		if s.HasIssues.Set {
			e.Comma()
		}
		if s.HasIssues.Set {
			e.RawStr("\"has_issues\"" + ":")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			e.Comma()
		}
		if s.HasProjects.Set {
			e.RawStr("\"has_projects\"" + ":")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			e.Comma()
		}
		if s.HasWiki.Set {
			e.RawStr("\"has_wiki\"" + ":")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.TeamID.Set {
			e.Comma()
		}
		if s.TeamID.Set {
			e.RawStr("\"team_id\"" + ":")
			s.TeamID.Encode(e)
		}
	}
	{
		if s.AutoInit.Set {
			e.Comma()
		}
		if s.AutoInit.Set {
			e.RawStr("\"auto_init\"" + ":")
			s.AutoInit.Encode(e)
		}
	}
	{
		if s.GitignoreTemplate.Set {
			e.Comma()
		}
		if s.GitignoreTemplate.Set {
			e.RawStr("\"gitignore_template\"" + ":")
			s.GitignoreTemplate.Encode(e)
		}
	}
	{
		if s.LicenseTemplate.Set {
			e.Comma()
		}
		if s.LicenseTemplate.Set {
			e.RawStr("\"license_template\"" + ":")
			s.LicenseTemplate.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.Comma()
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.HasDownloads.Set {
			e.Comma()
		}
		if s.HasDownloads.Set {
			e.RawStr("\"has_downloads\"" + ":")
			s.HasDownloads.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateForAuthenticatedUserReq from json.
func (s *ReposCreateForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateForAuthenticatedUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "homepage":
			s.Homepage.Reset()
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		case "has_issues":
			s.HasIssues.Reset()
			if err := s.HasIssues.Decode(d); err != nil {
				return err
			}
		case "has_projects":
			s.HasProjects.Reset()
			if err := s.HasProjects.Decode(d); err != nil {
				return err
			}
		case "has_wiki":
			s.HasWiki.Reset()
			if err := s.HasWiki.Decode(d); err != nil {
				return err
			}
		case "team_id":
			s.TeamID.Reset()
			if err := s.TeamID.Decode(d); err != nil {
				return err
			}
		case "auto_init":
			s.AutoInit.Reset()
			if err := s.AutoInit.Decode(d); err != nil {
				return err
			}
		case "gitignore_template":
			s.GitignoreTemplate.Reset()
			if err := s.GitignoreTemplate.Decode(d); err != nil {
				return err
			}
		case "license_template":
			s.LicenseTemplate.Reset()
			if err := s.LicenseTemplate.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "has_downloads":
			s.HasDownloads.Reset()
			if err := s.HasDownloads.Decode(d); err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposCreateForkApplicationJSONBadRequest as json.
func (s ReposCreateForkApplicationJSONBadRequest) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForkApplicationJSONBadRequest from json.
func (s *ReposCreateForkApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateForkApplicationJSONBadRequest to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForkApplicationJSONBadRequest(unwrapped)
	return nil
}

// Encode encodes ReposCreateForkApplicationJSONForbidden as json.
func (s ReposCreateForkApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForkApplicationJSONForbidden from json.
func (s *ReposCreateForkApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateForkApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForkApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposCreateForkApplicationJSONNotFound as json.
func (s ReposCreateForkApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForkApplicationJSONNotFound from json.
func (s *ReposCreateForkApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateForkApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForkApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateForkReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Organization.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Organization.Set {
			e.RawStr("\"organization\"" + ":")
			s.Organization.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateForkReq from json.
func (s *ReposCreateForkReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateForkReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "organization":
			s.Organization.Reset()
			if err := s.Organization.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			e.Comma()
		}
		if s.Homepage.Set {
			e.RawStr("\"homepage\"" + ":")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.Comma()
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.HasIssues.Set {
			e.Comma()
		}
		if s.HasIssues.Set {
			e.RawStr("\"has_issues\"" + ":")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			e.Comma()
		}
		if s.HasProjects.Set {
			e.RawStr("\"has_projects\"" + ":")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			e.Comma()
		}
		if s.HasWiki.Set {
			e.RawStr("\"has_wiki\"" + ":")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.TeamID.Set {
			e.Comma()
		}
		if s.TeamID.Set {
			e.RawStr("\"team_id\"" + ":")
			s.TeamID.Encode(e)
		}
	}
	{
		if s.AutoInit.Set {
			e.Comma()
		}
		if s.AutoInit.Set {
			e.RawStr("\"auto_init\"" + ":")
			s.AutoInit.Encode(e)
		}
	}
	{
		if s.GitignoreTemplate.Set {
			e.Comma()
		}
		if s.GitignoreTemplate.Set {
			e.RawStr("\"gitignore_template\"" + ":")
			s.GitignoreTemplate.Encode(e)
		}
	}
	{
		if s.LicenseTemplate.Set {
			e.Comma()
		}
		if s.LicenseTemplate.Set {
			e.RawStr("\"license_template\"" + ":")
			s.LicenseTemplate.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.Comma()
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateInOrgReq from json.
func (s *ReposCreateInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "homepage":
			s.Homepage.Reset()
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "has_issues":
			s.HasIssues.Reset()
			if err := s.HasIssues.Decode(d); err != nil {
				return err
			}
		case "has_projects":
			s.HasProjects.Reset()
			if err := s.HasProjects.Decode(d); err != nil {
				return err
			}
		case "has_wiki":
			s.HasWiki.Reset()
			if err := s.HasWiki.Decode(d); err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "team_id":
			s.TeamID.Reset()
			if err := s.TeamID.Decode(d); err != nil {
				return err
			}
		case "auto_init":
			s.AutoInit.Reset()
			if err := s.AutoInit.Decode(d); err != nil {
				return err
			}
		case "gitignore_template":
			s.GitignoreTemplate.Reset()
			if err := s.GitignoreTemplate.Decode(d); err != nil {
				return err
			}
		case "license_template":
			s.LicenseTemplate.Reset()
			if err := s.LicenseTemplate.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposCreateInOrgReqVisibility as json.
func (s ReposCreateInOrgReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposCreateInOrgReqVisibility from json.
func (s *ReposCreateInOrgReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateInOrgReqVisibility to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposCreateInOrgReqVisibility(v) {
	case ReposCreateInOrgReqVisibilityPublic:
		*s = ReposCreateInOrgReqVisibilityPublic
	case ReposCreateInOrgReqVisibilityPrivate:
		*s = ReposCreateInOrgReqVisibilityPrivate
	case ReposCreateInOrgReqVisibilityVisibility:
		*s = ReposCreateInOrgReqVisibilityVisibility
	case ReposCreateInOrgReqVisibilityInternal:
		*s = ReposCreateInOrgReqVisibilityInternal
	default:
		*s = ReposCreateInOrgReqVisibility(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateOrUpdateEnvironmentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.WaitTimer.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.WaitTimer.Set {
			e.RawStr("\"wait_timer\"" + ":")
			s.WaitTimer.Encode(e)
		}
	}
	{
		if s.Reviewers.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reviewers.Set {
			e.RawStr("\"reviewers\"" + ":")
			s.Reviewers.Encode(e)
		}
	}
	{
		if s.DeploymentBranchPolicy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeploymentBranchPolicy.Set {
			e.RawStr("\"deployment_branch_policy\"" + ":")
			s.DeploymentBranchPolicy.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateOrUpdateEnvironmentReq from json.
func (s *ReposCreateOrUpdateEnvironmentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateOrUpdateEnvironmentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "wait_timer":
			s.WaitTimer.Reset()
			if err := s.WaitTimer.Decode(d); err != nil {
				return err
			}
		case "reviewers":
			s.Reviewers.Reset()
			if err := s.Reviewers.Decode(d); err != nil {
				return err
			}
		case "deployment_branch_policy":
			s.DeploymentBranchPolicy.Reset()
			if err := s.DeploymentBranchPolicy.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateOrUpdateEnvironmentReqReviewersItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateOrUpdateEnvironmentReqReviewersItem from json.
func (s *ReposCreateOrUpdateEnvironmentReqReviewersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateOrUpdateEnvironmentReqReviewersItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposCreateOrUpdateFileContentsApplicationJSONConflict as json.
func (s ReposCreateOrUpdateFileContentsApplicationJSONConflict) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsApplicationJSONConflict from json.
func (s *ReposCreateOrUpdateFileContentsApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateOrUpdateFileContentsApplicationJSONConflict to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateOrUpdateFileContentsApplicationJSONConflict(unwrapped)
	return nil
}

// Encode encodes ReposCreateOrUpdateFileContentsApplicationJSONCreated as json.
func (s ReposCreateOrUpdateFileContentsApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := FileCommit(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsApplicationJSONCreated from json.
func (s *ReposCreateOrUpdateFileContentsApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateOrUpdateFileContentsApplicationJSONCreated to nil`)
	}
	var unwrapped FileCommit
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateOrUpdateFileContentsApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReposCreateOrUpdateFileContentsApplicationJSONNotFound as json.
func (s ReposCreateOrUpdateFileContentsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsApplicationJSONNotFound from json.
func (s *ReposCreateOrUpdateFileContentsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateOrUpdateFileContentsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateOrUpdateFileContentsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposCreateOrUpdateFileContentsApplicationJSONOK as json.
func (s ReposCreateOrUpdateFileContentsApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := FileCommit(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsApplicationJSONOK from json.
func (s *ReposCreateOrUpdateFileContentsApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateOrUpdateFileContentsApplicationJSONOK to nil`)
	}
	var unwrapped FileCommit
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateOrUpdateFileContentsApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateOrUpdateFileContentsReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"content\"" + ":")
		e.Str(s.Content)
	}
	{
		if s.Sha.Set {
			e.Comma()
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.Branch.Set {
			e.Comma()
		}
		if s.Branch.Set {
			e.RawStr("\"branch\"" + ":")
			s.Branch.Encode(e)
		}
	}
	{
		if s.Committer.Set {
			e.Comma()
		}
		if s.Committer.Set {
			e.RawStr("\"committer\"" + ":")
			s.Committer.Encode(e)
		}
	}
	{
		if s.Author.Set {
			e.Comma()
		}
		if s.Author.Set {
			e.RawStr("\"author\"" + ":")
			s.Author.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateOrUpdateFileContentsReq from json.
func (s *ReposCreateOrUpdateFileContentsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateOrUpdateFileContentsReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "content":
			v, err := d.Str()
			s.Content = string(v)
			if err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "branch":
			s.Branch.Reset()
			if err := s.Branch.Decode(d); err != nil {
				return err
			}
		case "committer":
			s.Committer.Reset()
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "author":
			s.Author.Reset()
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateOrUpdateFileContentsReqAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		if s.Date.Set {
			e.Comma()
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateOrUpdateFileContentsReqAuthor from json.
func (s *ReposCreateOrUpdateFileContentsReqAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateOrUpdateFileContentsReqAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateOrUpdateFileContentsReqCommitter) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		if s.Date.Set {
			e.Comma()
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateOrUpdateFileContentsReqCommitter from json.
func (s *ReposCreateOrUpdateFileContentsReqCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateOrUpdateFileContentsReqCommitter to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreatePagesSiteReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"source\"" + ":")
		s.Source.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreatePagesSiteReq from json.
func (s *ReposCreatePagesSiteReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreatePagesSiteReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			if err := s.Source.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreatePagesSiteReqSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"branch\"" + ":")
		e.Str(s.Branch)
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreatePagesSiteReqSource from json.
func (s *ReposCreatePagesSiteReqSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreatePagesSiteReqSource to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "branch":
			v, err := d.Str()
			s.Branch = string(v)
			if err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposCreatePagesSiteReqSourcePath as json.
func (s ReposCreatePagesSiteReqSourcePath) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposCreatePagesSiteReqSourcePath from json.
func (s *ReposCreatePagesSiteReqSourcePath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreatePagesSiteReqSourcePath to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposCreatePagesSiteReqSourcePath(v) {
	case ReposCreatePagesSiteReqSourcePathSlash:
		*s = ReposCreatePagesSiteReqSourcePathSlash
	case ReposCreatePagesSiteReqSourcePathSlashDocs:
		*s = ReposCreatePagesSiteReqSourcePathSlashDocs
	default:
		*s = ReposCreatePagesSiteReqSourcePath(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateReleaseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"tag_name\"" + ":")
		e.Str(s.TagName)
	}
	{
		if s.TargetCommitish.Set {
			e.Comma()
		}
		if s.TargetCommitish.Set {
			e.RawStr("\"target_commitish\"" + ":")
			s.TargetCommitish.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.Draft.Set {
			e.Comma()
		}
		if s.Draft.Set {
			e.RawStr("\"draft\"" + ":")
			s.Draft.Encode(e)
		}
	}
	{
		if s.Prerelease.Set {
			e.Comma()
		}
		if s.Prerelease.Set {
			e.RawStr("\"prerelease\"" + ":")
			s.Prerelease.Encode(e)
		}
	}
	{
		if s.DiscussionCategoryName.Set {
			e.Comma()
		}
		if s.DiscussionCategoryName.Set {
			e.RawStr("\"discussion_category_name\"" + ":")
			s.DiscussionCategoryName.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateReleaseReq from json.
func (s *ReposCreateReleaseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateReleaseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag_name":
			v, err := d.Str()
			s.TagName = string(v)
			if err != nil {
				return err
			}
		case "target_commitish":
			s.TargetCommitish.Reset()
			if err := s.TargetCommitish.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "draft":
			s.Draft.Reset()
			if err := s.Draft.Decode(d); err != nil {
				return err
			}
		case "prerelease":
			s.Prerelease.Reset()
			if err := s.Prerelease.Decode(d); err != nil {
				return err
			}
		case "discussion_category_name":
			s.DiscussionCategoryName.Reset()
			if err := s.DiscussionCategoryName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateUsingTemplateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Owner.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.IncludeAllBranches.Set {
			e.Comma()
		}
		if s.IncludeAllBranches.Set {
			e.RawStr("\"include_all_branches\"" + ":")
			s.IncludeAllBranches.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.Comma()
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateUsingTemplateReq from json.
func (s *ReposCreateUsingTemplateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateUsingTemplateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "include_all_branches":
			s.IncludeAllBranches.Reset()
			if err := s.IncludeAllBranches.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposCreateWebhookApplicationJSONForbidden as json.
func (s ReposCreateWebhookApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateWebhookApplicationJSONForbidden from json.
func (s *ReposCreateWebhookApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateWebhookApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateWebhookApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposCreateWebhookApplicationJSONNotFound as json.
func (s ReposCreateWebhookApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateWebhookApplicationJSONNotFound from json.
func (s *ReposCreateWebhookApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateWebhookApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateWebhookApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateWebhookReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Config.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Config.Set {
			e.RawStr("\"config\"" + ":")
			s.Config.Encode(e)
		}
	}
	{
		if s.Events != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Events != nil {
			e.RawStr("\"events\"" + ":")
			e.ArrStart()
			if len(s.Events) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Events[0]
					e.Str(elem)
				}
				for _, elem := range s.Events[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateWebhookReq from json.
func (s *ReposCreateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateWebhookReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "config":
			s.Config.Reset()
			if err := s.Config.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateWebhookReqConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	{
		if s.Token.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Token.Set {
			e.RawStr("\"token\"" + ":")
			s.Token.Encode(e)
		}
	}
	{
		if s.Digest.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Digest.Set {
			e.RawStr("\"digest\"" + ":")
			s.Digest.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateWebhookReqConfig from json.
func (s *ReposCreateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateWebhookReqConfig to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl.Reset()
			if err := s.InsecureSsl.Decode(d); err != nil {
				return err
			}
		case "token":
			s.Token.Reset()
			if err := s.Token.Decode(d); err != nil {
				return err
			}
		case "digest":
			s.Digest.Reset()
			if err := s.Digest.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposDeclineInvitationApplicationJSONConflict as json.
func (s ReposDeclineInvitationApplicationJSONConflict) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeclineInvitationApplicationJSONConflict from json.
func (s *ReposDeclineInvitationApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeclineInvitationApplicationJSONConflict to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeclineInvitationApplicationJSONConflict(unwrapped)
	return nil
}

// Encode encodes ReposDeclineInvitationApplicationJSONForbidden as json.
func (s ReposDeclineInvitationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeclineInvitationApplicationJSONForbidden from json.
func (s *ReposDeclineInvitationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeclineInvitationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeclineInvitationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposDeclineInvitationApplicationJSONNotFound as json.
func (s ReposDeclineInvitationApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeclineInvitationApplicationJSONNotFound from json.
func (s *ReposDeclineInvitationApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeclineInvitationApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeclineInvitationApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposDeclineInvitationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeclineInvitationNoContent from json.
func (s *ReposDeclineInvitationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeclineInvitationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteAccessRestrictionsNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeleteAccessRestrictionsNoContent from json.
func (s *ReposDeleteAccessRestrictionsNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteAccessRestrictionsNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteAdminBranchProtectionNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeleteAdminBranchProtectionNoContent from json.
func (s *ReposDeleteAdminBranchProtectionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteAdminBranchProtectionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteAnEnvironmentNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeleteAnEnvironmentNoContent from json.
func (s *ReposDeleteAnEnvironmentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteAnEnvironmentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposDeleteApplicationJSONNotFound as json.
func (s ReposDeleteApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeleteApplicationJSONNotFound from json.
func (s *ReposDeleteApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeleteApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposDeleteApplicationJSONTemporaryRedirect as json.
func (s ReposDeleteApplicationJSONTemporaryRedirect) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeleteApplicationJSONTemporaryRedirect from json.
func (s *ReposDeleteApplicationJSONTemporaryRedirect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteApplicationJSONTemporaryRedirect to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeleteApplicationJSONTemporaryRedirect(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposDeleteAutolinkNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeleteAutolinkNoContent from json.
func (s *ReposDeleteAutolinkNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteAutolinkNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteBranchProtectionNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeleteBranchProtectionNoContent from json.
func (s *ReposDeleteBranchProtectionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteBranchProtectionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteCommitCommentNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeleteCommitCommentNoContent from json.
func (s *ReposDeleteCommitCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteCommitCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteCommitSignatureProtectionNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeleteCommitSignatureProtectionNoContent from json.
func (s *ReposDeleteCommitSignatureProtectionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteCommitSignatureProtectionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteDeployKeyNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeleteDeployKeyNoContent from json.
func (s *ReposDeleteDeployKeyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteDeployKeyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteDeploymentNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeleteDeploymentNoContent from json.
func (s *ReposDeleteDeploymentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteDeploymentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposDeleteFileApplicationJSONConflict as json.
func (s ReposDeleteFileApplicationJSONConflict) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeleteFileApplicationJSONConflict from json.
func (s *ReposDeleteFileApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteFileApplicationJSONConflict to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeleteFileApplicationJSONConflict(unwrapped)
	return nil
}

// Encode encodes ReposDeleteFileApplicationJSONNotFound as json.
func (s ReposDeleteFileApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeleteFileApplicationJSONNotFound from json.
func (s *ReposDeleteFileApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteFileApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeleteFileApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposDeleteFileReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		if s.Branch.Set {
			e.Comma()
		}
		if s.Branch.Set {
			e.RawStr("\"branch\"" + ":")
			s.Branch.Encode(e)
		}
	}
	{
		if s.Committer.Set {
			e.Comma()
		}
		if s.Committer.Set {
			e.RawStr("\"committer\"" + ":")
			s.Committer.Encode(e)
		}
	}
	{
		if s.Author.Set {
			e.Comma()
		}
		if s.Author.Set {
			e.RawStr("\"author\"" + ":")
			s.Author.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposDeleteFileReq from json.
func (s *ReposDeleteFileReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteFileReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "branch":
			s.Branch.Reset()
			if err := s.Branch.Decode(d); err != nil {
				return err
			}
		case "committer":
			s.Committer.Reset()
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "author":
			s.Author.Reset()
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteFileReqAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposDeleteFileReqAuthor from json.
func (s *ReposDeleteFileReqAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteFileReqAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteFileReqCommitter) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposDeleteFileReqCommitter from json.
func (s *ReposDeleteFileReqCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteFileReqCommitter to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposDeleteForbidden from json.
func (s *ReposDeleteForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteInvitationNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeleteInvitationNoContent from json.
func (s *ReposDeleteInvitationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteInvitationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeleteNoContent from json.
func (s *ReposDeleteNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeletePagesSiteNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeletePagesSiteNoContent from json.
func (s *ReposDeletePagesSiteNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeletePagesSiteNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeletePullRequestReviewProtectionNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeletePullRequestReviewProtectionNoContent from json.
func (s *ReposDeletePullRequestReviewProtectionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeletePullRequestReviewProtectionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteReleaseAssetNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeleteReleaseAssetNoContent from json.
func (s *ReposDeleteReleaseAssetNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteReleaseAssetNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteReleaseNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeleteReleaseNoContent from json.
func (s *ReposDeleteReleaseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteReleaseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteWebhookNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDeleteWebhookNoContent from json.
func (s *ReposDeleteWebhookNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteWebhookNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDisableAutomatedSecurityFixesNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDisableAutomatedSecurityFixesNoContent from json.
func (s *ReposDisableAutomatedSecurityFixesNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDisableAutomatedSecurityFixesNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDisableLfsForRepoNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDisableLfsForRepoNoContent from json.
func (s *ReposDisableLfsForRepoNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDisableLfsForRepoNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDisableVulnerabilityAlertsNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDisableVulnerabilityAlertsNoContent from json.
func (s *ReposDisableVulnerabilityAlertsNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDisableVulnerabilityAlertsNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDownloadTarballArchiveFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDownloadTarballArchiveFound from json.
func (s *ReposDownloadTarballArchiveFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDownloadTarballArchiveFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDownloadZipballArchiveFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposDownloadZipballArchiveFound from json.
func (s *ReposDownloadZipballArchiveFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDownloadZipballArchiveFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposEnableAutomatedSecurityFixesNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposEnableAutomatedSecurityFixesNoContent from json.
func (s *ReposEnableAutomatedSecurityFixesNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposEnableAutomatedSecurityFixesNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposEnableLfsForRepoForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposEnableLfsForRepoForbidden from json.
func (s *ReposEnableLfsForRepoForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposEnableLfsForRepoForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposEnableVulnerabilityAlertsNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposEnableVulnerabilityAlertsNoContent from json.
func (s *ReposEnableVulnerabilityAlertsNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposEnableVulnerabilityAlertsNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposGetAllStatusCheckContextsOKApplicationJSON as json.
func (s ReposGetAllStatusCheckContextsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []string(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			e.Str(elem)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			e.Str(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetAllStatusCheckContextsOKApplicationJSON from json.
func (s *ReposGetAllStatusCheckContextsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetAllStatusCheckContextsOKApplicationJSON to nil`)
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetAllStatusCheckContextsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetApplicationJSONForbidden as json.
func (s ReposGetApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetApplicationJSONForbidden from json.
func (s *ReposGetApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposGetApplicationJSONMovedPermanently as json.
func (s ReposGetApplicationJSONMovedPermanently) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetApplicationJSONMovedPermanently from json.
func (s *ReposGetApplicationJSONMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetApplicationJSONMovedPermanently to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetApplicationJSONMovedPermanently(unwrapped)
	return nil
}

// Encode encodes ReposGetApplicationJSONNotFound as json.
func (s ReposGetApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetApplicationJSONNotFound from json.
func (s *ReposGetApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON as json.
func (s ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Integration(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON from json.
func (s *ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON to nil`)
	}
	var unwrapped []Integration
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Integration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetBranchApplicationJSONMovedPermanently as json.
func (s ReposGetBranchApplicationJSONMovedPermanently) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetBranchApplicationJSONMovedPermanently from json.
func (s *ReposGetBranchApplicationJSONMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetBranchApplicationJSONMovedPermanently to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetBranchApplicationJSONMovedPermanently(unwrapped)
	return nil
}

// Encode encodes ReposGetBranchApplicationJSONNotFound as json.
func (s ReposGetBranchApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetBranchApplicationJSONNotFound from json.
func (s *ReposGetBranchApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetBranchApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetBranchApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposGetClonesPer as json.
func (s ReposGetClonesPer) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposGetClonesPer from json.
func (s *ReposGetClonesPer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetClonesPer to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposGetClonesPer(v) {
	case ReposGetClonesPerEmpty:
		*s = ReposGetClonesPerEmpty
	case ReposGetClonesPerDay:
		*s = ReposGetClonesPerDay
	case ReposGetClonesPerWeek:
		*s = ReposGetClonesPerWeek
	default:
		*s = ReposGetClonesPer(v)
	}

	return nil
}

// Encode encodes ReposGetCodeFrequencyStatsOKApplicationJSON as json.
func (s ReposGetCodeFrequencyStatsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CodeFrequencyStat(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetCodeFrequencyStatsOKApplicationJSON from json.
func (s *ReposGetCodeFrequencyStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetCodeFrequencyStatsOKApplicationJSON to nil`)
	}
	var unwrapped []CodeFrequencyStat
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeFrequencyStat
			{
				var unwrapped []int
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = CodeFrequencyStat(unwrapped)
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetCodeFrequencyStatsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetCommitActivityStatsOKApplicationJSON as json.
func (s ReposGetCommitActivityStatsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CommitActivity(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetCommitActivityStatsOKApplicationJSON from json.
func (s *ReposGetCommitActivityStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetCommitActivityStatsOKApplicationJSON to nil`)
	}
	var unwrapped []CommitActivity
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CommitActivity
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetCommitActivityStatsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetCommitApplicationJSONInternalServerError as json.
func (s ReposGetCommitApplicationJSONInternalServerError) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetCommitApplicationJSONInternalServerError from json.
func (s *ReposGetCommitApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetCommitApplicationJSONInternalServerError to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetCommitApplicationJSONInternalServerError(unwrapped)
	return nil
}

// Encode encodes ReposGetCommitApplicationJSONNotFound as json.
func (s ReposGetCommitApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetCommitApplicationJSONNotFound from json.
func (s *ReposGetCommitApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetCommitApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetCommitApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposGetContributorsStatsOKApplicationJSON as json.
func (s ReposGetContributorsStatsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ContributorActivity(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetContributorsStatsOKApplicationJSON from json.
func (s *ReposGetContributorsStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetContributorsStatsOKApplicationJSON to nil`)
	}
	var unwrapped []ContributorActivity
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ContributorActivity
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetContributorsStatsOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposGetPagesHealthCheckBadRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposGetPagesHealthCheckBadRequest from json.
func (s *ReposGetPagesHealthCheckBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetPagesHealthCheckBadRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposGetPagesHealthCheckUnprocessableEntity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposGetPagesHealthCheckUnprocessableEntity from json.
func (s *ReposGetPagesHealthCheckUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetPagesHealthCheckUnprocessableEntity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposGetPunchCardStatsOKApplicationJSON as json.
func (s ReposGetPunchCardStatsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CodeFrequencyStat(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetPunchCardStatsOKApplicationJSON from json.
func (s *ReposGetPunchCardStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetPunchCardStatsOKApplicationJSON to nil`)
	}
	var unwrapped []CodeFrequencyStat
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeFrequencyStat
			{
				var unwrapped []int
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = CodeFrequencyStat(unwrapped)
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetPunchCardStatsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON as json.
func (s ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Team(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON from json.
func (s *ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON to nil`)
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetTopPathsOKApplicationJSON as json.
func (s ReposGetTopPathsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ContentTraffic(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetTopPathsOKApplicationJSON from json.
func (s *ReposGetTopPathsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetTopPathsOKApplicationJSON to nil`)
	}
	var unwrapped []ContentTraffic
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ContentTraffic
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetTopPathsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetTopReferrersOKApplicationJSON as json.
func (s ReposGetTopReferrersOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ReferrerTraffic(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetTopReferrersOKApplicationJSON from json.
func (s *ReposGetTopReferrersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetTopReferrersOKApplicationJSON to nil`)
	}
	var unwrapped []ReferrerTraffic
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ReferrerTraffic
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetTopReferrersOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON as json.
func (s ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON from json.
func (s *ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetViewsPer as json.
func (s ReposGetViewsPer) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposGetViewsPer from json.
func (s *ReposGetViewsPer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetViewsPer to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposGetViewsPer(v) {
	case ReposGetViewsPerEmpty:
		*s = ReposGetViewsPerEmpty
	case ReposGetViewsPerDay:
		*s = ReposGetViewsPerDay
	case ReposGetViewsPerWeek:
		*s = ReposGetViewsPerWeek
	default:
		*s = ReposGetViewsPer(v)
	}

	return nil
}

// Encode encodes ReposListBranchesForHeadCommitOKApplicationJSON as json.
func (s ReposListBranchesForHeadCommitOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []BranchShort(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListBranchesForHeadCommitOKApplicationJSON from json.
func (s *ReposListBranchesForHeadCommitOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListBranchesForHeadCommitOKApplicationJSON to nil`)
	}
	var unwrapped []BranchShort
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BranchShort
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListBranchesForHeadCommitOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListBranchesOKApplicationJSON as json.
func (s ReposListBranchesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ShortBranch(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListBranchesOKApplicationJSON from json.
func (s *ReposListBranchesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListBranchesOKApplicationJSON to nil`)
	}
	var unwrapped []ShortBranch
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ShortBranch
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListBranchesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListCollaboratorsAffiliation as json.
func (s ReposListCollaboratorsAffiliation) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposListCollaboratorsAffiliation from json.
func (s *ReposListCollaboratorsAffiliation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCollaboratorsAffiliation to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposListCollaboratorsAffiliation(v) {
	case ReposListCollaboratorsAffiliationOutside:
		*s = ReposListCollaboratorsAffiliationOutside
	case ReposListCollaboratorsAffiliationDirect:
		*s = ReposListCollaboratorsAffiliationDirect
	case ReposListCollaboratorsAffiliationAll:
		*s = ReposListCollaboratorsAffiliationAll
	default:
		*s = ReposListCollaboratorsAffiliation(v)
	}

	return nil
}

// Encode encodes ReposListCollaboratorsOKApplicationJSON as json.
func (s ReposListCollaboratorsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Collaborator(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListCollaboratorsOKApplicationJSON from json.
func (s *ReposListCollaboratorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCollaboratorsOKApplicationJSON to nil`)
	}
	var unwrapped []Collaborator
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Collaborator
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCollaboratorsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListCommitStatusesForRefOKApplicationJSON as json.
func (s ReposListCommitStatusesForRefOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Status(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListCommitStatusesForRefOKApplicationJSON from json.
func (s *ReposListCommitStatusesForRefOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCommitStatusesForRefOKApplicationJSON to nil`)
	}
	var unwrapped []Status
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Status
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitStatusesForRefOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListCommitsApplicationJSONBadRequest as json.
func (s ReposListCommitsApplicationJSONBadRequest) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsApplicationJSONBadRequest from json.
func (s *ReposListCommitsApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCommitsApplicationJSONBadRequest to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsApplicationJSONBadRequest(unwrapped)
	return nil
}

// Encode encodes ReposListCommitsApplicationJSONConflict as json.
func (s ReposListCommitsApplicationJSONConflict) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsApplicationJSONConflict from json.
func (s *ReposListCommitsApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCommitsApplicationJSONConflict to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsApplicationJSONConflict(unwrapped)
	return nil
}

// Encode encodes ReposListCommitsApplicationJSONInternalServerError as json.
func (s ReposListCommitsApplicationJSONInternalServerError) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsApplicationJSONInternalServerError from json.
func (s *ReposListCommitsApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCommitsApplicationJSONInternalServerError to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsApplicationJSONInternalServerError(unwrapped)
	return nil
}

// Encode encodes ReposListCommitsApplicationJSONNotFound as json.
func (s ReposListCommitsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsApplicationJSONNotFound from json.
func (s *ReposListCommitsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCommitsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposListCommitsOKApplicationJSON as json.
func (s ReposListCommitsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Commit(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListCommitsOKApplicationJSON from json.
func (s *ReposListCommitsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCommitsOKApplicationJSON to nil`)
	}
	var unwrapped []Commit
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Commit
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListContributorsApplicationJSONForbidden as json.
func (s ReposListContributorsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListContributorsApplicationJSONForbidden from json.
func (s *ReposListContributorsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListContributorsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListContributorsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposListContributorsApplicationJSONNotFound as json.
func (s ReposListContributorsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListContributorsApplicationJSONNotFound from json.
func (s *ReposListContributorsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListContributorsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListContributorsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposListContributorsNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposListContributorsNoContent from json.
func (s *ReposListContributorsNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListContributorsNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposListContributorsOKApplicationJSON as json.
func (s ReposListContributorsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Contributor(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListContributorsOKApplicationJSON from json.
func (s *ReposListContributorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListContributorsOKApplicationJSON to nil`)
	}
	var unwrapped []Contributor
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Contributor
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListContributorsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListDeploymentStatusesOKApplicationJSON as json.
func (s ReposListDeploymentStatusesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []DeploymentStatus(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListDeploymentStatusesOKApplicationJSON from json.
func (s *ReposListDeploymentStatusesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListDeploymentStatusesOKApplicationJSON to nil`)
	}
	var unwrapped []DeploymentStatus
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem DeploymentStatus
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListDeploymentStatusesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListForAuthenticatedUserApplicationJSONForbidden as json.
func (s ReposListForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ReposListForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposListForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ReposListForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ReposListForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ReposListForAuthenticatedUserDirection as json.
func (s ReposListForAuthenticatedUserDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposListForAuthenticatedUserDirection from json.
func (s *ReposListForAuthenticatedUserDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForAuthenticatedUserDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposListForAuthenticatedUserDirection(v) {
	case ReposListForAuthenticatedUserDirectionAsc:
		*s = ReposListForAuthenticatedUserDirectionAsc
	case ReposListForAuthenticatedUserDirectionDesc:
		*s = ReposListForAuthenticatedUserDirectionDesc
	default:
		*s = ReposListForAuthenticatedUserDirection(v)
	}

	return nil
}

// Encode encodes ReposListForAuthenticatedUserOKApplicationJSON as json.
func (s ReposListForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Repository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListForAuthenticatedUserOKApplicationJSON from json.
func (s *ReposListForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []Repository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Repository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListForAuthenticatedUserSort as json.
func (s ReposListForAuthenticatedUserSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposListForAuthenticatedUserSort from json.
func (s *ReposListForAuthenticatedUserSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForAuthenticatedUserSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposListForAuthenticatedUserSort(v) {
	case ReposListForAuthenticatedUserSortCreated:
		*s = ReposListForAuthenticatedUserSortCreated
	case ReposListForAuthenticatedUserSortUpdated:
		*s = ReposListForAuthenticatedUserSortUpdated
	case ReposListForAuthenticatedUserSortPushed:
		*s = ReposListForAuthenticatedUserSortPushed
	case ReposListForAuthenticatedUserSortFullName:
		*s = ReposListForAuthenticatedUserSortFullName
	default:
		*s = ReposListForAuthenticatedUserSort(v)
	}

	return nil
}

// Encode encodes ReposListForAuthenticatedUserType as json.
func (s ReposListForAuthenticatedUserType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposListForAuthenticatedUserType from json.
func (s *ReposListForAuthenticatedUserType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForAuthenticatedUserType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposListForAuthenticatedUserType(v) {
	case ReposListForAuthenticatedUserTypeAll:
		*s = ReposListForAuthenticatedUserTypeAll
	case ReposListForAuthenticatedUserTypeOwner:
		*s = ReposListForAuthenticatedUserTypeOwner
	case ReposListForAuthenticatedUserTypePublic:
		*s = ReposListForAuthenticatedUserTypePublic
	case ReposListForAuthenticatedUserTypePrivate:
		*s = ReposListForAuthenticatedUserTypePrivate
	case ReposListForAuthenticatedUserTypeMember:
		*s = ReposListForAuthenticatedUserTypeMember
	default:
		*s = ReposListForAuthenticatedUserType(v)
	}

	return nil
}

// Encode encodes ReposListForAuthenticatedUserVisibility as json.
func (s ReposListForAuthenticatedUserVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposListForAuthenticatedUserVisibility from json.
func (s *ReposListForAuthenticatedUserVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForAuthenticatedUserVisibility to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposListForAuthenticatedUserVisibility(v) {
	case ReposListForAuthenticatedUserVisibilityAll:
		*s = ReposListForAuthenticatedUserVisibilityAll
	case ReposListForAuthenticatedUserVisibilityPublic:
		*s = ReposListForAuthenticatedUserVisibilityPublic
	case ReposListForAuthenticatedUserVisibilityPrivate:
		*s = ReposListForAuthenticatedUserVisibilityPrivate
	default:
		*s = ReposListForAuthenticatedUserVisibility(v)
	}

	return nil
}

// Encode encodes ReposListForOrgDirection as json.
func (s ReposListForOrgDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposListForOrgDirection from json.
func (s *ReposListForOrgDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForOrgDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposListForOrgDirection(v) {
	case ReposListForOrgDirectionAsc:
		*s = ReposListForOrgDirectionAsc
	case ReposListForOrgDirectionDesc:
		*s = ReposListForOrgDirectionDesc
	default:
		*s = ReposListForOrgDirection(v)
	}

	return nil
}

// Encode encodes ReposListForOrgSort as json.
func (s ReposListForOrgSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposListForOrgSort from json.
func (s *ReposListForOrgSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForOrgSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposListForOrgSort(v) {
	case ReposListForOrgSortCreated:
		*s = ReposListForOrgSortCreated
	case ReposListForOrgSortUpdated:
		*s = ReposListForOrgSortUpdated
	case ReposListForOrgSortPushed:
		*s = ReposListForOrgSortPushed
	case ReposListForOrgSortFullName:
		*s = ReposListForOrgSortFullName
	default:
		*s = ReposListForOrgSort(v)
	}

	return nil
}

// Encode encodes ReposListForOrgType as json.
func (s ReposListForOrgType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposListForOrgType from json.
func (s *ReposListForOrgType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForOrgType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposListForOrgType(v) {
	case ReposListForOrgTypeAll:
		*s = ReposListForOrgTypeAll
	case ReposListForOrgTypePublic:
		*s = ReposListForOrgTypePublic
	case ReposListForOrgTypePrivate:
		*s = ReposListForOrgTypePrivate
	case ReposListForOrgTypeForks:
		*s = ReposListForOrgTypeForks
	case ReposListForOrgTypeSources:
		*s = ReposListForOrgTypeSources
	case ReposListForOrgTypeMember:
		*s = ReposListForOrgTypeMember
	case ReposListForOrgTypeInternal:
		*s = ReposListForOrgTypeInternal
	default:
		*s = ReposListForOrgType(v)
	}

	return nil
}

// Encode encodes ReposListForUserDirection as json.
func (s ReposListForUserDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposListForUserDirection from json.
func (s *ReposListForUserDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForUserDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposListForUserDirection(v) {
	case ReposListForUserDirectionAsc:
		*s = ReposListForUserDirectionAsc
	case ReposListForUserDirectionDesc:
		*s = ReposListForUserDirectionDesc
	default:
		*s = ReposListForUserDirection(v)
	}

	return nil
}

// Encode encodes ReposListForUserSort as json.
func (s ReposListForUserSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposListForUserSort from json.
func (s *ReposListForUserSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForUserSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposListForUserSort(v) {
	case ReposListForUserSortCreated:
		*s = ReposListForUserSortCreated
	case ReposListForUserSortUpdated:
		*s = ReposListForUserSortUpdated
	case ReposListForUserSortPushed:
		*s = ReposListForUserSortPushed
	case ReposListForUserSortFullName:
		*s = ReposListForUserSortFullName
	default:
		*s = ReposListForUserSort(v)
	}

	return nil
}

// Encode encodes ReposListForUserType as json.
func (s ReposListForUserType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposListForUserType from json.
func (s *ReposListForUserType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForUserType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposListForUserType(v) {
	case ReposListForUserTypeAll:
		*s = ReposListForUserTypeAll
	case ReposListForUserTypeOwner:
		*s = ReposListForUserTypeOwner
	case ReposListForUserTypeMember:
		*s = ReposListForUserTypeMember
	default:
		*s = ReposListForUserType(v)
	}

	return nil
}

// Encode encodes ReposListForksOKApplicationJSON as json.
func (s ReposListForksOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListForksOKApplicationJSON from json.
func (s *ReposListForksOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForksOKApplicationJSON to nil`)
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListForksOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListForksSort as json.
func (s ReposListForksSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposListForksSort from json.
func (s *ReposListForksSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForksSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposListForksSort(v) {
	case ReposListForksSortNewest:
		*s = ReposListForksSortNewest
	case ReposListForksSortOldest:
		*s = ReposListForksSortOldest
	case ReposListForksSortStargazers:
		*s = ReposListForksSortStargazers
	case ReposListForksSortWatchers:
		*s = ReposListForksSortWatchers
	default:
		*s = ReposListForksSort(v)
	}

	return nil
}

// Encode encodes ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden as json.
func (s ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound as json.
func (s ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound from json.
func (s *ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ReposListInvitationsForAuthenticatedUserOKApplicationJSON as json.
func (s ReposListInvitationsForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []RepositoryInvitation(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListInvitationsForAuthenticatedUserOKApplicationJSON from json.
func (s *ReposListInvitationsForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListInvitationsForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []RepositoryInvitation
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem RepositoryInvitation
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListInvitationsForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListPublicOKApplicationJSON as json.
func (s ReposListPublicOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListPublicOKApplicationJSON from json.
func (s *ReposListPublicOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListPublicOKApplicationJSON to nil`)
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListPublicOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListReleasesOKApplicationJSON as json.
func (s ReposListReleasesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Release(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListReleasesOKApplicationJSON from json.
func (s *ReposListReleasesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListReleasesOKApplicationJSON to nil`)
	}
	var unwrapped []Release
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Release
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListReleasesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListWebhookDeliveriesOKApplicationJSON as json.
func (s ReposListWebhookDeliveriesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []HookDeliveryItem(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListWebhookDeliveriesOKApplicationJSON from json.
func (s *ReposListWebhookDeliveriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListWebhookDeliveriesOKApplicationJSON to nil`)
	}
	var unwrapped []HookDeliveryItem
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HookDeliveryItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListWebhookDeliveriesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListWebhooksOKApplicationJSON as json.
func (s ReposListWebhooksOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Hook(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListWebhooksOKApplicationJSON from json.
func (s *ReposListWebhooksOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListWebhooksOKApplicationJSON to nil`)
	}
	var unwrapped []Hook
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Hook
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListWebhooksOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposMergeConflict) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposMergeConflict from json.
func (s *ReposMergeConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposMergeConflict to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposMergeNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposMergeNoContent from json.
func (s *ReposMergeNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposMergeNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposMergeNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposMergeNotFound from json.
func (s *ReposMergeNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposMergeNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposMergeReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"base\"" + ":")
		e.Str(s.Base)
	}
	{
		e.Comma()

		e.RawStr("\"head\"" + ":")
		e.Str(s.Head)
	}
	{
		if s.CommitMessage.Set {
			e.Comma()
		}
		if s.CommitMessage.Set {
			e.RawStr("\"commit_message\"" + ":")
			s.CommitMessage.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposMergeReq from json.
func (s *ReposMergeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposMergeReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "base":
			v, err := d.Str()
			s.Base = string(v)
			if err != nil {
				return err
			}
		case "head":
			v, err := d.Str()
			s.Head = string(v)
			if err != nil {
				return err
			}
		case "commit_message":
			s.CommitMessage.Reset()
			if err := s.CommitMessage.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposMergeUpstreamConflict) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposMergeUpstreamConflict from json.
func (s *ReposMergeUpstreamConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposMergeUpstreamConflict to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposMergeUpstreamReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"branch\"" + ":")
		e.Str(s.Branch)
	}
	e.ObjEnd()
}

// Decode decodes ReposMergeUpstreamReq from json.
func (s *ReposMergeUpstreamReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposMergeUpstreamReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "branch":
			v, err := d.Str()
			s.Branch = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposMergeUpstreamUnprocessableEntity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposMergeUpstreamUnprocessableEntity from json.
func (s *ReposMergeUpstreamUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposMergeUpstreamUnprocessableEntity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposPingWebhookNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposPingWebhookNoContent from json.
func (s *ReposPingWebhookNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposPingWebhookNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposRemoveAppAccessRestrictionsOKApplicationJSON as json.
func (s ReposRemoveAppAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Integration(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposRemoveAppAccessRestrictionsOKApplicationJSON from json.
func (s *ReposRemoveAppAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveAppAccessRestrictionsOKApplicationJSON to nil`)
	}
	var unwrapped []Integration
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Integration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRemoveAppAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposRemoveAppAccessRestrictionsReq as json.
func (s ReposRemoveAppAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposRemoveAppAccessRestrictionsReq0ReposRemoveAppAccessRestrictionsReq:
		s.ReposRemoveAppAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposRemoveAppAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposRemoveAppAccessRestrictionsReq from json.
func (s *ReposRemoveAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveAppAccessRestrictionsReq to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposRemoveAppAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposRemoveAppAccessRestrictionsReq0ReposRemoveAppAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposRemoveAppAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposRemoveAppAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"apps\"" + ":")
		e.ArrStart()
		if len(s.Apps) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Apps[0]
				e.Str(elem)
			}
			for _, elem := range s.Apps[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposRemoveAppAccessRestrictionsReq0 from json.
func (s *ReposRemoveAppAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveAppAccessRestrictionsReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apps":
			s.Apps = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Apps = append(s.Apps, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposRemoveCollaboratorNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposRemoveCollaboratorNoContent from json.
func (s *ReposRemoveCollaboratorNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveCollaboratorNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposRemoveStatusCheckContextsOKApplicationJSON as json.
func (s ReposRemoveStatusCheckContextsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []string(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			e.Str(elem)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			e.Str(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposRemoveStatusCheckContextsOKApplicationJSON from json.
func (s *ReposRemoveStatusCheckContextsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveStatusCheckContextsOKApplicationJSON to nil`)
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRemoveStatusCheckContextsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposRemoveStatusCheckContextsReq as json.
func (s ReposRemoveStatusCheckContextsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposRemoveStatusCheckContextsReq0ReposRemoveStatusCheckContextsReq:
		s.ReposRemoveStatusCheckContextsReq0.Encode(e)
	case ArrayStringReposRemoveStatusCheckContextsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposRemoveStatusCheckContextsReq from json.
func (s *ReposRemoveStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveStatusCheckContextsReq to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposRemoveStatusCheckContextsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposRemoveStatusCheckContextsReq0ReposRemoveStatusCheckContextsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposRemoveStatusCheckContextsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposRemoveStatusCheckContextsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"contexts\"" + ":")
		e.ArrStart()
		if len(s.Contexts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Contexts[0]
				e.Str(elem)
			}
			for _, elem := range s.Contexts[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposRemoveStatusCheckContextsReq0 from json.
func (s *ReposRemoveStatusCheckContextsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveStatusCheckContextsReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contexts":
			s.Contexts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Contexts = append(s.Contexts, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposRemoveStatusCheckProtectionNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposRemoveStatusCheckProtectionNoContent from json.
func (s *ReposRemoveStatusCheckProtectionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveStatusCheckProtectionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposRemoveTeamAccessRestrictionsOKApplicationJSON as json.
func (s ReposRemoveTeamAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Team(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposRemoveTeamAccessRestrictionsOKApplicationJSON from json.
func (s *ReposRemoveTeamAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveTeamAccessRestrictionsOKApplicationJSON to nil`)
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRemoveTeamAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposRemoveTeamAccessRestrictionsReq as json.
func (s ReposRemoveTeamAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposRemoveTeamAccessRestrictionsReq0ReposRemoveTeamAccessRestrictionsReq:
		s.ReposRemoveTeamAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposRemoveTeamAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposRemoveTeamAccessRestrictionsReq from json.
func (s *ReposRemoveTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveTeamAccessRestrictionsReq to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposRemoveTeamAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposRemoveTeamAccessRestrictionsReq0ReposRemoveTeamAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposRemoveTeamAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposRemoveTeamAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"teams\"" + ":")
		e.ArrStart()
		if len(s.Teams) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Teams[0]
				e.Str(elem)
			}
			for _, elem := range s.Teams[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposRemoveTeamAccessRestrictionsReq0 from json.
func (s *ReposRemoveTeamAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveTeamAccessRestrictionsReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposRemoveUserAccessRestrictionsOKApplicationJSON as json.
func (s ReposRemoveUserAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposRemoveUserAccessRestrictionsOKApplicationJSON from json.
func (s *ReposRemoveUserAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveUserAccessRestrictionsOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRemoveUserAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposRemoveUserAccessRestrictionsReq as json.
func (s ReposRemoveUserAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposRemoveUserAccessRestrictionsReq0ReposRemoveUserAccessRestrictionsReq:
		s.ReposRemoveUserAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposRemoveUserAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposRemoveUserAccessRestrictionsReq from json.
func (s *ReposRemoveUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveUserAccessRestrictionsReq to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposRemoveUserAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposRemoveUserAccessRestrictionsReq0ReposRemoveUserAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposRemoveUserAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposRemoveUserAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"users\"" + ":")
		e.ArrStart()
		if len(s.Users) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Users[0]
				e.Str(elem)
			}
			for _, elem := range s.Users[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposRemoveUserAccessRestrictionsReq0 from json.
func (s *ReposRemoveUserAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveUserAccessRestrictionsReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposRenameBranchApplicationJSONForbidden as json.
func (s ReposRenameBranchApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposRenameBranchApplicationJSONForbidden from json.
func (s *ReposRenameBranchApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRenameBranchApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRenameBranchApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposRenameBranchApplicationJSONNotFound as json.
func (s ReposRenameBranchApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposRenameBranchApplicationJSONNotFound from json.
func (s *ReposRenameBranchApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRenameBranchApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRenameBranchApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposRenameBranchReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"new_name\"" + ":")
		e.Str(s.NewName)
	}
	e.ObjEnd()
}

// Decode decodes ReposRenameBranchReq from json.
func (s *ReposRenameBranchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRenameBranchReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "new_name":
			v, err := d.Str()
			s.NewName = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposReplaceAllTopicsReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"names\"" + ":")
		e.ArrStart()
		if len(s.Names) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Names[0]
				e.Str(elem)
			}
			for _, elem := range s.Names[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposReplaceAllTopicsReq from json.
func (s *ReposReplaceAllTopicsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposReplaceAllTopicsReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "names":
			s.Names = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Names = append(s.Names, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposSetAppAccessRestrictionsOKApplicationJSON as json.
func (s ReposSetAppAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Integration(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposSetAppAccessRestrictionsOKApplicationJSON from json.
func (s *ReposSetAppAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposSetAppAccessRestrictionsOKApplicationJSON to nil`)
	}
	var unwrapped []Integration
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Integration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposSetAppAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposSetAppAccessRestrictionsReq as json.
func (s ReposSetAppAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposSetAppAccessRestrictionsReq0ReposSetAppAccessRestrictionsReq:
		s.ReposSetAppAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposSetAppAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposSetAppAccessRestrictionsReq from json.
func (s *ReposSetAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposSetAppAccessRestrictionsReq to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposSetAppAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposSetAppAccessRestrictionsReq0ReposSetAppAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposSetAppAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposSetAppAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"apps\"" + ":")
		e.ArrStart()
		if len(s.Apps) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Apps[0]
				e.Str(elem)
			}
			for _, elem := range s.Apps[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposSetAppAccessRestrictionsReq0 from json.
func (s *ReposSetAppAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposSetAppAccessRestrictionsReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apps":
			s.Apps = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Apps = append(s.Apps, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposSetStatusCheckContextsOKApplicationJSON as json.
func (s ReposSetStatusCheckContextsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []string(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			e.Str(elem)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			e.Str(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposSetStatusCheckContextsOKApplicationJSON from json.
func (s *ReposSetStatusCheckContextsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposSetStatusCheckContextsOKApplicationJSON to nil`)
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposSetStatusCheckContextsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposSetStatusCheckContextsReq as json.
func (s ReposSetStatusCheckContextsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposSetStatusCheckContextsReq0ReposSetStatusCheckContextsReq:
		s.ReposSetStatusCheckContextsReq0.Encode(e)
	case ArrayStringReposSetStatusCheckContextsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposSetStatusCheckContextsReq from json.
func (s *ReposSetStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposSetStatusCheckContextsReq to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposSetStatusCheckContextsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposSetStatusCheckContextsReq0ReposSetStatusCheckContextsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposSetStatusCheckContextsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposSetStatusCheckContextsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"contexts\"" + ":")
		e.ArrStart()
		if len(s.Contexts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Contexts[0]
				e.Str(elem)
			}
			for _, elem := range s.Contexts[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposSetStatusCheckContextsReq0 from json.
func (s *ReposSetStatusCheckContextsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposSetStatusCheckContextsReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contexts":
			s.Contexts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Contexts = append(s.Contexts, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposSetTeamAccessRestrictionsOKApplicationJSON as json.
func (s ReposSetTeamAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Team(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposSetTeamAccessRestrictionsOKApplicationJSON from json.
func (s *ReposSetTeamAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposSetTeamAccessRestrictionsOKApplicationJSON to nil`)
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposSetTeamAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposSetTeamAccessRestrictionsReq as json.
func (s ReposSetTeamAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposSetTeamAccessRestrictionsReq0ReposSetTeamAccessRestrictionsReq:
		s.ReposSetTeamAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposSetTeamAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposSetTeamAccessRestrictionsReq from json.
func (s *ReposSetTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposSetTeamAccessRestrictionsReq to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposSetTeamAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposSetTeamAccessRestrictionsReq0ReposSetTeamAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposSetTeamAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposSetTeamAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"teams\"" + ":")
		e.ArrStart()
		if len(s.Teams) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Teams[0]
				e.Str(elem)
			}
			for _, elem := range s.Teams[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposSetTeamAccessRestrictionsReq0 from json.
func (s *ReposSetTeamAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposSetTeamAccessRestrictionsReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposSetUserAccessRestrictionsOKApplicationJSON as json.
func (s ReposSetUserAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposSetUserAccessRestrictionsOKApplicationJSON from json.
func (s *ReposSetUserAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposSetUserAccessRestrictionsOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposSetUserAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposSetUserAccessRestrictionsReq as json.
func (s ReposSetUserAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposSetUserAccessRestrictionsReq0ReposSetUserAccessRestrictionsReq:
		s.ReposSetUserAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposSetUserAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposSetUserAccessRestrictionsReq from json.
func (s *ReposSetUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposSetUserAccessRestrictionsReq to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposSetUserAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposSetUserAccessRestrictionsReq0ReposSetUserAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposSetUserAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposSetUserAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"users\"" + ":")
		e.ArrStart()
		if len(s.Users) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Users[0]
				e.Str(elem)
			}
			for _, elem := range s.Users[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposSetUserAccessRestrictionsReq0 from json.
func (s *ReposSetUserAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposSetUserAccessRestrictionsReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposTestPushWebhookNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ReposTestPushWebhookNoContent from json.
func (s *ReposTestPushWebhookNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposTestPushWebhookNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposTransferReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"new_owner\"" + ":")
		e.Str(s.NewOwner)
	}
	{
		if s.TeamIds != nil {
			e.Comma()
		}
		if s.TeamIds != nil {
			e.RawStr("\"team_ids\"" + ":")
			e.ArrStart()
			if len(s.TeamIds) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TeamIds[0]
					e.Int(elem)
				}
				for _, elem := range s.TeamIds[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposTransferReq from json.
func (s *ReposTransferReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposTransferReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "new_owner":
			v, err := d.Str()
			s.NewOwner = string(v)
			if err != nil {
				return err
			}
		case "team_ids":
			s.TeamIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.TeamIds = append(s.TeamIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposUpdateApplicationJSONForbidden as json.
func (s ReposUpdateApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateApplicationJSONForbidden from json.
func (s *ReposUpdateApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposUpdateApplicationJSONNotFound as json.
func (s ReposUpdateApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateApplicationJSONNotFound from json.
func (s *ReposUpdateApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposUpdateApplicationJSONTemporaryRedirect as json.
func (s ReposUpdateApplicationJSONTemporaryRedirect) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateApplicationJSONTemporaryRedirect from json.
func (s *ReposUpdateApplicationJSONTemporaryRedirect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateApplicationJSONTemporaryRedirect to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateApplicationJSONTemporaryRedirect(unwrapped)
	return nil
}

// Encode encodes ReposUpdateBranchProtectionApplicationJSONForbidden as json.
func (s ReposUpdateBranchProtectionApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionApplicationJSONForbidden from json.
func (s *ReposUpdateBranchProtectionApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateBranchProtectionApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateBranchProtectionApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposUpdateBranchProtectionApplicationJSONNotFound as json.
func (s ReposUpdateBranchProtectionApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionApplicationJSONNotFound from json.
func (s *ReposUpdateBranchProtectionApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateBranchProtectionApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateBranchProtectionApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateBranchProtectionReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"required_status_checks\"" + ":")
		s.RequiredStatusChecks.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"enforce_admins\"" + ":")
		s.EnforceAdmins.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"required_pull_request_reviews\"" + ":")
		s.RequiredPullRequestReviews.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"restrictions\"" + ":")
		s.Restrictions.Encode(e)
	}
	{
		if s.RequiredLinearHistory.Set {
			e.Comma()
		}
		if s.RequiredLinearHistory.Set {
			e.RawStr("\"required_linear_history\"" + ":")
			s.RequiredLinearHistory.Encode(e)
		}
	}
	{
		if s.AllowForcePushes.Set {
			e.Comma()
		}
		if s.AllowForcePushes.Set {
			e.RawStr("\"allow_force_pushes\"" + ":")
			s.AllowForcePushes.Encode(e)
		}
	}
	{
		if s.AllowDeletions.Set {
			e.Comma()
		}
		if s.AllowDeletions.Set {
			e.RawStr("\"allow_deletions\"" + ":")
			s.AllowDeletions.Encode(e)
		}
	}
	{
		if s.RequiredConversationResolution.Set {
			e.Comma()
		}
		if s.RequiredConversationResolution.Set {
			e.RawStr("\"required_conversation_resolution\"" + ":")
			s.RequiredConversationResolution.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateBranchProtectionReq from json.
func (s *ReposUpdateBranchProtectionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateBranchProtectionReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "required_status_checks":
			if err := s.RequiredStatusChecks.Decode(d); err != nil {
				return err
			}
		case "enforce_admins":
			if err := s.EnforceAdmins.Decode(d); err != nil {
				return err
			}
		case "required_pull_request_reviews":
			if err := s.RequiredPullRequestReviews.Decode(d); err != nil {
				return err
			}
		case "restrictions":
			if err := s.Restrictions.Decode(d); err != nil {
				return err
			}
		case "required_linear_history":
			s.RequiredLinearHistory.Reset()
			if err := s.RequiredLinearHistory.Decode(d); err != nil {
				return err
			}
		case "allow_force_pushes":
			s.AllowForcePushes.Reset()
			if err := s.AllowForcePushes.Decode(d); err != nil {
				return err
			}
		case "allow_deletions":
			s.AllowDeletions.Reset()
			if err := s.AllowDeletions.Decode(d); err != nil {
				return err
			}
		case "required_conversation_resolution":
			s.RequiredConversationResolution.Reset()
			if err := s.RequiredConversationResolution.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateBranchProtectionReqRequiredPullRequestReviews) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DismissalRestrictions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DismissalRestrictions.Set {
			e.RawStr("\"dismissal_restrictions\"" + ":")
			s.DismissalRestrictions.Encode(e)
		}
	}
	{
		if s.DismissStaleReviews.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DismissStaleReviews.Set {
			e.RawStr("\"dismiss_stale_reviews\"" + ":")
			s.DismissStaleReviews.Encode(e)
		}
	}
	{
		if s.RequireCodeOwnerReviews.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequireCodeOwnerReviews.Set {
			e.RawStr("\"require_code_owner_reviews\"" + ":")
			s.RequireCodeOwnerReviews.Encode(e)
		}
	}
	{
		if s.RequiredApprovingReviewCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredApprovingReviewCount.Set {
			e.RawStr("\"required_approving_review_count\"" + ":")
			s.RequiredApprovingReviewCount.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviews from json.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateBranchProtectionReqRequiredPullRequestReviews to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dismissal_restrictions":
			s.DismissalRestrictions.Reset()
			if err := s.DismissalRestrictions.Decode(d); err != nil {
				return err
			}
		case "dismiss_stale_reviews":
			s.DismissStaleReviews.Reset()
			if err := s.DismissStaleReviews.Decode(d); err != nil {
				return err
			}
		case "require_code_owner_reviews":
			s.RequireCodeOwnerReviews.Reset()
			if err := s.RequireCodeOwnerReviews.Decode(d); err != nil {
				return err
			}
		case "required_approving_review_count":
			s.RequiredApprovingReviewCount.Reset()
			if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Users != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Users != nil {
			e.RawStr("\"users\"" + ":")
			e.ArrStart()
			if len(s.Users) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Users[0]
					e.Str(elem)
				}
				for _, elem := range s.Users[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Teams != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Teams != nil {
			e.RawStr("\"teams\"" + ":")
			e.ArrStart()
			if len(s.Teams) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Teams[0]
					e.Str(elem)
				}
				for _, elem := range s.Teams[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions from json.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateBranchProtectionReqRequiredStatusChecks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"strict\"" + ":")
		e.Bool(s.Strict)
	}
	{
		e.Comma()

		e.RawStr("\"contexts\"" + ":")
		e.ArrStart()
		if len(s.Contexts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Contexts[0]
				e.Str(elem)
			}
			for _, elem := range s.Contexts[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredStatusChecks from json.
func (s *ReposUpdateBranchProtectionReqRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateBranchProtectionReqRequiredStatusChecks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strict":
			v, err := d.Bool()
			s.Strict = bool(v)
			if err != nil {
				return err
			}
		case "contexts":
			s.Contexts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Contexts = append(s.Contexts, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateBranchProtectionReqRestrictions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"users\"" + ":")
		e.ArrStart()
		if len(s.Users) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Users[0]
				e.Str(elem)
			}
			for _, elem := range s.Users[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"teams\"" + ":")
		e.ArrStart()
		if len(s.Teams) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Teams[0]
				e.Str(elem)
			}
			for _, elem := range s.Teams[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Apps != nil {
			e.Comma()
		}
		if s.Apps != nil {
			e.RawStr("\"apps\"" + ":")
			e.ArrStart()
			if len(s.Apps) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Apps[0]
					e.Str(elem)
				}
				for _, elem := range s.Apps[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateBranchProtectionReqRestrictions from json.
func (s *ReposUpdateBranchProtectionReqRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateBranchProtectionReqRestrictions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		case "apps":
			s.Apps = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Apps = append(s.Apps, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateCommitCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateCommitCommentReq from json.
func (s *ReposUpdateCommitCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateCommitCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateInvitationReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Permissions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateInvitationReq from json.
func (s *ReposUpdateInvitationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateInvitationReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposUpdateInvitationReqPermissions as json.
func (s ReposUpdateInvitationReqPermissions) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposUpdateInvitationReqPermissions from json.
func (s *ReposUpdateInvitationReqPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateInvitationReqPermissions to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposUpdateInvitationReqPermissions(v) {
	case ReposUpdateInvitationReqPermissionsRead:
		*s = ReposUpdateInvitationReqPermissionsRead
	case ReposUpdateInvitationReqPermissionsWrite:
		*s = ReposUpdateInvitationReqPermissionsWrite
	case ReposUpdateInvitationReqPermissionsMaintain:
		*s = ReposUpdateInvitationReqPermissionsMaintain
	case ReposUpdateInvitationReqPermissionsTriage:
		*s = ReposUpdateInvitationReqPermissionsTriage
	case ReposUpdateInvitationReqPermissionsAdmin:
		*s = ReposUpdateInvitationReqPermissionsAdmin
	default:
		*s = ReposUpdateInvitationReqPermissions(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdatePullRequestReviewProtectionReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DismissalRestrictions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DismissalRestrictions.Set {
			e.RawStr("\"dismissal_restrictions\"" + ":")
			s.DismissalRestrictions.Encode(e)
		}
	}
	{
		if s.DismissStaleReviews.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DismissStaleReviews.Set {
			e.RawStr("\"dismiss_stale_reviews\"" + ":")
			s.DismissStaleReviews.Encode(e)
		}
	}
	{
		if s.RequireCodeOwnerReviews.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequireCodeOwnerReviews.Set {
			e.RawStr("\"require_code_owner_reviews\"" + ":")
			s.RequireCodeOwnerReviews.Encode(e)
		}
	}
	{
		if s.RequiredApprovingReviewCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredApprovingReviewCount.Set {
			e.RawStr("\"required_approving_review_count\"" + ":")
			s.RequiredApprovingReviewCount.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdatePullRequestReviewProtectionReq from json.
func (s *ReposUpdatePullRequestReviewProtectionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdatePullRequestReviewProtectionReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dismissal_restrictions":
			s.DismissalRestrictions.Reset()
			if err := s.DismissalRestrictions.Decode(d); err != nil {
				return err
			}
		case "dismiss_stale_reviews":
			s.DismissStaleReviews.Reset()
			if err := s.DismissStaleReviews.Decode(d); err != nil {
				return err
			}
		case "require_code_owner_reviews":
			s.RequireCodeOwnerReviews.Reset()
			if err := s.RequireCodeOwnerReviews.Decode(d); err != nil {
				return err
			}
		case "required_approving_review_count":
			s.RequiredApprovingReviewCount.Reset()
			if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Users != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Users != nil {
			e.RawStr("\"users\"" + ":")
			e.ArrStart()
			if len(s.Users) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Users[0]
					e.Str(elem)
				}
				for _, elem := range s.Users[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Teams != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Teams != nil {
			e.RawStr("\"teams\"" + ":")
			e.ArrStart()
			if len(s.Teams) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Teams[0]
					e.Str(elem)
				}
				for _, elem := range s.Teams[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions from json.
func (s *ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateReleaseAssetReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Label.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Label.Set {
			e.RawStr("\"label\"" + ":")
			s.Label.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateReleaseAssetReq from json.
func (s *ReposUpdateReleaseAssetReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateReleaseAssetReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "label":
			s.Label.Reset()
			if err := s.Label.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateReleaseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.TagName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TagName.Set {
			e.RawStr("\"tag_name\"" + ":")
			s.TagName.Encode(e)
		}
	}
	{
		if s.TargetCommitish.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TargetCommitish.Set {
			e.RawStr("\"target_commitish\"" + ":")
			s.TargetCommitish.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.Draft.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Draft.Set {
			e.RawStr("\"draft\"" + ":")
			s.Draft.Encode(e)
		}
	}
	{
		if s.Prerelease.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Prerelease.Set {
			e.RawStr("\"prerelease\"" + ":")
			s.Prerelease.Encode(e)
		}
	}
	{
		if s.DiscussionCategoryName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DiscussionCategoryName.Set {
			e.RawStr("\"discussion_category_name\"" + ":")
			s.DiscussionCategoryName.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateReleaseReq from json.
func (s *ReposUpdateReleaseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateReleaseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag_name":
			s.TagName.Reset()
			if err := s.TagName.Decode(d); err != nil {
				return err
			}
		case "target_commitish":
			s.TargetCommitish.Reset()
			if err := s.TargetCommitish.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "draft":
			s.Draft.Reset()
			if err := s.Draft.Decode(d); err != nil {
				return err
			}
		case "prerelease":
			s.Prerelease.Reset()
			if err := s.Prerelease.Decode(d); err != nil {
				return err
			}
		case "discussion_category_name":
			s.DiscussionCategoryName.Reset()
			if err := s.DiscussionCategoryName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Homepage.Set {
			e.RawStr("\"homepage\"" + ":")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Private.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.SecurityAndAnalysis.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecurityAndAnalysis.Set {
			e.RawStr("\"security_and_analysis\"" + ":")
			s.SecurityAndAnalysis.Encode(e)
		}
	}
	{
		if s.HasIssues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasIssues.Set {
			e.RawStr("\"has_issues\"" + ":")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasProjects.Set {
			e.RawStr("\"has_projects\"" + ":")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasWiki.Set {
			e.RawStr("\"has_wiki\"" + ":")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.DefaultBranch.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultBranch.Set {
			e.RawStr("\"default_branch\"" + ":")
			s.DefaultBranch.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Archived.Set {
			e.RawStr("\"archived\"" + ":")
			s.Archived.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateReq from json.
func (s *ReposUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "homepage":
			s.Homepage.Reset()
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "security_and_analysis":
			s.SecurityAndAnalysis.Reset()
			if err := s.SecurityAndAnalysis.Decode(d); err != nil {
				return err
			}
		case "has_issues":
			s.HasIssues.Reset()
			if err := s.HasIssues.Decode(d); err != nil {
				return err
			}
		case "has_projects":
			s.HasProjects.Reset()
			if err := s.HasProjects.Decode(d); err != nil {
				return err
			}
		case "has_wiki":
			s.HasWiki.Reset()
			if err := s.HasWiki.Decode(d); err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "default_branch":
			s.DefaultBranch.Reset()
			if err := s.DefaultBranch.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "archived":
			s.Archived.Reset()
			if err := s.Archived.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateReqSecurityAndAnalysis) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AdvancedSecurity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AdvancedSecurity.Set {
			e.RawStr("\"advanced_security\"" + ":")
			s.AdvancedSecurity.Encode(e)
		}
	}
	{
		if s.SecretScanning.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretScanning.Set {
			e.RawStr("\"secret_scanning\"" + ":")
			s.SecretScanning.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateReqSecurityAndAnalysis from json.
func (s *ReposUpdateReqSecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateReqSecurityAndAnalysis to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "advanced_security":
			s.AdvancedSecurity.Reset()
			if err := s.AdvancedSecurity.Decode(d); err != nil {
				return err
			}
		case "secret_scanning":
			s.SecretScanning.Reset()
			if err := s.SecretScanning.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisAdvancedSecurity from json.
func (s *ReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateReqSecurityAndAnalysisAdvancedSecurity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateReqSecurityAndAnalysisSecretScanning) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisSecretScanning from json.
func (s *ReposUpdateReqSecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateReqSecurityAndAnalysisSecretScanning to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposUpdateReqVisibility as json.
func (s ReposUpdateReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposUpdateReqVisibility from json.
func (s *ReposUpdateReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateReqVisibility to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposUpdateReqVisibility(v) {
	case ReposUpdateReqVisibilityPublic:
		*s = ReposUpdateReqVisibilityPublic
	case ReposUpdateReqVisibilityPrivate:
		*s = ReposUpdateReqVisibilityPrivate
	case ReposUpdateReqVisibilityVisibility:
		*s = ReposUpdateReqVisibilityVisibility
	case ReposUpdateReqVisibilityInternal:
		*s = ReposUpdateReqVisibilityInternal
	default:
		*s = ReposUpdateReqVisibility(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateStatusCheckProtectionReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Strict.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Strict.Set {
			e.RawStr("\"strict\"" + ":")
			s.Strict.Encode(e)
		}
	}
	{
		if s.Contexts != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Contexts != nil {
			e.RawStr("\"contexts\"" + ":")
			e.ArrStart()
			if len(s.Contexts) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Contexts[0]
					e.Str(elem)
				}
				for _, elem := range s.Contexts[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateStatusCheckProtectionReq from json.
func (s *ReposUpdateStatusCheckProtectionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateStatusCheckProtectionReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strict":
			s.Strict.Reset()
			if err := s.Strict.Decode(d); err != nil {
				return err
			}
		case "contexts":
			s.Contexts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Contexts = append(s.Contexts, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateWebhookConfigForRepoReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateWebhookConfigForRepoReq from json.
func (s *ReposUpdateWebhookConfigForRepoReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateWebhookConfigForRepoReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl.Reset()
			if err := s.InsecureSsl.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateWebhookReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Config.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Config.Set {
			e.RawStr("\"config\"" + ":")
			s.Config.Encode(e)
		}
	}
	{
		if s.Events != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Events != nil {
			e.RawStr("\"events\"" + ":")
			e.ArrStart()
			if len(s.Events) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Events[0]
					e.Str(elem)
				}
				for _, elem := range s.Events[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AddEvents != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AddEvents != nil {
			e.RawStr("\"add_events\"" + ":")
			e.ArrStart()
			if len(s.AddEvents) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AddEvents[0]
					e.Str(elem)
				}
				for _, elem := range s.AddEvents[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RemoveEvents != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RemoveEvents != nil {
			e.RawStr("\"remove_events\"" + ":")
			e.ArrStart()
			if len(s.RemoveEvents) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RemoveEvents[0]
					e.Str(elem)
				}
				for _, elem := range s.RemoveEvents[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateWebhookReq from json.
func (s *ReposUpdateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateWebhookReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			s.Config.Reset()
			if err := s.Config.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "add_events":
			s.AddEvents = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AddEvents = append(s.AddEvents, elem)
				return nil
			}); err != nil {
				return err
			}
		case "remove_events":
			s.RemoveEvents = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.RemoveEvents = append(s.RemoveEvents, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateWebhookReqConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		if s.ContentType.Set {
			e.Comma()
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.Comma()
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.Comma()
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	{
		if s.Address.Set {
			e.Comma()
		}
		if s.Address.Set {
			e.RawStr("\"address\"" + ":")
			s.Address.Encode(e)
		}
	}
	{
		if s.Room.Set {
			e.Comma()
		}
		if s.Room.Set {
			e.RawStr("\"room\"" + ":")
			s.Room.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateWebhookReqConfig from json.
func (s *ReposUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateWebhookReqConfig to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.URL = WebhookConfigURL(unwrapped)
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl.Reset()
			if err := s.InsecureSsl.Decode(d); err != nil {
				return err
			}
		case "address":
			s.Address.Reset()
			if err := s.Address.Decode(d); err != nil {
				return err
			}
		case "room":
			s.Room.Reset()
			if err := s.Room.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Repository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		if s.Organization.Set {
			e.Comma()
		}
		if s.Organization.Set {
			e.RawStr("\"organization\"" + ":")
			s.Organization.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"forks\"" + ":")
		e.Int(s.Forks)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		e.Str(s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		e.Comma()

		e.RawStr("\"ssh_url\"" + ":")
		e.Str(s.SSHURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		e.Comma()

		e.RawStr("\"clone_url\"" + ":")
		e.Str(s.CloneURL)
	}
	{
		e.Comma()

		e.RawStr("\"mirror_url\"" + ":")
		s.MirrorURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"svn_url\"" + ":")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		e.Comma()

		e.RawStr("\"homepage\"" + ":")
		s.Homepage.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"language\"" + ":")
		s.Language.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"forks_count\"" + ":")
		e.Int(s.ForksCount)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_count\"" + ":")
		e.Int(s.StargazersCount)
	}
	{
		e.Comma()

		e.RawStr("\"watchers_count\"" + ":")
		e.Int(s.WatchersCount)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"default_branch\"" + ":")
		e.Str(s.DefaultBranch)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues_count\"" + ":")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"has_issues\"" + ":")
		e.Bool(s.HasIssues)
	}
	{
		e.Comma()

		e.RawStr("\"has_projects\"" + ":")
		e.Bool(s.HasProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_wiki\"" + ":")
		e.Bool(s.HasWiki)
	}
	{
		e.Comma()

		e.RawStr("\"has_pages\"" + ":")
		e.Bool(s.HasPages)
	}
	{
		e.Comma()

		e.RawStr("\"has_downloads\"" + ":")
		e.Bool(s.HasDownloads)
	}
	{
		e.Comma()

		e.RawStr("\"archived\"" + ":")
		e.Bool(s.Archived)
	}
	{
		e.Comma()

		e.RawStr("\"disabled\"" + ":")
		e.Bool(s.Disabled)
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pushed_at\"" + ":")
		s.PushedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.Comma()
		}
		if s.TemplateRepository.Set {
			e.RawStr("\"template_repository\"" + ":")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.Comma()
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.Comma()
		}
		if s.SubscribersCount.Set {
			e.RawStr("\"subscribers_count\"" + ":")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.Comma()
		}
		if s.NetworkCount.Set {
			e.RawStr("\"network_count\"" + ":")
			s.NetworkCount.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"watchers\"" + ":")
		e.Int(s.Watchers)
	}
	{
		if s.MasterBranch.Set {
			e.Comma()
		}
		if s.MasterBranch.Set {
			e.RawStr("\"master_branch\"" + ":")
			s.MasterBranch.Encode(e)
		}
	}
	{
		if s.StarredAt.Set {
			e.Comma()
		}
		if s.StarredAt.Set {
			e.RawStr("\"starred_at\"" + ":")
			s.StarredAt.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes Repository from json.
func (s *Repository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Repository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "organization":
			s.Organization.Reset()
			if err := s.Organization.Decode(d); err != nil {
				return err
			}
		case "forks":
			v, err := d.Int()
			s.Forks = int(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "git_url":
			v, err := d.Str()
			s.GitURL = string(v)
			if err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			v, err := d.Str()
			s.SSHURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "clone_url":
			v, err := d.Str()
			s.CloneURL = string(v)
			if err != nil {
				return err
			}
		case "mirror_url":
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "svn_url":
			v, err := json.DecodeURI(d)
			s.SvnURL = v
			if err != nil {
				return err
			}
		case "homepage":
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			v, err := d.Int()
			s.ForksCount = int(v)
			if err != nil {
				return err
			}
		case "stargazers_count":
			v, err := d.Int()
			s.StargazersCount = int(v)
			if err != nil {
				return err
			}
		case "watchers_count":
			v, err := d.Int()
			s.WatchersCount = int(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "default_branch":
			v, err := d.Str()
			s.DefaultBranch = string(v)
			if err != nil {
				return err
			}
		case "open_issues_count":
			v, err := d.Int()
			s.OpenIssuesCount = int(v)
			if err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			v, err := d.Bool()
			s.HasIssues = bool(v)
			if err != nil {
				return err
			}
		case "has_projects":
			v, err := d.Bool()
			s.HasProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_wiki":
			v, err := d.Bool()
			s.HasWiki = bool(v)
			if err != nil {
				return err
			}
		case "has_pages":
			v, err := d.Bool()
			s.HasPages = bool(v)
			if err != nil {
				return err
			}
		case "has_downloads":
			v, err := d.Bool()
			s.HasDownloads = bool(v)
			if err != nil {
				return err
			}
		case "archived":
			v, err := d.Bool()
			s.Archived = bool(v)
			if err != nil {
				return err
			}
		case "disabled":
			v, err := d.Bool()
			s.Disabled = bool(v)
			if err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "created_at":
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "template_repository":
			s.TemplateRepository.Reset()
			if err := s.TemplateRepository.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			s.SubscribersCount.Reset()
			if err := s.SubscribersCount.Decode(d); err != nil {
				return err
			}
		case "network_count":
			s.NetworkCount.Reset()
			if err := s.NetworkCount.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "watchers":
			v, err := d.Int()
			s.Watchers = int(v)
			if err != nil {
				return err
			}
		case "master_branch":
			s.MasterBranch.Reset()
			if err := s.MasterBranch.Decode(d); err != nil {
				return err
			}
		case "starred_at":
			s.StarredAt.Reset()
			if err := s.StarredAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RepositoryCollaboratorPermission) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"permission\"" + ":")
		e.Str(s.Permission)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes RepositoryCollaboratorPermission from json.
func (s *RepositoryCollaboratorPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositoryCollaboratorPermission to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			v, err := d.Str()
			s.Permission = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RepositoryInvitation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"invitee\"" + ":")
		s.Invitee.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"inviter\"" + ":")
		s.Inviter.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"permissions\"" + ":")
		s.Permissions.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.Expired.Set {
			e.Comma()
		}
		if s.Expired.Set {
			e.RawStr("\"expired\"" + ":")
			s.Expired.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		e.Str(s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	e.ObjEnd()
}

// Decode decodes RepositoryInvitation from json.
func (s *RepositoryInvitation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositoryInvitation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "invitee":
			if err := s.Invitee.Decode(d); err != nil {
				return err
			}
		case "inviter":
			if err := s.Inviter.Decode(d); err != nil {
				return err
			}
		case "permissions":
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "expired":
			s.Expired.Reset()
			if err := s.Expired.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := d.Str()
			s.HTMLURL = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes RepositoryInvitationPermissions as json.
func (s RepositoryInvitationPermissions) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes RepositoryInvitationPermissions from json.
func (s *RepositoryInvitationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositoryInvitationPermissions to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RepositoryInvitationPermissions(v) {
	case RepositoryInvitationPermissionsRead:
		*s = RepositoryInvitationPermissionsRead
	case RepositoryInvitationPermissionsWrite:
		*s = RepositoryInvitationPermissionsWrite
	case RepositoryInvitationPermissionsAdmin:
		*s = RepositoryInvitationPermissionsAdmin
	case RepositoryInvitationPermissionsTriage:
		*s = RepositoryInvitationPermissionsTriage
	case RepositoryInvitationPermissionsMaintain:
		*s = RepositoryInvitationPermissionsMaintain
	default:
		*s = RepositoryInvitationPermissions(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	{
		e.Comma()

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes RepositoryPermissions from json.
func (s *RepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RepositorySubscription) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"subscribed\"" + ":")
		e.Bool(s.Subscribed)
	}
	{
		e.Comma()

		e.RawStr("\"ignored\"" + ":")
		e.Bool(s.Ignored)
	}
	{
		e.Comma()

		e.RawStr("\"reason\"" + ":")
		s.Reason.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	e.ObjEnd()
}

// Decode decodes RepositorySubscription from json.
func (s *RepositorySubscription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositorySubscription to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscribed":
			v, err := d.Bool()
			s.Subscribed = bool(v)
			if err != nil {
				return err
			}
		case "ignored":
			v, err := d.Bool()
			s.Ignored = bool(v)
			if err != nil {
				return err
			}
		case "reason":
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := json.DecodeURI(d)
			s.RepositoryURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RepositoryTemplateRepository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.FullName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FullName.Set {
			e.RawStr("\"full_name\"" + ":")
			s.FullName.Encode(e)
		}
	}
	{
		if s.Owner.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Private.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Fork.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fork.Set {
			e.RawStr("\"fork\"" + ":")
			s.Fork.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ArchiveURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ArchiveURL.Set {
			e.RawStr("\"archive_url\"" + ":")
			s.ArchiveURL.Encode(e)
		}
	}
	{
		if s.AssigneesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AssigneesURL.Set {
			e.RawStr("\"assignees_url\"" + ":")
			s.AssigneesURL.Encode(e)
		}
	}
	{
		if s.BlobsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BlobsURL.Set {
			e.RawStr("\"blobs_url\"" + ":")
			s.BlobsURL.Encode(e)
		}
	}
	{
		if s.BranchesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BranchesURL.Set {
			e.RawStr("\"branches_url\"" + ":")
			s.BranchesURL.Encode(e)
		}
	}
	{
		if s.CollaboratorsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CollaboratorsURL.Set {
			e.RawStr("\"collaborators_url\"" + ":")
			s.CollaboratorsURL.Encode(e)
		}
	}
	{
		if s.CommentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommentsURL.Set {
			e.RawStr("\"comments_url\"" + ":")
			s.CommentsURL.Encode(e)
		}
	}
	{
		if s.CommitsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommitsURL.Set {
			e.RawStr("\"commits_url\"" + ":")
			s.CommitsURL.Encode(e)
		}
	}
	{
		if s.CompareURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CompareURL.Set {
			e.RawStr("\"compare_url\"" + ":")
			s.CompareURL.Encode(e)
		}
	}
	{
		if s.ContentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentsURL.Set {
			e.RawStr("\"contents_url\"" + ":")
			s.ContentsURL.Encode(e)
		}
	}
	{
		if s.ContributorsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContributorsURL.Set {
			e.RawStr("\"contributors_url\"" + ":")
			s.ContributorsURL.Encode(e)
		}
	}
	{
		if s.DeploymentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeploymentsURL.Set {
			e.RawStr("\"deployments_url\"" + ":")
			s.DeploymentsURL.Encode(e)
		}
	}
	{
		if s.DownloadsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DownloadsURL.Set {
			e.RawStr("\"downloads_url\"" + ":")
			s.DownloadsURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsURL.Set {
			e.RawStr("\"events_url\"" + ":")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ForksURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForksURL.Set {
			e.RawStr("\"forks_url\"" + ":")
			s.ForksURL.Encode(e)
		}
	}
	{
		if s.GitCommitsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitCommitsURL.Set {
			e.RawStr("\"git_commits_url\"" + ":")
			s.GitCommitsURL.Encode(e)
		}
	}
	{
		if s.GitRefsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitRefsURL.Set {
			e.RawStr("\"git_refs_url\"" + ":")
			s.GitRefsURL.Encode(e)
		}
	}
	{
		if s.GitTagsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitTagsURL.Set {
			e.RawStr("\"git_tags_url\"" + ":")
			s.GitTagsURL.Encode(e)
		}
	}
	{
		if s.GitURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitURL.Set {
			e.RawStr("\"git_url\"" + ":")
			s.GitURL.Encode(e)
		}
	}
	{
		if s.IssueCommentURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IssueCommentURL.Set {
			e.RawStr("\"issue_comment_url\"" + ":")
			s.IssueCommentURL.Encode(e)
		}
	}
	{
		if s.IssueEventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IssueEventsURL.Set {
			e.RawStr("\"issue_events_url\"" + ":")
			s.IssueEventsURL.Encode(e)
		}
	}
	{
		if s.IssuesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IssuesURL.Set {
			e.RawStr("\"issues_url\"" + ":")
			s.IssuesURL.Encode(e)
		}
	}
	{
		if s.KeysURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.KeysURL.Set {
			e.RawStr("\"keys_url\"" + ":")
			s.KeysURL.Encode(e)
		}
	}
	{
		if s.LabelsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LabelsURL.Set {
			e.RawStr("\"labels_url\"" + ":")
			s.LabelsURL.Encode(e)
		}
	}
	{
		if s.LanguagesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LanguagesURL.Set {
			e.RawStr("\"languages_url\"" + ":")
			s.LanguagesURL.Encode(e)
		}
	}
	{
		if s.MergesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MergesURL.Set {
			e.RawStr("\"merges_url\"" + ":")
			s.MergesURL.Encode(e)
		}
	}
	{
		if s.MilestonesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MilestonesURL.Set {
			e.RawStr("\"milestones_url\"" + ":")
			s.MilestonesURL.Encode(e)
		}
	}
	{
		if s.NotificationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NotificationsURL.Set {
			e.RawStr("\"notifications_url\"" + ":")
			s.NotificationsURL.Encode(e)
		}
	}
	{
		if s.PullsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PullsURL.Set {
			e.RawStr("\"pulls_url\"" + ":")
			s.PullsURL.Encode(e)
		}
	}
	{
		if s.ReleasesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReleasesURL.Set {
			e.RawStr("\"releases_url\"" + ":")
			s.ReleasesURL.Encode(e)
		}
	}
	{
		if s.SSHURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SSHURL.Set {
			e.RawStr("\"ssh_url\"" + ":")
			s.SSHURL.Encode(e)
		}
	}
	{
		if s.StargazersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StargazersURL.Set {
			e.RawStr("\"stargazers_url\"" + ":")
			s.StargazersURL.Encode(e)
		}
	}
	{
		if s.StatusesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StatusesURL.Set {
			e.RawStr("\"statuses_url\"" + ":")
			s.StatusesURL.Encode(e)
		}
	}
	{
		if s.SubscribersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscribersURL.Set {
			e.RawStr("\"subscribers_url\"" + ":")
			s.SubscribersURL.Encode(e)
		}
	}
	{
		if s.SubscriptionURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscriptionURL.Set {
			e.RawStr("\"subscription_url\"" + ":")
			s.SubscriptionURL.Encode(e)
		}
	}
	{
		if s.TagsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TagsURL.Set {
			e.RawStr("\"tags_url\"" + ":")
			s.TagsURL.Encode(e)
		}
	}
	{
		if s.TeamsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TeamsURL.Set {
			e.RawStr("\"teams_url\"" + ":")
			s.TeamsURL.Encode(e)
		}
	}
	{
		if s.TreesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TreesURL.Set {
			e.RawStr("\"trees_url\"" + ":")
			s.TreesURL.Encode(e)
		}
	}
	{
		if s.CloneURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CloneURL.Set {
			e.RawStr("\"clone_url\"" + ":")
			s.CloneURL.Encode(e)
		}
	}
	{
		if s.MirrorURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MirrorURL.Set {
			e.RawStr("\"mirror_url\"" + ":")
			s.MirrorURL.Encode(e)
		}
	}
	{
		if s.HooksURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HooksURL.Set {
			e.RawStr("\"hooks_url\"" + ":")
			s.HooksURL.Encode(e)
		}
	}
	{
		if s.SvnURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SvnURL.Set {
			e.RawStr("\"svn_url\"" + ":")
			s.SvnURL.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Homepage.Set {
			e.RawStr("\"homepage\"" + ":")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Language.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Language.Set {
			e.RawStr("\"language\"" + ":")
			s.Language.Encode(e)
		}
	}
	{
		if s.ForksCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForksCount.Set {
			e.RawStr("\"forks_count\"" + ":")
			s.ForksCount.Encode(e)
		}
	}
	{
		if s.StargazersCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StargazersCount.Set {
			e.RawStr("\"stargazers_count\"" + ":")
			s.StargazersCount.Encode(e)
		}
	}
	{
		if s.WatchersCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.WatchersCount.Set {
			e.RawStr("\"watchers_count\"" + ":")
			s.WatchersCount.Encode(e)
		}
	}
	{
		if s.Size.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Size.Set {
			e.RawStr("\"size\"" + ":")
			s.Size.Encode(e)
		}
	}
	{
		if s.DefaultBranch.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultBranch.Set {
			e.RawStr("\"default_branch\"" + ":")
			s.DefaultBranch.Encode(e)
		}
	}
	{
		if s.OpenIssuesCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OpenIssuesCount.Set {
			e.RawStr("\"open_issues_count\"" + ":")
			s.OpenIssuesCount.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.HasIssues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasIssues.Set {
			e.RawStr("\"has_issues\"" + ":")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasProjects.Set {
			e.RawStr("\"has_projects\"" + ":")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasWiki.Set {
			e.RawStr("\"has_wiki\"" + ":")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.HasPages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasPages.Set {
			e.RawStr("\"has_pages\"" + ":")
			s.HasPages.Encode(e)
		}
	}
	{
		if s.HasDownloads.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasDownloads.Set {
			e.RawStr("\"has_downloads\"" + ":")
			s.HasDownloads.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Archived.Set {
			e.RawStr("\"archived\"" + ":")
			s.Archived.Encode(e)
		}
	}
	{
		if s.Disabled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Disabled.Set {
			e.RawStr("\"disabled\"" + ":")
			s.Disabled.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.PushedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PushedAt.Set {
			e.RawStr("\"pushed_at\"" + ":")
			s.PushedAt.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.Permissions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscribersCount.Set {
			e.RawStr("\"subscribers_count\"" + ":")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NetworkCount.Set {
			e.RawStr("\"network_count\"" + ":")
			s.NetworkCount.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes RepositoryTemplateRepository from json.
func (s *RepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositoryTemplateRepository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "full_name":
			s.FullName.Reset()
			if err := s.FullName.Decode(d); err != nil {
				return err
			}
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			s.Fork.Reset()
			if err := s.Fork.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "archive_url":
			s.ArchiveURL.Reset()
			if err := s.ArchiveURL.Decode(d); err != nil {
				return err
			}
		case "assignees_url":
			s.AssigneesURL.Reset()
			if err := s.AssigneesURL.Decode(d); err != nil {
				return err
			}
		case "blobs_url":
			s.BlobsURL.Reset()
			if err := s.BlobsURL.Decode(d); err != nil {
				return err
			}
		case "branches_url":
			s.BranchesURL.Reset()
			if err := s.BranchesURL.Decode(d); err != nil {
				return err
			}
		case "collaborators_url":
			s.CollaboratorsURL.Reset()
			if err := s.CollaboratorsURL.Decode(d); err != nil {
				return err
			}
		case "comments_url":
			s.CommentsURL.Reset()
			if err := s.CommentsURL.Decode(d); err != nil {
				return err
			}
		case "commits_url":
			s.CommitsURL.Reset()
			if err := s.CommitsURL.Decode(d); err != nil {
				return err
			}
		case "compare_url":
			s.CompareURL.Reset()
			if err := s.CompareURL.Decode(d); err != nil {
				return err
			}
		case "contents_url":
			s.ContentsURL.Reset()
			if err := s.ContentsURL.Decode(d); err != nil {
				return err
			}
		case "contributors_url":
			s.ContributorsURL.Reset()
			if err := s.ContributorsURL.Decode(d); err != nil {
				return err
			}
		case "deployments_url":
			s.DeploymentsURL.Reset()
			if err := s.DeploymentsURL.Decode(d); err != nil {
				return err
			}
		case "downloads_url":
			s.DownloadsURL.Reset()
			if err := s.DownloadsURL.Decode(d); err != nil {
				return err
			}
		case "events_url":
			s.EventsURL.Reset()
			if err := s.EventsURL.Decode(d); err != nil {
				return err
			}
		case "forks_url":
			s.ForksURL.Reset()
			if err := s.ForksURL.Decode(d); err != nil {
				return err
			}
		case "git_commits_url":
			s.GitCommitsURL.Reset()
			if err := s.GitCommitsURL.Decode(d); err != nil {
				return err
			}
		case "git_refs_url":
			s.GitRefsURL.Reset()
			if err := s.GitRefsURL.Decode(d); err != nil {
				return err
			}
		case "git_tags_url":
			s.GitTagsURL.Reset()
			if err := s.GitTagsURL.Decode(d); err != nil {
				return err
			}
		case "git_url":
			s.GitURL.Reset()
			if err := s.GitURL.Decode(d); err != nil {
				return err
			}
		case "issue_comment_url":
			s.IssueCommentURL.Reset()
			if err := s.IssueCommentURL.Decode(d); err != nil {
				return err
			}
		case "issue_events_url":
			s.IssueEventsURL.Reset()
			if err := s.IssueEventsURL.Decode(d); err != nil {
				return err
			}
		case "issues_url":
			s.IssuesURL.Reset()
			if err := s.IssuesURL.Decode(d); err != nil {
				return err
			}
		case "keys_url":
			s.KeysURL.Reset()
			if err := s.KeysURL.Decode(d); err != nil {
				return err
			}
		case "labels_url":
			s.LabelsURL.Reset()
			if err := s.LabelsURL.Decode(d); err != nil {
				return err
			}
		case "languages_url":
			s.LanguagesURL.Reset()
			if err := s.LanguagesURL.Decode(d); err != nil {
				return err
			}
		case "merges_url":
			s.MergesURL.Reset()
			if err := s.MergesURL.Decode(d); err != nil {
				return err
			}
		case "milestones_url":
			s.MilestonesURL.Reset()
			if err := s.MilestonesURL.Decode(d); err != nil {
				return err
			}
		case "notifications_url":
			s.NotificationsURL.Reset()
			if err := s.NotificationsURL.Decode(d); err != nil {
				return err
			}
		case "pulls_url":
			s.PullsURL.Reset()
			if err := s.PullsURL.Decode(d); err != nil {
				return err
			}
		case "releases_url":
			s.ReleasesURL.Reset()
			if err := s.ReleasesURL.Decode(d); err != nil {
				return err
			}
		case "ssh_url":
			s.SSHURL.Reset()
			if err := s.SSHURL.Decode(d); err != nil {
				return err
			}
		case "stargazers_url":
			s.StargazersURL.Reset()
			if err := s.StargazersURL.Decode(d); err != nil {
				return err
			}
		case "statuses_url":
			s.StatusesURL.Reset()
			if err := s.StatusesURL.Decode(d); err != nil {
				return err
			}
		case "subscribers_url":
			s.SubscribersURL.Reset()
			if err := s.SubscribersURL.Decode(d); err != nil {
				return err
			}
		case "subscription_url":
			s.SubscriptionURL.Reset()
			if err := s.SubscriptionURL.Decode(d); err != nil {
				return err
			}
		case "tags_url":
			s.TagsURL.Reset()
			if err := s.TagsURL.Decode(d); err != nil {
				return err
			}
		case "teams_url":
			s.TeamsURL.Reset()
			if err := s.TeamsURL.Decode(d); err != nil {
				return err
			}
		case "trees_url":
			s.TreesURL.Reset()
			if err := s.TreesURL.Decode(d); err != nil {
				return err
			}
		case "clone_url":
			s.CloneURL.Reset()
			if err := s.CloneURL.Decode(d); err != nil {
				return err
			}
		case "mirror_url":
			s.MirrorURL.Reset()
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			s.HooksURL.Reset()
			if err := s.HooksURL.Decode(d); err != nil {
				return err
			}
		case "svn_url":
			s.SvnURL.Reset()
			if err := s.SvnURL.Decode(d); err != nil {
				return err
			}
		case "homepage":
			s.Homepage.Reset()
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			s.Language.Reset()
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			s.ForksCount.Reset()
			if err := s.ForksCount.Decode(d); err != nil {
				return err
			}
		case "stargazers_count":
			s.StargazersCount.Reset()
			if err := s.StargazersCount.Decode(d); err != nil {
				return err
			}
		case "watchers_count":
			s.WatchersCount.Reset()
			if err := s.WatchersCount.Decode(d); err != nil {
				return err
			}
		case "size":
			s.Size.Reset()
			if err := s.Size.Decode(d); err != nil {
				return err
			}
		case "default_branch":
			s.DefaultBranch.Reset()
			if err := s.DefaultBranch.Decode(d); err != nil {
				return err
			}
		case "open_issues_count":
			s.OpenIssuesCount.Reset()
			if err := s.OpenIssuesCount.Decode(d); err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			s.HasIssues.Reset()
			if err := s.HasIssues.Decode(d); err != nil {
				return err
			}
		case "has_projects":
			s.HasProjects.Reset()
			if err := s.HasProjects.Decode(d); err != nil {
				return err
			}
		case "has_wiki":
			s.HasWiki.Reset()
			if err := s.HasWiki.Decode(d); err != nil {
				return err
			}
		case "has_pages":
			s.HasPages.Reset()
			if err := s.HasPages.Decode(d); err != nil {
				return err
			}
		case "has_downloads":
			s.HasDownloads.Reset()
			if err := s.HasDownloads.Decode(d); err != nil {
				return err
			}
		case "archived":
			s.Archived.Reset()
			if err := s.Archived.Decode(d); err != nil {
				return err
			}
		case "disabled":
			s.Disabled.Reset()
			if err := s.Disabled.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			s.PushedAt.Reset()
			if err := s.PushedAt.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			s.SubscribersCount.Reset()
			if err := s.SubscribersCount.Decode(d); err != nil {
				return err
			}
		case "network_count":
			s.NetworkCount.Reset()
			if err := s.NetworkCount.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RepositoryTemplateRepositoryOwner) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Login.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Login.Set {
			e.RawStr("\"login\"" + ":")
			s.Login.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvatarURL.Set {
			e.RawStr("\"avatar_url\"" + ":")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.GravatarID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GravatarID.Set {
			e.RawStr("\"gravatar_id\"" + ":")
			s.GravatarID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.FollowersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowersURL.Set {
			e.RawStr("\"followers_url\"" + ":")
			s.FollowersURL.Encode(e)
		}
	}
	{
		if s.FollowingURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowingURL.Set {
			e.RawStr("\"following_url\"" + ":")
			s.FollowingURL.Encode(e)
		}
	}
	{
		if s.GistsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GistsURL.Set {
			e.RawStr("\"gists_url\"" + ":")
			s.GistsURL.Encode(e)
		}
	}
	{
		if s.StarredURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StarredURL.Set {
			e.RawStr("\"starred_url\"" + ":")
			s.StarredURL.Encode(e)
		}
	}
	{
		if s.SubscriptionsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscriptionsURL.Set {
			e.RawStr("\"subscriptions_url\"" + ":")
			s.SubscriptionsURL.Encode(e)
		}
	}
	{
		if s.OrganizationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationsURL.Set {
			e.RawStr("\"organizations_url\"" + ":")
			s.OrganizationsURL.Encode(e)
		}
	}
	{
		if s.ReposURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReposURL.Set {
			e.RawStr("\"repos_url\"" + ":")
			s.ReposURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsURL.Set {
			e.RawStr("\"events_url\"" + ":")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ReceivedEventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReceivedEventsURL.Set {
			e.RawStr("\"received_events_url\"" + ":")
			s.ReceivedEventsURL.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.SiteAdmin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SiteAdmin.Set {
			e.RawStr("\"site_admin\"" + ":")
			s.SiteAdmin.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes RepositoryTemplateRepositoryOwner from json.
func (s *RepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositoryTemplateRepositoryOwner to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			s.Login.Reset()
			if err := s.Login.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "avatar_url":
			s.AvatarURL.Reset()
			if err := s.AvatarURL.Decode(d); err != nil {
				return err
			}
		case "gravatar_id":
			s.GravatarID.Reset()
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "followers_url":
			s.FollowersURL.Reset()
			if err := s.FollowersURL.Decode(d); err != nil {
				return err
			}
		case "following_url":
			s.FollowingURL.Reset()
			if err := s.FollowingURL.Decode(d); err != nil {
				return err
			}
		case "gists_url":
			s.GistsURL.Reset()
			if err := s.GistsURL.Decode(d); err != nil {
				return err
			}
		case "starred_url":
			s.StarredURL.Reset()
			if err := s.StarredURL.Decode(d); err != nil {
				return err
			}
		case "subscriptions_url":
			s.SubscriptionsURL.Reset()
			if err := s.SubscriptionsURL.Decode(d); err != nil {
				return err
			}
		case "organizations_url":
			s.OrganizationsURL.Reset()
			if err := s.OrganizationsURL.Decode(d); err != nil {
				return err
			}
		case "repos_url":
			s.ReposURL.Reset()
			if err := s.ReposURL.Decode(d); err != nil {
				return err
			}
		case "events_url":
			s.EventsURL.Reset()
			if err := s.EventsURL.Decode(d); err != nil {
				return err
			}
		case "received_events_url":
			s.ReceivedEventsURL.Reset()
			if err := s.ReceivedEventsURL.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "site_admin":
			s.SiteAdmin.Reset()
			if err := s.SiteAdmin.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RepositoryTemplateRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Admin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Admin.Set {
			e.RawStr("\"admin\"" + ":")
			s.Admin.Encode(e)
		}
	}
	{
		if s.Maintain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		if s.Push.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Push.Set {
			e.RawStr("\"push\"" + ":")
			s.Push.Encode(e)
		}
	}
	{
		if s.Triage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		if s.Pull.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pull.Set {
			e.RawStr("\"pull\"" + ":")
			s.Pull.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes RepositoryTemplateRepositoryPermissions from json.
func (s *RepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositoryTemplateRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			s.Admin.Reset()
			if err := s.Admin.Decode(d); err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			s.Push.Reset()
			if err := s.Push.Decode(d); err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			s.Pull.Reset()
			if err := s.Pull.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReviewComment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request_review_id\"" + ":")
		s.PullRequestReviewID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"diff_hunk\"" + ":")
		e.Str(s.DiffHunk)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"position\"" + ":")
		s.Position.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"original_position\"" + ":")
		e.Int(s.OriginalPosition)
	}
	{
		e.Comma()

		e.RawStr("\"commit_id\"" + ":")
		e.Str(s.CommitID)
	}
	{
		e.Comma()

		e.RawStr("\"original_commit_id\"" + ":")
		e.Str(s.OriginalCommitID)
	}
	{
		if s.InReplyToID.Set {
			e.Comma()
		}
		if s.InReplyToID.Set {
			e.RawStr("\"in_reply_to_id\"" + ":")
			s.InReplyToID.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request_url\"" + ":")
		json.EncodeURI(e, s.PullRequestURL)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	{
		if s.Side.Set {
			e.Comma()
		}
		if s.Side.Set {
			e.RawStr("\"side\"" + ":")
			s.Side.Encode(e)
		}
	}
	{
		if s.StartSide.Set {
			e.Comma()
		}
		if s.StartSide.Set {
			e.RawStr("\"start_side\"" + ":")
			s.StartSide.Encode(e)
		}
	}
	{
		if s.Line.Set {
			e.Comma()
		}
		if s.Line.Set {
			e.RawStr("\"line\"" + ":")
			s.Line.Encode(e)
		}
	}
	{
		if s.OriginalLine.Set {
			e.Comma()
		}
		if s.OriginalLine.Set {
			e.RawStr("\"original_line\"" + ":")
			s.OriginalLine.Encode(e)
		}
	}
	{
		if s.StartLine.Set {
			e.Comma()
		}
		if s.StartLine.Set {
			e.RawStr("\"start_line\"" + ":")
			s.StartLine.Encode(e)
		}
	}
	{
		if s.OriginalStartLine.Set {
			e.Comma()
		}
		if s.OriginalStartLine.Set {
			e.RawStr("\"original_start_line\"" + ":")
			s.OriginalStartLine.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ReviewComment from json.
func (s *ReviewComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReviewComment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "pull_request_review_id":
			if err := s.PullRequestReviewID.Decode(d); err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "diff_hunk":
			v, err := d.Str()
			s.DiffHunk = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "position":
			if err := s.Position.Decode(d); err != nil {
				return err
			}
		case "original_position":
			v, err := d.Int()
			s.OriginalPosition = int(v)
			if err != nil {
				return err
			}
		case "commit_id":
			v, err := d.Str()
			s.CommitID = string(v)
			if err != nil {
				return err
			}
		case "original_commit_id":
			v, err := d.Str()
			s.OriginalCommitID = string(v)
			if err != nil {
				return err
			}
		case "in_reply_to_id":
			s.InReplyToID.Reset()
			if err := s.InReplyToID.Decode(d); err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "pull_request_url":
			v, err := json.DecodeURI(d)
			s.PullRequestURL = v
			if err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "body_text":
			s.BodyText.Reset()
			if err := s.BodyText.Decode(d); err != nil {
				return err
			}
		case "body_html":
			s.BodyHTML.Reset()
			if err := s.BodyHTML.Decode(d); err != nil {
				return err
			}
		case "reactions":
			s.Reactions.Reset()
			if err := s.Reactions.Decode(d); err != nil {
				return err
			}
		case "side":
			s.Side.Reset()
			if err := s.Side.Decode(d); err != nil {
				return err
			}
		case "start_side":
			s.StartSide.Reset()
			if err := s.StartSide.Decode(d); err != nil {
				return err
			}
		case "line":
			s.Line.Reset()
			if err := s.Line.Decode(d); err != nil {
				return err
			}
		case "original_line":
			s.OriginalLine.Reset()
			if err := s.OriginalLine.Decode(d); err != nil {
				return err
			}
		case "start_line":
			s.StartLine.Reset()
			if err := s.StartLine.Decode(d); err != nil {
				return err
			}
		case "original_start_line":
			s.OriginalStartLine.Reset()
			if err := s.OriginalStartLine.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReviewCommentLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"self\"" + ":")
		s.Self.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html\"" + ":")
		s.HTML.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request\"" + ":")
		s.PullRequest.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReviewCommentLinks from json.
func (s *ReviewCommentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReviewCommentLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			if err := s.Self.Decode(d); err != nil {
				return err
			}
		case "html":
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		case "pull_request":
			if err := s.PullRequest.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReviewCommentSide as json.
func (s ReviewCommentSide) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReviewCommentSide from json.
func (s *ReviewCommentSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReviewCommentSide to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReviewCommentSide(v) {
	case ReviewCommentSideLEFT:
		*s = ReviewCommentSideLEFT
	case ReviewCommentSideRIGHT:
		*s = ReviewCommentSideRIGHT
	default:
		*s = ReviewCommentSide(v)
	}

	return nil
}

// Encode encodes ReviewCommentStartSide as json.
func (s ReviewCommentStartSide) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReviewCommentStartSide from json.
func (s *ReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReviewCommentStartSide to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReviewCommentStartSide(v) {
	case ReviewCommentStartSideLEFT:
		*s = ReviewCommentStartSideLEFT
	case ReviewCommentStartSideRIGHT:
		*s = ReviewCommentStartSideRIGHT
	default:
		*s = ReviewCommentStartSide(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Runner) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"os\"" + ":")
		e.Str(s.Os)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"busy\"" + ":")
		e.Bool(s.Busy)
	}
	{
		e.Comma()

		e.RawStr("\"labels\"" + ":")
		e.ArrStart()
		if len(s.Labels) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Labels[0]
				elem.Encode(e)
			}
			for _, elem := range s.Labels[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes Runner from json.
func (s *Runner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Runner to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "os":
			v, err := d.Str()
			s.Os = string(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "busy":
			v, err := d.Bool()
			s.Busy = bool(v)
			if err != nil {
				return err
			}
		case "labels":
			s.Labels = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem RunnerLabelsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Labels = append(s.Labels, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RunnerApplication) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"os\"" + ":")
		e.Str(s.Os)
	}
	{
		e.Comma()

		e.RawStr("\"architecture\"" + ":")
		e.Str(s.Architecture)
	}
	{
		e.Comma()

		e.RawStr("\"download_url\"" + ":")
		e.Str(s.DownloadURL)
	}
	{
		e.Comma()

		e.RawStr("\"filename\"" + ":")
		e.Str(s.Filename)
	}
	{
		if s.TempDownloadToken.Set {
			e.Comma()
		}
		if s.TempDownloadToken.Set {
			e.RawStr("\"temp_download_token\"" + ":")
			s.TempDownloadToken.Encode(e)
		}
	}
	{
		if s.SHA256Checksum.Set {
			e.Comma()
		}
		if s.SHA256Checksum.Set {
			e.RawStr("\"sha256_checksum\"" + ":")
			s.SHA256Checksum.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes RunnerApplication from json.
func (s *RunnerApplication) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RunnerApplication to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "os":
			v, err := d.Str()
			s.Os = string(v)
			if err != nil {
				return err
			}
		case "architecture":
			v, err := d.Str()
			s.Architecture = string(v)
			if err != nil {
				return err
			}
		case "download_url":
			v, err := d.Str()
			s.DownloadURL = string(v)
			if err != nil {
				return err
			}
		case "filename":
			v, err := d.Str()
			s.Filename = string(v)
			if err != nil {
				return err
			}
		case "temp_download_token":
			s.TempDownloadToken.Reset()
			if err := s.TempDownloadToken.Decode(d); err != nil {
				return err
			}
		case "sha256_checksum":
			s.SHA256Checksum.Reset()
			if err := s.SHA256Checksum.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RunnerGroupsEnterprise) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Float64(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"visibility\"" + ":")
		e.Str(s.Visibility)
	}
	{
		e.Comma()

		e.RawStr("\"default\"" + ":")
		e.Bool(s.Default)
	}
	{
		if s.SelectedOrganizationsURL.Set {
			e.Comma()
		}
		if s.SelectedOrganizationsURL.Set {
			e.RawStr("\"selected_organizations_url\"" + ":")
			s.SelectedOrganizationsURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"runners_url\"" + ":")
		e.Str(s.RunnersURL)
	}
	{
		e.Comma()

		e.RawStr("\"allows_public_repositories\"" + ":")
		e.Bool(s.AllowsPublicRepositories)
	}
	e.ObjEnd()
}

// Decode decodes RunnerGroupsEnterprise from json.
func (s *RunnerGroupsEnterprise) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RunnerGroupsEnterprise to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Float64()
			s.ID = float64(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "visibility":
			v, err := d.Str()
			s.Visibility = string(v)
			if err != nil {
				return err
			}
		case "default":
			v, err := d.Bool()
			s.Default = bool(v)
			if err != nil {
				return err
			}
		case "selected_organizations_url":
			s.SelectedOrganizationsURL.Reset()
			if err := s.SelectedOrganizationsURL.Decode(d); err != nil {
				return err
			}
		case "runners_url":
			v, err := d.Str()
			s.RunnersURL = string(v)
			if err != nil {
				return err
			}
		case "allows_public_repositories":
			v, err := d.Bool()
			s.AllowsPublicRepositories = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RunnerGroupsOrg) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Float64(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"visibility\"" + ":")
		e.Str(s.Visibility)
	}
	{
		e.Comma()

		e.RawStr("\"default\"" + ":")
		e.Bool(s.Default)
	}
	{
		if s.SelectedRepositoriesURL.Set {
			e.Comma()
		}
		if s.SelectedRepositoriesURL.Set {
			e.RawStr("\"selected_repositories_url\"" + ":")
			s.SelectedRepositoriesURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"runners_url\"" + ":")
		e.Str(s.RunnersURL)
	}
	{
		e.Comma()

		e.RawStr("\"inherited\"" + ":")
		e.Bool(s.Inherited)
	}
	{
		if s.InheritedAllowsPublicRepositories.Set {
			e.Comma()
		}
		if s.InheritedAllowsPublicRepositories.Set {
			e.RawStr("\"inherited_allows_public_repositories\"" + ":")
			s.InheritedAllowsPublicRepositories.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"allows_public_repositories\"" + ":")
		e.Bool(s.AllowsPublicRepositories)
	}
	e.ObjEnd()
}

// Decode decodes RunnerGroupsOrg from json.
func (s *RunnerGroupsOrg) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RunnerGroupsOrg to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Float64()
			s.ID = float64(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "visibility":
			v, err := d.Str()
			s.Visibility = string(v)
			if err != nil {
				return err
			}
		case "default":
			v, err := d.Bool()
			s.Default = bool(v)
			if err != nil {
				return err
			}
		case "selected_repositories_url":
			s.SelectedRepositoriesURL.Reset()
			if err := s.SelectedRepositoriesURL.Decode(d); err != nil {
				return err
			}
		case "runners_url":
			v, err := d.Str()
			s.RunnersURL = string(v)
			if err != nil {
				return err
			}
		case "inherited":
			v, err := d.Bool()
			s.Inherited = bool(v)
			if err != nil {
				return err
			}
		case "inherited_allows_public_repositories":
			s.InheritedAllowsPublicRepositories.Reset()
			if err := s.InheritedAllowsPublicRepositories.Decode(d); err != nil {
				return err
			}
		case "allows_public_repositories":
			v, err := d.Bool()
			s.AllowsPublicRepositories = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RunnerLabelsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes RunnerLabelsItem from json.
func (s *RunnerLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RunnerLabelsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes RunnerLabelsItemType as json.
func (s RunnerLabelsItemType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes RunnerLabelsItemType from json.
func (s *RunnerLabelsItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RunnerLabelsItemType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RunnerLabelsItemType(v) {
	case RunnerLabelsItemTypeReadMinusOnly:
		*s = RunnerLabelsItemTypeReadMinusOnly
	case RunnerLabelsItemTypeCustom:
		*s = RunnerLabelsItemTypeCustom
	default:
		*s = RunnerLabelsItemType(v)
	}

	return nil
}

// Encode encodes ScimDeleteUserFromOrgApplicationJSONForbidden as json.
func (s ScimDeleteUserFromOrgApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := ScimError(s)
	unwrapped.Encode(e)
}

// Decode decodes ScimDeleteUserFromOrgApplicationJSONForbidden from json.
func (s *ScimDeleteUserFromOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimDeleteUserFromOrgApplicationJSONForbidden to nil`)
	}
	var unwrapped ScimError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ScimDeleteUserFromOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ScimDeleteUserFromOrgApplicationJSONNotFound as json.
func (s ScimDeleteUserFromOrgApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := ScimError(s)
	unwrapped.Encode(e)
}

// Decode decodes ScimDeleteUserFromOrgApplicationJSONNotFound from json.
func (s *ScimDeleteUserFromOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimDeleteUserFromOrgApplicationJSONNotFound to nil`)
	}
	var unwrapped ScimError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ScimDeleteUserFromOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ScimDeleteUserFromOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes ScimDeleteUserFromOrgNoContent from json.
func (s *ScimDeleteUserFromOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimDeleteUserFromOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseGroup) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		if s.ExternalId.Set {
			e.Comma()
		}
		if s.ExternalId.Set {
			e.RawStr("\"externalId\"" + ":")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.DisplayName.Set {
			e.Comma()
		}
		if s.DisplayName.Set {
			e.RawStr("\"displayName\"" + ":")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.Members != nil {
			e.Comma()
		}
		if s.Members != nil {
			e.RawStr("\"members\"" + ":")
			e.ArrStart()
			if len(s.Members) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Members[0]
					elem.Encode(e)
				}
				for _, elem := range s.Members[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.Comma()
		}
		if s.Meta.Set {
			e.RawStr("\"meta\"" + ":")
			s.Meta.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseGroup from json.
func (s *ScimEnterpriseGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseGroup to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "externalId":
			s.ExternalId.Reset()
			if err := s.ExternalId.Decode(d); err != nil {
				return err
			}
		case "displayName":
			s.DisplayName.Reset()
			if err := s.DisplayName.Decode(d); err != nil {
				return err
			}
		case "members":
			s.Members = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimEnterpriseGroupMembersItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Members = append(s.Members, elem)
				return nil
			}); err != nil {
				return err
			}
		case "meta":
			s.Meta.Reset()
			if err := s.Meta.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseGroupMembersItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	{
		if s.Ref.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ref.Set {
			e.RawStr("\"$ref\"" + ":")
			s.Ref.Encode(e)
		}
	}
	{
		if s.Display.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Display.Set {
			e.RawStr("\"display\"" + ":")
			s.Display.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseGroupMembersItem from json.
func (s *ScimEnterpriseGroupMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseGroupMembersItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		case "$ref":
			s.Ref.Reset()
			if err := s.Ref.Decode(d); err != nil {
				return err
			}
		case "display":
			s.Display.Reset()
			if err := s.Display.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseGroupMeta) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ResourceType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceType.Set {
			e.RawStr("\"resourceType\"" + ":")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.Created.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Created.Set {
			e.RawStr("\"created\"" + ":")
			s.Created.Encode(e)
		}
	}
	{
		if s.LastModified.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastModified.Set {
			e.RawStr("\"lastModified\"" + ":")
			s.LastModified.Encode(e)
		}
	}
	{
		if s.Location.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseGroupMeta from json.
func (s *ScimEnterpriseGroupMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseGroupMeta to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			s.ResourceType.Reset()
			if err := s.ResourceType.Decode(d); err != nil {
				return err
			}
		case "created":
			s.Created.Reset()
			if err := s.Created.Decode(d); err != nil {
				return err
			}
		case "lastModified":
			s.LastModified.Reset()
			if err := s.LastModified.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		if s.ExternalId.Set {
			e.Comma()
		}
		if s.ExternalId.Set {
			e.RawStr("\"externalId\"" + ":")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.UserName.Set {
			e.Comma()
		}
		if s.UserName.Set {
			e.RawStr("\"userName\"" + ":")
			s.UserName.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Emails != nil {
			e.Comma()
		}
		if s.Emails != nil {
			e.RawStr("\"emails\"" + ":")
			e.ArrStart()
			if len(s.Emails) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Emails[0]
					elem.Encode(e)
				}
				for _, elem := range s.Emails[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Groups != nil {
			e.Comma()
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					elem.Encode(e)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.Comma()
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if s.Meta.Set {
			e.Comma()
		}
		if s.Meta.Set {
			e.RawStr("\"meta\"" + ":")
			s.Meta.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseUser from json.
func (s *ScimEnterpriseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "externalId":
			s.ExternalId.Reset()
			if err := s.ExternalId.Decode(d); err != nil {
				return err
			}
		case "userName":
			s.UserName.Reset()
			if err := s.UserName.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimEnterpriseUserEmailsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimEnterpriseUserGroupsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		case "meta":
			s.Meta.Reset()
			if err := s.Meta.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseUserEmailsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.Primary.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Primary.Set {
			e.RawStr("\"primary\"" + ":")
			s.Primary.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseUserEmailsItem from json.
func (s *ScimEnterpriseUserEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseUserEmailsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "primary":
			s.Primary.Reset()
			if err := s.Primary.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseUserGroupsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseUserGroupsItem from json.
func (s *ScimEnterpriseUserGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseUserGroupsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseUserMeta) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ResourceType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceType.Set {
			e.RawStr("\"resourceType\"" + ":")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.Created.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Created.Set {
			e.RawStr("\"created\"" + ":")
			s.Created.Encode(e)
		}
	}
	{
		if s.LastModified.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastModified.Set {
			e.RawStr("\"lastModified\"" + ":")
			s.LastModified.Encode(e)
		}
	}
	{
		if s.Location.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseUserMeta from json.
func (s *ScimEnterpriseUserMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseUserMeta to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			s.ResourceType.Reset()
			if err := s.ResourceType.Decode(d); err != nil {
				return err
			}
		case "created":
			s.Created.Reset()
			if err := s.Created.Decode(d); err != nil {
				return err
			}
		case "lastModified":
			s.LastModified.Reset()
			if err := s.LastModified.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseUserName) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.GivenName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GivenName.Set {
			e.RawStr("\"givenName\"" + ":")
			s.GivenName.Encode(e)
		}
	}
	{
		if s.FamilyName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FamilyName.Set {
			e.RawStr("\"familyName\"" + ":")
			s.FamilyName.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseUserName from json.
func (s *ScimEnterpriseUserName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseUserName to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			s.GivenName.Reset()
			if err := s.GivenName.Decode(d); err != nil {
				return err
			}
		case "familyName":
			s.FamilyName.Reset()
			if err := s.FamilyName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimError) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Detail.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Detail.Set {
			e.RawStr("\"detail\"" + ":")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	{
		if s.ScimType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ScimType.Set {
			e.RawStr("\"scimType\"" + ":")
			s.ScimType.Encode(e)
		}
	}
	{
		if s.Schemas != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Schemas != nil {
			e.RawStr("\"schemas\"" + ":")
			e.ArrStart()
			if len(s.Schemas) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Schemas[0]
					e.Str(elem)
				}
				for _, elem := range s.Schemas[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimError from json.
func (s *ScimError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimError to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		case "detail":
			s.Detail.Reset()
			if err := s.Detail.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "scimType":
			s.ScimType.Reset()
			if err := s.ScimType.Decode(d); err != nil {
				return err
			}
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimGroupListEnterprise) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"totalResults\"" + ":")
		e.Float64(s.TotalResults)
	}
	{
		e.Comma()

		e.RawStr("\"itemsPerPage\"" + ":")
		e.Float64(s.ItemsPerPage)
	}
	{
		e.Comma()

		e.RawStr("\"startIndex\"" + ":")
		e.Float64(s.StartIndex)
	}
	{
		e.Comma()

		e.RawStr("\"Resources\"" + ":")
		e.ArrStart()
		if len(s.Resources) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Resources[0]
				elem.Encode(e)
			}
			for _, elem := range s.Resources[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ScimGroupListEnterprise from json.
func (s *ScimGroupListEnterprise) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimGroupListEnterprise to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "totalResults":
			v, err := d.Float64()
			s.TotalResults = float64(v)
			if err != nil {
				return err
			}
		case "itemsPerPage":
			v, err := d.Float64()
			s.ItemsPerPage = float64(v)
			if err != nil {
				return err
			}
		case "startIndex":
			v, err := d.Float64()
			s.StartIndex = float64(v)
			if err != nil {
				return err
			}
		case "Resources":
			s.Resources = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimGroupListEnterpriseResourcesItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Resources = append(s.Resources, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimGroupListEnterpriseResourcesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		if s.ExternalId.Set {
			e.Comma()
		}
		if s.ExternalId.Set {
			e.RawStr("\"externalId\"" + ":")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.DisplayName.Set {
			e.Comma()
		}
		if s.DisplayName.Set {
			e.RawStr("\"displayName\"" + ":")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.Members != nil {
			e.Comma()
		}
		if s.Members != nil {
			e.RawStr("\"members\"" + ":")
			e.ArrStart()
			if len(s.Members) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Members[0]
					elem.Encode(e)
				}
				for _, elem := range s.Members[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.Comma()
		}
		if s.Meta.Set {
			e.RawStr("\"meta\"" + ":")
			s.Meta.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimGroupListEnterpriseResourcesItem from json.
func (s *ScimGroupListEnterpriseResourcesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimGroupListEnterpriseResourcesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "externalId":
			s.ExternalId.Reset()
			if err := s.ExternalId.Decode(d); err != nil {
				return err
			}
		case "displayName":
			s.DisplayName.Reset()
			if err := s.DisplayName.Decode(d); err != nil {
				return err
			}
		case "members":
			s.Members = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimGroupListEnterpriseResourcesItemMembersItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Members = append(s.Members, elem)
				return nil
			}); err != nil {
				return err
			}
		case "meta":
			s.Meta.Reset()
			if err := s.Meta.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimGroupListEnterpriseResourcesItemMembersItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	{
		if s.Ref.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ref.Set {
			e.RawStr("\"$ref\"" + ":")
			s.Ref.Encode(e)
		}
	}
	{
		if s.Display.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Display.Set {
			e.RawStr("\"display\"" + ":")
			s.Display.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimGroupListEnterpriseResourcesItemMembersItem from json.
func (s *ScimGroupListEnterpriseResourcesItemMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimGroupListEnterpriseResourcesItemMembersItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		case "$ref":
			s.Ref.Reset()
			if err := s.Ref.Decode(d); err != nil {
				return err
			}
		case "display":
			s.Display.Reset()
			if err := s.Display.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimGroupListEnterpriseResourcesItemMeta) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ResourceType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceType.Set {
			e.RawStr("\"resourceType\"" + ":")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.Created.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Created.Set {
			e.RawStr("\"created\"" + ":")
			s.Created.Encode(e)
		}
	}
	{
		if s.LastModified.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastModified.Set {
			e.RawStr("\"lastModified\"" + ":")
			s.LastModified.Encode(e)
		}
	}
	{
		if s.Location.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimGroupListEnterpriseResourcesItemMeta from json.
func (s *ScimGroupListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimGroupListEnterpriseResourcesItemMeta to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			s.ResourceType.Reset()
			if err := s.ResourceType.Decode(d); err != nil {
				return err
			}
		case "created":
			s.Created.Reset()
			if err := s.Created.Decode(d); err != nil {
				return err
			}
		case "lastModified":
			s.LastModified.Reset()
			if err := s.LastModified.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimProvisionAndInviteUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"userName\"" + ":")
		e.Str(s.UserName)
	}
	{
		if s.DisplayName.Set {
			e.Comma()
		}
		if s.DisplayName.Set {
			e.RawStr("\"displayName\"" + ":")
			s.DisplayName.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		s.Name.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"emails\"" + ":")
		e.ArrStart()
		if len(s.Emails) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Emails[0]
				elem.Encode(e)
			}
			for _, elem := range s.Emails[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Schemas != nil {
			e.Comma()
		}
		if s.Schemas != nil {
			e.RawStr("\"schemas\"" + ":")
			e.ArrStart()
			if len(s.Schemas) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Schemas[0]
					e.Str(elem)
				}
				for _, elem := range s.Schemas[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExternalId.Set {
			e.Comma()
		}
		if s.ExternalId.Set {
			e.RawStr("\"externalId\"" + ":")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.Groups != nil {
			e.Comma()
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					e.Str(elem)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.Comma()
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimProvisionAndInviteUserReq from json.
func (s *ScimProvisionAndInviteUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimProvisionAndInviteUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userName":
			v, err := d.Str()
			s.UserName = string(v)
			if err != nil {
				return err
			}
		case "displayName":
			s.DisplayName.Reset()
			if err := s.DisplayName.Decode(d); err != nil {
				return err
			}
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimProvisionAndInviteUserReqEmailsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "externalId":
			s.ExternalId.Reset()
			if err := s.ExternalId.Decode(d); err != nil {
				return err
			}
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimProvisionAndInviteUserReqEmailsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	{
		if s.Primary.Set {
			e.Comma()
		}
		if s.Primary.Set {
			e.RawStr("\"primary\"" + ":")
			s.Primary.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.Comma()
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimProvisionAndInviteUserReqEmailsItem from json.
func (s *ScimProvisionAndInviteUserReqEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimProvisionAndInviteUserReqEmailsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			v, err := d.Str()
			s.Value = string(v)
			if err != nil {
				return err
			}
		case "primary":
			s.Primary.Reset()
			if err := s.Primary.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimProvisionAndInviteUserReqName) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"givenName\"" + ":")
		e.Str(s.GivenName)
	}
	{
		e.Comma()

		e.RawStr("\"familyName\"" + ":")
		e.Str(s.FamilyName)
	}
	{
		if s.Formatted.Set {
			e.Comma()
		}
		if s.Formatted.Set {
			e.RawStr("\"formatted\"" + ":")
			s.Formatted.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimProvisionAndInviteUserReqName from json.
func (s *ScimProvisionAndInviteUserReqName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimProvisionAndInviteUserReqName to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			v, err := d.Str()
			s.GivenName = string(v)
			if err != nil {
				return err
			}
		case "familyName":
			v, err := d.Str()
			s.FamilyName = string(v)
			if err != nil {
				return err
			}
		case "formatted":
			s.Formatted.Reset()
			if err := s.Formatted.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimSetInformationForProvisionedUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Schemas != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Schemas != nil {
			e.RawStr("\"schemas\"" + ":")
			e.ArrStart()
			if len(s.Schemas) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Schemas[0]
					e.Str(elem)
				}
				for _, elem := range s.Schemas[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisplayName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DisplayName.Set {
			e.RawStr("\"displayName\"" + ":")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.ExternalId.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalId.Set {
			e.RawStr("\"externalId\"" + ":")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.Groups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					e.Str(elem)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"userName\"" + ":")
		e.Str(s.UserName)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		s.Name.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"emails\"" + ":")
		e.ArrStart()
		if len(s.Emails) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Emails[0]
				elem.Encode(e)
			}
			for _, elem := range s.Emails[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ScimSetInformationForProvisionedUserReq from json.
func (s *ScimSetInformationForProvisionedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimSetInformationForProvisionedUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "displayName":
			s.DisplayName.Reset()
			if err := s.DisplayName.Decode(d); err != nil {
				return err
			}
		case "externalId":
			s.ExternalId.Reset()
			if err := s.ExternalId.Decode(d); err != nil {
				return err
			}
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		case "userName":
			v, err := d.Str()
			s.UserName = string(v)
			if err != nil {
				return err
			}
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimSetInformationForProvisionedUserReqEmailsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimSetInformationForProvisionedUserReqEmailsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	{
		if s.Primary.Set {
			e.Comma()
		}
		if s.Primary.Set {
			e.RawStr("\"primary\"" + ":")
			s.Primary.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimSetInformationForProvisionedUserReqEmailsItem from json.
func (s *ScimSetInformationForProvisionedUserReqEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimSetInformationForProvisionedUserReqEmailsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "value":
			v, err := d.Str()
			s.Value = string(v)
			if err != nil {
				return err
			}
		case "primary":
			s.Primary.Reset()
			if err := s.Primary.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimSetInformationForProvisionedUserReqName) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"givenName\"" + ":")
		e.Str(s.GivenName)
	}
	{
		e.Comma()

		e.RawStr("\"familyName\"" + ":")
		e.Str(s.FamilyName)
	}
	{
		if s.Formatted.Set {
			e.Comma()
		}
		if s.Formatted.Set {
			e.RawStr("\"formatted\"" + ":")
			s.Formatted.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimSetInformationForProvisionedUserReqName from json.
func (s *ScimSetInformationForProvisionedUserReqName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimSetInformationForProvisionedUserReqName to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			v, err := d.Str()
			s.GivenName = string(v)
			if err != nil {
				return err
			}
		case "familyName":
			v, err := d.Str()
			s.FamilyName = string(v)
			if err != nil {
				return err
			}
		case "formatted":
			s.Formatted.Reset()
			if err := s.Formatted.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimUpdateAttributeForUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Schemas != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Schemas != nil {
			e.RawStr("\"schemas\"" + ":")
			e.ArrStart()
			if len(s.Schemas) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Schemas[0]
					e.Str(elem)
				}
				for _, elem := range s.Schemas[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"Operations\"" + ":")
		e.ArrStart()
		if len(s.Operations) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Operations[0]
				elem.Encode(e)
			}
			for _, elem := range s.Operations[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ScimUpdateAttributeForUserReq from json.
func (s *ScimUpdateAttributeForUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUpdateAttributeForUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "Operations":
			s.Operations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimUpdateAttributeForUserReqOperationsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Operations = append(s.Operations, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimUpdateAttributeForUserReqOperationsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"op\"" + ":")
		s.Op.Encode(e)
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.Comma()
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimUpdateAttributeForUserReqOperationsItem from json.
func (s *ScimUpdateAttributeForUserReqOperationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUpdateAttributeForUserReqOperationsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "op":
			if err := s.Op.Decode(d); err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ScimUpdateAttributeForUserReqOperationsItemOp as json.
func (s ScimUpdateAttributeForUserReqOperationsItemOp) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ScimUpdateAttributeForUserReqOperationsItemOp from json.
func (s *ScimUpdateAttributeForUserReqOperationsItemOp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUpdateAttributeForUserReqOperationsItemOp to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ScimUpdateAttributeForUserReqOperationsItemOp(v) {
	case ScimUpdateAttributeForUserReqOperationsItemOpAdd:
		*s = ScimUpdateAttributeForUserReqOperationsItemOpAdd
	case ScimUpdateAttributeForUserReqOperationsItemOpRemove:
		*s = ScimUpdateAttributeForUserReqOperationsItemOpRemove
	case ScimUpdateAttributeForUserReqOperationsItemOpReplace:
		*s = ScimUpdateAttributeForUserReqOperationsItemOpReplace
	default:
		*s = ScimUpdateAttributeForUserReqOperationsItemOp(v)
	}

	return nil
}

// Encode encodes ScimUpdateAttributeForUserReqOperationsItemValue as json.
func (s ScimUpdateAttributeForUserReqOperationsItemValue) Encode(e *jx.Writer) {
	switch s.Type {
	case ScimUpdateAttributeForUserReqOperationsItemValue0ScimUpdateAttributeForUserReqOperationsItemValue:
		s.ScimUpdateAttributeForUserReqOperationsItemValue0.Encode(e)
	case ArrayScimUpdateAttributeForUserReqOperationsItemValue1ItemScimUpdateAttributeForUserReqOperationsItemValue:
		e.ArrStart()
		if len(s.ArrayScimUpdateAttributeForUserReqOperationsItemValue1Item) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayScimUpdateAttributeForUserReqOperationsItemValue1Item[0]
				elem.Encode(e)
			}
			for _, elem := range s.ArrayScimUpdateAttributeForUserReqOperationsItemValue1Item[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	case StringScimUpdateAttributeForUserReqOperationsItemValue:
		e.Str(s.String)
	}
}

// Decode decodes ScimUpdateAttributeForUserReqOperationsItemValue from json.
func (s *ScimUpdateAttributeForUserReqOperationsItemValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUpdateAttributeForUserReqOperationsItemValue to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ScimUpdateAttributeForUserReqOperationsItemValue0.Decode(d); err != nil {
			return err
		}
		s.Type = ScimUpdateAttributeForUserReqOperationsItemValue0ScimUpdateAttributeForUserReqOperationsItemValue
	case jx.Array:
		s.ArrayScimUpdateAttributeForUserReqOperationsItemValue1Item = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ScimUpdateAttributeForUserReqOperationsItemValue1Item
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ArrayScimUpdateAttributeForUserReqOperationsItemValue1Item = append(s.ArrayScimUpdateAttributeForUserReqOperationsItemValue1Item, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayScimUpdateAttributeForUserReqOperationsItemValue1ItemScimUpdateAttributeForUserReqOperationsItemValue
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringScimUpdateAttributeForUserReqOperationsItemValue
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ScimUpdateAttributeForUserReqOperationsItemValue0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Active.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if s.UserName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UserName.Set {
			e.RawStr("\"userName\"" + ":")
			s.UserName.Encode(e)
		}
	}
	{
		if s.ExternalId.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalId.Set {
			e.RawStr("\"externalId\"" + ":")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.GivenName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GivenName.Set {
			e.RawStr("\"givenName\"" + ":")
			s.GivenName.Encode(e)
		}
	}
	{
		if s.FamilyName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FamilyName.Set {
			e.RawStr("\"familyName\"" + ":")
			s.FamilyName.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimUpdateAttributeForUserReqOperationsItemValue0 from json.
func (s *ScimUpdateAttributeForUserReqOperationsItemValue0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUpdateAttributeForUserReqOperationsItemValue0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		case "userName":
			s.UserName.Reset()
			if err := s.UserName.Decode(d); err != nil {
				return err
			}
		case "externalId":
			s.ExternalId.Reset()
			if err := s.ExternalId.Decode(d); err != nil {
				return err
			}
		case "givenName":
			s.GivenName.Reset()
			if err := s.GivenName.Decode(d); err != nil {
				return err
			}
		case "familyName":
			s.FamilyName.Reset()
			if err := s.FamilyName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimUpdateAttributeForUserReqOperationsItemValue1Item) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	{
		if s.Primary.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Primary.Set {
			e.RawStr("\"primary\"" + ":")
			s.Primary.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimUpdateAttributeForUserReqOperationsItemValue1Item from json.
func (s *ScimUpdateAttributeForUserReqOperationsItemValue1Item) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUpdateAttributeForUserReqOperationsItemValue1Item to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		case "primary":
			s.Primary.Reset()
			if err := s.Primary.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterprise) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"totalResults\"" + ":")
		e.Float64(s.TotalResults)
	}
	{
		e.Comma()

		e.RawStr("\"itemsPerPage\"" + ":")
		e.Float64(s.ItemsPerPage)
	}
	{
		e.Comma()

		e.RawStr("\"startIndex\"" + ":")
		e.Float64(s.StartIndex)
	}
	{
		e.Comma()

		e.RawStr("\"Resources\"" + ":")
		e.ArrStart()
		if len(s.Resources) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Resources[0]
				elem.Encode(e)
			}
			for _, elem := range s.Resources[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ScimUserListEnterprise from json.
func (s *ScimUserListEnterprise) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUserListEnterprise to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "totalResults":
			v, err := d.Float64()
			s.TotalResults = float64(v)
			if err != nil {
				return err
			}
		case "itemsPerPage":
			v, err := d.Float64()
			s.ItemsPerPage = float64(v)
			if err != nil {
				return err
			}
		case "startIndex":
			v, err := d.Float64()
			s.StartIndex = float64(v)
			if err != nil {
				return err
			}
		case "Resources":
			s.Resources = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimUserListEnterpriseResourcesItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Resources = append(s.Resources, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterpriseResourcesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		if s.ExternalId.Set {
			e.Comma()
		}
		if s.ExternalId.Set {
			e.RawStr("\"externalId\"" + ":")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.UserName.Set {
			e.Comma()
		}
		if s.UserName.Set {
			e.RawStr("\"userName\"" + ":")
			s.UserName.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Emails != nil {
			e.Comma()
		}
		if s.Emails != nil {
			e.RawStr("\"emails\"" + ":")
			e.ArrStart()
			if len(s.Emails) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Emails[0]
					elem.Encode(e)
				}
				for _, elem := range s.Emails[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Groups != nil {
			e.Comma()
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					elem.Encode(e)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.Comma()
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if s.Meta.Set {
			e.Comma()
		}
		if s.Meta.Set {
			e.RawStr("\"meta\"" + ":")
			s.Meta.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimUserListEnterpriseResourcesItem from json.
func (s *ScimUserListEnterpriseResourcesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUserListEnterpriseResourcesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "externalId":
			s.ExternalId.Reset()
			if err := s.ExternalId.Decode(d); err != nil {
				return err
			}
		case "userName":
			s.UserName.Reset()
			if err := s.UserName.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimUserListEnterpriseResourcesItemEmailsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimUserListEnterpriseResourcesItemGroupsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		case "meta":
			s.Meta.Reset()
			if err := s.Meta.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterpriseResourcesItemEmailsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	{
		if s.Primary.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Primary.Set {
			e.RawStr("\"primary\"" + ":")
			s.Primary.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimUserListEnterpriseResourcesItemEmailsItem from json.
func (s *ScimUserListEnterpriseResourcesItemEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUserListEnterpriseResourcesItemEmailsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		case "primary":
			s.Primary.Reset()
			if err := s.Primary.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterpriseResourcesItemGroupsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimUserListEnterpriseResourcesItemGroupsItem from json.
func (s *ScimUserListEnterpriseResourcesItemGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUserListEnterpriseResourcesItemGroupsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterpriseResourcesItemMeta) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ResourceType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceType.Set {
			e.RawStr("\"resourceType\"" + ":")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.Created.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Created.Set {
			e.RawStr("\"created\"" + ":")
			s.Created.Encode(e)
		}
	}
	{
		if s.LastModified.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastModified.Set {
			e.RawStr("\"lastModified\"" + ":")
			s.LastModified.Encode(e)
		}
	}
	{
		if s.Location.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimUserListEnterpriseResourcesItemMeta from json.
func (s *ScimUserListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUserListEnterpriseResourcesItemMeta to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			s.ResourceType.Reset()
			if err := s.ResourceType.Decode(d); err != nil {
				return err
			}
		case "created":
			s.Created.Reset()
			if err := s.Created.Decode(d); err != nil {
				return err
			}
		case "lastModified":
			s.LastModified.Reset()
			if err := s.LastModified.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterpriseResourcesItemName) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.GivenName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GivenName.Set {
			e.RawStr("\"givenName\"" + ":")
			s.GivenName.Encode(e)
		}
	}
	{
		if s.FamilyName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FamilyName.Set {
			e.RawStr("\"familyName\"" + ":")
			s.FamilyName.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ScimUserListEnterpriseResourcesItemName from json.
func (s *ScimUserListEnterpriseResourcesItemName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUserListEnterpriseResourcesItemName to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			s.GivenName.Reset()
			if err := s.GivenName.Decode(d); err != nil {
				return err
			}
		case "familyName":
			s.FamilyName.Reset()
			if err := s.FamilyName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SearchCodeOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"incomplete_results\"" + ":")
		e.Bool(s.IncompleteResults)
	}
	{
		e.Comma()

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes SearchCodeOK from json.
func (s *SearchCodeOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchCodeOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "incomplete_results":
			v, err := d.Bool()
			s.IncompleteResults = bool(v)
			if err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CodeSearchResultItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SearchCodeOrder as json.
func (s SearchCodeOrder) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SearchCodeOrder from json.
func (s *SearchCodeOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchCodeOrder to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchCodeOrder(v) {
	case SearchCodeOrderDesc:
		*s = SearchCodeOrderDesc
	case SearchCodeOrderAsc:
		*s = SearchCodeOrderAsc
	default:
		*s = SearchCodeOrder(v)
	}

	return nil
}

// Encode encodes SearchCodeSort as json.
func (s SearchCodeSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SearchCodeSort from json.
func (s *SearchCodeSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchCodeSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchCodeSort(v) {
	case SearchCodeSortIndexed:
		*s = SearchCodeSortIndexed
	default:
		*s = SearchCodeSort(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SearchCommitsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"incomplete_results\"" + ":")
		e.Bool(s.IncompleteResults)
	}
	{
		e.Comma()

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes SearchCommitsOK from json.
func (s *SearchCommitsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchCommitsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "incomplete_results":
			v, err := d.Bool()
			s.IncompleteResults = bool(v)
			if err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CommitSearchResultItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SearchCommitsOrder as json.
func (s SearchCommitsOrder) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SearchCommitsOrder from json.
func (s *SearchCommitsOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchCommitsOrder to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchCommitsOrder(v) {
	case SearchCommitsOrderDesc:
		*s = SearchCommitsOrderDesc
	case SearchCommitsOrderAsc:
		*s = SearchCommitsOrderAsc
	default:
		*s = SearchCommitsOrder(v)
	}

	return nil
}

// Encode encodes SearchCommitsSort as json.
func (s SearchCommitsSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SearchCommitsSort from json.
func (s *SearchCommitsSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchCommitsSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchCommitsSort(v) {
	case SearchCommitsSortAuthorMinusDate:
		*s = SearchCommitsSortAuthorMinusDate
	case SearchCommitsSortCommitterMinusDate:
		*s = SearchCommitsSortCommitterMinusDate
	default:
		*s = SearchCommitsSort(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SearchIssuesAndPullRequestsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"incomplete_results\"" + ":")
		e.Bool(s.IncompleteResults)
	}
	{
		e.Comma()

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes SearchIssuesAndPullRequestsOK from json.
func (s *SearchIssuesAndPullRequestsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchIssuesAndPullRequestsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "incomplete_results":
			v, err := d.Bool()
			s.IncompleteResults = bool(v)
			if err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IssueSearchResultItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SearchIssuesAndPullRequestsOrder as json.
func (s SearchIssuesAndPullRequestsOrder) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SearchIssuesAndPullRequestsOrder from json.
func (s *SearchIssuesAndPullRequestsOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchIssuesAndPullRequestsOrder to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchIssuesAndPullRequestsOrder(v) {
	case SearchIssuesAndPullRequestsOrderDesc:
		*s = SearchIssuesAndPullRequestsOrderDesc
	case SearchIssuesAndPullRequestsOrderAsc:
		*s = SearchIssuesAndPullRequestsOrderAsc
	default:
		*s = SearchIssuesAndPullRequestsOrder(v)
	}

	return nil
}

// Encode encodes SearchIssuesAndPullRequestsSort as json.
func (s SearchIssuesAndPullRequestsSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SearchIssuesAndPullRequestsSort from json.
func (s *SearchIssuesAndPullRequestsSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchIssuesAndPullRequestsSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchIssuesAndPullRequestsSort(v) {
	case SearchIssuesAndPullRequestsSortComments:
		*s = SearchIssuesAndPullRequestsSortComments
	case SearchIssuesAndPullRequestsSortReactions:
		*s = SearchIssuesAndPullRequestsSortReactions
	case SearchIssuesAndPullRequestsSortReactionsMinusPlus1:
		*s = SearchIssuesAndPullRequestsSortReactionsMinusPlus1
	case SearchIssuesAndPullRequestsSortReactionsMinusMinus1:
		*s = SearchIssuesAndPullRequestsSortReactionsMinusMinus1
	case SearchIssuesAndPullRequestsSortReactionsMinusSmile:
		*s = SearchIssuesAndPullRequestsSortReactionsMinusSmile
	case SearchIssuesAndPullRequestsSortReactionsMinusThinkingFace:
		*s = SearchIssuesAndPullRequestsSortReactionsMinusThinkingFace
	case SearchIssuesAndPullRequestsSortReactionsMinusHeart:
		*s = SearchIssuesAndPullRequestsSortReactionsMinusHeart
	case SearchIssuesAndPullRequestsSortReactionsMinusTada:
		*s = SearchIssuesAndPullRequestsSortReactionsMinusTada
	case SearchIssuesAndPullRequestsSortInteractions:
		*s = SearchIssuesAndPullRequestsSortInteractions
	case SearchIssuesAndPullRequestsSortCreated:
		*s = SearchIssuesAndPullRequestsSortCreated
	case SearchIssuesAndPullRequestsSortUpdated:
		*s = SearchIssuesAndPullRequestsSortUpdated
	default:
		*s = SearchIssuesAndPullRequestsSort(v)
	}

	return nil
}

// Encode encodes SearchLabelsApplicationJSONForbidden as json.
func (s SearchLabelsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes SearchLabelsApplicationJSONForbidden from json.
func (s *SearchLabelsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchLabelsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchLabelsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes SearchLabelsApplicationJSONNotFound as json.
func (s SearchLabelsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes SearchLabelsApplicationJSONNotFound from json.
func (s *SearchLabelsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchLabelsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchLabelsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s SearchLabelsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"incomplete_results\"" + ":")
		e.Bool(s.IncompleteResults)
	}
	{
		e.Comma()

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes SearchLabelsOK from json.
func (s *SearchLabelsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchLabelsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "incomplete_results":
			v, err := d.Bool()
			s.IncompleteResults = bool(v)
			if err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem LabelSearchResultItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SearchLabelsOrder as json.
func (s SearchLabelsOrder) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SearchLabelsOrder from json.
func (s *SearchLabelsOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchLabelsOrder to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchLabelsOrder(v) {
	case SearchLabelsOrderDesc:
		*s = SearchLabelsOrderDesc
	case SearchLabelsOrderAsc:
		*s = SearchLabelsOrderAsc
	default:
		*s = SearchLabelsOrder(v)
	}

	return nil
}

// Encode encodes SearchLabelsSort as json.
func (s SearchLabelsSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SearchLabelsSort from json.
func (s *SearchLabelsSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchLabelsSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchLabelsSort(v) {
	case SearchLabelsSortCreated:
		*s = SearchLabelsSortCreated
	case SearchLabelsSortUpdated:
		*s = SearchLabelsSortUpdated
	default:
		*s = SearchLabelsSort(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SearchReposOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"incomplete_results\"" + ":")
		e.Bool(s.IncompleteResults)
	}
	{
		e.Comma()

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes SearchReposOK from json.
func (s *SearchReposOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchReposOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "incomplete_results":
			v, err := d.Bool()
			s.IncompleteResults = bool(v)
			if err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem RepoSearchResultItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SearchReposOrder as json.
func (s SearchReposOrder) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SearchReposOrder from json.
func (s *SearchReposOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchReposOrder to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchReposOrder(v) {
	case SearchReposOrderDesc:
		*s = SearchReposOrderDesc
	case SearchReposOrderAsc:
		*s = SearchReposOrderAsc
	default:
		*s = SearchReposOrder(v)
	}

	return nil
}

// Encode encodes SearchReposSort as json.
func (s SearchReposSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SearchReposSort from json.
func (s *SearchReposSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchReposSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchReposSort(v) {
	case SearchReposSortStars:
		*s = SearchReposSortStars
	case SearchReposSortForks:
		*s = SearchReposSortForks
	case SearchReposSortHelpMinusWantedMinusIssues:
		*s = SearchReposSortHelpMinusWantedMinusIssues
	case SearchReposSortUpdated:
		*s = SearchReposSortUpdated
	default:
		*s = SearchReposSort(v)
	}

	return nil
}

// Encode encodes SearchResultTextMatches as json.
func (s SearchResultTextMatches) Encode(e *jx.Writer) {
	unwrapped := []SearchResultTextMatchesItem(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes SearchResultTextMatches from json.
func (s *SearchResultTextMatches) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchResultTextMatches to nil`)
	}
	var unwrapped []SearchResultTextMatchesItem
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SearchResultTextMatchesItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchResultTextMatches(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s SearchResultTextMatchesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ObjectURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ObjectURL.Set {
			e.RawStr("\"object_url\"" + ":")
			s.ObjectURL.Encode(e)
		}
	}
	{
		if s.ObjectType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ObjectType.Set {
			e.RawStr("\"object_type\"" + ":")
			s.ObjectType.Encode(e)
		}
	}
	{
		if s.Property.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Property.Set {
			e.RawStr("\"property\"" + ":")
			s.Property.Encode(e)
		}
	}
	{
		if s.Fragment.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fragment.Set {
			e.RawStr("\"fragment\"" + ":")
			s.Fragment.Encode(e)
		}
	}
	{
		if s.Matches != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Matches != nil {
			e.RawStr("\"matches\"" + ":")
			e.ArrStart()
			if len(s.Matches) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Matches[0]
					elem.Encode(e)
				}
				for _, elem := range s.Matches[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes SearchResultTextMatchesItem from json.
func (s *SearchResultTextMatchesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchResultTextMatchesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_url":
			s.ObjectURL.Reset()
			if err := s.ObjectURL.Decode(d); err != nil {
				return err
			}
		case "object_type":
			s.ObjectType.Reset()
			if err := s.ObjectType.Decode(d); err != nil {
				return err
			}
		case "property":
			s.Property.Reset()
			if err := s.Property.Decode(d); err != nil {
				return err
			}
		case "fragment":
			s.Fragment.Reset()
			if err := s.Fragment.Decode(d); err != nil {
				return err
			}
		case "matches":
			s.Matches = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem SearchResultTextMatchesItemMatchesItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Matches = append(s.Matches, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SearchResultTextMatchesItemMatchesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Text.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Text.Set {
			e.RawStr("\"text\"" + ":")
			s.Text.Encode(e)
		}
	}
	{
		if s.Indices != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Indices != nil {
			e.RawStr("\"indices\"" + ":")
			e.ArrStart()
			if len(s.Indices) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Indices[0]
					e.Int(elem)
				}
				for _, elem := range s.Indices[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes SearchResultTextMatchesItemMatchesItem from json.
func (s *SearchResultTextMatchesItemMatchesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchResultTextMatchesItemMatchesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			s.Text.Reset()
			if err := s.Text.Decode(d); err != nil {
				return err
			}
		case "indices":
			s.Indices = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Indices = append(s.Indices, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SearchTopicsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"incomplete_results\"" + ":")
		e.Bool(s.IncompleteResults)
	}
	{
		e.Comma()

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes SearchTopicsOK from json.
func (s *SearchTopicsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchTopicsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "incomplete_results":
			v, err := d.Bool()
			s.IncompleteResults = bool(v)
			if err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem TopicSearchResultItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SearchUsersOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"incomplete_results\"" + ":")
		e.Bool(s.IncompleteResults)
	}
	{
		e.Comma()

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes SearchUsersOK from json.
func (s *SearchUsersOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchUsersOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "incomplete_results":
			v, err := d.Bool()
			s.IncompleteResults = bool(v)
			if err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem UserSearchResultItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SearchUsersOrder as json.
func (s SearchUsersOrder) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SearchUsersOrder from json.
func (s *SearchUsersOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchUsersOrder to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchUsersOrder(v) {
	case SearchUsersOrderDesc:
		*s = SearchUsersOrderDesc
	case SearchUsersOrderAsc:
		*s = SearchUsersOrderAsc
	default:
		*s = SearchUsersOrder(v)
	}

	return nil
}

// Encode encodes SearchUsersSort as json.
func (s SearchUsersSort) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SearchUsersSort from json.
func (s *SearchUsersSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchUsersSort to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchUsersSort(v) {
	case SearchUsersSortFollowers:
		*s = SearchUsersSortFollowers
	case SearchUsersSortRepositories:
		*s = SearchUsersSortRepositories
	case SearchUsersSortJoined:
		*s = SearchUsersSortJoined
	default:
		*s = SearchUsersSort(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SecretScanningAlert) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Number.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Number.Set {
			e.RawStr("\"number\"" + ":")
			s.Number.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.LocationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LocationsURL.Set {
			e.RawStr("\"locations_url\"" + ":")
			s.LocationsURL.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.Resolution.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resolution.Set {
			e.RawStr("\"resolution\"" + ":")
			s.Resolution.Encode(e)
		}
	}
	{
		if s.ResolvedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResolvedAt.Set {
			e.RawStr("\"resolved_at\"" + ":")
			s.ResolvedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ResolvedBy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResolvedBy.Set {
			e.RawStr("\"resolved_by\"" + ":")
			s.ResolvedBy.Encode(e)
		}
	}
	{
		if s.SecretType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretType.Set {
			e.RawStr("\"secret_type\"" + ":")
			s.SecretType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes SecretScanningAlert from json.
func (s *SecretScanningAlert) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningAlert to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			s.Number.Reset()
			if err := s.Number.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "locations_url":
			s.LocationsURL.Reset()
			if err := s.LocationsURL.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "resolution":
			s.Resolution.Reset()
			if err := s.Resolution.Decode(d); err != nil {
				return err
			}
		case "resolved_at":
			s.ResolvedAt.Reset()
			if err := s.ResolvedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "resolved_by":
			s.ResolvedBy.Reset()
			if err := s.ResolvedBy.Decode(d); err != nil {
				return err
			}
		case "secret_type":
			s.SecretType.Reset()
			if err := s.SecretType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SecretScanningAlertResolution as json.
func (s SecretScanningAlertResolution) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SecretScanningAlertResolution from json.
func (s *SecretScanningAlertResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningAlertResolution to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SecretScanningAlertResolution(v) {
	case SecretScanningAlertResolutionFalsePositive:
		*s = SecretScanningAlertResolutionFalsePositive
	case SecretScanningAlertResolutionWontFix:
		*s = SecretScanningAlertResolutionWontFix
	case SecretScanningAlertResolutionRevoked:
		*s = SecretScanningAlertResolutionRevoked
	case SecretScanningAlertResolutionUsedInTests:
		*s = SecretScanningAlertResolutionUsedInTests
	default:
		*s = SecretScanningAlertResolution(v)
	}

	return nil
}

// Encode encodes SecretScanningAlertState as json.
func (s SecretScanningAlertState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SecretScanningAlertState from json.
func (s *SecretScanningAlertState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningAlertState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SecretScanningAlertState(v) {
	case SecretScanningAlertStateOpen:
		*s = SecretScanningAlertStateOpen
	case SecretScanningAlertStateResolved:
		*s = SecretScanningAlertStateResolved
	default:
		*s = SecretScanningAlertState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SecretScanningGetAlertNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes SecretScanningGetAlertNotFound from json.
func (s *SecretScanningGetAlertNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningGetAlertNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SecretScanningListAlertsForOrgOKApplicationJSON as json.
func (s SecretScanningListAlertsForOrgOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []OrganizationSecretScanningAlert(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes SecretScanningListAlertsForOrgOKApplicationJSON from json.
func (s *SecretScanningListAlertsForOrgOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningListAlertsForOrgOKApplicationJSON to nil`)
	}
	var unwrapped []OrganizationSecretScanningAlert
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationSecretScanningAlert
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SecretScanningListAlertsForOrgOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes SecretScanningListAlertsForOrgState as json.
func (s SecretScanningListAlertsForOrgState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SecretScanningListAlertsForOrgState from json.
func (s *SecretScanningListAlertsForOrgState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningListAlertsForOrgState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SecretScanningListAlertsForOrgState(v) {
	case SecretScanningListAlertsForOrgStateOpen:
		*s = SecretScanningListAlertsForOrgStateOpen
	case SecretScanningListAlertsForOrgStateResolved:
		*s = SecretScanningListAlertsForOrgStateResolved
	default:
		*s = SecretScanningListAlertsForOrgState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SecretScanningListAlertsForRepoNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes SecretScanningListAlertsForRepoNotFound from json.
func (s *SecretScanningListAlertsForRepoNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningListAlertsForRepoNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SecretScanningListAlertsForRepoOKApplicationJSON as json.
func (s SecretScanningListAlertsForRepoOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SecretScanningAlert(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes SecretScanningListAlertsForRepoOKApplicationJSON from json.
func (s *SecretScanningListAlertsForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningListAlertsForRepoOKApplicationJSON to nil`)
	}
	var unwrapped []SecretScanningAlert
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SecretScanningAlert
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SecretScanningListAlertsForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes SecretScanningListAlertsForRepoState as json.
func (s SecretScanningListAlertsForRepoState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SecretScanningListAlertsForRepoState from json.
func (s *SecretScanningListAlertsForRepoState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningListAlertsForRepoState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SecretScanningListAlertsForRepoState(v) {
	case SecretScanningListAlertsForRepoStateOpen:
		*s = SecretScanningListAlertsForRepoStateOpen
	case SecretScanningListAlertsForRepoStateResolved:
		*s = SecretScanningListAlertsForRepoStateResolved
	default:
		*s = SecretScanningListAlertsForRepoState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SecretScanningUpdateAlertNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes SecretScanningUpdateAlertNotFound from json.
func (s *SecretScanningUpdateAlertNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningUpdateAlertNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SecretScanningUpdateAlertReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		if s.Resolution.Set {
			e.Comma()
		}
		if s.Resolution.Set {
			e.RawStr("\"resolution\"" + ":")
			s.Resolution.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes SecretScanningUpdateAlertReq from json.
func (s *SecretScanningUpdateAlertReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningUpdateAlertReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "resolution":
			s.Resolution.Reset()
			if err := s.Resolution.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SecretScanningUpdateAlertUnprocessableEntity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes SecretScanningUpdateAlertUnprocessableEntity from json.
func (s *SecretScanningUpdateAlertUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningUpdateAlertUnprocessableEntity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SelectedActions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.GithubOwnedAllowed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GithubOwnedAllowed.Set {
			e.RawStr("\"github_owned_allowed\"" + ":")
			s.GithubOwnedAllowed.Encode(e)
		}
	}
	{
		if s.VerifiedAllowed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VerifiedAllowed.Set {
			e.RawStr("\"verified_allowed\"" + ":")
			s.VerifiedAllowed.Encode(e)
		}
	}
	{
		if s.PatternsAllowed != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PatternsAllowed != nil {
			e.RawStr("\"patterns_allowed\"" + ":")
			e.ArrStart()
			if len(s.PatternsAllowed) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PatternsAllowed[0]
					e.Str(elem)
				}
				for _, elem := range s.PatternsAllowed[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes SelectedActions from json.
func (s *SelectedActions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SelectedActions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "github_owned_allowed":
			s.GithubOwnedAllowed.Reset()
			if err := s.GithubOwnedAllowed.Decode(d); err != nil {
				return err
			}
		case "verified_allowed":
			s.VerifiedAllowed.Reset()
			if err := s.VerifiedAllowed.Decode(d); err != nil {
				return err
			}
		case "patterns_allowed":
			s.PatternsAllowed = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.PatternsAllowed = append(s.PatternsAllowed, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SelectedActionsURL as json.
func (s SelectedActionsURL) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes SelectedActionsURL from json.
func (s *SelectedActionsURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SelectedActionsURL to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SelectedActionsURL(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ServiceUnavailable) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Code.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Code.Set {
			e.RawStr("\"code\"" + ":")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ServiceUnavailable from json.
func (s *ServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ServiceUnavailable to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			s.Code.Reset()
			if err := s.Code.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ShortBlob) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	e.ObjEnd()
}

// Decode decodes ShortBlob from json.
func (s *ShortBlob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ShortBlob to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ShortBranch) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		s.Commit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"protected\"" + ":")
		e.Bool(s.Protected)
	}
	{
		if s.Protection.Set {
			e.Comma()
		}
		if s.Protection.Set {
			e.RawStr("\"protection\"" + ":")
			s.Protection.Encode(e)
		}
	}
	{
		if s.ProtectionURL.Set {
			e.Comma()
		}
		if s.ProtectionURL.Set {
			e.RawStr("\"protection_url\"" + ":")
			s.ProtectionURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ShortBranch from json.
func (s *ShortBranch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ShortBranch to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "commit":
			if err := s.Commit.Decode(d); err != nil {
				return err
			}
		case "protected":
			v, err := d.Bool()
			s.Protected = bool(v)
			if err != nil {
				return err
			}
		case "protection":
			s.Protection.Reset()
			if err := s.Protection.Decode(d); err != nil {
				return err
			}
		case "protection_url":
			s.ProtectionURL.Reset()
			if err := s.ProtectionURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ShortBranchCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

// Decode decodes ShortBranchCommit from json.
func (s *ShortBranchCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ShortBranchCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SimpleCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"tree_id\"" + ":")
		e.Str(s.TreeID)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"timestamp\"" + ":")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		e.Comma()

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committer\"" + ":")
		s.Committer.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SimpleCommit from json.
func (s *SimpleCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SimpleCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "tree_id":
			v, err := d.Str()
			s.TreeID = string(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "timestamp":
			v, err := json.DecodeDateTime(d)
			s.Timestamp = v
			if err != nil {
				return err
			}
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SimpleCommitAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	e.ObjEnd()
}

// Decode decodes SimpleCommitAuthor from json.
func (s *SimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SimpleCommitAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SimpleCommitCommitter) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	e.ObjEnd()
}

// Decode decodes SimpleCommitCommitter from json.
func (s *SimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SimpleCommitCommitter to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SimpleCommitStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"context\"" + ":")
		e.Str(s.Context)
	}
	{
		e.Comma()

		e.RawStr("\"target_url\"" + ":")
		json.EncodeURI(e, s.TargetURL)
	}
	{
		if s.Required.Set {
			e.Comma()
		}
		if s.Required.Set {
			e.RawStr("\"required\"" + ":")
			s.Required.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		s.AvatarURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	e.ObjEnd()
}

// Decode decodes SimpleCommitStatus from json.
func (s *SimpleCommitStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SimpleCommitStatus to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "context":
			v, err := d.Str()
			s.Context = string(v)
			if err != nil {
				return err
			}
		case "target_url":
			v, err := json.DecodeURI(d)
			s.TargetURL = v
			if err != nil {
				return err
			}
		case "required":
			s.Required.Reset()
			if err := s.Required.Decode(d); err != nil {
				return err
			}
		case "avatar_url":
			if err := s.AvatarURL.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SimpleUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		if s.StarredAt.Set {
			e.Comma()
		}
		if s.StarredAt.Set {
			e.RawStr("\"starred_at\"" + ":")
			s.StarredAt.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes SimpleUser from json.
func (s *SimpleUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SimpleUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "starred_at":
			s.StarredAt.Reset()
			if err := s.StarredAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Status) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		s.AvatarURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"target_url\"" + ":")
		e.Str(s.TargetURL)
	}
	{
		e.Comma()

		e.RawStr("\"context\"" + ":")
		e.Str(s.Context)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		e.Str(s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		e.Str(s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Status from json.
func (s *Status) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Status to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			if err := s.AvatarURL.Decode(d); err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "description":
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "target_url":
			v, err := d.Str()
			s.TargetURL = string(v)
			if err != nil {
				return err
			}
		case "context":
			v, err := d.Str()
			s.Context = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := d.Str()
			s.CreatedAt = string(v)
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := d.Str()
			s.UpdatedAt = string(v)
			if err != nil {
				return err
			}
		case "creator":
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s StatusCheckPolicy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"strict\"" + ":")
		e.Bool(s.Strict)
	}
	{
		e.Comma()

		e.RawStr("\"contexts\"" + ":")
		e.ArrStart()
		if len(s.Contexts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Contexts[0]
				e.Str(elem)
			}
			for _, elem := range s.Contexts[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"contexts_url\"" + ":")
		json.EncodeURI(e, s.ContextsURL)
	}
	e.ObjEnd()
}

// Decode decodes StatusCheckPolicy from json.
func (s *StatusCheckPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode StatusCheckPolicy to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "strict":
			v, err := d.Bool()
			s.Strict = bool(v)
			if err != nil {
				return err
			}
		case "contexts":
			s.Contexts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Contexts = append(s.Contexts, elem)
				return nil
			}); err != nil {
				return err
			}
		case "contexts_url":
			v, err := json.DecodeURI(d)
			s.ContextsURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Tag) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		s.Commit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"zipball_url\"" + ":")
		json.EncodeURI(e, s.ZipballURL)
	}
	{
		e.Comma()

		e.RawStr("\"tarball_url\"" + ":")
		json.EncodeURI(e, s.TarballURL)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	e.ObjEnd()
}

// Decode decodes Tag from json.
func (s *Tag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Tag to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "commit":
			if err := s.Commit.Decode(d); err != nil {
				return err
			}
		case "zipball_url":
			v, err := json.DecodeURI(d)
			s.ZipballURL = v
			if err != nil {
				return err
			}
		case "tarball_url":
			v, err := json.DecodeURI(d)
			s.TarballURL = v
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TagCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

// Decode decodes TagCommit from json.
func (s *TagCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TagCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Team) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"slug\"" + ":")
		e.Str(s.Slug)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		if s.Privacy.Set {
			e.Comma()
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"permission\"" + ":")
		e.Str(s.Permission)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"members_url\"" + ":")
		e.Str(s.MembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"repositories_url\"" + ":")
		json.EncodeURI(e, s.RepositoriesURL)
	}
	{
		e.Comma()

		e.RawStr("\"parent\"" + ":")
		s.Parent.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Team from json.
func (s *Team) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Team to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "slug":
			v, err := d.Str()
			s.Slug = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "permission":
			v, err := d.Str()
			s.Permission = string(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "members_url":
			v, err := d.Str()
			s.MembersURL = string(v)
			if err != nil {
				return err
			}
		case "repositories_url":
			v, err := json.DecodeURI(d)
			s.RepositoriesURL = v
			if err != nil {
				return err
			}
		case "parent":
			if err := s.Parent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamDiscussion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"body_html\"" + ":")
		e.Str(s.BodyHTML)
	}
	{
		e.Comma()

		e.RawStr("\"body_version\"" + ":")
		e.Str(s.BodyVersion)
	}
	{
		e.Comma()

		e.RawStr("\"comments_count\"" + ":")
		e.Int(s.CommentsCount)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"last_edited_at\"" + ":")
		s.LastEditedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"pinned\"" + ":")
		e.Bool(s.Pinned)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"team_url\"" + ":")
		json.EncodeURI(e, s.TeamURL)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamDiscussion from json.
func (s *TeamDiscussion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamDiscussion to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "body_html":
			v, err := d.Str()
			s.BodyHTML = string(v)
			if err != nil {
				return err
			}
		case "body_version":
			v, err := d.Str()
			s.BodyVersion = string(v)
			if err != nil {
				return err
			}
		case "comments_count":
			v, err := d.Int()
			s.CommentsCount = int(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "last_edited_at":
			if err := s.LastEditedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "pinned":
			v, err := d.Bool()
			s.Pinned = bool(v)
			if err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "team_url":
			v, err := json.DecodeURI(d)
			s.TeamURL = v
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "reactions":
			s.Reactions.Reset()
			if err := s.Reactions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamDiscussionComment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"body_html\"" + ":")
		e.Str(s.BodyHTML)
	}
	{
		e.Comma()

		e.RawStr("\"body_version\"" + ":")
		e.Str(s.BodyVersion)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"last_edited_at\"" + ":")
		s.LastEditedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"discussion_url\"" + ":")
		json.EncodeURI(e, s.DiscussionURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamDiscussionComment from json.
func (s *TeamDiscussionComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamDiscussionComment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "body_html":
			v, err := d.Str()
			s.BodyHTML = string(v)
			if err != nil {
				return err
			}
		case "body_version":
			v, err := d.Str()
			s.BodyVersion = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "last_edited_at":
			if err := s.LastEditedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "discussion_url":
			v, err := json.DecodeURI(d)
			s.DiscussionURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "reactions":
			s.Reactions.Reset()
			if err := s.Reactions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamFull) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"slug\"" + ":")
		e.Str(s.Slug)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		if s.Privacy.Set {
			e.Comma()
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"permission\"" + ":")
		e.Str(s.Permission)
	}
	{
		e.Comma()

		e.RawStr("\"members_url\"" + ":")
		e.Str(s.MembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"repositories_url\"" + ":")
		json.EncodeURI(e, s.RepositoriesURL)
	}
	{
		if s.Parent.Set {
			e.Comma()
		}
		if s.Parent.Set {
			e.RawStr("\"parent\"" + ":")
			s.Parent.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"members_count\"" + ":")
		e.Int(s.MembersCount)
	}
	{
		e.Comma()

		e.RawStr("\"repos_count\"" + ":")
		e.Int(s.ReposCount)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"organization\"" + ":")
		s.Organization.Encode(e)
	}
	{
		if s.LdapDn.Set {
			e.Comma()
		}
		if s.LdapDn.Set {
			e.RawStr("\"ldap_dn\"" + ":")
			s.LdapDn.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamFull from json.
func (s *TeamFull) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamFull to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "slug":
			v, err := d.Str()
			s.Slug = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "permission":
			v, err := d.Str()
			s.Permission = string(v)
			if err != nil {
				return err
			}
		case "members_url":
			v, err := d.Str()
			s.MembersURL = string(v)
			if err != nil {
				return err
			}
		case "repositories_url":
			v, err := json.DecodeURI(d)
			s.RepositoriesURL = v
			if err != nil {
				return err
			}
		case "parent":
			s.Parent.Reset()
			if err := s.Parent.Decode(d); err != nil {
				return err
			}
		case "members_count":
			v, err := d.Int()
			s.MembersCount = int(v)
			if err != nil {
				return err
			}
		case "repos_count":
			v, err := d.Int()
			s.ReposCount = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "organization":
			if err := s.Organization.Decode(d); err != nil {
				return err
			}
		case "ldap_dn":
			s.LdapDn.Reset()
			if err := s.LdapDn.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamFullPrivacy as json.
func (s TeamFullPrivacy) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamFullPrivacy from json.
func (s *TeamFullPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamFullPrivacy to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamFullPrivacy(v) {
	case TeamFullPrivacyClosed:
		*s = TeamFullPrivacyClosed
	case TeamFullPrivacySecret:
		*s = TeamFullPrivacySecret
	default:
		*s = TeamFullPrivacy(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamMembership) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"role\"" + ":")
		s.Role.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamMembership from json.
func (s *TeamMembership) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamMembership to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "role":
			if err := s.Role.Decode(d); err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamMembershipRole as json.
func (s TeamMembershipRole) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamMembershipRole from json.
func (s *TeamMembershipRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamMembershipRole to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamMembershipRole(v) {
	case TeamMembershipRoleMember:
		*s = TeamMembershipRoleMember
	case TeamMembershipRoleMaintainer:
		*s = TeamMembershipRoleMaintainer
	default:
		*s = TeamMembershipRole(v)
	}

	return nil
}

// Encode encodes TeamMembershipState as json.
func (s TeamMembershipState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamMembershipState from json.
func (s *TeamMembershipState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamMembershipState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamMembershipState(v) {
	case TeamMembershipStateActive:
		*s = TeamMembershipStateActive
	case TeamMembershipStatePending:
		*s = TeamMembershipStatePending
	default:
		*s = TeamMembershipState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	{
		e.Comma()

		e.RawStr("\"triage\"" + ":")
		e.Bool(s.Triage)
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		e.Comma()

		e.RawStr("\"maintain\"" + ":")
		e.Bool(s.Maintain)
	}
	{
		e.Comma()

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	e.ObjEnd()
}

// Decode decodes TeamPermissions from json.
func (s *TeamPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			v, err := d.Bool()
			s.Triage = bool(v)
			if err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			v, err := d.Bool()
			s.Maintain = bool(v)
			if err != nil {
				return err
			}
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamProject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"owner_url\"" + ":")
		e.Str(s.OwnerURL)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		e.Str(s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"columns_url\"" + ":")
		e.Str(s.ColumnsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		s.Body.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		e.Str(s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		e.Str(s.UpdatedAt)
	}
	{
		if s.OrganizationPermission.Set {
			e.Comma()
		}
		if s.OrganizationPermission.Set {
			e.RawStr("\"organization_permission\"" + ":")
			s.OrganizationPermission.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.Comma()
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"permissions\"" + ":")
		s.Permissions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamProject from json.
func (s *TeamProject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamProject to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "owner_url":
			v, err := d.Str()
			s.OwnerURL = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := d.Str()
			s.HTMLURL = string(v)
			if err != nil {
				return err
			}
		case "columns_url":
			v, err := d.Str()
			s.ColumnsURL = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "body":
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "creator":
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := d.Str()
			s.CreatedAt = string(v)
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := d.Str()
			s.UpdatedAt = string(v)
			if err != nil {
				return err
			}
		case "organization_permission":
			s.OrganizationPermission.Reset()
			if err := s.OrganizationPermission.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		case "permissions":
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamProjectPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"read\"" + ":")
		e.Bool(s.Read)
	}
	{
		e.Comma()

		e.RawStr("\"write\"" + ":")
		e.Bool(s.Write)
	}
	{
		e.Comma()

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	e.ObjEnd()
}

// Decode decodes TeamProjectPermissions from json.
func (s *TeamProjectPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamProjectPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "read":
			v, err := d.Bool()
			s.Read = bool(v)
			if err != nil {
				return err
			}
		case "write":
			v, err := d.Bool()
			s.Write = bool(v)
			if err != nil {
				return err
			}
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamRepository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"forks\"" + ":")
		e.Int(s.Forks)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		e.Str(s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		e.Comma()

		e.RawStr("\"ssh_url\"" + ":")
		e.Str(s.SSHURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		e.Comma()

		e.RawStr("\"clone_url\"" + ":")
		e.Str(s.CloneURL)
	}
	{
		e.Comma()

		e.RawStr("\"mirror_url\"" + ":")
		s.MirrorURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"svn_url\"" + ":")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		e.Comma()

		e.RawStr("\"homepage\"" + ":")
		s.Homepage.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"language\"" + ":")
		s.Language.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"forks_count\"" + ":")
		e.Int(s.ForksCount)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_count\"" + ":")
		e.Int(s.StargazersCount)
	}
	{
		e.Comma()

		e.RawStr("\"watchers_count\"" + ":")
		e.Int(s.WatchersCount)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"default_branch\"" + ":")
		e.Str(s.DefaultBranch)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues_count\"" + ":")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"has_issues\"" + ":")
		e.Bool(s.HasIssues)
	}
	{
		e.Comma()

		e.RawStr("\"has_projects\"" + ":")
		e.Bool(s.HasProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_wiki\"" + ":")
		e.Bool(s.HasWiki)
	}
	{
		e.Comma()

		e.RawStr("\"has_pages\"" + ":")
		e.Bool(s.HasPages)
	}
	{
		e.Comma()

		e.RawStr("\"has_downloads\"" + ":")
		e.Bool(s.HasDownloads)
	}
	{
		e.Comma()

		e.RawStr("\"archived\"" + ":")
		e.Bool(s.Archived)
	}
	{
		e.Comma()

		e.RawStr("\"disabled\"" + ":")
		e.Bool(s.Disabled)
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pushed_at\"" + ":")
		s.PushedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.Comma()
		}
		if s.TemplateRepository.Set {
			e.RawStr("\"template_repository\"" + ":")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.Comma()
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.Comma()
		}
		if s.SubscribersCount.Set {
			e.RawStr("\"subscribers_count\"" + ":")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.Comma()
		}
		if s.NetworkCount.Set {
			e.RawStr("\"network_count\"" + ":")
			s.NetworkCount.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"watchers\"" + ":")
		e.Int(s.Watchers)
	}
	{
		if s.MasterBranch.Set {
			e.Comma()
		}
		if s.MasterBranch.Set {
			e.RawStr("\"master_branch\"" + ":")
			s.MasterBranch.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamRepository from json.
func (s *TeamRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamRepository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "forks":
			v, err := d.Int()
			s.Forks = int(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "git_url":
			v, err := d.Str()
			s.GitURL = string(v)
			if err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			v, err := d.Str()
			s.SSHURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "clone_url":
			v, err := d.Str()
			s.CloneURL = string(v)
			if err != nil {
				return err
			}
		case "mirror_url":
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "svn_url":
			v, err := json.DecodeURI(d)
			s.SvnURL = v
			if err != nil {
				return err
			}
		case "homepage":
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			v, err := d.Int()
			s.ForksCount = int(v)
			if err != nil {
				return err
			}
		case "stargazers_count":
			v, err := d.Int()
			s.StargazersCount = int(v)
			if err != nil {
				return err
			}
		case "watchers_count":
			v, err := d.Int()
			s.WatchersCount = int(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "default_branch":
			v, err := d.Str()
			s.DefaultBranch = string(v)
			if err != nil {
				return err
			}
		case "open_issues_count":
			v, err := d.Int()
			s.OpenIssuesCount = int(v)
			if err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			v, err := d.Bool()
			s.HasIssues = bool(v)
			if err != nil {
				return err
			}
		case "has_projects":
			v, err := d.Bool()
			s.HasProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_wiki":
			v, err := d.Bool()
			s.HasWiki = bool(v)
			if err != nil {
				return err
			}
		case "has_pages":
			v, err := d.Bool()
			s.HasPages = bool(v)
			if err != nil {
				return err
			}
		case "has_downloads":
			v, err := d.Bool()
			s.HasDownloads = bool(v)
			if err != nil {
				return err
			}
		case "archived":
			v, err := d.Bool()
			s.Archived = bool(v)
			if err != nil {
				return err
			}
		case "disabled":
			v, err := d.Bool()
			s.Disabled = bool(v)
			if err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "created_at":
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "template_repository":
			s.TemplateRepository.Reset()
			if err := s.TemplateRepository.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			s.SubscribersCount.Reset()
			if err := s.SubscribersCount.Decode(d); err != nil {
				return err
			}
		case "network_count":
			s.NetworkCount.Reset()
			if err := s.NetworkCount.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "watchers":
			v, err := d.Int()
			s.Watchers = int(v)
			if err != nil {
				return err
			}
		case "master_branch":
			s.MasterBranch.Reset()
			if err := s.MasterBranch.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	{
		e.Comma()

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamRepositoryPermissions from json.
func (s *TeamRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"members_url\"" + ":")
		e.Str(s.MembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"permission\"" + ":")
		e.Str(s.Permission)
	}
	{
		if s.Privacy.Set {
			e.Comma()
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"repositories_url\"" + ":")
		json.EncodeURI(e, s.RepositoriesURL)
	}
	{
		e.Comma()

		e.RawStr("\"slug\"" + ":")
		e.Str(s.Slug)
	}
	{
		if s.LdapDn.Set {
			e.Comma()
		}
		if s.LdapDn.Set {
			e.RawStr("\"ldap_dn\"" + ":")
			s.LdapDn.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamSimple from json.
func (s *TeamSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "members_url":
			v, err := d.Str()
			s.MembersURL = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "permission":
			v, err := d.Str()
			s.Permission = string(v)
			if err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "repositories_url":
			v, err := json.DecodeURI(d)
			s.RepositoriesURL = v
			if err != nil {
				return err
			}
		case "slug":
			v, err := d.Str()
			s.Slug = string(v)
			if err != nil {
				return err
			}
		case "ldap_dn":
			s.LdapDn.Reset()
			if err := s.LdapDn.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddMemberLegacyNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsAddMemberLegacyNoContent from json.
func (s *TeamsAddMemberLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddMemberLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddMemberLegacyNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsAddMemberLegacyNotFound from json.
func (s *TeamsAddMemberLegacyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddMemberLegacyNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddMemberLegacyUnprocessableEntity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsAddMemberLegacyUnprocessableEntity from json.
func (s *TeamsAddMemberLegacyUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddMemberLegacyUnprocessableEntity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserInOrgForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgForbidden from json.
func (s *TeamsAddOrUpdateMembershipForUserInOrgForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserInOrgForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Role.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Role.Set {
			e.RawStr("\"role\"" + ":")
			s.Role.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgReq from json.
func (s *TeamsAddOrUpdateMembershipForUserInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			s.Role.Reset()
			if err := s.Role.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsAddOrUpdateMembershipForUserInOrgReqRole as json.
func (s TeamsAddOrUpdateMembershipForUserInOrgReqRole) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgReqRole from json.
func (s *TeamsAddOrUpdateMembershipForUserInOrgReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserInOrgReqRole to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateMembershipForUserInOrgReqRole(v) {
	case TeamsAddOrUpdateMembershipForUserInOrgReqRoleMember:
		*s = TeamsAddOrUpdateMembershipForUserInOrgReqRoleMember
	case TeamsAddOrUpdateMembershipForUserInOrgReqRoleMaintainer:
		*s = TeamsAddOrUpdateMembershipForUserInOrgReqRoleMaintainer
	default:
		*s = TeamsAddOrUpdateMembershipForUserInOrgReqRole(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserInOrgUnprocessableEntity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgUnprocessableEntity from json.
func (s *TeamsAddOrUpdateMembershipForUserInOrgUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserInOrgUnprocessableEntity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserLegacyForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyForbidden from json.
func (s *TeamsAddOrUpdateMembershipForUserLegacyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserLegacyForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Role.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Role.Set {
			e.RawStr("\"role\"" + ":")
			s.Role.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyReq from json.
func (s *TeamsAddOrUpdateMembershipForUserLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			s.Role.Reset()
			if err := s.Role.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsAddOrUpdateMembershipForUserLegacyReqRole as json.
func (s TeamsAddOrUpdateMembershipForUserLegacyReqRole) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyReqRole from json.
func (s *TeamsAddOrUpdateMembershipForUserLegacyReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserLegacyReqRole to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateMembershipForUserLegacyReqRole(v) {
	case TeamsAddOrUpdateMembershipForUserLegacyReqRoleMember:
		*s = TeamsAddOrUpdateMembershipForUserLegacyReqRoleMember
	case TeamsAddOrUpdateMembershipForUserLegacyReqRoleMaintainer:
		*s = TeamsAddOrUpdateMembershipForUserLegacyReqRoleMaintainer
	default:
		*s = TeamsAddOrUpdateMembershipForUserLegacyReqRole(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserLegacyUnprocessableEntity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyUnprocessableEntity from json.
func (s *TeamsAddOrUpdateMembershipForUserLegacyUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserLegacyUnprocessableEntity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsInOrgForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgForbidden from json.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsInOrgForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsInOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgNoContent from json.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgReq from json.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission as json.
func (s TeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission from json.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsInOrgReqPermission to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateProjectPermissionsInOrgReqPermission(v) {
	case TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionRead:
		*s = TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionRead
	case TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionWrite:
		*s = TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionWrite
	case TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionAdmin:
		*s = TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionAdmin
	default:
		*s = TeamsAddOrUpdateProjectPermissionsInOrgReqPermission(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsLegacyForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyForbidden from json.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsLegacyForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsLegacyNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyNoContent from json.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyReq from json.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission as json.
func (s TeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission from json.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsLegacyReqPermission to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateProjectPermissionsLegacyReqPermission(v) {
	case TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionRead:
		*s = TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionRead
	case TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionWrite:
		*s = TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionWrite
	case TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionAdmin:
		*s = TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionAdmin
	default:
		*s = TeamsAddOrUpdateProjectPermissionsLegacyReqPermission(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateRepoPermissionsInOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgNoContent from json.
func (s *TeamsAddOrUpdateRepoPermissionsInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateRepoPermissionsInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateRepoPermissionsInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgReq from json.
func (s *TeamsAddOrUpdateRepoPermissionsInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateRepoPermissionsInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission as json.
func (s TeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission from json.
func (s *TeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateRepoPermissionsInOrgReqPermission to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateRepoPermissionsInOrgReqPermission(v) {
	case TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionPull:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionPull
	case TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionPush:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionPush
	case TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionAdmin:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionAdmin
	case TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionMaintain:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionMaintain
	case TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionTriage:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionTriage
	default:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermission(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateRepoPermissionsLegacyNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyNoContent from json.
func (s *TeamsAddOrUpdateRepoPermissionsLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateRepoPermissionsLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateRepoPermissionsLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyReq from json.
func (s *TeamsAddOrUpdateRepoPermissionsLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateRepoPermissionsLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission as json.
func (s TeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission from json.
func (s *TeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateRepoPermissionsLegacyReqPermission to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateRepoPermissionsLegacyReqPermission(v) {
	case TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionPull:
		*s = TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionPull
	case TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionPush:
		*s = TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionPush
	case TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionAdmin:
		*s = TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionAdmin
	default:
		*s = TeamsAddOrUpdateRepoPermissionsLegacyReqPermission(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsCheckPermissionsForProjectInOrgNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsCheckPermissionsForProjectInOrgNotFound from json.
func (s *TeamsCheckPermissionsForProjectInOrgNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCheckPermissionsForProjectInOrgNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCheckPermissionsForProjectLegacyNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsCheckPermissionsForProjectLegacyNotFound from json.
func (s *TeamsCheckPermissionsForProjectLegacyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCheckPermissionsForProjectLegacyNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCheckPermissionsForRepoInOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsCheckPermissionsForRepoInOrgNoContent from json.
func (s *TeamsCheckPermissionsForRepoInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCheckPermissionsForRepoInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCheckPermissionsForRepoInOrgNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsCheckPermissionsForRepoInOrgNotFound from json.
func (s *TeamsCheckPermissionsForRepoInOrgNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCheckPermissionsForRepoInOrgNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCheckPermissionsForRepoLegacyNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsCheckPermissionsForRepoLegacyNoContent from json.
func (s *TeamsCheckPermissionsForRepoLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCheckPermissionsForRepoLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCheckPermissionsForRepoLegacyNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsCheckPermissionsForRepoLegacyNotFound from json.
func (s *TeamsCheckPermissionsForRepoLegacyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCheckPermissionsForRepoLegacyNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateDiscussionCommentInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

// Decode decodes TeamsCreateDiscussionCommentInOrgReq from json.
func (s *TeamsCreateDiscussionCommentInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateDiscussionCommentInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateDiscussionCommentLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

// Decode decodes TeamsCreateDiscussionCommentLegacyReq from json.
func (s *TeamsCreateDiscussionCommentLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateDiscussionCommentLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateDiscussionInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		if s.Private.Set {
			e.Comma()
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsCreateDiscussionInOrgReq from json.
func (s *TeamsCreateDiscussionInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateDiscussionInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateDiscussionLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		if s.Private.Set {
			e.Comma()
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsCreateDiscussionLegacyReq from json.
func (s *TeamsCreateDiscussionLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateDiscussionLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Groups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					elem.Encode(e)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"group_id\"" + ":")
		e.Str(s.GroupID)
	}
	{
		e.Comma()

		e.RawStr("\"group_name\"" + ":")
		e.Str(s.GroupName)
	}
	{
		e.Comma()

		e.RawStr("\"group_description\"" + ":")
		e.Str(s.GroupDescription)
	}
	e.ObjEnd()
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group_id":
			v, err := d.Str()
			s.GroupID = string(v)
			if err != nil {
				return err
			}
		case "group_name":
			v, err := d.Str()
			s.GroupName = string(v)
			if err != nil {
				return err
			}
		case "group_description":
			v, err := d.Str()
			s.GroupDescription = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"groups\"" + ":")
		e.ArrStart()
		if len(s.Groups) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Groups[0]
				elem.Encode(e)
			}
			for _, elem := range s.Groups[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.SyncedAt.Set {
			e.Comma()
		}
		if s.SyncedAt.Set {
			e.RawStr("\"synced_at\"" + ":")
			s.SyncedAt.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "synced_at":
			s.SyncedAt.Reset()
			if err := s.SyncedAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"group_id\"" + ":")
		e.Str(s.GroupID)
	}
	{
		e.Comma()

		e.RawStr("\"group_name\"" + ":")
		e.Str(s.GroupName)
	}
	{
		e.Comma()

		e.RawStr("\"group_description\"" + ":")
		e.Str(s.GroupDescription)
	}
	{
		if s.ID.Set {
			e.Comma()
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group_id":
			v, err := d.Str()
			s.GroupID = string(v)
			if err != nil {
				return err
			}
		case "group_name":
			v, err := d.Str()
			s.GroupName = string(v)
			if err != nil {
				return err
			}
		case "group_description":
			v, err := d.Str()
			s.GroupDescription = string(v)
			if err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Maintainers != nil {
			e.Comma()
		}
		if s.Maintainers != nil {
			e.RawStr("\"maintainers\"" + ":")
			e.ArrStart()
			if len(s.Maintainers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Maintainers[0]
					e.Str(elem)
				}
				for _, elem := range s.Maintainers[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RepoNames != nil {
			e.Comma()
		}
		if s.RepoNames != nil {
			e.RawStr("\"repo_names\"" + ":")
			e.ArrStart()
			if len(s.RepoNames) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RepoNames[0]
					e.Str(elem)
				}
				for _, elem := range s.RepoNames[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Privacy.Set {
			e.Comma()
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		if s.Permission.Set {
			e.Comma()
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	{
		if s.ParentTeamID.Set {
			e.Comma()
		}
		if s.ParentTeamID.Set {
			e.RawStr("\"parent_team_id\"" + ":")
			s.ParentTeamID.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsCreateReq from json.
func (s *TeamsCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "maintainers":
			s.Maintainers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Maintainers = append(s.Maintainers, elem)
				return nil
			}); err != nil {
				return err
			}
		case "repo_names":
			s.RepoNames = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.RepoNames = append(s.RepoNames, elem)
				return nil
			}); err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		case "parent_team_id":
			s.ParentTeamID.Reset()
			if err := s.ParentTeamID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsCreateReqPermission as json.
func (s TeamsCreateReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsCreateReqPermission from json.
func (s *TeamsCreateReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateReqPermission to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsCreateReqPermission(v) {
	case TeamsCreateReqPermissionPull:
		*s = TeamsCreateReqPermissionPull
	case TeamsCreateReqPermissionPush:
		*s = TeamsCreateReqPermissionPush
	case TeamsCreateReqPermissionAdmin:
		*s = TeamsCreateReqPermissionAdmin
	default:
		*s = TeamsCreateReqPermission(v)
	}

	return nil
}

// Encode encodes TeamsCreateReqPrivacy as json.
func (s TeamsCreateReqPrivacy) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsCreateReqPrivacy from json.
func (s *TeamsCreateReqPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateReqPrivacy to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsCreateReqPrivacy(v) {
	case TeamsCreateReqPrivacySecret:
		*s = TeamsCreateReqPrivacySecret
	case TeamsCreateReqPrivacyClosed:
		*s = TeamsCreateReqPrivacyClosed
	default:
		*s = TeamsCreateReqPrivacy(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsDeleteDiscussionCommentInOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsDeleteDiscussionCommentInOrgNoContent from json.
func (s *TeamsDeleteDiscussionCommentInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsDeleteDiscussionCommentInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsDeleteDiscussionCommentLegacyNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsDeleteDiscussionCommentLegacyNoContent from json.
func (s *TeamsDeleteDiscussionCommentLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsDeleteDiscussionCommentLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsDeleteDiscussionInOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsDeleteDiscussionInOrgNoContent from json.
func (s *TeamsDeleteDiscussionInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsDeleteDiscussionInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsDeleteDiscussionLegacyNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsDeleteDiscussionLegacyNoContent from json.
func (s *TeamsDeleteDiscussionLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsDeleteDiscussionLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsDeleteInOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsDeleteInOrgNoContent from json.
func (s *TeamsDeleteInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsDeleteInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsDeleteLegacyNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsDeleteLegacyNoContent from json.
func (s *TeamsDeleteLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsDeleteLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsGetMemberLegacyNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsGetMemberLegacyNoContent from json.
func (s *TeamsGetMemberLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsGetMemberLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsGetMemberLegacyNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsGetMemberLegacyNotFound from json.
func (s *TeamsGetMemberLegacyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsGetMemberLegacyNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsGetMembershipForUserInOrgNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsGetMembershipForUserInOrgNotFound from json.
func (s *TeamsGetMembershipForUserInOrgNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsGetMembershipForUserInOrgNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsListChildLegacyApplicationJSONForbidden as json.
func (s TeamsListChildLegacyApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListChildLegacyApplicationJSONForbidden from json.
func (s *TeamsListChildLegacyApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListChildLegacyApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListChildLegacyApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes TeamsListChildLegacyApplicationJSONNotFound as json.
func (s TeamsListChildLegacyApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListChildLegacyApplicationJSONNotFound from json.
func (s *TeamsListChildLegacyApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListChildLegacyApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListChildLegacyApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes TeamsListChildLegacyOKApplicationJSON as json.
func (s TeamsListChildLegacyOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Team(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes TeamsListChildLegacyOKApplicationJSON from json.
func (s *TeamsListChildLegacyOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListChildLegacyOKApplicationJSON to nil`)
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListChildLegacyOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes TeamsListDiscussionCommentsInOrgDirection as json.
func (s TeamsListDiscussionCommentsInOrgDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsListDiscussionCommentsInOrgDirection from json.
func (s *TeamsListDiscussionCommentsInOrgDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListDiscussionCommentsInOrgDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsListDiscussionCommentsInOrgDirection(v) {
	case TeamsListDiscussionCommentsInOrgDirectionAsc:
		*s = TeamsListDiscussionCommentsInOrgDirectionAsc
	case TeamsListDiscussionCommentsInOrgDirectionDesc:
		*s = TeamsListDiscussionCommentsInOrgDirectionDesc
	default:
		*s = TeamsListDiscussionCommentsInOrgDirection(v)
	}

	return nil
}

// Encode encodes TeamsListDiscussionCommentsLegacyDirection as json.
func (s TeamsListDiscussionCommentsLegacyDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsListDiscussionCommentsLegacyDirection from json.
func (s *TeamsListDiscussionCommentsLegacyDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListDiscussionCommentsLegacyDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsListDiscussionCommentsLegacyDirection(v) {
	case TeamsListDiscussionCommentsLegacyDirectionAsc:
		*s = TeamsListDiscussionCommentsLegacyDirectionAsc
	case TeamsListDiscussionCommentsLegacyDirectionDesc:
		*s = TeamsListDiscussionCommentsLegacyDirectionDesc
	default:
		*s = TeamsListDiscussionCommentsLegacyDirection(v)
	}

	return nil
}

// Encode encodes TeamsListDiscussionsInOrgDirection as json.
func (s TeamsListDiscussionsInOrgDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsListDiscussionsInOrgDirection from json.
func (s *TeamsListDiscussionsInOrgDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListDiscussionsInOrgDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsListDiscussionsInOrgDirection(v) {
	case TeamsListDiscussionsInOrgDirectionAsc:
		*s = TeamsListDiscussionsInOrgDirectionAsc
	case TeamsListDiscussionsInOrgDirectionDesc:
		*s = TeamsListDiscussionsInOrgDirectionDesc
	default:
		*s = TeamsListDiscussionsInOrgDirection(v)
	}

	return nil
}

// Encode encodes TeamsListDiscussionsLegacyDirection as json.
func (s TeamsListDiscussionsLegacyDirection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsListDiscussionsLegacyDirection from json.
func (s *TeamsListDiscussionsLegacyDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListDiscussionsLegacyDirection to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsListDiscussionsLegacyDirection(v) {
	case TeamsListDiscussionsLegacyDirectionAsc:
		*s = TeamsListDiscussionsLegacyDirectionAsc
	case TeamsListDiscussionsLegacyDirectionDesc:
		*s = TeamsListDiscussionsLegacyDirectionDesc
	default:
		*s = TeamsListDiscussionsLegacyDirection(v)
	}

	return nil
}

// Encode encodes TeamsListForAuthenticatedUserApplicationJSONForbidden as json.
func (s TeamsListForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListForAuthenticatedUserApplicationJSONForbidden from json.
func (s *TeamsListForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes TeamsListForAuthenticatedUserApplicationJSONNotFound as json.
func (s TeamsListForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListForAuthenticatedUserApplicationJSONNotFound from json.
func (s *TeamsListForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes TeamsListForAuthenticatedUserOKApplicationJSON as json.
func (s TeamsListForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []TeamFull(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes TeamsListForAuthenticatedUserOKApplicationJSON from json.
func (s *TeamsListForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []TeamFull
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TeamFull
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes TeamsListIdpGroupsForLegacyApplicationJSONForbidden as json.
func (s TeamsListIdpGroupsForLegacyApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListIdpGroupsForLegacyApplicationJSONForbidden from json.
func (s *TeamsListIdpGroupsForLegacyApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListIdpGroupsForLegacyApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListIdpGroupsForLegacyApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes TeamsListIdpGroupsForLegacyApplicationJSONNotFound as json.
func (s TeamsListIdpGroupsForLegacyApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListIdpGroupsForLegacyApplicationJSONNotFound from json.
func (s *TeamsListIdpGroupsForLegacyApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListIdpGroupsForLegacyApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListIdpGroupsForLegacyApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes TeamsListMembersInOrgRole as json.
func (s TeamsListMembersInOrgRole) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsListMembersInOrgRole from json.
func (s *TeamsListMembersInOrgRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListMembersInOrgRole to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsListMembersInOrgRole(v) {
	case TeamsListMembersInOrgRoleMember:
		*s = TeamsListMembersInOrgRoleMember
	case TeamsListMembersInOrgRoleMaintainer:
		*s = TeamsListMembersInOrgRoleMaintainer
	case TeamsListMembersInOrgRoleAll:
		*s = TeamsListMembersInOrgRoleAll
	default:
		*s = TeamsListMembersInOrgRole(v)
	}

	return nil
}

// Encode encodes TeamsListMembersLegacyOKApplicationJSON as json.
func (s TeamsListMembersLegacyOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes TeamsListMembersLegacyOKApplicationJSON from json.
func (s *TeamsListMembersLegacyOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListMembersLegacyOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListMembersLegacyOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes TeamsListMembersLegacyRole as json.
func (s TeamsListMembersLegacyRole) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsListMembersLegacyRole from json.
func (s *TeamsListMembersLegacyRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListMembersLegacyRole to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsListMembersLegacyRole(v) {
	case TeamsListMembersLegacyRoleMember:
		*s = TeamsListMembersLegacyRoleMember
	case TeamsListMembersLegacyRoleMaintainer:
		*s = TeamsListMembersLegacyRoleMaintainer
	case TeamsListMembersLegacyRoleAll:
		*s = TeamsListMembersLegacyRoleAll
	default:
		*s = TeamsListMembersLegacyRole(v)
	}

	return nil
}

// Encode encodes TeamsListOKApplicationJSON as json.
func (s TeamsListOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Team(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes TeamsListOKApplicationJSON from json.
func (s *TeamsListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListOKApplicationJSON to nil`)
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes TeamsListProjectsLegacyOKApplicationJSON as json.
func (s TeamsListProjectsLegacyOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []TeamProject(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes TeamsListProjectsLegacyOKApplicationJSON from json.
func (s *TeamsListProjectsLegacyOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListProjectsLegacyOKApplicationJSON to nil`)
	}
	var unwrapped []TeamProject
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TeamProject
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListProjectsLegacyOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes TeamsListReposLegacyOKApplicationJSON as json.
func (s TeamsListReposLegacyOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes TeamsListReposLegacyOKApplicationJSON from json.
func (s *TeamsListReposLegacyOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListReposLegacyOKApplicationJSON to nil`)
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListReposLegacyOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s TeamsRemoveMemberLegacyNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsRemoveMemberLegacyNoContent from json.
func (s *TeamsRemoveMemberLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveMemberLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveMemberLegacyNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsRemoveMemberLegacyNotFound from json.
func (s *TeamsRemoveMemberLegacyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveMemberLegacyNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveMembershipForUserInOrgForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsRemoveMembershipForUserInOrgForbidden from json.
func (s *TeamsRemoveMembershipForUserInOrgForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveMembershipForUserInOrgForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveMembershipForUserInOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsRemoveMembershipForUserInOrgNoContent from json.
func (s *TeamsRemoveMembershipForUserInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveMembershipForUserInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveMembershipForUserLegacyForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsRemoveMembershipForUserLegacyForbidden from json.
func (s *TeamsRemoveMembershipForUserLegacyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveMembershipForUserLegacyForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveMembershipForUserLegacyNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsRemoveMembershipForUserLegacyNoContent from json.
func (s *TeamsRemoveMembershipForUserLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveMembershipForUserLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveProjectInOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsRemoveProjectInOrgNoContent from json.
func (s *TeamsRemoveProjectInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveProjectInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveProjectLegacyNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsRemoveProjectLegacyNoContent from json.
func (s *TeamsRemoveProjectLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveProjectLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveRepoInOrgNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsRemoveRepoInOrgNoContent from json.
func (s *TeamsRemoveRepoInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveRepoInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveRepoLegacyNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes TeamsRemoveRepoLegacyNoContent from json.
func (s *TeamsRemoveRepoLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveRepoLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsUpdateDiscussionCommentInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

// Decode decodes TeamsUpdateDiscussionCommentInOrgReq from json.
func (s *TeamsUpdateDiscussionCommentInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateDiscussionCommentInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsUpdateDiscussionCommentLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

// Decode decodes TeamsUpdateDiscussionCommentLegacyReq from json.
func (s *TeamsUpdateDiscussionCommentLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateDiscussionCommentLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsUpdateDiscussionInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsUpdateDiscussionInOrgReq from json.
func (s *TeamsUpdateDiscussionInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateDiscussionInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsUpdateDiscussionLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsUpdateDiscussionLegacyReq from json.
func (s *TeamsUpdateDiscussionLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateDiscussionLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsUpdateInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Privacy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	{
		if s.ParentTeamID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ParentTeamID.Set {
			e.RawStr("\"parent_team_id\"" + ":")
			s.ParentTeamID.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsUpdateInOrgReq from json.
func (s *TeamsUpdateInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		case "parent_team_id":
			s.ParentTeamID.Reset()
			if err := s.ParentTeamID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsUpdateInOrgReqPermission as json.
func (s TeamsUpdateInOrgReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateInOrgReqPermission from json.
func (s *TeamsUpdateInOrgReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateInOrgReqPermission to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsUpdateInOrgReqPermission(v) {
	case TeamsUpdateInOrgReqPermissionPull:
		*s = TeamsUpdateInOrgReqPermissionPull
	case TeamsUpdateInOrgReqPermissionPush:
		*s = TeamsUpdateInOrgReqPermissionPush
	case TeamsUpdateInOrgReqPermissionAdmin:
		*s = TeamsUpdateInOrgReqPermissionAdmin
	default:
		*s = TeamsUpdateInOrgReqPermission(v)
	}

	return nil
}

// Encode encodes TeamsUpdateInOrgReqPrivacy as json.
func (s TeamsUpdateInOrgReqPrivacy) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateInOrgReqPrivacy from json.
func (s *TeamsUpdateInOrgReqPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateInOrgReqPrivacy to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsUpdateInOrgReqPrivacy(v) {
	case TeamsUpdateInOrgReqPrivacySecret:
		*s = TeamsUpdateInOrgReqPrivacySecret
	case TeamsUpdateInOrgReqPrivacyClosed:
		*s = TeamsUpdateInOrgReqPrivacyClosed
	default:
		*s = TeamsUpdateInOrgReqPrivacy(v)
	}

	return nil
}

// Encode encodes TeamsUpdateLegacyApplicationJSONCreated as json.
func (s TeamsUpdateLegacyApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := TeamFull(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsUpdateLegacyApplicationJSONCreated from json.
func (s *TeamsUpdateLegacyApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateLegacyApplicationJSONCreated to nil`)
	}
	var unwrapped TeamFull
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsUpdateLegacyApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes TeamsUpdateLegacyApplicationJSONForbidden as json.
func (s TeamsUpdateLegacyApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsUpdateLegacyApplicationJSONForbidden from json.
func (s *TeamsUpdateLegacyApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateLegacyApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsUpdateLegacyApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes TeamsUpdateLegacyApplicationJSONNotFound as json.
func (s TeamsUpdateLegacyApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsUpdateLegacyApplicationJSONNotFound from json.
func (s *TeamsUpdateLegacyApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateLegacyApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsUpdateLegacyApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes TeamsUpdateLegacyApplicationJSONOK as json.
func (s TeamsUpdateLegacyApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := TeamFull(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsUpdateLegacyApplicationJSONOK from json.
func (s *TeamsUpdateLegacyApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateLegacyApplicationJSONOK to nil`)
	}
	var unwrapped TeamFull
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsUpdateLegacyApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s TeamsUpdateLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Privacy.Set {
			e.Comma()
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		if s.Permission.Set {
			e.Comma()
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	{
		if s.ParentTeamID.Set {
			e.Comma()
		}
		if s.ParentTeamID.Set {
			e.RawStr("\"parent_team_id\"" + ":")
			s.ParentTeamID.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TeamsUpdateLegacyReq from json.
func (s *TeamsUpdateLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		case "parent_team_id":
			s.ParentTeamID.Reset()
			if err := s.ParentTeamID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsUpdateLegacyReqPermission as json.
func (s TeamsUpdateLegacyReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateLegacyReqPermission from json.
func (s *TeamsUpdateLegacyReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateLegacyReqPermission to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsUpdateLegacyReqPermission(v) {
	case TeamsUpdateLegacyReqPermissionPull:
		*s = TeamsUpdateLegacyReqPermissionPull
	case TeamsUpdateLegacyReqPermissionPush:
		*s = TeamsUpdateLegacyReqPermissionPush
	case TeamsUpdateLegacyReqPermissionAdmin:
		*s = TeamsUpdateLegacyReqPermissionAdmin
	default:
		*s = TeamsUpdateLegacyReqPermission(v)
	}

	return nil
}

// Encode encodes TeamsUpdateLegacyReqPrivacy as json.
func (s TeamsUpdateLegacyReqPrivacy) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateLegacyReqPrivacy from json.
func (s *TeamsUpdateLegacyReqPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateLegacyReqPrivacy to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsUpdateLegacyReqPrivacy(v) {
	case TeamsUpdateLegacyReqPrivacySecret:
		*s = TeamsUpdateLegacyReqPrivacySecret
	case TeamsUpdateLegacyReqPrivacyClosed:
		*s = TeamsUpdateLegacyReqPrivacyClosed
	default:
		*s = TeamsUpdateLegacyReqPrivacy(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Thread) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"subject\"" + ":")
		s.Subject.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"reason\"" + ":")
		e.Str(s.Reason)
	}
	{
		e.Comma()

		e.RawStr("\"unread\"" + ":")
		e.Bool(s.Unread)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		e.Str(s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"last_read_at\"" + ":")
		s.LastReadAt.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		e.Str(s.SubscriptionURL)
	}
	e.ObjEnd()
}

// Decode decodes Thread from json.
func (s *Thread) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Thread to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "subject":
			if err := s.Subject.Decode(d); err != nil {
				return err
			}
		case "reason":
			v, err := d.Str()
			s.Reason = string(v)
			if err != nil {
				return err
			}
		case "unread":
			v, err := d.Bool()
			s.Unread = bool(v)
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := d.Str()
			s.UpdatedAt = string(v)
			if err != nil {
				return err
			}
		case "last_read_at":
			if err := s.LastReadAt.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := d.Str()
			s.SubscriptionURL = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ThreadSubject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"latest_comment_url\"" + ":")
		e.Str(s.LatestCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

// Decode decodes ThreadSubject from json.
func (s *ThreadSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ThreadSubject to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "latest_comment_url":
			v, err := d.Str()
			s.LatestCommentURL = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ThreadSubscription) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"subscribed\"" + ":")
		e.Bool(s.Subscribed)
	}
	{
		e.Comma()

		e.RawStr("\"ignored\"" + ":")
		e.Bool(s.Ignored)
	}
	{
		e.Comma()

		e.RawStr("\"reason\"" + ":")
		s.Reason.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.ThreadURL.Set {
			e.Comma()
		}
		if s.ThreadURL.Set {
			e.RawStr("\"thread_url\"" + ":")
			s.ThreadURL.Encode(e)
		}
	}
	{
		if s.RepositoryURL.Set {
			e.Comma()
		}
		if s.RepositoryURL.Set {
			e.RawStr("\"repository_url\"" + ":")
			s.RepositoryURL.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ThreadSubscription from json.
func (s *ThreadSubscription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ThreadSubscription to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscribed":
			v, err := d.Bool()
			s.Subscribed = bool(v)
			if err != nil {
				return err
			}
		case "ignored":
			v, err := d.Bool()
			s.Ignored = bool(v)
			if err != nil {
				return err
			}
		case "reason":
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "created_at":
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "thread_url":
			s.ThreadURL.Reset()
			if err := s.ThreadURL.Decode(d); err != nil {
				return err
			}
		case "repository_url":
			s.RepositoryURL.Reset()
			if err := s.RepositoryURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Topic) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"names\"" + ":")
		e.ArrStart()
		if len(s.Names) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Names[0]
				e.Str(elem)
			}
			for _, elem := range s.Names[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes Topic from json.
func (s *Topic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Topic to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "names":
			s.Names = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Names = append(s.Names, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TopicSearchResultItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"display_name\"" + ":")
		s.DisplayName.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"short_description\"" + ":")
		s.ShortDescription.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_by\"" + ":")
		s.CreatedBy.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"released\"" + ":")
		s.Released.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"featured\"" + ":")
		e.Bool(s.Featured)
	}
	{
		e.Comma()

		e.RawStr("\"curated\"" + ":")
		e.Bool(s.Curated)
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Float64(s.Score)
	}
	{
		if s.RepositoryCount.Set {
			e.Comma()
		}
		if s.RepositoryCount.Set {
			e.RawStr("\"repository_count\"" + ":")
			s.RepositoryCount.Encode(e)
		}
	}
	{
		if s.LogoURL.Set {
			e.Comma()
		}
		if s.LogoURL.Set {
			e.RawStr("\"logo_url\"" + ":")
			s.LogoURL.Encode(e)
		}
	}
	{
		if s.TextMatches != nil {
			e.Comma()
		}
		if s.TextMatches != nil {
			e.RawStr("\"text_matches\"" + ":")
			s.TextMatches.Encode(e)
		}
	}
	{
		if s.Related.Set {
			e.Comma()
		}
		if s.Related.Set {
			e.RawStr("\"related\"" + ":")
			s.Related.Encode(e)
		}
	}
	{
		if s.Aliases.Set {
			e.Comma()
		}
		if s.Aliases.Set {
			e.RawStr("\"aliases\"" + ":")
			s.Aliases.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TopicSearchResultItem from json.
func (s *TopicSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TopicSearchResultItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "display_name":
			if err := s.DisplayName.Decode(d); err != nil {
				return err
			}
		case "short_description":
			if err := s.ShortDescription.Decode(d); err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "created_by":
			if err := s.CreatedBy.Decode(d); err != nil {
				return err
			}
		case "released":
			if err := s.Released.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "featured":
			v, err := d.Bool()
			s.Featured = bool(v)
			if err != nil {
				return err
			}
		case "curated":
			v, err := d.Bool()
			s.Curated = bool(v)
			if err != nil {
				return err
			}
		case "score":
			v, err := d.Float64()
			s.Score = float64(v)
			if err != nil {
				return err
			}
		case "repository_count":
			s.RepositoryCount.Reset()
			if err := s.RepositoryCount.Decode(d); err != nil {
				return err
			}
		case "logo_url":
			s.LogoURL.Reset()
			if err := s.LogoURL.Decode(d); err != nil {
				return err
			}
		case "text_matches":
			s.TextMatches = nil
			var elem SearchResultTextMatches
			{
				var unwrapped []SearchResultTextMatchesItem
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = SearchResultTextMatches(unwrapped)
			}
			s.TextMatches = &elem
		case "related":
			s.Related.Reset()
			if err := s.Related.Decode(d); err != nil {
				return err
			}
		case "aliases":
			s.Aliases.Reset()
			if err := s.Aliases.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TopicSearchResultItemAliasesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.TopicRelation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TopicRelation.Set {
			e.RawStr("\"topic_relation\"" + ":")
			s.TopicRelation.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TopicSearchResultItemAliasesItem from json.
func (s *TopicSearchResultItemAliasesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TopicSearchResultItemAliasesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "topic_relation":
			s.TopicRelation.Reset()
			if err := s.TopicRelation.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TopicSearchResultItemAliasesItemTopicRelation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.TopicID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TopicID.Set {
			e.RawStr("\"topic_id\"" + ":")
			s.TopicID.Encode(e)
		}
	}
	{
		if s.RelationType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RelationType.Set {
			e.RawStr("\"relation_type\"" + ":")
			s.RelationType.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TopicSearchResultItemAliasesItemTopicRelation from json.
func (s *TopicSearchResultItemAliasesItemTopicRelation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TopicSearchResultItemAliasesItemTopicRelation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "topic_id":
			s.TopicID.Reset()
			if err := s.TopicID.Decode(d); err != nil {
				return err
			}
		case "relation_type":
			s.RelationType.Reset()
			if err := s.RelationType.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TopicSearchResultItemRelatedItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.TopicRelation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TopicRelation.Set {
			e.RawStr("\"topic_relation\"" + ":")
			s.TopicRelation.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TopicSearchResultItemRelatedItem from json.
func (s *TopicSearchResultItemRelatedItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TopicSearchResultItemRelatedItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "topic_relation":
			s.TopicRelation.Reset()
			if err := s.TopicRelation.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TopicSearchResultItemRelatedItemTopicRelation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.TopicID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TopicID.Set {
			e.RawStr("\"topic_id\"" + ":")
			s.TopicID.Encode(e)
		}
	}
	{
		if s.RelationType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RelationType.Set {
			e.RawStr("\"relation_type\"" + ":")
			s.RelationType.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes TopicSearchResultItemRelatedItemTopicRelation from json.
func (s *TopicSearchResultItemRelatedItemTopicRelation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TopicSearchResultItemRelatedItemTopicRelation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "topic_id":
			s.TopicID.Reset()
			if err := s.TopicID.Decode(d); err != nil {
				return err
			}
		case "relation_type":
			s.RelationType.Reset()
			if err := s.RelationType.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Traffic) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"timestamp\"" + ":")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		e.Comma()

		e.RawStr("\"uniques\"" + ":")
		e.Int(s.Uniques)
	}
	{
		e.Comma()

		e.RawStr("\"count\"" + ":")
		e.Int(s.Count)
	}
	e.ObjEnd()
}

// Decode decodes Traffic from json.
func (s *Traffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Traffic to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			v, err := json.DecodeDateTime(d)
			s.Timestamp = v
			if err != nil {
				return err
			}
		case "uniques":
			v, err := d.Int()
			s.Uniques = int(v)
			if err != nil {
				return err
			}
		case "count":
			v, err := d.Int()
			s.Count = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UserMarketplacePurchase) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"billing_cycle\"" + ":")
		e.Str(s.BillingCycle)
	}
	{
		e.Comma()

		e.RawStr("\"next_billing_date\"" + ":")
		s.NextBillingDate.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"unit_count\"" + ":")
		s.UnitCount.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"on_free_trial\"" + ":")
		e.Bool(s.OnFreeTrial)
	}
	{
		e.Comma()

		e.RawStr("\"free_trial_ends_on\"" + ":")
		s.FreeTrialEndsOn.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"account\"" + ":")
		s.Account.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"plan\"" + ":")
		s.Plan.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes UserMarketplacePurchase from json.
func (s *UserMarketplacePurchase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UserMarketplacePurchase to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billing_cycle":
			v, err := d.Str()
			s.BillingCycle = string(v)
			if err != nil {
				return err
			}
		case "next_billing_date":
			if err := s.NextBillingDate.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "unit_count":
			if err := s.UnitCount.Decode(d); err != nil {
				return err
			}
		case "on_free_trial":
			v, err := d.Bool()
			s.OnFreeTrial = bool(v)
			if err != nil {
				return err
			}
		case "free_trial_ends_on":
			if err := s.FreeTrialEndsOn.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "account":
			if err := s.Account.Decode(d); err != nil {
				return err
			}
		case "plan":
			if err := s.Plan.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UserSearchResultItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Float64(s.Score)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		if s.PublicRepos.Set {
			e.Comma()
		}
		if s.PublicRepos.Set {
			e.RawStr("\"public_repos\"" + ":")
			s.PublicRepos.Encode(e)
		}
	}
	{
		if s.PublicGists.Set {
			e.Comma()
		}
		if s.PublicGists.Set {
			e.RawStr("\"public_gists\"" + ":")
			s.PublicGists.Encode(e)
		}
	}
	{
		if s.Followers.Set {
			e.Comma()
		}
		if s.Followers.Set {
			e.RawStr("\"followers\"" + ":")
			s.Followers.Encode(e)
		}
	}
	{
		if s.Following.Set {
			e.Comma()
		}
		if s.Following.Set {
			e.RawStr("\"following\"" + ":")
			s.Following.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.Comma()
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.Comma()
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.Comma()
		}
		if s.Bio.Set {
			e.RawStr("\"bio\"" + ":")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.Comma()
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.Comma()
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		if s.Hireable.Set {
			e.Comma()
		}
		if s.Hireable.Set {
			e.RawStr("\"hireable\"" + ":")
			s.Hireable.Encode(e)
		}
	}
	{
		if s.TextMatches != nil {
			e.Comma()
		}
		if s.TextMatches != nil {
			e.RawStr("\"text_matches\"" + ":")
			s.TextMatches.Encode(e)
		}
	}
	{
		if s.Blog.Set {
			e.Comma()
		}
		if s.Blog.Set {
			e.RawStr("\"blog\"" + ":")
			s.Blog.Encode(e)
		}
	}
	{
		if s.Company.Set {
			e.Comma()
		}
		if s.Company.Set {
			e.RawStr("\"company\"" + ":")
			s.Company.Encode(e)
		}
	}
	{
		if s.SuspendedAt.Set {
			e.Comma()
		}
		if s.SuspendedAt.Set {
			e.RawStr("\"suspended_at\"" + ":")
			s.SuspendedAt.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

// Decode decodes UserSearchResultItem from json.
func (s *UserSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UserSearchResultItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "score":
			v, err := d.Float64()
			s.Score = float64(v)
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "public_repos":
			s.PublicRepos.Reset()
			if err := s.PublicRepos.Decode(d); err != nil {
				return err
			}
		case "public_gists":
			s.PublicGists.Reset()
			if err := s.PublicGists.Decode(d); err != nil {
				return err
			}
		case "followers":
			s.Followers.Reset()
			if err := s.Followers.Decode(d); err != nil {
				return err
			}
		case "following":
			s.Following.Reset()
			if err := s.Following.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "bio":
			s.Bio.Reset()
			if err := s.Bio.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "hireable":
			s.Hireable.Reset()
			if err := s.Hireable.Decode(d); err != nil {
				return err
			}
		case "text_matches":
			s.TextMatches = nil
			var elem SearchResultTextMatches
			{
				var unwrapped []SearchResultTextMatchesItem
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = SearchResultTextMatches(unwrapped)
			}
			s.TextMatches = &elem
		case "blog":
			s.Blog.Reset()
			if err := s.Blog.Decode(d); err != nil {
				return err
			}
		case "company":
			s.Company.Reset()
			if err := s.Company.Decode(d); err != nil {
				return err
			}
		case "suspended_at":
			s.SuspendedAt.Reset()
			if err := s.SuspendedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersAddEmailForAuthenticatedApplicationJSONForbidden as json.
func (s UsersAddEmailForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersAddEmailForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersAddEmailForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersAddEmailForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersAddEmailForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersAddEmailForAuthenticatedApplicationJSONNotFound as json.
func (s UsersAddEmailForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersAddEmailForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersAddEmailForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersAddEmailForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersAddEmailForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersAddEmailForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersAddEmailForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersAddEmailForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersAddEmailForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersAddEmailForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersAddEmailForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersAddEmailForAuthenticatedCreatedApplicationJSON as json.
func (s UsersAddEmailForAuthenticatedCreatedApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Email(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersAddEmailForAuthenticatedCreatedApplicationJSON from json.
func (s *UsersAddEmailForAuthenticatedCreatedApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersAddEmailForAuthenticatedCreatedApplicationJSON to nil`)
	}
	var unwrapped []Email
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Email
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersAddEmailForAuthenticatedCreatedApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersAddEmailForAuthenticatedReq as json.
func (s UsersAddEmailForAuthenticatedReq) Encode(e *jx.Writer) {
	switch s.Type {
	case UsersAddEmailForAuthenticatedReq0UsersAddEmailForAuthenticatedReq:
		s.UsersAddEmailForAuthenticatedReq0.Encode(e)
	case ArrayStringUsersAddEmailForAuthenticatedReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	case StringUsersAddEmailForAuthenticatedReq:
		e.Str(s.String)
	}
}

// Decode decodes UsersAddEmailForAuthenticatedReq from json.
func (s *UsersAddEmailForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersAddEmailForAuthenticatedReq to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.UsersAddEmailForAuthenticatedReq0.Decode(d); err != nil {
			return err
		}
		s.Type = UsersAddEmailForAuthenticatedReq0UsersAddEmailForAuthenticatedReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringUsersAddEmailForAuthenticatedReq
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringUsersAddEmailForAuthenticatedReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s UsersAddEmailForAuthenticatedReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"emails\"" + ":")
		e.ArrStart()
		if len(s.Emails) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Emails[0]
				e.Str(elem)
			}
			for _, elem := range s.Emails[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes UsersAddEmailForAuthenticatedReq0 from json.
func (s *UsersAddEmailForAuthenticatedReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersAddEmailForAuthenticatedReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersBlockApplicationJSONForbidden as json.
func (s UsersBlockApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersBlockApplicationJSONForbidden from json.
func (s *UsersBlockApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersBlockApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersBlockApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersBlockApplicationJSONNotFound as json.
func (s UsersBlockApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersBlockApplicationJSONNotFound from json.
func (s *UsersBlockApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersBlockApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersBlockApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersBlockApplicationJSONUnauthorized as json.
func (s UsersBlockApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersBlockApplicationJSONUnauthorized from json.
func (s *UsersBlockApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersBlockApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersBlockApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersBlockNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes UsersBlockNoContent from json.
func (s *UsersBlockNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersBlockNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersCheckBlockedApplicationJSONForbidden as json.
func (s UsersCheckBlockedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckBlockedApplicationJSONForbidden from json.
func (s *UsersCheckBlockedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckBlockedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckBlockedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersCheckBlockedApplicationJSONNotFound as json.
func (s UsersCheckBlockedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckBlockedApplicationJSONNotFound from json.
func (s *UsersCheckBlockedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckBlockedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckBlockedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersCheckBlockedApplicationJSONUnauthorized as json.
func (s UsersCheckBlockedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckBlockedApplicationJSONUnauthorized from json.
func (s *UsersCheckBlockedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckBlockedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckBlockedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersCheckBlockedNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes UsersCheckBlockedNoContent from json.
func (s *UsersCheckBlockedNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckBlockedNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UsersCheckFollowingForUserNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes UsersCheckFollowingForUserNoContent from json.
func (s *UsersCheckFollowingForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckFollowingForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UsersCheckFollowingForUserNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes UsersCheckFollowingForUserNotFound from json.
func (s *UsersCheckFollowingForUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckFollowingForUserNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden as json.
func (s UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden from json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound as json.
func (s UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound from json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersCheckPersonIsFollowedByAuthenticatedNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes UsersCheckPersonIsFollowedByAuthenticatedNoContent from json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckPersonIsFollowedByAuthenticatedNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersCreateGpgKeyForAuthenticatedApplicationJSONForbidden as json.
func (s UsersCreateGpgKeyForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCreateGpgKeyForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersCreateGpgKeyForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCreateGpgKeyForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreateGpgKeyForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersCreateGpgKeyForAuthenticatedApplicationJSONNotFound as json.
func (s UsersCreateGpgKeyForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCreateGpgKeyForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersCreateGpgKeyForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCreateGpgKeyForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreateGpgKeyForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersCreateGpgKeyForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersCreateGpgKeyForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCreateGpgKeyForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersCreateGpgKeyForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCreateGpgKeyForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreateGpgKeyForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersCreateGpgKeyForAuthenticatedReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"armored_public_key\"" + ":")
		e.Str(s.ArmoredPublicKey)
	}
	e.ObjEnd()
}

// Decode decodes UsersCreateGpgKeyForAuthenticatedReq from json.
func (s *UsersCreateGpgKeyForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCreateGpgKeyForAuthenticatedReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "armored_public_key":
			v, err := d.Str()
			s.ArmoredPublicKey = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONForbidden as json.
func (s UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONNotFound as json.
func (s UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersCreatePublicSSHKeyForAuthenticatedReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	e.ObjEnd()
}

// Decode decodes UsersCreatePublicSSHKeyForAuthenticatedReq from json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCreatePublicSSHKeyForAuthenticatedReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersDeleteEmailForAuthenticatedApplicationJSONForbidden as json.
func (s UsersDeleteEmailForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteEmailForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersDeleteEmailForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeleteEmailForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteEmailForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersDeleteEmailForAuthenticatedApplicationJSONNotFound as json.
func (s UsersDeleteEmailForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteEmailForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersDeleteEmailForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeleteEmailForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteEmailForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersDeleteEmailForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersDeleteEmailForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteEmailForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersDeleteEmailForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeleteEmailForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteEmailForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersDeleteEmailForAuthenticatedNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes UsersDeleteEmailForAuthenticatedNoContent from json.
func (s *UsersDeleteEmailForAuthenticatedNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeleteEmailForAuthenticatedNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersDeleteEmailForAuthenticatedReq as json.
func (s UsersDeleteEmailForAuthenticatedReq) Encode(e *jx.Writer) {
	switch s.Type {
	case UsersDeleteEmailForAuthenticatedReq0UsersDeleteEmailForAuthenticatedReq:
		s.UsersDeleteEmailForAuthenticatedReq0.Encode(e)
	case ArrayStringUsersDeleteEmailForAuthenticatedReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	case StringUsersDeleteEmailForAuthenticatedReq:
		e.Str(s.String)
	}
}

// Decode decodes UsersDeleteEmailForAuthenticatedReq from json.
func (s *UsersDeleteEmailForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeleteEmailForAuthenticatedReq to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.UsersDeleteEmailForAuthenticatedReq0.Decode(d); err != nil {
			return err
		}
		s.Type = UsersDeleteEmailForAuthenticatedReq0UsersDeleteEmailForAuthenticatedReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringUsersDeleteEmailForAuthenticatedReq
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringUsersDeleteEmailForAuthenticatedReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s UsersDeleteEmailForAuthenticatedReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"emails\"" + ":")
		e.ArrStart()
		if len(s.Emails) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Emails[0]
				e.Str(elem)
			}
			for _, elem := range s.Emails[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes UsersDeleteEmailForAuthenticatedReq0 from json.
func (s *UsersDeleteEmailForAuthenticatedReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeleteEmailForAuthenticatedReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersDeleteGpgKeyForAuthenticatedApplicationJSONForbidden as json.
func (s UsersDeleteGpgKeyForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteGpgKeyForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersDeleteGpgKeyForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeleteGpgKeyForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteGpgKeyForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersDeleteGpgKeyForAuthenticatedApplicationJSONNotFound as json.
func (s UsersDeleteGpgKeyForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteGpgKeyForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersDeleteGpgKeyForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeleteGpgKeyForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteGpgKeyForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersDeleteGpgKeyForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersDeleteGpgKeyForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteGpgKeyForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersDeleteGpgKeyForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeleteGpgKeyForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteGpgKeyForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersDeleteGpgKeyForAuthenticatedNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes UsersDeleteGpgKeyForAuthenticatedNoContent from json.
func (s *UsersDeleteGpgKeyForAuthenticatedNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeleteGpgKeyForAuthenticatedNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden as json.
func (s UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound as json.
func (s UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersDeletePublicSSHKeyForAuthenticatedNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes UsersDeletePublicSSHKeyForAuthenticatedNoContent from json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeletePublicSSHKeyForAuthenticatedNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersFollowApplicationJSONForbidden as json.
func (s UsersFollowApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersFollowApplicationJSONForbidden from json.
func (s *UsersFollowApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersFollowApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersFollowApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersFollowApplicationJSONNotFound as json.
func (s UsersFollowApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersFollowApplicationJSONNotFound from json.
func (s *UsersFollowApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersFollowApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersFollowApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersFollowApplicationJSONUnauthorized as json.
func (s UsersFollowApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersFollowApplicationJSONUnauthorized from json.
func (s *UsersFollowApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersFollowApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersFollowApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersFollowNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes UsersFollowNoContent from json.
func (s *UsersFollowNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersFollowNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersGetAuthenticatedApplicationJSONForbidden as json.
func (s UsersGetAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetAuthenticatedApplicationJSONForbidden from json.
func (s *UsersGetAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersGetAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersGetAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersGetAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersGetAuthenticatedOK as json.
func (s UsersGetAuthenticatedOK) Encode(e *jx.Writer) {
	switch s.Type {
	case PrivateUserUsersGetAuthenticatedOK:
		s.PrivateUser.Encode(e)
	case PublicUserUsersGetAuthenticatedOK:
		s.PublicUser.Encode(e)
	}
}

// Decode decodes UsersGetAuthenticatedOK from json.
func (s *UsersGetAuthenticatedOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetAuthenticatedOK to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "two_factor_authentication":
				found = true
				s.Type = PrivateUserUsersGetAuthenticatedOK
			case "business_plus":
				found = true
				s.Type = PrivateUserUsersGetAuthenticatedOK
			case "ldap_dn":
				found = true
				s.Type = PrivateUserUsersGetAuthenticatedOK
			case "login":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "id":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "node_id":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "avatar_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "gravatar_id":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "html_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "followers_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "following_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "gists_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "starred_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "subscriptions_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "organizations_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "repos_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "events_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "received_events_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "type":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "site_admin":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "name":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "company":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "blog":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "location":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "email":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "hireable":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "bio":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "twitter_username":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "public_repos":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "public_gists":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "followers":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "following":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "created_at":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "updated_at":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "plan":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "suspended_at":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "private_gists":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "total_private_repos":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "owned_private_repos":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "disk_usage":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "collaborators":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PrivateUserUsersGetAuthenticatedOK:
		if err := s.PrivateUser.Decode(d); err != nil {
			return err
		}
	case PublicUserUsersGetAuthenticatedOK:
		if err := s.PublicUser.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode encodes UsersGetByUsernameOK as json.
func (s UsersGetByUsernameOK) Encode(e *jx.Writer) {
	switch s.Type {
	case PrivateUserUsersGetByUsernameOK:
		s.PrivateUser.Encode(e)
	case PublicUserUsersGetByUsernameOK:
		s.PublicUser.Encode(e)
	}
}

// Decode decodes UsersGetByUsernameOK from json.
func (s *UsersGetByUsernameOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetByUsernameOK to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "two_factor_authentication":
				found = true
				s.Type = PrivateUserUsersGetByUsernameOK
			case "business_plus":
				found = true
				s.Type = PrivateUserUsersGetByUsernameOK
			case "ldap_dn":
				found = true
				s.Type = PrivateUserUsersGetByUsernameOK
			case "login":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "id":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "node_id":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "avatar_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "gravatar_id":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "html_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "followers_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "following_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "gists_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "starred_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "subscriptions_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "organizations_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "repos_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "events_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "received_events_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "type":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "site_admin":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "name":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "company":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "blog":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "location":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "email":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "hireable":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "bio":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "twitter_username":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "public_repos":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "public_gists":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "followers":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "following":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "created_at":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "updated_at":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "plan":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "suspended_at":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "private_gists":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "total_private_repos":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "owned_private_repos":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "disk_usage":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "collaborators":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PrivateUserUsersGetByUsernameOK:
		if err := s.PrivateUser.Decode(d); err != nil {
			return err
		}
	case PublicUserUsersGetByUsernameOK:
		if err := s.PublicUser.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode encodes UsersGetContextForUserSubjectType as json.
func (s UsersGetContextForUserSubjectType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UsersGetContextForUserSubjectType from json.
func (s *UsersGetContextForUserSubjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetContextForUserSubjectType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UsersGetContextForUserSubjectType(v) {
	case UsersGetContextForUserSubjectTypeOrganization:
		*s = UsersGetContextForUserSubjectTypeOrganization
	case UsersGetContextForUserSubjectTypeRepository:
		*s = UsersGetContextForUserSubjectTypeRepository
	case UsersGetContextForUserSubjectTypeIssue:
		*s = UsersGetContextForUserSubjectTypeIssue
	case UsersGetContextForUserSubjectTypePullRequest:
		*s = UsersGetContextForUserSubjectTypePullRequest
	default:
		*s = UsersGetContextForUserSubjectType(v)
	}

	return nil
}

// Encode encodes UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden as json.
func (s UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound as json.
func (s UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden as json.
func (s UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound as json.
func (s UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListBlockedByAuthenticatedApplicationJSONForbidden as json.
func (s UsersListBlockedByAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListBlockedByAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListBlockedByAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListBlockedByAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListBlockedByAuthenticatedApplicationJSONNotFound as json.
func (s UsersListBlockedByAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListBlockedByAuthenticatedApplicationJSONNotFound from json.
func (s *UsersListBlockedByAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListBlockedByAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersListBlockedByAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListBlockedByAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListBlockedByAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListBlockedByAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListBlockedByAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListBlockedByAuthenticatedOKApplicationJSON as json.
func (s UsersListBlockedByAuthenticatedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListBlockedByAuthenticatedOKApplicationJSON from json.
func (s *UsersListBlockedByAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListBlockedByAuthenticatedOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListEmailsForAuthenticatedApplicationJSONForbidden as json.
func (s UsersListEmailsForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListEmailsForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListEmailsForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListEmailsForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListEmailsForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListEmailsForAuthenticatedApplicationJSONNotFound as json.
func (s UsersListEmailsForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListEmailsForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersListEmailsForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListEmailsForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListEmailsForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersListEmailsForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListEmailsForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListEmailsForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListEmailsForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListEmailsForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListEmailsForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListEmailsForAuthenticatedOKApplicationJSON as json.
func (s UsersListEmailsForAuthenticatedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Email(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListEmailsForAuthenticatedOKApplicationJSON from json.
func (s *UsersListEmailsForAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListEmailsForAuthenticatedOKApplicationJSON to nil`)
	}
	var unwrapped []Email
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Email
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListEmailsForAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListFollowedByAuthenticatedApplicationJSONForbidden as json.
func (s UsersListFollowedByAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowedByAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListFollowedByAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListFollowedByAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowedByAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListFollowedByAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListFollowedByAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowedByAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListFollowedByAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListFollowedByAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowedByAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListFollowedByAuthenticatedOKApplicationJSON as json.
func (s UsersListFollowedByAuthenticatedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListFollowedByAuthenticatedOKApplicationJSON from json.
func (s *UsersListFollowedByAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListFollowedByAuthenticatedOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowedByAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListFollowersForAuthenticatedUserApplicationJSONForbidden as json.
func (s UsersListFollowersForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowersForAuthenticatedUserApplicationJSONForbidden from json.
func (s *UsersListFollowersForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListFollowersForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowersForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListFollowersForAuthenticatedUserOKApplicationJSON as json.
func (s UsersListFollowersForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListFollowersForAuthenticatedUserOKApplicationJSON from json.
func (s *UsersListFollowersForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListFollowersForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowersForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListGpgKeysForAuthenticatedApplicationJSONForbidden as json.
func (s UsersListGpgKeysForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListGpgKeysForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListGpgKeysForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListGpgKeysForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListGpgKeysForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListGpgKeysForAuthenticatedApplicationJSONNotFound as json.
func (s UsersListGpgKeysForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListGpgKeysForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersListGpgKeysForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListGpgKeysForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListGpgKeysForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListGpgKeysForAuthenticatedOKApplicationJSON as json.
func (s UsersListGpgKeysForAuthenticatedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []GpgKey(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListGpgKeysForAuthenticatedOKApplicationJSON from json.
func (s *UsersListGpgKeysForAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListGpgKeysForAuthenticatedOKApplicationJSON to nil`)
	}
	var unwrapped []GpgKey
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GpgKey
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListGpgKeysForAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListOKApplicationJSON as json.
func (s UsersListOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListOKApplicationJSON from json.
func (s *UsersListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden as json.
func (s UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound as json.
func (s UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListPublicEmailsForAuthenticatedOKApplicationJSON as json.
func (s UsersListPublicEmailsForAuthenticatedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Email(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListPublicEmailsForAuthenticatedOKApplicationJSON from json.
func (s *UsersListPublicEmailsForAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicEmailsForAuthenticatedOKApplicationJSON to nil`)
	}
	var unwrapped []Email
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Email
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicEmailsForAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden as json.
func (s UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound as json.
func (s UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON as json.
func (s UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Key(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON from json.
func (s *UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON to nil`)
	}
	var unwrapped []Key
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Key
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONForbidden as json.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONNotFound as json.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON as json.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Email(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON to nil`)
	}
	var unwrapped []Email
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Email
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"visibility\"" + ":")
		s.Visibility.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedReq from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "visibility":
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility as json.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility(v) {
	case UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibilityPublic:
		*s = UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibilityPublic
	case UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibilityPrivate:
		*s = UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibilityPrivate
	default:
		*s = UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility(v)
	}

	return nil
}

// Encode encodes UsersUnblockApplicationJSONForbidden as json.
func (s UsersUnblockApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnblockApplicationJSONForbidden from json.
func (s *UsersUnblockApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnblockApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnblockApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersUnblockApplicationJSONNotFound as json.
func (s UsersUnblockApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnblockApplicationJSONNotFound from json.
func (s *UsersUnblockApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnblockApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnblockApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersUnblockApplicationJSONUnauthorized as json.
func (s UsersUnblockApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnblockApplicationJSONUnauthorized from json.
func (s *UsersUnblockApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnblockApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnblockApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersUnblockNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes UsersUnblockNoContent from json.
func (s *UsersUnblockNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnblockNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersUnfollowApplicationJSONForbidden as json.
func (s UsersUnfollowApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnfollowApplicationJSONForbidden from json.
func (s *UsersUnfollowApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnfollowApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnfollowApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersUnfollowApplicationJSONNotFound as json.
func (s UsersUnfollowApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnfollowApplicationJSONNotFound from json.
func (s *UsersUnfollowApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnfollowApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnfollowApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersUnfollowApplicationJSONUnauthorized as json.
func (s UsersUnfollowApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnfollowApplicationJSONUnauthorized from json.
func (s *UsersUnfollowApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnfollowApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnfollowApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersUnfollowNoContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes UsersUnfollowNoContent from json.
func (s *UsersUnfollowNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnfollowNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersUpdateAuthenticatedApplicationJSONForbidden as json.
func (s UsersUpdateAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUpdateAuthenticatedApplicationJSONForbidden from json.
func (s *UsersUpdateAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUpdateAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUpdateAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersUpdateAuthenticatedApplicationJSONNotFound as json.
func (s UsersUpdateAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUpdateAuthenticatedApplicationJSONNotFound from json.
func (s *UsersUpdateAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUpdateAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUpdateAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersUpdateAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersUpdateAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUpdateAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersUpdateAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUpdateAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUpdateAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersUpdateAuthenticatedReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Blog.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Blog.Set {
			e.RawStr("\"blog\"" + ":")
			s.Blog.Encode(e)
		}
	}
	{
		if s.TwitterUsername.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TwitterUsername.Set {
			e.RawStr("\"twitter_username\"" + ":")
			s.TwitterUsername.Encode(e)
		}
	}
	{
		if s.Company.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Company.Set {
			e.RawStr("\"company\"" + ":")
			s.Company.Encode(e)
		}
	}
	{
		if s.Location.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	{
		if s.Hireable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Hireable.Set {
			e.RawStr("\"hireable\"" + ":")
			s.Hireable.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Bio.Set {
			e.RawStr("\"bio\"" + ":")
			s.Bio.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes UsersUpdateAuthenticatedReq from json.
func (s *UsersUpdateAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUpdateAuthenticatedReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "blog":
			s.Blog.Reset()
			if err := s.Blog.Decode(d); err != nil {
				return err
			}
		case "twitter_username":
			s.TwitterUsername.Reset()
			if err := s.TwitterUsername.Decode(d); err != nil {
				return err
			}
		case "company":
			s.Company.Reset()
			if err := s.Company.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "hireable":
			s.Hireable.Reset()
			if err := s.Hireable.Decode(d); err != nil {
				return err
			}
		case "bio":
			s.Bio.Reset()
			if err := s.Bio.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ValidationError) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"documentation_url\"" + ":")
		e.Str(s.DocumentationURL)
	}
	{
		if s.Errors != nil {
			e.Comma()
		}
		if s.Errors != nil {
			e.RawStr("\"errors\"" + ":")
			e.ArrStart()
			if len(s.Errors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Errors[0]
					elem.Encode(e)
				}
				for _, elem := range s.Errors[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ValidationError from json.
func (s *ValidationError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ValidationError to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "documentation_url":
			v, err := d.Str()
			s.DocumentationURL = string(v)
			if err != nil {
				return err
			}
		case "errors":
			s.Errors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ValidationErrorErrorsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Errors = append(s.Errors, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ValidationErrorErrorsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Resource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resource.Set {
			e.RawStr("\"resource\"" + ":")
			s.Resource.Encode(e)
		}
	}
	{
		if s.Field.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Field.Set {
			e.RawStr("\"field\"" + ":")
			s.Field.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		e.Str(s.Code)
	}
	{
		if s.Index.Set {
			e.Comma()
		}
		if s.Index.Set {
			e.RawStr("\"index\"" + ":")
			s.Index.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.Comma()
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ValidationErrorErrorsItem from json.
func (s *ValidationErrorErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ValidationErrorErrorsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resource":
			s.Resource.Reset()
			if err := s.Resource.Decode(d); err != nil {
				return err
			}
		case "field":
			s.Field.Reset()
			if err := s.Field.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "code":
			v, err := d.Str()
			s.Code = string(v)
			if err != nil {
				return err
			}
		case "index":
			s.Index.Reset()
			if err := s.Index.Decode(d); err != nil {
				return err
			}
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ValidationErrorErrorsItemValue as json.
func (s ValidationErrorErrorsItemValue) Encode(e *jx.Writer) {
	switch s.Type {
	case StringValidationErrorErrorsItemValue:
		e.Str(s.String)
	case IntValidationErrorErrorsItemValue:
		e.Int(s.Int)
	case ArrayStringValidationErrorErrorsItemValue:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ValidationErrorErrorsItemValue from json.
func (s *ValidationErrorErrorsItemValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ValidationErrorErrorsItemValue to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringValidationErrorErrorsItemValue
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntValidationErrorErrorsItemValue
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringValidationErrorErrorsItemValue
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ValidationErrorSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"documentation_url\"" + ":")
		e.Str(s.DocumentationURL)
	}
	{
		if s.Errors != nil {
			e.Comma()
		}
		if s.Errors != nil {
			e.RawStr("\"errors\"" + ":")
			e.ArrStart()
			if len(s.Errors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Errors[0]
					e.Str(elem)
				}
				for _, elem := range s.Errors[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

// Decode decodes ValidationErrorSimple from json.
func (s *ValidationErrorSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ValidationErrorSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "documentation_url":
			v, err := d.Str()
			s.DocumentationURL = string(v)
			if err != nil {
				return err
			}
		case "errors":
			s.Errors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Errors = append(s.Errors, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Verification) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"verified\"" + ":")
		e.Bool(s.Verified)
	}
	{
		e.Comma()

		e.RawStr("\"reason\"" + ":")
		e.Str(s.Reason)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"signature\"" + ":")
		s.Signature.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Verification from json.
func (s *Verification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Verification to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verified":
			v, err := d.Bool()
			s.Verified = bool(v)
			if err != nil {
				return err
			}
		case "reason":
			v, err := d.Str()
			s.Reason = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		case "signature":
			if err := s.Signature.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ViewTraffic) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"count\"" + ":")
		e.Int(s.Count)
	}
	{
		e.Comma()

		e.RawStr("\"uniques\"" + ":")
		e.Int(s.Uniques)
	}
	{
		e.Comma()

		e.RawStr("\"views\"" + ":")
		e.ArrStart()
		if len(s.Views) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Views[0]
				elem.Encode(e)
			}
			for _, elem := range s.Views[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ViewTraffic from json.
func (s *ViewTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ViewTraffic to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			v, err := d.Int()
			s.Count = int(v)
			if err != nil {
				return err
			}
		case "uniques":
			v, err := d.Int()
			s.Uniques = int(v)
			if err != nil {
				return err
			}
		case "views":
			s.Views = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Traffic
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Views = append(s.Views, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes WaitTimer as json.
func (s WaitTimer) Encode(e *jx.Writer) {
	unwrapped := int(s)
	e.Int(unwrapped)
}

// Decode decodes WaitTimer from json.
func (s *WaitTimer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WaitTimer to nil`)
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WaitTimer(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s WebhookConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes WebhookConfig from json.
func (s *WebhookConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WebhookConfig to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl.Reset()
			if err := s.InsecureSsl.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes WebhookConfigContentType as json.
func (s WebhookConfigContentType) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes WebhookConfigContentType from json.
func (s *WebhookConfigContentType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WebhookConfigContentType to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebhookConfigContentType(unwrapped)
	return nil
}

// Encode encodes WebhookConfigInsecureSsl as json.
func (s WebhookConfigInsecureSsl) Encode(e *jx.Writer) {
	switch s.Type {
	case StringWebhookConfigInsecureSsl:
		e.Str(s.String)
	case Float64WebhookConfigInsecureSsl:
		e.Float64(s.Float64)
	}
}

// Decode decodes WebhookConfigInsecureSsl from json.
func (s *WebhookConfigInsecureSsl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WebhookConfigInsecureSsl to nil`)
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringWebhookConfigInsecureSsl
	case jx.Number:
		v, err := d.Float64()
		s.Float64 = float64(v)
		if err != nil {
			return err
		}
		s.Type = Float64WebhookConfigInsecureSsl
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode encodes WebhookConfigSecret as json.
func (s WebhookConfigSecret) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes WebhookConfigSecret from json.
func (s *WebhookConfigSecret) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WebhookConfigSecret to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebhookConfigSecret(unwrapped)
	return nil
}

// Encode encodes WebhookConfigURL as json.
func (s WebhookConfigURL) Encode(e *jx.Writer) {
	unwrapped := url.URL(s)
	json.EncodeURI(e, unwrapped)
}

// Decode decodes WebhookConfigURL from json.
func (s *WebhookConfigURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WebhookConfigURL to nil`)
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebhookConfigURL(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s Workflow) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		e.Str(s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"badge_url\"" + ":")
		e.Str(s.BadgeURL)
	}
	{
		if s.DeletedAt.Set {
			e.Comma()
		}
		if s.DeletedAt.Set {
			e.RawStr("\"deleted_at\"" + ":")
			s.DeletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

// Decode decodes Workflow from json.
func (s *Workflow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Workflow to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := d.Str()
			s.HTMLURL = string(v)
			if err != nil {
				return err
			}
		case "badge_url":
			v, err := d.Str()
			s.BadgeURL = string(v)
			if err != nil {
				return err
			}
		case "deleted_at":
			s.DeletedAt.Reset()
			if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s WorkflowRun) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		if s.CheckSuiteID.Set {
			e.Comma()
		}
		if s.CheckSuiteID.Set {
			e.RawStr("\"check_suite_id\"" + ":")
			s.CheckSuiteID.Encode(e)
		}
	}
	{
		if s.CheckSuiteNodeID.Set {
			e.Comma()
		}
		if s.CheckSuiteNodeID.Set {
			e.RawStr("\"check_suite_node_id\"" + ":")
			s.CheckSuiteNodeID.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"head_branch\"" + ":")
		s.HeadBranch.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"head_sha\"" + ":")
		e.Str(s.HeadSha)
	}
	{
		e.Comma()

		e.RawStr("\"run_number\"" + ":")
		e.Int(s.RunNumber)
	}
	{
		if s.RunAttempt.Set {
			e.Comma()
		}
		if s.RunAttempt.Set {
			e.RawStr("\"run_attempt\"" + ":")
			s.RunAttempt.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"event\"" + ":")
		e.Str(s.Event)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"conclusion\"" + ":")
		s.Conclusion.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"workflow_id\"" + ":")
		e.Int(s.WorkflowID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		e.Str(s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"pull_requests\"" + ":")
		if s.PullRequests == nil {
			e.Null()
		} else {
			e.ArrStart()
			if len(s.PullRequests) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PullRequests[0]
					elem.Encode(e)
				}
				for _, elem := range s.PullRequests[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"jobs_url\"" + ":")
		e.Str(s.JobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"logs_url\"" + ":")
		e.Str(s.LogsURL)
	}
	{
		e.Comma()

		e.RawStr("\"check_suite_url\"" + ":")
		e.Str(s.CheckSuiteURL)
	}
	{
		e.Comma()

		e.RawStr("\"artifacts_url\"" + ":")
		e.Str(s.ArtifactsURL)
	}
	{
		e.Comma()

		e.RawStr("\"cancel_url\"" + ":")
		e.Str(s.CancelURL)
	}
	{
		e.Comma()

		e.RawStr("\"rerun_url\"" + ":")
		e.Str(s.RerunURL)
	}
	{
		if s.PreviousAttemptURL.Set {
			e.Comma()
		}
		if s.PreviousAttemptURL.Set {
			e.RawStr("\"previous_attempt_url\"" + ":")
			s.PreviousAttemptURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"workflow_url\"" + ":")
		e.Str(s.WorkflowURL)
	}
	{
		e.Comma()

		e.RawStr("\"head_commit\"" + ":")
		s.HeadCommit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"head_repository\"" + ":")
		s.HeadRepository.Encode(e)
	}
	{
		if s.HeadRepositoryID.Set {
			e.Comma()
		}
		if s.HeadRepositoryID.Set {
			e.RawStr("\"head_repository_id\"" + ":")
			s.HeadRepositoryID.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes WorkflowRun from json.
func (s *WorkflowRun) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WorkflowRun to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "check_suite_id":
			s.CheckSuiteID.Reset()
			if err := s.CheckSuiteID.Decode(d); err != nil {
				return err
			}
		case "check_suite_node_id":
			s.CheckSuiteNodeID.Reset()
			if err := s.CheckSuiteNodeID.Decode(d); err != nil {
				return err
			}
		case "head_branch":
			if err := s.HeadBranch.Decode(d); err != nil {
				return err
			}
		case "head_sha":
			v, err := d.Str()
			s.HeadSha = string(v)
			if err != nil {
				return err
			}
		case "run_number":
			v, err := d.Int()
			s.RunNumber = int(v)
			if err != nil {
				return err
			}
		case "run_attempt":
			s.RunAttempt.Reset()
			if err := s.RunAttempt.Decode(d); err != nil {
				return err
			}
		case "event":
			v, err := d.Str()
			s.Event = string(v)
			if err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "conclusion":
			if err := s.Conclusion.Decode(d); err != nil {
				return err
			}
		case "workflow_id":
			v, err := d.Int()
			s.WorkflowID = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := d.Str()
			s.HTMLURL = string(v)
			if err != nil {
				return err
			}
		case "pull_requests":
			s.PullRequests = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PullRequestMinimal
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PullRequests = append(s.PullRequests, elem)
				return nil
			}); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "jobs_url":
			v, err := d.Str()
			s.JobsURL = string(v)
			if err != nil {
				return err
			}
		case "logs_url":
			v, err := d.Str()
			s.LogsURL = string(v)
			if err != nil {
				return err
			}
		case "check_suite_url":
			v, err := d.Str()
			s.CheckSuiteURL = string(v)
			if err != nil {
				return err
			}
		case "artifacts_url":
			v, err := d.Str()
			s.ArtifactsURL = string(v)
			if err != nil {
				return err
			}
		case "cancel_url":
			v, err := d.Str()
			s.CancelURL = string(v)
			if err != nil {
				return err
			}
		case "rerun_url":
			v, err := d.Str()
			s.RerunURL = string(v)
			if err != nil {
				return err
			}
		case "previous_attempt_url":
			s.PreviousAttemptURL.Reset()
			if err := s.PreviousAttemptURL.Decode(d); err != nil {
				return err
			}
		case "workflow_url":
			v, err := d.Str()
			s.WorkflowURL = string(v)
			if err != nil {
				return err
			}
		case "head_commit":
			if err := s.HeadCommit.Decode(d); err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "head_repository":
			if err := s.HeadRepository.Decode(d); err != nil {
				return err
			}
		case "head_repository_id":
			s.HeadRepositoryID.Reset()
			if err := s.HeadRepositoryID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s WorkflowRunUsage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"billable\"" + ":")
		s.Billable.Encode(e)
	}
	{
		if s.RunDurationMs.Set {
			e.Comma()
		}
		if s.RunDurationMs.Set {
			e.RawStr("\"run_duration_ms\"" + ":")
			s.RunDurationMs.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes WorkflowRunUsage from json.
func (s *WorkflowRunUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WorkflowRunUsage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billable":
			if err := s.Billable.Decode(d); err != nil {
				return err
			}
		case "run_duration_ms":
			s.RunDurationMs.Reset()
			if err := s.RunDurationMs.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s WorkflowRunUsageBillable) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.UBUNTU.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UBUNTU.Set {
			e.RawStr("\"UBUNTU\"" + ":")
			s.UBUNTU.Encode(e)
		}
	}
	{
		if s.MACOS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MACOS.Set {
			e.RawStr("\"MACOS\"" + ":")
			s.MACOS.Encode(e)
		}
	}
	{
		if s.WINDOWS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.WINDOWS.Set {
			e.RawStr("\"WINDOWS\"" + ":")
			s.WINDOWS.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes WorkflowRunUsageBillable from json.
func (s *WorkflowRunUsageBillable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WorkflowRunUsageBillable to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "UBUNTU":
			s.UBUNTU.Reset()
			if err := s.UBUNTU.Decode(d); err != nil {
				return err
			}
		case "MACOS":
			s.MACOS.Reset()
			if err := s.MACOS.Decode(d); err != nil {
				return err
			}
		case "WINDOWS":
			s.WINDOWS.Reset()
			if err := s.WINDOWS.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s WorkflowRunUsageBillableMACOS) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_ms\"" + ":")
		e.Int(s.TotalMs)
	}
	{
		e.Comma()

		e.RawStr("\"jobs\"" + ":")
		e.Int(s.Jobs)
	}
	e.ObjEnd()
}

// Decode decodes WorkflowRunUsageBillableMACOS from json.
func (s *WorkflowRunUsageBillableMACOS) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WorkflowRunUsageBillableMACOS to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_ms":
			v, err := d.Int()
			s.TotalMs = int(v)
			if err != nil {
				return err
			}
		case "jobs":
			v, err := d.Int()
			s.Jobs = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s WorkflowRunUsageBillableUBUNTU) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_ms\"" + ":")
		e.Int(s.TotalMs)
	}
	{
		e.Comma()

		e.RawStr("\"jobs\"" + ":")
		e.Int(s.Jobs)
	}
	e.ObjEnd()
}

// Decode decodes WorkflowRunUsageBillableUBUNTU from json.
func (s *WorkflowRunUsageBillableUBUNTU) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WorkflowRunUsageBillableUBUNTU to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_ms":
			v, err := d.Int()
			s.TotalMs = int(v)
			if err != nil {
				return err
			}
		case "jobs":
			v, err := d.Int()
			s.Jobs = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s WorkflowRunUsageBillableWINDOWS) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_ms\"" + ":")
		e.Int(s.TotalMs)
	}
	{
		e.Comma()

		e.RawStr("\"jobs\"" + ":")
		e.Int(s.Jobs)
	}
	e.ObjEnd()
}

// Decode decodes WorkflowRunUsageBillableWINDOWS from json.
func (s *WorkflowRunUsageBillableWINDOWS) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WorkflowRunUsageBillableWINDOWS to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_ms":
			v, err := d.Int()
			s.TotalMs = int(v)
			if err != nil {
				return err
			}
		case "jobs":
			v, err := d.Int()
			s.Jobs = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes WorkflowState as json.
func (s WorkflowState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes WorkflowState from json.
func (s *WorkflowState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WorkflowState to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowState(v) {
	case WorkflowStateActive:
		*s = WorkflowStateActive
	case WorkflowStateDeleted:
		*s = WorkflowStateDeleted
	case WorkflowStateDisabledFork:
		*s = WorkflowStateDisabledFork
	case WorkflowStateDisabledInactivity:
		*s = WorkflowStateDisabledInactivity
	case WorkflowStateDisabledManually:
		*s = WorkflowStateDisabledManually
	default:
		*s = WorkflowState(v)
	}

	return nil
}
