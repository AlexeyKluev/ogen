// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/bits"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = bits.LeadingZeros64
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
	_ = codes.Unset
)

// Encode implements json.Marshaler.
func (s APIOverview) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"verifiable_password_authentication\"" + ":")
		e.Bool(s.VerifiablePasswordAuthentication)
	}
	{
		if s.SSHKeyFingerprints.Set {
			e.Comma()
		}
		if s.SSHKeyFingerprints.Set {
			e.RawStr("\"ssh_key_fingerprints\"" + ":")
			s.SSHKeyFingerprints.Encode(e)
		}
	}
	{
		if s.Hooks != nil {
			e.Comma()
		}
		if s.Hooks != nil {
			e.RawStr("\"hooks\"" + ":")
			e.ArrStart()
			if len(s.Hooks) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Hooks[0]
					e.Str(elem)
				}
				for _, elem := range s.Hooks[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Web != nil {
			e.Comma()
		}
		if s.Web != nil {
			e.RawStr("\"web\"" + ":")
			e.ArrStart()
			if len(s.Web) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Web[0]
					e.Str(elem)
				}
				for _, elem := range s.Web[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.API != nil {
			e.Comma()
		}
		if s.API != nil {
			e.RawStr("\"api\"" + ":")
			e.ArrStart()
			if len(s.API) >= 1 {
				// Encode first element without comma.
				{
					elem := s.API[0]
					e.Str(elem)
				}
				for _, elem := range s.API[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Git != nil {
			e.Comma()
		}
		if s.Git != nil {
			e.RawStr("\"git\"" + ":")
			e.ArrStart()
			if len(s.Git) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Git[0]
					e.Str(elem)
				}
				for _, elem := range s.Git[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Packages != nil {
			e.Comma()
		}
		if s.Packages != nil {
			e.RawStr("\"packages\"" + ":")
			e.ArrStart()
			if len(s.Packages) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Packages[0]
					e.Str(elem)
				}
				for _, elem := range s.Packages[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Pages != nil {
			e.Comma()
		}
		if s.Pages != nil {
			e.RawStr("\"pages\"" + ":")
			e.ArrStart()
			if len(s.Pages) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Pages[0]
					e.Str(elem)
				}
				for _, elem := range s.Pages[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Importer != nil {
			e.Comma()
		}
		if s.Importer != nil {
			e.RawStr("\"importer\"" + ":")
			e.ArrStart()
			if len(s.Importer) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Importer[0]
					e.Str(elem)
				}
				for _, elem := range s.Importer[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Actions != nil {
			e.Comma()
		}
		if s.Actions != nil {
			e.RawStr("\"actions\"" + ":")
			e.ArrStart()
			if len(s.Actions) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Actions[0]
					e.Str(elem)
				}
				for _, elem := range s.Actions[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Dependabot != nil {
			e.Comma()
		}
		if s.Dependabot != nil {
			e.RawStr("\"dependabot\"" + ":")
			e.ArrStart()
			if len(s.Dependabot) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Dependabot[0]
					e.Str(elem)
				}
				for _, elem := range s.Dependabot[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAPIOverview = [11]string{
	0:  "verifiable_password_authentication",
	1:  "ssh_key_fingerprints",
	2:  "hooks",
	3:  "web",
	4:  "api",
	5:  "git",
	6:  "packages",
	7:  "pages",
	8:  "importer",
	9:  "actions",
	10: "dependabot",
}

// Decode decodes APIOverview from json.
func (s *APIOverview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIOverview to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verifiable_password_authentication":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.VerifiablePasswordAuthentication = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verifiable_password_authentication\"")
			}
		case "ssh_key_fingerprints":
			if err := func() error {
				s.SSHKeyFingerprints.Reset()
				if err := s.SSHKeyFingerprints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_key_fingerprints\"")
			}
		case "hooks":
			if err := func() error {
				s.Hooks = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hooks = append(s.Hooks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks\"")
			}
		case "web":
			if err := func() error {
				s.Web = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Web = append(s.Web, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"web\"")
			}
		case "api":
			if err := func() error {
				s.API = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.API = append(s.API, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api\"")
			}
		case "git":
			if err := func() error {
				s.Git = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Git = append(s.Git, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git\"")
			}
		case "packages":
			if err := func() error {
				s.Packages = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Packages = append(s.Packages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"packages\"")
			}
		case "pages":
			if err := func() error {
				s.Pages = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Pages = append(s.Pages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		case "importer":
			if err := func() error {
				s.Importer = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Importer = append(s.Importer, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importer\"")
			}
		case "actions":
			if err := func() error {
				s.Actions = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Actions = append(s.Actions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actions\"")
			}
		case "dependabot":
			if err := func() error {
				s.Dependabot = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Dependabot = append(s.Dependabot, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dependabot\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIOverview")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIOverview) {
					name = jsonFieldsNameOfAPIOverview[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s APIOverviewSSHKeyFingerprints) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.SHA256RSA.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SHA256RSA.Set {
			e.RawStr("\"SHA256_RSA\"" + ":")
			s.SHA256RSA.Encode(e)
		}
	}
	{
		if s.SHA256DSA.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SHA256DSA.Set {
			e.RawStr("\"SHA256_DSA\"" + ":")
			s.SHA256DSA.Encode(e)
		}
	}
	{
		if s.SHA256ECDSA.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SHA256ECDSA.Set {
			e.RawStr("\"SHA256_ECDSA\"" + ":")
			s.SHA256ECDSA.Encode(e)
		}
	}
	{
		if s.SHA256ED25519.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SHA256ED25519.Set {
			e.RawStr("\"SHA256_ED25519\"" + ":")
			s.SHA256ED25519.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAPIOverviewSSHKeyFingerprints = [4]string{
	0: "SHA256_RSA",
	1: "SHA256_DSA",
	2: "SHA256_ECDSA",
	3: "SHA256_ED25519",
}

// Decode decodes APIOverviewSSHKeyFingerprints from json.
func (s *APIOverviewSSHKeyFingerprints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIOverviewSSHKeyFingerprints to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "SHA256_RSA":
			if err := func() error {
				s.SHA256RSA.Reset()
				if err := s.SHA256RSA.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SHA256_RSA\"")
			}
		case "SHA256_DSA":
			if err := func() error {
				s.SHA256DSA.Reset()
				if err := s.SHA256DSA.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SHA256_DSA\"")
			}
		case "SHA256_ECDSA":
			if err := func() error {
				s.SHA256ECDSA.Reset()
				if err := s.SHA256ECDSA.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SHA256_ECDSA\"")
			}
		case "SHA256_ED25519":
			if err := func() error {
				s.SHA256ED25519.Reset()
				if err := s.SHA256ED25519.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SHA256_ED25519\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIOverviewSSHKeyFingerprints")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Accepted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfAccepted = [0]string{}

// Decode decodes Accepted from json.
func (s *Accepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Accepted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Accepted")
	}

	return nil
}

// Encode encodes ActionsApproveWorkflowRunApplicationJSONForbidden as json.
func (s ActionsApproveWorkflowRunApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActionsApproveWorkflowRunApplicationJSONForbidden from json.
func (s *ActionsApproveWorkflowRunApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsApproveWorkflowRunApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActionsApproveWorkflowRunApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActionsApproveWorkflowRunApplicationJSONNotFound as json.
func (s ActionsApproveWorkflowRunApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActionsApproveWorkflowRunApplicationJSONNotFound from json.
func (s *ActionsApproveWorkflowRunApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsApproveWorkflowRunApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActionsApproveWorkflowRunApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsBillingUsage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_minutes_used\"" + ":")
		e.Int(s.TotalMinutesUsed)
	}
	{
		e.Comma()

		e.RawStr("\"total_paid_minutes_used\"" + ":")
		e.Int(s.TotalPaidMinutesUsed)
	}
	{
		e.Comma()

		e.RawStr("\"included_minutes\"" + ":")
		e.Int(s.IncludedMinutes)
	}
	{
		e.Comma()

		e.RawStr("\"minutes_used_breakdown\"" + ":")
		s.MinutesUsedBreakdown.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsBillingUsage = [4]string{
	0: "total_minutes_used",
	1: "total_paid_minutes_used",
	2: "included_minutes",
	3: "minutes_used_breakdown",
}

// Decode decodes ActionsBillingUsage from json.
func (s *ActionsBillingUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsBillingUsage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_minutes_used":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalMinutesUsed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_minutes_used\"")
			}
		case "total_paid_minutes_used":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalPaidMinutesUsed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_paid_minutes_used\"")
			}
		case "included_minutes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.IncludedMinutes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"included_minutes\"")
			}
		case "minutes_used_breakdown":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.MinutesUsedBreakdown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minutes_used_breakdown\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsBillingUsage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsBillingUsage) {
					name = jsonFieldsNameOfActionsBillingUsage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsBillingUsageMinutesUsedBreakdown) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.UBUNTU.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UBUNTU.Set {
			e.RawStr("\"UBUNTU\"" + ":")
			s.UBUNTU.Encode(e)
		}
	}
	{
		if s.MACOS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MACOS.Set {
			e.RawStr("\"MACOS\"" + ":")
			s.MACOS.Encode(e)
		}
	}
	{
		if s.WINDOWS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.WINDOWS.Set {
			e.RawStr("\"WINDOWS\"" + ":")
			s.WINDOWS.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsBillingUsageMinutesUsedBreakdown = [3]string{
	0: "UBUNTU",
	1: "MACOS",
	2: "WINDOWS",
}

// Decode decodes ActionsBillingUsageMinutesUsedBreakdown from json.
func (s *ActionsBillingUsageMinutesUsedBreakdown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsBillingUsageMinutesUsedBreakdown to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "UBUNTU":
			if err := func() error {
				s.UBUNTU.Reset()
				if err := s.UBUNTU.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UBUNTU\"")
			}
		case "MACOS":
			if err := func() error {
				s.MACOS.Reset()
				if err := s.MACOS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MACOS\"")
			}
		case "WINDOWS":
			if err := func() error {
				s.WINDOWS.Reset()
				if err := s.WINDOWS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"WINDOWS\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsBillingUsageMinutesUsedBreakdown")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsCancelWorkflowRunAccepted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsCancelWorkflowRunAccepted = [0]string{}

// Decode decodes ActionsCancelWorkflowRunAccepted from json.
func (s ActionsCancelWorkflowRunAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCancelWorkflowRunAccepted to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsCancelWorkflowRunAccepted")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateEnvironmentSecretReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"encrypted_value\"" + ":")
		e.Str(s.EncryptedValue)
	}
	{
		e.Comma()

		e.RawStr("\"key_id\"" + ":")
		e.Str(s.KeyID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsCreateOrUpdateEnvironmentSecretReq = [2]string{
	0: "encrypted_value",
	1: "key_id",
}

// Decode decodes ActionsCreateOrUpdateEnvironmentSecretReq from json.
func (s *ActionsCreateOrUpdateEnvironmentSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCreateOrUpdateEnvironmentSecretReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encrypted_value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EncryptedValue = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encrypted_value\"")
			}
		case "key_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.KeyID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsCreateOrUpdateEnvironmentSecretReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsCreateOrUpdateEnvironmentSecretReq) {
					name = jsonFieldsNameOfActionsCreateOrUpdateEnvironmentSecretReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateOrgSecretReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.EncryptedValue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EncryptedValue.Set {
			e.RawStr("\"encrypted_value\"" + ":")
			s.EncryptedValue.Encode(e)
		}
	}
	{
		if s.KeyID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.KeyID.Set {
			e.RawStr("\"key_id\"" + ":")
			s.KeyID.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"visibility\"" + ":")
		s.Visibility.Encode(e)
	}
	{
		if s.SelectedRepositoryIds != nil {
			e.Comma()
		}
		if s.SelectedRepositoryIds != nil {
			e.RawStr("\"selected_repository_ids\"" + ":")
			e.ArrStart()
			if len(s.SelectedRepositoryIds) >= 1 {
				// Encode first element without comma.
				{
					elem := s.SelectedRepositoryIds[0]
					e.Str(elem)
				}
				for _, elem := range s.SelectedRepositoryIds[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsCreateOrUpdateOrgSecretReq = [4]string{
	0: "encrypted_value",
	1: "key_id",
	2: "visibility",
	3: "selected_repository_ids",
}

// Decode decodes ActionsCreateOrUpdateOrgSecretReq from json.
func (s *ActionsCreateOrUpdateOrgSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCreateOrUpdateOrgSecretReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encrypted_value":
			if err := func() error {
				s.EncryptedValue.Reset()
				if err := s.EncryptedValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encrypted_value\"")
			}
		case "key_id":
			if err := func() error {
				s.KeyID.Reset()
				if err := s.KeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_id\"")
			}
		case "visibility":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "selected_repository_ids":
			if err := func() error {
				s.SelectedRepositoryIds = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repository_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsCreateOrUpdateOrgSecretReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsCreateOrUpdateOrgSecretReq) {
					name = jsonFieldsNameOfActionsCreateOrUpdateOrgSecretReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ActionsCreateOrUpdateOrgSecretReqVisibility as json.
func (s ActionsCreateOrUpdateOrgSecretReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ActionsCreateOrUpdateOrgSecretReqVisibility from json.
func (s *ActionsCreateOrUpdateOrgSecretReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCreateOrUpdateOrgSecretReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionsCreateOrUpdateOrgSecretReqVisibility(v) {
	case ActionsCreateOrUpdateOrgSecretReqVisibilityAll:
		*s = ActionsCreateOrUpdateOrgSecretReqVisibilityAll
	case ActionsCreateOrUpdateOrgSecretReqVisibilityPrivate:
		*s = ActionsCreateOrUpdateOrgSecretReqVisibilityPrivate
	case ActionsCreateOrUpdateOrgSecretReqVisibilitySelected:
		*s = ActionsCreateOrUpdateOrgSecretReqVisibilitySelected
	default:
		*s = ActionsCreateOrUpdateOrgSecretReqVisibility(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateRepoSecretCreated) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsCreateOrUpdateRepoSecretCreated = [0]string{}

// Decode decodes ActionsCreateOrUpdateRepoSecretCreated from json.
func (s ActionsCreateOrUpdateRepoSecretCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCreateOrUpdateRepoSecretCreated to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsCreateOrUpdateRepoSecretCreated")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateRepoSecretReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.EncryptedValue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EncryptedValue.Set {
			e.RawStr("\"encrypted_value\"" + ":")
			s.EncryptedValue.Encode(e)
		}
	}
	{
		if s.KeyID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.KeyID.Set {
			e.RawStr("\"key_id\"" + ":")
			s.KeyID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsCreateOrUpdateRepoSecretReq = [2]string{
	0: "encrypted_value",
	1: "key_id",
}

// Decode decodes ActionsCreateOrUpdateRepoSecretReq from json.
func (s *ActionsCreateOrUpdateRepoSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCreateOrUpdateRepoSecretReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encrypted_value":
			if err := func() error {
				s.EncryptedValue.Reset()
				if err := s.EncryptedValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encrypted_value\"")
			}
		case "key_id":
			if err := func() error {
				s.KeyID.Reset()
				if err := s.KeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsCreateOrUpdateRepoSecretReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsCreateSelfHostedRunnerGroupForOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.SelectedRepositoryIds != nil {
			e.Comma()
		}
		if s.SelectedRepositoryIds != nil {
			e.RawStr("\"selected_repository_ids\"" + ":")
			e.ArrStart()
			if len(s.SelectedRepositoryIds) >= 1 {
				// Encode first element without comma.
				{
					elem := s.SelectedRepositoryIds[0]
					e.Int(elem)
				}
				for _, elem := range s.SelectedRepositoryIds[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Runners != nil {
			e.Comma()
		}
		if s.Runners != nil {
			e.RawStr("\"runners\"" + ":")
			e.ArrStart()
			if len(s.Runners) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Runners[0]
					e.Int(elem)
				}
				for _, elem := range s.Runners[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsCreateSelfHostedRunnerGroupForOrgReq = [4]string{
	0: "name",
	1: "visibility",
	2: "selected_repository_ids",
	3: "runners",
}

// Decode decodes ActionsCreateSelfHostedRunnerGroupForOrgReq from json.
func (s *ActionsCreateSelfHostedRunnerGroupForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCreateSelfHostedRunnerGroupForOrgReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "selected_repository_ids":
			if err := func() error {
				s.SelectedRepositoryIds = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repository_ids\"")
			}
		case "runners":
			if err := func() error {
				s.Runners = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsCreateSelfHostedRunnerGroupForOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsCreateSelfHostedRunnerGroupForOrgReq) {
					name = jsonFieldsNameOfActionsCreateSelfHostedRunnerGroupForOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (s ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (s *ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility(v) {
	case ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilitySelected:
		*s = ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilitySelected
	case ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilityAll:
		*s = ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilityAll
	case ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilityPrivate:
		*s = ActionsCreateSelfHostedRunnerGroupForOrgReqVisibilityPrivate
	default:
		*s = ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility(v)
	}

	return nil
}

// Encode encodes ActionsEnabled as json.
func (s ActionsEnabled) Encode(e *jx.Writer) {
	unwrapped := bool(s)
	e.Bool(unwrapped)
}

// Decode decodes ActionsEnabled from json.
func (s *ActionsEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsEnabled to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActionsEnabled(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsEnterprisePermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled_organizations\"" + ":")
		s.EnabledOrganizations.Encode(e)
	}
	{
		if s.SelectedOrganizationsURL.Set {
			e.Comma()
		}
		if s.SelectedOrganizationsURL.Set {
			e.RawStr("\"selected_organizations_url\"" + ":")
			s.SelectedOrganizationsURL.Encode(e)
		}
	}
	{
		if s.AllowedActions.Set {
			e.Comma()
		}
		if s.AllowedActions.Set {
			e.RawStr("\"allowed_actions\"" + ":")
			s.AllowedActions.Encode(e)
		}
	}
	{
		if s.SelectedActionsURL.Set {
			e.Comma()
		}
		if s.SelectedActionsURL.Set {
			e.RawStr("\"selected_actions_url\"" + ":")
			s.SelectedActionsURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsEnterprisePermissions = [4]string{
	0: "enabled_organizations",
	1: "selected_organizations_url",
	2: "allowed_actions",
	3: "selected_actions_url",
}

// Decode decodes ActionsEnterprisePermissions from json.
func (s *ActionsEnterprisePermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsEnterprisePermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_organizations":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EnabledOrganizations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled_organizations\"")
			}
		case "selected_organizations_url":
			if err := func() error {
				s.SelectedOrganizationsURL.Reset()
				if err := s.SelectedOrganizationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_organizations_url\"")
			}
		case "allowed_actions":
			if err := func() error {
				s.AllowedActions.Reset()
				if err := s.AllowedActions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_actions\"")
			}
		case "selected_actions_url":
			if err := func() error {
				s.SelectedActionsURL.Reset()
				if err := s.SelectedActionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_actions_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsEnterprisePermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsEnterprisePermissions) {
					name = jsonFieldsNameOfActionsEnterprisePermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListArtifactsForRepoOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"artifacts\"" + ":")
		e.ArrStart()
		if len(s.Artifacts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Artifacts[0]
				elem.Encode(e)
			}
			for _, elem := range s.Artifacts[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsListArtifactsForRepoOK = [2]string{
	0: "total_count",
	1: "artifacts",
}

// Decode decodes ActionsListArtifactsForRepoOK from json.
func (s *ActionsListArtifactsForRepoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListArtifactsForRepoOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "artifacts":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Artifacts = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Artifact
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Artifacts = append(s.Artifacts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifacts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListArtifactsForRepoOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListArtifactsForRepoOK) {
					name = jsonFieldsNameOfActionsListArtifactsForRepoOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListEnvironmentSecretsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"secrets\"" + ":")
		e.ArrStart()
		if len(s.Secrets) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Secrets[0]
				elem.Encode(e)
			}
			for _, elem := range s.Secrets[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsListEnvironmentSecretsOK = [2]string{
	0: "total_count",
	1: "secrets",
}

// Decode decodes ActionsListEnvironmentSecretsOK from json.
func (s *ActionsListEnvironmentSecretsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListEnvironmentSecretsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Secrets = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ActionsSecret
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Secrets = append(s.Secrets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListEnvironmentSecretsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListEnvironmentSecretsOK) {
					name = jsonFieldsNameOfActionsListEnvironmentSecretsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListJobsForWorkflowRunOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"jobs\"" + ":")
		e.ArrStart()
		if len(s.Jobs) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Jobs[0]
				elem.Encode(e)
			}
			for _, elem := range s.Jobs[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsListJobsForWorkflowRunOK = [2]string{
	0: "total_count",
	1: "jobs",
}

// Decode decodes ActionsListJobsForWorkflowRunOK from json.
func (s *ActionsListJobsForWorkflowRunOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListJobsForWorkflowRunOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "jobs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Jobs = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Job
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Jobs = append(s.Jobs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListJobsForWorkflowRunOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListJobsForWorkflowRunOK) {
					name = jsonFieldsNameOfActionsListJobsForWorkflowRunOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListOrgSecretsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"secrets\"" + ":")
		e.ArrStart()
		if len(s.Secrets) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Secrets[0]
				elem.Encode(e)
			}
			for _, elem := range s.Secrets[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsListOrgSecretsOK = [2]string{
	0: "total_count",
	1: "secrets",
}

// Decode decodes ActionsListOrgSecretsOK from json.
func (s *ActionsListOrgSecretsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListOrgSecretsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Secrets = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem OrganizationActionsSecret
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Secrets = append(s.Secrets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListOrgSecretsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListOrgSecretsOK) {
					name = jsonFieldsNameOfActionsListOrgSecretsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				elem.Encode(e)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK = [2]string{
	0: "total_count",
	1: "repositories",
}

// Decode decodes ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK from json.
func (s *ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "repositories":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Repositories = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MinimalRepository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK) {
					name = jsonFieldsNameOfActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListRepoSecretsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"secrets\"" + ":")
		e.ArrStart()
		if len(s.Secrets) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Secrets[0]
				elem.Encode(e)
			}
			for _, elem := range s.Secrets[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsListRepoSecretsOK = [2]string{
	0: "total_count",
	1: "secrets",
}

// Decode decodes ActionsListRepoSecretsOK from json.
func (s *ActionsListRepoSecretsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListRepoSecretsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Secrets = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ActionsSecret
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Secrets = append(s.Secrets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListRepoSecretsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListRepoSecretsOK) {
					name = jsonFieldsNameOfActionsListRepoSecretsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListRepoWorkflowsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"workflows\"" + ":")
		e.ArrStart()
		if len(s.Workflows) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Workflows[0]
				elem.Encode(e)
			}
			for _, elem := range s.Workflows[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsListRepoWorkflowsOK = [2]string{
	0: "total_count",
	1: "workflows",
}

// Decode decodes ActionsListRepoWorkflowsOK from json.
func (s *ActionsListRepoWorkflowsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListRepoWorkflowsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "workflows":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Workflows = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Workflow
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Workflows = append(s.Workflows, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListRepoWorkflowsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListRepoWorkflowsOK) {
					name = jsonFieldsNameOfActionsListRepoWorkflowsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListSelectedReposForOrgSecretOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				elem.Encode(e)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsListSelectedReposForOrgSecretOK = [2]string{
	0: "total_count",
	1: "repositories",
}

// Decode decodes ActionsListSelectedReposForOrgSecretOK from json.
func (s *ActionsListSelectedReposForOrgSecretOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListSelectedReposForOrgSecretOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "repositories":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Repositories = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MinimalRepository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListSelectedReposForOrgSecretOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListSelectedReposForOrgSecretOK) {
					name = jsonFieldsNameOfActionsListSelectedReposForOrgSecretOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				elem.Encode(e)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK = [2]string{
	0: "total_count",
	1: "repositories",
}

// Decode decodes ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK from json.
func (s *ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "repositories":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Repositories = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Repository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK) {
					name = jsonFieldsNameOfActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListSelfHostedRunnerGroupsForOrgOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"runner_groups\"" + ":")
		e.ArrStart()
		if len(s.RunnerGroups) >= 1 {
			// Encode first element without comma.
			{
				elem := s.RunnerGroups[0]
				elem.Encode(e)
			}
			for _, elem := range s.RunnerGroups[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsListSelfHostedRunnerGroupsForOrgOK = [2]string{
	0: "total_count",
	1: "runner_groups",
}

// Decode decodes ActionsListSelfHostedRunnerGroupsForOrgOK from json.
func (s *ActionsListSelfHostedRunnerGroupsForOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListSelfHostedRunnerGroupsForOrgOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "runner_groups":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.RunnerGroups = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RunnerGroupsOrg
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RunnerGroups = append(s.RunnerGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runner_groups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListSelfHostedRunnerGroupsForOrgOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListSelfHostedRunnerGroupsForOrgOK) {
					name = jsonFieldsNameOfActionsListSelfHostedRunnerGroupsForOrgOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListSelfHostedRunnersForOrgOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"runners\"" + ":")
		e.ArrStart()
		if len(s.Runners) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Runners[0]
				elem.Encode(e)
			}
			for _, elem := range s.Runners[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsListSelfHostedRunnersForOrgOK = [2]string{
	0: "total_count",
	1: "runners",
}

// Decode decodes ActionsListSelfHostedRunnersForOrgOK from json.
func (s *ActionsListSelfHostedRunnersForOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListSelfHostedRunnersForOrgOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "runners":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Runners = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Runner
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListSelfHostedRunnersForOrgOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListSelfHostedRunnersForOrgOK) {
					name = jsonFieldsNameOfActionsListSelfHostedRunnersForOrgOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListSelfHostedRunnersForRepoOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"runners\"" + ":")
		e.ArrStart()
		if len(s.Runners) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Runners[0]
				elem.Encode(e)
			}
			for _, elem := range s.Runners[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsListSelfHostedRunnersForRepoOK = [2]string{
	0: "total_count",
	1: "runners",
}

// Decode decodes ActionsListSelfHostedRunnersForRepoOK from json.
func (s *ActionsListSelfHostedRunnersForRepoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListSelfHostedRunnersForRepoOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "runners":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Runners = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Runner
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListSelfHostedRunnersForRepoOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListSelfHostedRunnersForRepoOK) {
					name = jsonFieldsNameOfActionsListSelfHostedRunnersForRepoOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListSelfHostedRunnersInGroupForOrgOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"runners\"" + ":")
		e.ArrStart()
		if len(s.Runners) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Runners[0]
				elem.Encode(e)
			}
			for _, elem := range s.Runners[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsListSelfHostedRunnersInGroupForOrgOK = [2]string{
	0: "total_count",
	1: "runners",
}

// Decode decodes ActionsListSelfHostedRunnersInGroupForOrgOK from json.
func (s *ActionsListSelfHostedRunnersInGroupForOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListSelfHostedRunnersInGroupForOrgOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "runners":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Runners = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Runner
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListSelfHostedRunnersInGroupForOrgOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListSelfHostedRunnersInGroupForOrgOK) {
					name = jsonFieldsNameOfActionsListSelfHostedRunnersInGroupForOrgOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListWorkflowRunArtifactsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"artifacts\"" + ":")
		e.ArrStart()
		if len(s.Artifacts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Artifacts[0]
				elem.Encode(e)
			}
			for _, elem := range s.Artifacts[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsListWorkflowRunArtifactsOK = [2]string{
	0: "total_count",
	1: "artifacts",
}

// Decode decodes ActionsListWorkflowRunArtifactsOK from json.
func (s *ActionsListWorkflowRunArtifactsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListWorkflowRunArtifactsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "artifacts":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Artifacts = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Artifact
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Artifacts = append(s.Artifacts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifacts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListWorkflowRunArtifactsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListWorkflowRunArtifactsOK) {
					name = jsonFieldsNameOfActionsListWorkflowRunArtifactsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListWorkflowRunsForRepoOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"workflow_runs\"" + ":")
		e.ArrStart()
		if len(s.WorkflowRuns) >= 1 {
			// Encode first element without comma.
			{
				elem := s.WorkflowRuns[0]
				elem.Encode(e)
			}
			for _, elem := range s.WorkflowRuns[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsListWorkflowRunsForRepoOK = [2]string{
	0: "total_count",
	1: "workflow_runs",
}

// Decode decodes ActionsListWorkflowRunsForRepoOK from json.
func (s *ActionsListWorkflowRunsForRepoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsListWorkflowRunsForRepoOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "workflow_runs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.WorkflowRuns = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkflowRun
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.WorkflowRuns = append(s.WorkflowRuns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_runs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsListWorkflowRunsForRepoOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsListWorkflowRunsForRepoOK) {
					name = jsonFieldsNameOfActionsListWorkflowRunsForRepoOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsOrganizationPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled_repositories\"" + ":")
		s.EnabledRepositories.Encode(e)
	}
	{
		if s.SelectedRepositoriesURL.Set {
			e.Comma()
		}
		if s.SelectedRepositoriesURL.Set {
			e.RawStr("\"selected_repositories_url\"" + ":")
			s.SelectedRepositoriesURL.Encode(e)
		}
	}
	{
		if s.AllowedActions.Set {
			e.Comma()
		}
		if s.AllowedActions.Set {
			e.RawStr("\"allowed_actions\"" + ":")
			s.AllowedActions.Encode(e)
		}
	}
	{
		if s.SelectedActionsURL.Set {
			e.Comma()
		}
		if s.SelectedActionsURL.Set {
			e.RawStr("\"selected_actions_url\"" + ":")
			s.SelectedActionsURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsOrganizationPermissions = [4]string{
	0: "enabled_repositories",
	1: "selected_repositories_url",
	2: "allowed_actions",
	3: "selected_actions_url",
}

// Decode decodes ActionsOrganizationPermissions from json.
func (s *ActionsOrganizationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsOrganizationPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_repositories":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EnabledRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled_repositories\"")
			}
		case "selected_repositories_url":
			if err := func() error {
				s.SelectedRepositoriesURL.Reset()
				if err := s.SelectedRepositoriesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repositories_url\"")
			}
		case "allowed_actions":
			if err := func() error {
				s.AllowedActions.Reset()
				if err := s.AllowedActions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_actions\"")
			}
		case "selected_actions_url":
			if err := func() error {
				s.SelectedActionsURL.Reset()
				if err := s.SelectedActionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_actions_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsOrganizationPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsOrganizationPermissions) {
					name = jsonFieldsNameOfActionsOrganizationPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsPublicKey) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key_id\"" + ":")
		e.Str(s.KeyID)
	}
	{
		e.Comma()

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		if s.ID.Set {
			e.Comma()
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.Comma()
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.Comma()
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.Comma()
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsPublicKey = [6]string{
	0: "key_id",
	1: "key",
	2: "id",
	3: "url",
	4: "title",
	5: "created_at",
}

// Decode decodes ActionsPublicKey from json.
func (s *ActionsPublicKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsPublicKey to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.KeyID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_id\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsPublicKey")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsPublicKey) {
					name = jsonFieldsNameOfActionsPublicKey[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsReRunWorkflowCreated) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsReRunWorkflowCreated = [0]string{}

// Decode decodes ActionsReRunWorkflowCreated from json.
func (s ActionsReRunWorkflowCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsReRunWorkflowCreated to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsReRunWorkflowCreated")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled\"" + ":")
		s.Enabled.Encode(e)
	}
	{
		if s.AllowedActions.Set {
			e.Comma()
		}
		if s.AllowedActions.Set {
			e.RawStr("\"allowed_actions\"" + ":")
			s.AllowedActions.Encode(e)
		}
	}
	{
		if s.SelectedActionsURL.Set {
			e.Comma()
		}
		if s.SelectedActionsURL.Set {
			e.RawStr("\"selected_actions_url\"" + ":")
			s.SelectedActionsURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsRepositoryPermissions = [3]string{
	0: "enabled",
	1: "allowed_actions",
	2: "selected_actions_url",
}

// Decode decodes ActionsRepositoryPermissions from json.
func (s *ActionsRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsRepositoryPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				{
					var unwrapped bool
					v, err := d.Bool()
					unwrapped = bool(v)
					if err != nil {
						return err
					}
					s.Enabled = ActionsEnabled(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "allowed_actions":
			if err := func() error {
				s.AllowedActions.Reset()
				if err := s.AllowedActions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_actions\"")
			}
		case "selected_actions_url":
			if err := func() error {
				s.SelectedActionsURL.Reset()
				if err := s.SelectedActionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_actions_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsRepositoryPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsRepositoryPermissions) {
					name = jsonFieldsNameOfActionsRepositoryPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsRetryWorkflowCreated) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsRetryWorkflowCreated = [0]string{}

// Decode decodes ActionsRetryWorkflowCreated from json.
func (s ActionsRetryWorkflowCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsRetryWorkflowCreated to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsRetryWorkflowCreated")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsReviewPendingDeploymentsForRunReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"environment_ids\"" + ":")
		e.ArrStart()
		if len(s.EnvironmentIds) >= 1 {
			// Encode first element without comma.
			{
				elem := s.EnvironmentIds[0]
				e.Int(elem)
			}
			for _, elem := range s.EnvironmentIds[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comment\"" + ":")
		e.Str(s.Comment)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsReviewPendingDeploymentsForRunReq = [3]string{
	0: "environment_ids",
	1: "state",
	2: "comment",
}

// Decode decodes ActionsReviewPendingDeploymentsForRunReq from json.
func (s *ActionsReviewPendingDeploymentsForRunReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsReviewPendingDeploymentsForRunReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "environment_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.EnvironmentIds = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.EnvironmentIds = append(s.EnvironmentIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment_ids\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "comment":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Comment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsReviewPendingDeploymentsForRunReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsReviewPendingDeploymentsForRunReq) {
					name = jsonFieldsNameOfActionsReviewPendingDeploymentsForRunReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ActionsReviewPendingDeploymentsForRunReqState as json.
func (s ActionsReviewPendingDeploymentsForRunReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ActionsReviewPendingDeploymentsForRunReqState from json.
func (s *ActionsReviewPendingDeploymentsForRunReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsReviewPendingDeploymentsForRunReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionsReviewPendingDeploymentsForRunReqState(v) {
	case ActionsReviewPendingDeploymentsForRunReqStateApproved:
		*s = ActionsReviewPendingDeploymentsForRunReqStateApproved
	case ActionsReviewPendingDeploymentsForRunReqStateRejected:
		*s = ActionsReviewPendingDeploymentsForRunReqStateRejected
	default:
		*s = ActionsReviewPendingDeploymentsForRunReqState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsSecret) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsSecret = [3]string{
	0: "name",
	1: "created_at",
	2: "updated_at",
}

// Decode decodes ActionsSecret from json.
func (s *ActionsSecret) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsSecret to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsSecret")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsSecret) {
					name = jsonFieldsNameOfActionsSecret[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsSetGithubActionsPermissionsOrganizationReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled_repositories\"" + ":")
		s.EnabledRepositories.Encode(e)
	}
	{
		if s.AllowedActions.Set {
			e.Comma()
		}
		if s.AllowedActions.Set {
			e.RawStr("\"allowed_actions\"" + ":")
			s.AllowedActions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsSetGithubActionsPermissionsOrganizationReq = [2]string{
	0: "enabled_repositories",
	1: "allowed_actions",
}

// Decode decodes ActionsSetGithubActionsPermissionsOrganizationReq from json.
func (s *ActionsSetGithubActionsPermissionsOrganizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsSetGithubActionsPermissionsOrganizationReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_repositories":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EnabledRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled_repositories\"")
			}
		case "allowed_actions":
			if err := func() error {
				s.AllowedActions.Reset()
				if err := s.AllowedActions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_actions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsSetGithubActionsPermissionsOrganizationReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsSetGithubActionsPermissionsOrganizationReq) {
					name = jsonFieldsNameOfActionsSetGithubActionsPermissionsOrganizationReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsSetGithubActionsPermissionsRepositoryReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled\"" + ":")
		s.Enabled.Encode(e)
	}
	{
		if s.AllowedActions.Set {
			e.Comma()
		}
		if s.AllowedActions.Set {
			e.RawStr("\"allowed_actions\"" + ":")
			s.AllowedActions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsSetGithubActionsPermissionsRepositoryReq = [2]string{
	0: "enabled",
	1: "allowed_actions",
}

// Decode decodes ActionsSetGithubActionsPermissionsRepositoryReq from json.
func (s *ActionsSetGithubActionsPermissionsRepositoryReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsSetGithubActionsPermissionsRepositoryReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				{
					var unwrapped bool
					v, err := d.Bool()
					unwrapped = bool(v)
					if err != nil {
						return err
					}
					s.Enabled = ActionsEnabled(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "allowed_actions":
			if err := func() error {
				s.AllowedActions.Reset()
				if err := s.AllowedActions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_actions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsSetGithubActionsPermissionsRepositoryReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsSetGithubActionsPermissionsRepositoryReq) {
					name = jsonFieldsNameOfActionsSetGithubActionsPermissionsRepositoryReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selected_repository_ids\"" + ":")
		e.ArrStart()
		if len(s.SelectedRepositoryIds) >= 1 {
			// Encode first element without comma.
			{
				elem := s.SelectedRepositoryIds[0]
				e.Int(elem)
			}
			for _, elem := range s.SelectedRepositoryIds[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq = [1]string{
	0: "selected_repository_ids",
}

// Decode decodes ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq from json.
func (s *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_repository_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.SelectedRepositoryIds = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repository_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq) {
					name = jsonFieldsNameOfActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsSetSelectedReposForOrgSecretReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selected_repository_ids\"" + ":")
		e.ArrStart()
		if len(s.SelectedRepositoryIds) >= 1 {
			// Encode first element without comma.
			{
				elem := s.SelectedRepositoryIds[0]
				e.Int(elem)
			}
			for _, elem := range s.SelectedRepositoryIds[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsSetSelectedReposForOrgSecretReq = [1]string{
	0: "selected_repository_ids",
}

// Decode decodes ActionsSetSelectedReposForOrgSecretReq from json.
func (s *ActionsSetSelectedReposForOrgSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsSetSelectedReposForOrgSecretReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_repository_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.SelectedRepositoryIds = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repository_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsSetSelectedReposForOrgSecretReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsSetSelectedReposForOrgSecretReq) {
					name = jsonFieldsNameOfActionsSetSelectedReposForOrgSecretReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selected_repository_ids\"" + ":")
		e.ArrStart()
		if len(s.SelectedRepositoryIds) >= 1 {
			// Encode first element without comma.
			{
				elem := s.SelectedRepositoryIds[0]
				e.Int(elem)
			}
			for _, elem := range s.SelectedRepositoryIds[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq = [1]string{
	0: "selected_repository_ids",
}

// Decode decodes ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq from json.
func (s *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_repository_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.SelectedRepositoryIds = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repository_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq) {
					name = jsonFieldsNameOfActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsSetSelfHostedRunnersInGroupForOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"runners\"" + ":")
		e.ArrStart()
		if len(s.Runners) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Runners[0]
				e.Int(elem)
			}
			for _, elem := range s.Runners[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsSetSelfHostedRunnersInGroupForOrgReq = [1]string{
	0: "runners",
}

// Decode decodes ActionsSetSelfHostedRunnersInGroupForOrgReq from json.
func (s *ActionsSetSelfHostedRunnersInGroupForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsSetSelfHostedRunnersInGroupForOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "runners":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Runners = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsSetSelfHostedRunnersInGroupForOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsSetSelfHostedRunnersInGroupForOrgReq) {
					name = jsonFieldsNameOfActionsSetSelfHostedRunnersInGroupForOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActionsUpdateSelfHostedRunnerGroupForOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActionsUpdateSelfHostedRunnerGroupForOrgReq = [2]string{
	0: "name",
	1: "visibility",
}

// Decode decodes ActionsUpdateSelfHostedRunnerGroupForOrgReq from json.
func (s *ActionsUpdateSelfHostedRunnerGroupForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsUpdateSelfHostedRunnerGroupForOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionsUpdateSelfHostedRunnerGroupForOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionsUpdateSelfHostedRunnerGroupForOrgReq) {
					name = jsonFieldsNameOfActionsUpdateSelfHostedRunnerGroupForOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (s ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (s *ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility(v) {
	case ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilitySelected:
		*s = ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilitySelected
	case ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilityAll:
		*s = ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilityAll
	case ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilityPrivate:
		*s = ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibilityPrivate
	default:
		*s = ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility(v)
	}

	return nil
}

// Encode encodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound as json.
func (s ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound from json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityDeleteThreadSubscriptionApplicationJSONForbidden as json.
func (s ActivityDeleteThreadSubscriptionApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityDeleteThreadSubscriptionApplicationJSONForbidden from json.
func (s *ActivityDeleteThreadSubscriptionApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityDeleteThreadSubscriptionApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityDeleteThreadSubscriptionApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized as json.
func (s ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized from json.
func (s *ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityGetThreadApplicationJSONForbidden as json.
func (s ActivityGetThreadApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadApplicationJSONForbidden from json.
func (s *ActivityGetThreadApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityGetThreadApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityGetThreadApplicationJSONUnauthorized as json.
func (s ActivityGetThreadApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadApplicationJSONUnauthorized from json.
func (s *ActivityGetThreadApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityGetThreadApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityListNotificationsForAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityListNotificationsForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListNotificationsForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityListNotificationsForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListNotificationsForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListNotificationsForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityListNotificationsForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityListNotificationsForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListNotificationsForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityListNotificationsForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListNotificationsForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListNotificationsForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityListNotificationsForAuthenticatedUserOKApplicationJSON as json.
func (s ActivityListNotificationsForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Thread(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ActivityListNotificationsForAuthenticatedUserOKApplicationJSON from json.
func (s *ActivityListNotificationsForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListNotificationsForAuthenticatedUserOKApplicationJSON to nil")
	}
	var unwrapped []Thread
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Thread
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListNotificationsForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden as json.
func (s ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden from json.
func (s *ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently as json.
func (s ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently from json.
func (s *ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently(unwrapped)
	return nil
}

// Encode encodes ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound as json.
func (s ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound from json.
func (s *ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ActivityListPublicEventsForRepoNetworkOKApplicationJSON as json.
func (s ActivityListPublicEventsForRepoNetworkOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Event(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ActivityListPublicEventsForRepoNetworkOKApplicationJSON from json.
func (s *ActivityListPublicEventsForRepoNetworkOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListPublicEventsForRepoNetworkOKApplicationJSON to nil")
	}
	var unwrapped []Event
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Event
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ActivityListPublicEventsOKApplicationJSON as json.
func (s ActivityListPublicEventsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Event(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ActivityListPublicEventsOKApplicationJSON from json.
func (s *ActivityListPublicEventsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListPublicEventsOKApplicationJSON to nil")
	}
	var unwrapped []Event
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Event
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserOKApplicationJSON as json.
func (s ActivityListReposStarredByAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Repository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserOKApplicationJSON from json.
func (s *ActivityListReposStarredByAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListReposStarredByAuthenticatedUserOKApplicationJSON to nil")
	}
	var unwrapped []Repository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Repository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListReposStarredByAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON as json.
func (s ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON from json.
func (s *ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON to nil")
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivityMarkNotificationsAsReadAccepted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActivityMarkNotificationsAsReadAccepted = [1]string{
	0: "message",
}

// Decode decodes ActivityMarkNotificationsAsReadAccepted from json.
func (s *ActivityMarkNotificationsAsReadAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityMarkNotificationsAsReadAccepted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivityMarkNotificationsAsReadAccepted")
	}

	return nil
}

// Encode encodes ActivityMarkNotificationsAsReadApplicationJSONForbidden as json.
func (s ActivityMarkNotificationsAsReadApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityMarkNotificationsAsReadApplicationJSONForbidden from json.
func (s *ActivityMarkNotificationsAsReadApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityMarkNotificationsAsReadApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityMarkNotificationsAsReadApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityMarkNotificationsAsReadApplicationJSONUnauthorized as json.
func (s ActivityMarkNotificationsAsReadApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityMarkNotificationsAsReadApplicationJSONUnauthorized from json.
func (s *ActivityMarkNotificationsAsReadApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityMarkNotificationsAsReadApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityMarkNotificationsAsReadApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivityMarkNotificationsAsReadReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastReadAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastReadAt.Set {
			e.RawStr("\"last_read_at\"" + ":")
			s.LastReadAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Read.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Read.Set {
			e.RawStr("\"read\"" + ":")
			s.Read.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActivityMarkNotificationsAsReadReq = [2]string{
	0: "last_read_at",
	1: "read",
}

// Decode decodes ActivityMarkNotificationsAsReadReq from json.
func (s *ActivityMarkNotificationsAsReadReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityMarkNotificationsAsReadReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "last_read_at":
			if err := func() error {
				s.LastReadAt.Reset()
				if err := s.LastReadAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_read_at\"")
			}
		case "read":
			if err := func() error {
				s.Read.Reset()
				if err := s.Read.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"read\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivityMarkNotificationsAsReadReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActivityMarkRepoNotificationsAsReadAccepted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActivityMarkRepoNotificationsAsReadAccepted = [2]string{
	0: "message",
	1: "url",
}

// Decode decodes ActivityMarkRepoNotificationsAsReadAccepted from json.
func (s *ActivityMarkRepoNotificationsAsReadAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityMarkRepoNotificationsAsReadAccepted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivityMarkRepoNotificationsAsReadAccepted")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActivityMarkRepoNotificationsAsReadReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LastReadAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastReadAt.Set {
			e.RawStr("\"last_read_at\"" + ":")
			s.LastReadAt.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActivityMarkRepoNotificationsAsReadReq = [1]string{
	0: "last_read_at",
}

// Decode decodes ActivityMarkRepoNotificationsAsReadReq from json.
func (s *ActivityMarkRepoNotificationsAsReadReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityMarkRepoNotificationsAsReadReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "last_read_at":
			if err := func() error {
				s.LastReadAt.Reset()
				if err := s.LastReadAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_read_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivityMarkRepoNotificationsAsReadReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ActivitySetRepoSubscriptionReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Subscribed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Subscribed.Set {
			e.RawStr("\"subscribed\"" + ":")
			s.Subscribed.Encode(e)
		}
	}
	{
		if s.Ignored.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ignored.Set {
			e.RawStr("\"ignored\"" + ":")
			s.Ignored.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActivitySetRepoSubscriptionReq = [2]string{
	0: "subscribed",
	1: "ignored",
}

// Decode decodes ActivitySetRepoSubscriptionReq from json.
func (s *ActivitySetRepoSubscriptionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivitySetRepoSubscriptionReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscribed":
			if err := func() error {
				s.Subscribed.Reset()
				if err := s.Subscribed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribed\"")
			}
		case "ignored":
			if err := func() error {
				s.Ignored.Reset()
				if err := s.Ignored.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignored\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivitySetRepoSubscriptionReq")
	}

	return nil
}

// Encode encodes ActivitySetThreadSubscriptionApplicationJSONForbidden as json.
func (s ActivitySetThreadSubscriptionApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivitySetThreadSubscriptionApplicationJSONForbidden from json.
func (s *ActivitySetThreadSubscriptionApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivitySetThreadSubscriptionApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivitySetThreadSubscriptionApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivitySetThreadSubscriptionApplicationJSONUnauthorized as json.
func (s ActivitySetThreadSubscriptionApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivitySetThreadSubscriptionApplicationJSONUnauthorized from json.
func (s *ActivitySetThreadSubscriptionApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivitySetThreadSubscriptionApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivitySetThreadSubscriptionApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivitySetThreadSubscriptionReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ignored.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ignored.Set {
			e.RawStr("\"ignored\"" + ":")
			s.Ignored.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActivitySetThreadSubscriptionReq = [1]string{
	0: "ignored",
}

// Decode decodes ActivitySetThreadSubscriptionReq from json.
func (s *ActivitySetThreadSubscriptionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivitySetThreadSubscriptionReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ignored":
			if err := func() error {
				s.Ignored.Reset()
				if err := s.Ignored.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignored\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivitySetThreadSubscriptionReq")
	}

	return nil
}

// Encode encodes ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound as json.
func (s ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound from json.
func (s *ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound as json.
func (s ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound from json.
func (s *ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s Actor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		if s.DisplayLogin.Set {
			e.Comma()
		}
		if s.DisplayLogin.Set {
			e.RawStr("\"display_login\"" + ":")
			s.DisplayLogin.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfActor = [6]string{
	0: "id",
	1: "login",
	2: "display_login",
	3: "gravatar_id",
	4: "url",
	5: "avatar_url",
}

// Decode decodes Actor from json.
func (s *Actor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Actor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "login":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "display_login":
			if err := func() error {
				s.DisplayLogin.Reset()
				if err := s.DisplayLogin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_login\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Actor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActor) {
					name = jsonFieldsNameOfActor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes AlertCreatedAt as json.
func (s AlertCreatedAt) Encode(e *jx.Writer) {
	unwrapped := time.Time(s)
	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes AlertCreatedAt from json.
func (s *AlertCreatedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertCreatedAt to nil")
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertCreatedAt(unwrapped)
	return nil
}

// Encode encodes AlertHTMLURL as json.
func (s AlertHTMLURL) Encode(e *jx.Writer) {
	unwrapped := url.URL(s)
	json.EncodeURI(e, unwrapped)
}

// Decode decodes AlertHTMLURL from json.
func (s *AlertHTMLURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertHTMLURL to nil")
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertHTMLURL(unwrapped)
	return nil
}

// Encode encodes AlertInstancesURL as json.
func (s AlertInstancesURL) Encode(e *jx.Writer) {
	unwrapped := url.URL(s)
	json.EncodeURI(e, unwrapped)
}

// Decode decodes AlertInstancesURL from json.
func (s *AlertInstancesURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertInstancesURL to nil")
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertInstancesURL(unwrapped)
	return nil
}

// Encode encodes AlertNumber as json.
func (s AlertNumber) Encode(e *jx.Writer) {
	unwrapped := int(s)
	e.Int(unwrapped)
}

// Decode decodes AlertNumber from json.
func (s *AlertNumber) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertNumber to nil")
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertNumber(unwrapped)
	return nil
}

// Encode encodes AlertURL as json.
func (s AlertURL) Encode(e *jx.Writer) {
	unwrapped := url.URL(s)
	json.EncodeURI(e, unwrapped)
}

// Decode decodes AlertURL from json.
func (s *AlertURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertURL to nil")
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertURL(unwrapped)
	return nil
}

// Encode encodes AllowedActions as json.
func (s AllowedActions) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AllowedActions from json.
func (s *AllowedActions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AllowedActions to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AllowedActions(v) {
	case AllowedActionsAll:
		*s = AllowedActionsAll
	case AllowedActionsLocalOnly:
		*s = AllowedActionsLocalOnly
	case AllowedActionsSelected:
		*s = AllowedActionsSelected
	default:
		*s = AllowedActions(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AppPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Actions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Actions.Set {
			e.RawStr("\"actions\"" + ":")
			s.Actions.Encode(e)
		}
	}
	{
		if s.Administration.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Administration.Set {
			e.RawStr("\"administration\"" + ":")
			s.Administration.Encode(e)
		}
	}
	{
		if s.Checks.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Checks.Set {
			e.RawStr("\"checks\"" + ":")
			s.Checks.Encode(e)
		}
	}
	{
		if s.ContentReferences.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentReferences.Set {
			e.RawStr("\"content_references\"" + ":")
			s.ContentReferences.Encode(e)
		}
	}
	{
		if s.Contents.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Contents.Set {
			e.RawStr("\"contents\"" + ":")
			s.Contents.Encode(e)
		}
	}
	{
		if s.Deployments.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Deployments.Set {
			e.RawStr("\"deployments\"" + ":")
			s.Deployments.Encode(e)
		}
	}
	{
		if s.Environments.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Environments.Set {
			e.RawStr("\"environments\"" + ":")
			s.Environments.Encode(e)
		}
	}
	{
		if s.Issues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Issues.Set {
			e.RawStr("\"issues\"" + ":")
			s.Issues.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Packages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Packages.Set {
			e.RawStr("\"packages\"" + ":")
			s.Packages.Encode(e)
		}
	}
	{
		if s.Pages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pages.Set {
			e.RawStr("\"pages\"" + ":")
			s.Pages.Encode(e)
		}
	}
	{
		if s.PullRequests.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PullRequests.Set {
			e.RawStr("\"pull_requests\"" + ":")
			s.PullRequests.Encode(e)
		}
	}
	{
		if s.RepositoryHooks.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RepositoryHooks.Set {
			e.RawStr("\"repository_hooks\"" + ":")
			s.RepositoryHooks.Encode(e)
		}
	}
	{
		if s.RepositoryProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RepositoryProjects.Set {
			e.RawStr("\"repository_projects\"" + ":")
			s.RepositoryProjects.Encode(e)
		}
	}
	{
		if s.SecretScanningAlerts.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretScanningAlerts.Set {
			e.RawStr("\"secret_scanning_alerts\"" + ":")
			s.SecretScanningAlerts.Encode(e)
		}
	}
	{
		if s.Secrets.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secrets.Set {
			e.RawStr("\"secrets\"" + ":")
			s.Secrets.Encode(e)
		}
	}
	{
		if s.SecurityEvents.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecurityEvents.Set {
			e.RawStr("\"security_events\"" + ":")
			s.SecurityEvents.Encode(e)
		}
	}
	{
		if s.SingleFile.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SingleFile.Set {
			e.RawStr("\"single_file\"" + ":")
			s.SingleFile.Encode(e)
		}
	}
	{
		if s.Statuses.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Statuses.Set {
			e.RawStr("\"statuses\"" + ":")
			s.Statuses.Encode(e)
		}
	}
	{
		if s.VulnerabilityAlerts.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VulnerabilityAlerts.Set {
			e.RawStr("\"vulnerability_alerts\"" + ":")
			s.VulnerabilityAlerts.Encode(e)
		}
	}
	{
		if s.Workflows.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Workflows.Set {
			e.RawStr("\"workflows\"" + ":")
			s.Workflows.Encode(e)
		}
	}
	{
		if s.Members.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Members.Set {
			e.RawStr("\"members\"" + ":")
			s.Members.Encode(e)
		}
	}
	{
		if s.OrganizationAdministration.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationAdministration.Set {
			e.RawStr("\"organization_administration\"" + ":")
			s.OrganizationAdministration.Encode(e)
		}
	}
	{
		if s.OrganizationHooks.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationHooks.Set {
			e.RawStr("\"organization_hooks\"" + ":")
			s.OrganizationHooks.Encode(e)
		}
	}
	{
		if s.OrganizationPlan.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationPlan.Set {
			e.RawStr("\"organization_plan\"" + ":")
			s.OrganizationPlan.Encode(e)
		}
	}
	{
		if s.OrganizationProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationProjects.Set {
			e.RawStr("\"organization_projects\"" + ":")
			s.OrganizationProjects.Encode(e)
		}
	}
	{
		if s.OrganizationPackages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationPackages.Set {
			e.RawStr("\"organization_packages\"" + ":")
			s.OrganizationPackages.Encode(e)
		}
	}
	{
		if s.OrganizationSecrets.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationSecrets.Set {
			e.RawStr("\"organization_secrets\"" + ":")
			s.OrganizationSecrets.Encode(e)
		}
	}
	{
		if s.OrganizationSelfHostedRunners.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationSelfHostedRunners.Set {
			e.RawStr("\"organization_self_hosted_runners\"" + ":")
			s.OrganizationSelfHostedRunners.Encode(e)
		}
	}
	{
		if s.OrganizationUserBlocking.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationUserBlocking.Set {
			e.RawStr("\"organization_user_blocking\"" + ":")
			s.OrganizationUserBlocking.Encode(e)
		}
	}
	{
		if s.TeamDiscussions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TeamDiscussions.Set {
			e.RawStr("\"team_discussions\"" + ":")
			s.TeamDiscussions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAppPermissions = [31]string{
	0:  "actions",
	1:  "administration",
	2:  "checks",
	3:  "content_references",
	4:  "contents",
	5:  "deployments",
	6:  "environments",
	7:  "issues",
	8:  "metadata",
	9:  "packages",
	10: "pages",
	11: "pull_requests",
	12: "repository_hooks",
	13: "repository_projects",
	14: "secret_scanning_alerts",
	15: "secrets",
	16: "security_events",
	17: "single_file",
	18: "statuses",
	19: "vulnerability_alerts",
	20: "workflows",
	21: "members",
	22: "organization_administration",
	23: "organization_hooks",
	24: "organization_plan",
	25: "organization_projects",
	26: "organization_packages",
	27: "organization_secrets",
	28: "organization_self_hosted_runners",
	29: "organization_user_blocking",
	30: "team_discussions",
}

// Decode decodes AppPermissions from json.
func (s *AppPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "actions":
			if err := func() error {
				s.Actions.Reset()
				if err := s.Actions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actions\"")
			}
		case "administration":
			if err := func() error {
				s.Administration.Reset()
				if err := s.Administration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"administration\"")
			}
		case "checks":
			if err := func() error {
				s.Checks.Reset()
				if err := s.Checks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checks\"")
			}
		case "content_references":
			if err := func() error {
				s.ContentReferences.Reset()
				if err := s.ContentReferences.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_references\"")
			}
		case "contents":
			if err := func() error {
				s.Contents.Reset()
				if err := s.Contents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents\"")
			}
		case "deployments":
			if err := func() error {
				s.Deployments.Reset()
				if err := s.Deployments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments\"")
			}
		case "environments":
			if err := func() error {
				s.Environments.Reset()
				if err := s.Environments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environments\"")
			}
		case "issues":
			if err := func() error {
				s.Issues.Reset()
				if err := s.Issues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "packages":
			if err := func() error {
				s.Packages.Reset()
				if err := s.Packages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"packages\"")
			}
		case "pages":
			if err := func() error {
				s.Pages.Reset()
				if err := s.Pages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		case "pull_requests":
			if err := func() error {
				s.PullRequests.Reset()
				if err := s.PullRequests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_requests\"")
			}
		case "repository_hooks":
			if err := func() error {
				s.RepositoryHooks.Reset()
				if err := s.RepositoryHooks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_hooks\"")
			}
		case "repository_projects":
			if err := func() error {
				s.RepositoryProjects.Reset()
				if err := s.RepositoryProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_projects\"")
			}
		case "secret_scanning_alerts":
			if err := func() error {
				s.SecretScanningAlerts.Reset()
				if err := s.SecretScanningAlerts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_scanning_alerts\"")
			}
		case "secrets":
			if err := func() error {
				s.Secrets.Reset()
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		case "security_events":
			if err := func() error {
				s.SecurityEvents.Reset()
				if err := s.SecurityEvents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_events\"")
			}
		case "single_file":
			if err := func() error {
				s.SingleFile.Reset()
				if err := s.SingleFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"single_file\"")
			}
		case "statuses":
			if err := func() error {
				s.Statuses.Reset()
				if err := s.Statuses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses\"")
			}
		case "vulnerability_alerts":
			if err := func() error {
				s.VulnerabilityAlerts.Reset()
				if err := s.VulnerabilityAlerts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vulnerability_alerts\"")
			}
		case "workflows":
			if err := func() error {
				s.Workflows.Reset()
				if err := s.Workflows.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflows\"")
			}
		case "members":
			if err := func() error {
				s.Members.Reset()
				if err := s.Members.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members\"")
			}
		case "organization_administration":
			if err := func() error {
				s.OrganizationAdministration.Reset()
				if err := s.OrganizationAdministration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_administration\"")
			}
		case "organization_hooks":
			if err := func() error {
				s.OrganizationHooks.Reset()
				if err := s.OrganizationHooks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_hooks\"")
			}
		case "organization_plan":
			if err := func() error {
				s.OrganizationPlan.Reset()
				if err := s.OrganizationPlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_plan\"")
			}
		case "organization_projects":
			if err := func() error {
				s.OrganizationProjects.Reset()
				if err := s.OrganizationProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_projects\"")
			}
		case "organization_packages":
			if err := func() error {
				s.OrganizationPackages.Reset()
				if err := s.OrganizationPackages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_packages\"")
			}
		case "organization_secrets":
			if err := func() error {
				s.OrganizationSecrets.Reset()
				if err := s.OrganizationSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_secrets\"")
			}
		case "organization_self_hosted_runners":
			if err := func() error {
				s.OrganizationSelfHostedRunners.Reset()
				if err := s.OrganizationSelfHostedRunners.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_self_hosted_runners\"")
			}
		case "organization_user_blocking":
			if err := func() error {
				s.OrganizationUserBlocking.Reset()
				if err := s.OrganizationUserBlocking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_user_blocking\"")
			}
		case "team_discussions":
			if err := func() error {
				s.TeamDiscussions.Reset()
				if err := s.TeamDiscussions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_discussions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppPermissions")
	}

	return nil
}

// Encode encodes AppPermissionsActions as json.
func (s AppPermissionsActions) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsActions from json.
func (s *AppPermissionsActions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsActions to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsActions(v) {
	case AppPermissionsActionsRead:
		*s = AppPermissionsActionsRead
	case AppPermissionsActionsWrite:
		*s = AppPermissionsActionsWrite
	default:
		*s = AppPermissionsActions(v)
	}

	return nil
}

// Encode encodes AppPermissionsAdministration as json.
func (s AppPermissionsAdministration) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsAdministration from json.
func (s *AppPermissionsAdministration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsAdministration to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsAdministration(v) {
	case AppPermissionsAdministrationRead:
		*s = AppPermissionsAdministrationRead
	case AppPermissionsAdministrationWrite:
		*s = AppPermissionsAdministrationWrite
	default:
		*s = AppPermissionsAdministration(v)
	}

	return nil
}

// Encode encodes AppPermissionsChecks as json.
func (s AppPermissionsChecks) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsChecks from json.
func (s *AppPermissionsChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsChecks to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsChecks(v) {
	case AppPermissionsChecksRead:
		*s = AppPermissionsChecksRead
	case AppPermissionsChecksWrite:
		*s = AppPermissionsChecksWrite
	default:
		*s = AppPermissionsChecks(v)
	}

	return nil
}

// Encode encodes AppPermissionsContentReferences as json.
func (s AppPermissionsContentReferences) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsContentReferences from json.
func (s *AppPermissionsContentReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsContentReferences to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsContentReferences(v) {
	case AppPermissionsContentReferencesRead:
		*s = AppPermissionsContentReferencesRead
	case AppPermissionsContentReferencesWrite:
		*s = AppPermissionsContentReferencesWrite
	default:
		*s = AppPermissionsContentReferences(v)
	}

	return nil
}

// Encode encodes AppPermissionsContents as json.
func (s AppPermissionsContents) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsContents from json.
func (s *AppPermissionsContents) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsContents to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsContents(v) {
	case AppPermissionsContentsRead:
		*s = AppPermissionsContentsRead
	case AppPermissionsContentsWrite:
		*s = AppPermissionsContentsWrite
	default:
		*s = AppPermissionsContents(v)
	}

	return nil
}

// Encode encodes AppPermissionsDeployments as json.
func (s AppPermissionsDeployments) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsDeployments from json.
func (s *AppPermissionsDeployments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsDeployments to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsDeployments(v) {
	case AppPermissionsDeploymentsRead:
		*s = AppPermissionsDeploymentsRead
	case AppPermissionsDeploymentsWrite:
		*s = AppPermissionsDeploymentsWrite
	default:
		*s = AppPermissionsDeployments(v)
	}

	return nil
}

// Encode encodes AppPermissionsEnvironments as json.
func (s AppPermissionsEnvironments) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsEnvironments from json.
func (s *AppPermissionsEnvironments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsEnvironments to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsEnvironments(v) {
	case AppPermissionsEnvironmentsRead:
		*s = AppPermissionsEnvironmentsRead
	case AppPermissionsEnvironmentsWrite:
		*s = AppPermissionsEnvironmentsWrite
	default:
		*s = AppPermissionsEnvironments(v)
	}

	return nil
}

// Encode encodes AppPermissionsIssues as json.
func (s AppPermissionsIssues) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsIssues from json.
func (s *AppPermissionsIssues) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsIssues to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsIssues(v) {
	case AppPermissionsIssuesRead:
		*s = AppPermissionsIssuesRead
	case AppPermissionsIssuesWrite:
		*s = AppPermissionsIssuesWrite
	default:
		*s = AppPermissionsIssues(v)
	}

	return nil
}

// Encode encodes AppPermissionsMembers as json.
func (s AppPermissionsMembers) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsMembers from json.
func (s *AppPermissionsMembers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsMembers to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsMembers(v) {
	case AppPermissionsMembersRead:
		*s = AppPermissionsMembersRead
	case AppPermissionsMembersWrite:
		*s = AppPermissionsMembersWrite
	default:
		*s = AppPermissionsMembers(v)
	}

	return nil
}

// Encode encodes AppPermissionsMetadata as json.
func (s AppPermissionsMetadata) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsMetadata from json.
func (s *AppPermissionsMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsMetadata to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsMetadata(v) {
	case AppPermissionsMetadataRead:
		*s = AppPermissionsMetadataRead
	case AppPermissionsMetadataWrite:
		*s = AppPermissionsMetadataWrite
	default:
		*s = AppPermissionsMetadata(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationAdministration as json.
func (s AppPermissionsOrganizationAdministration) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationAdministration from json.
func (s *AppPermissionsOrganizationAdministration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationAdministration to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationAdministration(v) {
	case AppPermissionsOrganizationAdministrationRead:
		*s = AppPermissionsOrganizationAdministrationRead
	case AppPermissionsOrganizationAdministrationWrite:
		*s = AppPermissionsOrganizationAdministrationWrite
	default:
		*s = AppPermissionsOrganizationAdministration(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationHooks as json.
func (s AppPermissionsOrganizationHooks) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationHooks from json.
func (s *AppPermissionsOrganizationHooks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationHooks to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationHooks(v) {
	case AppPermissionsOrganizationHooksRead:
		*s = AppPermissionsOrganizationHooksRead
	case AppPermissionsOrganizationHooksWrite:
		*s = AppPermissionsOrganizationHooksWrite
	default:
		*s = AppPermissionsOrganizationHooks(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationPackages as json.
func (s AppPermissionsOrganizationPackages) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationPackages from json.
func (s *AppPermissionsOrganizationPackages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationPackages to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationPackages(v) {
	case AppPermissionsOrganizationPackagesRead:
		*s = AppPermissionsOrganizationPackagesRead
	case AppPermissionsOrganizationPackagesWrite:
		*s = AppPermissionsOrganizationPackagesWrite
	default:
		*s = AppPermissionsOrganizationPackages(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationPlan as json.
func (s AppPermissionsOrganizationPlan) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationPlan from json.
func (s *AppPermissionsOrganizationPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationPlan to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationPlan(v) {
	case AppPermissionsOrganizationPlanRead:
		*s = AppPermissionsOrganizationPlanRead
	default:
		*s = AppPermissionsOrganizationPlan(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationProjects as json.
func (s AppPermissionsOrganizationProjects) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationProjects from json.
func (s *AppPermissionsOrganizationProjects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationProjects to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationProjects(v) {
	case AppPermissionsOrganizationProjectsRead:
		*s = AppPermissionsOrganizationProjectsRead
	case AppPermissionsOrganizationProjectsWrite:
		*s = AppPermissionsOrganizationProjectsWrite
	case AppPermissionsOrganizationProjectsAdmin:
		*s = AppPermissionsOrganizationProjectsAdmin
	default:
		*s = AppPermissionsOrganizationProjects(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationSecrets as json.
func (s AppPermissionsOrganizationSecrets) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationSecrets from json.
func (s *AppPermissionsOrganizationSecrets) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationSecrets to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationSecrets(v) {
	case AppPermissionsOrganizationSecretsRead:
		*s = AppPermissionsOrganizationSecretsRead
	case AppPermissionsOrganizationSecretsWrite:
		*s = AppPermissionsOrganizationSecretsWrite
	default:
		*s = AppPermissionsOrganizationSecrets(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationSelfHostedRunners as json.
func (s AppPermissionsOrganizationSelfHostedRunners) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationSelfHostedRunners from json.
func (s *AppPermissionsOrganizationSelfHostedRunners) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationSelfHostedRunners to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationSelfHostedRunners(v) {
	case AppPermissionsOrganizationSelfHostedRunnersRead:
		*s = AppPermissionsOrganizationSelfHostedRunnersRead
	case AppPermissionsOrganizationSelfHostedRunnersWrite:
		*s = AppPermissionsOrganizationSelfHostedRunnersWrite
	default:
		*s = AppPermissionsOrganizationSelfHostedRunners(v)
	}

	return nil
}

// Encode encodes AppPermissionsOrganizationUserBlocking as json.
func (s AppPermissionsOrganizationUserBlocking) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationUserBlocking from json.
func (s *AppPermissionsOrganizationUserBlocking) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsOrganizationUserBlocking to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsOrganizationUserBlocking(v) {
	case AppPermissionsOrganizationUserBlockingRead:
		*s = AppPermissionsOrganizationUserBlockingRead
	case AppPermissionsOrganizationUserBlockingWrite:
		*s = AppPermissionsOrganizationUserBlockingWrite
	default:
		*s = AppPermissionsOrganizationUserBlocking(v)
	}

	return nil
}

// Encode encodes AppPermissionsPackages as json.
func (s AppPermissionsPackages) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsPackages from json.
func (s *AppPermissionsPackages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsPackages to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsPackages(v) {
	case AppPermissionsPackagesRead:
		*s = AppPermissionsPackagesRead
	case AppPermissionsPackagesWrite:
		*s = AppPermissionsPackagesWrite
	default:
		*s = AppPermissionsPackages(v)
	}

	return nil
}

// Encode encodes AppPermissionsPages as json.
func (s AppPermissionsPages) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsPages from json.
func (s *AppPermissionsPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsPages to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsPages(v) {
	case AppPermissionsPagesRead:
		*s = AppPermissionsPagesRead
	case AppPermissionsPagesWrite:
		*s = AppPermissionsPagesWrite
	default:
		*s = AppPermissionsPages(v)
	}

	return nil
}

// Encode encodes AppPermissionsPullRequests as json.
func (s AppPermissionsPullRequests) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsPullRequests from json.
func (s *AppPermissionsPullRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsPullRequests to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsPullRequests(v) {
	case AppPermissionsPullRequestsRead:
		*s = AppPermissionsPullRequestsRead
	case AppPermissionsPullRequestsWrite:
		*s = AppPermissionsPullRequestsWrite
	default:
		*s = AppPermissionsPullRequests(v)
	}

	return nil
}

// Encode encodes AppPermissionsRepositoryHooks as json.
func (s AppPermissionsRepositoryHooks) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsRepositoryHooks from json.
func (s *AppPermissionsRepositoryHooks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsRepositoryHooks to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsRepositoryHooks(v) {
	case AppPermissionsRepositoryHooksRead:
		*s = AppPermissionsRepositoryHooksRead
	case AppPermissionsRepositoryHooksWrite:
		*s = AppPermissionsRepositoryHooksWrite
	default:
		*s = AppPermissionsRepositoryHooks(v)
	}

	return nil
}

// Encode encodes AppPermissionsRepositoryProjects as json.
func (s AppPermissionsRepositoryProjects) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsRepositoryProjects from json.
func (s *AppPermissionsRepositoryProjects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsRepositoryProjects to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsRepositoryProjects(v) {
	case AppPermissionsRepositoryProjectsRead:
		*s = AppPermissionsRepositoryProjectsRead
	case AppPermissionsRepositoryProjectsWrite:
		*s = AppPermissionsRepositoryProjectsWrite
	case AppPermissionsRepositoryProjectsAdmin:
		*s = AppPermissionsRepositoryProjectsAdmin
	default:
		*s = AppPermissionsRepositoryProjects(v)
	}

	return nil
}

// Encode encodes AppPermissionsSecretScanningAlerts as json.
func (s AppPermissionsSecretScanningAlerts) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSecretScanningAlerts from json.
func (s *AppPermissionsSecretScanningAlerts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsSecretScanningAlerts to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsSecretScanningAlerts(v) {
	case AppPermissionsSecretScanningAlertsRead:
		*s = AppPermissionsSecretScanningAlertsRead
	case AppPermissionsSecretScanningAlertsWrite:
		*s = AppPermissionsSecretScanningAlertsWrite
	default:
		*s = AppPermissionsSecretScanningAlerts(v)
	}

	return nil
}

// Encode encodes AppPermissionsSecrets as json.
func (s AppPermissionsSecrets) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSecrets from json.
func (s *AppPermissionsSecrets) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsSecrets to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsSecrets(v) {
	case AppPermissionsSecretsRead:
		*s = AppPermissionsSecretsRead
	case AppPermissionsSecretsWrite:
		*s = AppPermissionsSecretsWrite
	default:
		*s = AppPermissionsSecrets(v)
	}

	return nil
}

// Encode encodes AppPermissionsSecurityEvents as json.
func (s AppPermissionsSecurityEvents) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSecurityEvents from json.
func (s *AppPermissionsSecurityEvents) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsSecurityEvents to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsSecurityEvents(v) {
	case AppPermissionsSecurityEventsRead:
		*s = AppPermissionsSecurityEventsRead
	case AppPermissionsSecurityEventsWrite:
		*s = AppPermissionsSecurityEventsWrite
	default:
		*s = AppPermissionsSecurityEvents(v)
	}

	return nil
}

// Encode encodes AppPermissionsSingleFile as json.
func (s AppPermissionsSingleFile) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSingleFile from json.
func (s *AppPermissionsSingleFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsSingleFile to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsSingleFile(v) {
	case AppPermissionsSingleFileRead:
		*s = AppPermissionsSingleFileRead
	case AppPermissionsSingleFileWrite:
		*s = AppPermissionsSingleFileWrite
	default:
		*s = AppPermissionsSingleFile(v)
	}

	return nil
}

// Encode encodes AppPermissionsStatuses as json.
func (s AppPermissionsStatuses) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsStatuses from json.
func (s *AppPermissionsStatuses) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsStatuses to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsStatuses(v) {
	case AppPermissionsStatusesRead:
		*s = AppPermissionsStatusesRead
	case AppPermissionsStatusesWrite:
		*s = AppPermissionsStatusesWrite
	default:
		*s = AppPermissionsStatuses(v)
	}

	return nil
}

// Encode encodes AppPermissionsTeamDiscussions as json.
func (s AppPermissionsTeamDiscussions) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsTeamDiscussions from json.
func (s *AppPermissionsTeamDiscussions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsTeamDiscussions to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsTeamDiscussions(v) {
	case AppPermissionsTeamDiscussionsRead:
		*s = AppPermissionsTeamDiscussionsRead
	case AppPermissionsTeamDiscussionsWrite:
		*s = AppPermissionsTeamDiscussionsWrite
	default:
		*s = AppPermissionsTeamDiscussions(v)
	}

	return nil
}

// Encode encodes AppPermissionsVulnerabilityAlerts as json.
func (s AppPermissionsVulnerabilityAlerts) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsVulnerabilityAlerts from json.
func (s *AppPermissionsVulnerabilityAlerts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsVulnerabilityAlerts to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsVulnerabilityAlerts(v) {
	case AppPermissionsVulnerabilityAlertsRead:
		*s = AppPermissionsVulnerabilityAlertsRead
	default:
		*s = AppPermissionsVulnerabilityAlerts(v)
	}

	return nil
}

// Encode encodes AppPermissionsWorkflows as json.
func (s AppPermissionsWorkflows) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsWorkflows from json.
func (s *AppPermissionsWorkflows) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppPermissionsWorkflows to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AppPermissionsWorkflows(v) {
	case AppPermissionsWorkflowsWrite:
		*s = AppPermissionsWorkflowsWrite
	default:
		*s = AppPermissionsWorkflows(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ApplicationGrant) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"app\"" + ":")
		s.App.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"scopes\"" + ":")
		e.ArrStart()
		if len(s.Scopes) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Scopes[0]
				e.Str(elem)
			}
			for _, elem := range s.Scopes[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfApplicationGrant = [7]string{
	0: "id",
	1: "url",
	2: "app",
	3: "created_at",
	4: "updated_at",
	5: "scopes",
	6: "user",
}

// Decode decodes ApplicationGrant from json.
func (s *ApplicationGrant) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplicationGrant to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "app":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.App.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "scopes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Scopes = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Scopes = append(s.Scopes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplicationGrant")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApplicationGrant) {
					name = jsonFieldsNameOfApplicationGrant[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ApplicationGrantApp) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"client_id\"" + ":")
		e.Str(s.ClientID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfApplicationGrantApp = [3]string{
	0: "client_id",
	1: "name",
	2: "url",
}

// Decode decodes ApplicationGrantApp from json.
func (s *ApplicationGrantApp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApplicationGrantApp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClientID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApplicationGrantApp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApplicationGrantApp) {
					name = jsonFieldsNameOfApplicationGrantApp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes AppsAddRepoToInstallationApplicationJSONForbidden as json.
func (s AppsAddRepoToInstallationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsAddRepoToInstallationApplicationJSONForbidden from json.
func (s *AppsAddRepoToInstallationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsAddRepoToInstallationApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsAddRepoToInstallationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsAddRepoToInstallationApplicationJSONNotFound as json.
func (s AppsAddRepoToInstallationApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsAddRepoToInstallationApplicationJSONNotFound from json.
func (s *AppsAddRepoToInstallationApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsAddRepoToInstallationApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsAddRepoToInstallationApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsCheckTokenReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"access_token\"" + ":")
		e.Str(s.AccessToken)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAppsCheckTokenReq = [1]string{
	0: "access_token",
}

// Decode decodes AppsCheckTokenReq from json.
func (s *AppsCheckTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCheckTokenReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsCheckTokenReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsCheckTokenReq) {
					name = jsonFieldsNameOfAppsCheckTokenReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes AppsCreateContentAttachmentApplicationJSONForbidden as json.
func (s AppsCreateContentAttachmentApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsCreateContentAttachmentApplicationJSONForbidden from json.
func (s *AppsCreateContentAttachmentApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateContentAttachmentApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateContentAttachmentApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsCreateContentAttachmentApplicationJSONGone as json.
func (s AppsCreateContentAttachmentApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsCreateContentAttachmentApplicationJSONGone from json.
func (s *AppsCreateContentAttachmentApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateContentAttachmentApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateContentAttachmentApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes AppsCreateContentAttachmentApplicationJSONNotFound as json.
func (s AppsCreateContentAttachmentApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsCreateContentAttachmentApplicationJSONNotFound from json.
func (s *AppsCreateContentAttachmentApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateContentAttachmentApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateContentAttachmentApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsCreateContentAttachmentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAppsCreateContentAttachmentReq = [2]string{
	0: "title",
	1: "body",
}

// Decode decodes AppsCreateContentAttachmentReq from json.
func (s *AppsCreateContentAttachmentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateContentAttachmentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsCreateContentAttachmentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsCreateContentAttachmentReq) {
					name = jsonFieldsNameOfAppsCreateContentAttachmentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AppsCreateFromManifestReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAppsCreateFromManifestReq = [0]string{}

// Decode decodes AppsCreateFromManifestReq from json.
func (s AppsCreateFromManifestReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateFromManifestReq to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsCreateFromManifestReq")
	}

	return nil
}

// Encode encodes AppsCreateInstallationAccessTokenApplicationJSONForbidden as json.
func (s AppsCreateInstallationAccessTokenApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsCreateInstallationAccessTokenApplicationJSONForbidden from json.
func (s *AppsCreateInstallationAccessTokenApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateInstallationAccessTokenApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateInstallationAccessTokenApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsCreateInstallationAccessTokenApplicationJSONNotFound as json.
func (s AppsCreateInstallationAccessTokenApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsCreateInstallationAccessTokenApplicationJSONNotFound from json.
func (s *AppsCreateInstallationAccessTokenApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateInstallationAccessTokenApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateInstallationAccessTokenApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsCreateInstallationAccessTokenApplicationJSONUnauthorized as json.
func (s AppsCreateInstallationAccessTokenApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsCreateInstallationAccessTokenApplicationJSONUnauthorized from json.
func (s *AppsCreateInstallationAccessTokenApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateInstallationAccessTokenApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsCreateInstallationAccessTokenApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsCreateInstallationAccessTokenReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Repositories != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Repositories != nil {
			e.RawStr("\"repositories\"" + ":")
			e.ArrStart()
			if len(s.Repositories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Repositories[0]
					e.Str(elem)
				}
				for _, elem := range s.Repositories[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RepositoryIds != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RepositoryIds != nil {
			e.RawStr("\"repository_ids\"" + ":")
			e.ArrStart()
			if len(s.RepositoryIds) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RepositoryIds[0]
					e.Int(elem)
				}
				for _, elem := range s.RepositoryIds[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Permissions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAppsCreateInstallationAccessTokenReq = [3]string{
	0: "repositories",
	1: "repository_ids",
	2: "permissions",
}

// Decode decodes AppsCreateInstallationAccessTokenReq from json.
func (s *AppsCreateInstallationAccessTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsCreateInstallationAccessTokenReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "repositories":
			if err := func() error {
				s.Repositories = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		case "repository_ids":
			if err := func() error {
				s.RepositoryIds = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.RepositoryIds = append(s.RepositoryIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_ids\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsCreateInstallationAccessTokenReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AppsDeleteAuthorizationReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"access_token\"" + ":")
		e.Str(s.AccessToken)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAppsDeleteAuthorizationReq = [1]string{
	0: "access_token",
}

// Decode decodes AppsDeleteAuthorizationReq from json.
func (s *AppsDeleteAuthorizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsDeleteAuthorizationReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsDeleteAuthorizationReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsDeleteAuthorizationReq) {
					name = jsonFieldsNameOfAppsDeleteAuthorizationReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AppsDeleteTokenReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"access_token\"" + ":")
		e.Str(s.AccessToken)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAppsDeleteTokenReq = [1]string{
	0: "access_token",
}

// Decode decodes AppsDeleteTokenReq from json.
func (s *AppsDeleteTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsDeleteTokenReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsDeleteTokenReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsDeleteTokenReq) {
					name = jsonFieldsNameOfAppsDeleteTokenReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes AppsGetBySlugApplicationJSONForbidden as json.
func (s AppsGetBySlugApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsGetBySlugApplicationJSONForbidden from json.
func (s *AppsGetBySlugApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsGetBySlugApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetBySlugApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsGetBySlugApplicationJSONNotFound as json.
func (s AppsGetBySlugApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsGetBySlugApplicationJSONNotFound from json.
func (s *AppsGetBySlugApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsGetBySlugApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetBySlugApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsGetSubscriptionPlanForAccountApplicationJSONNotFound as json.
func (s AppsGetSubscriptionPlanForAccountApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsGetSubscriptionPlanForAccountApplicationJSONNotFound from json.
func (s *AppsGetSubscriptionPlanForAccountApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsGetSubscriptionPlanForAccountApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetSubscriptionPlanForAccountApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized as json.
func (s AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized from json.
func (s *AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes AppsListAccountsForPlanApplicationJSONNotFound as json.
func (s AppsListAccountsForPlanApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListAccountsForPlanApplicationJSONNotFound from json.
func (s *AppsListAccountsForPlanApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListAccountsForPlanApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListAccountsForPlanApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsListAccountsForPlanApplicationJSONUnauthorized as json.
func (s AppsListAccountsForPlanApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListAccountsForPlanApplicationJSONUnauthorized from json.
func (s *AppsListAccountsForPlanApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListAccountsForPlanApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListAccountsForPlanApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes AppsListAccountsForPlanOKApplicationJSON as json.
func (s AppsListAccountsForPlanOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MarketplacePurchase(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes AppsListAccountsForPlanOKApplicationJSON from json.
func (s *AppsListAccountsForPlanOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListAccountsForPlanOKApplicationJSON to nil")
	}
	var unwrapped []MarketplacePurchase
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MarketplacePurchase
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListAccountsForPlanOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListAccountsForPlanStubbedOKApplicationJSON as json.
func (s AppsListAccountsForPlanStubbedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MarketplacePurchase(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes AppsListAccountsForPlanStubbedOKApplicationJSON from json.
func (s *AppsListAccountsForPlanStubbedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListAccountsForPlanStubbedOKApplicationJSON to nil")
	}
	var unwrapped []MarketplacePurchase
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MarketplacePurchase
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListAccountsForPlanStubbedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden as json.
func (s AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden from json.
func (s *AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound as json.
func (s AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound from json.
func (s *AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsListInstallationReposForAuthenticatedUserOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		if s.RepositorySelection.Set {
			e.Comma()
		}
		if s.RepositorySelection.Set {
			e.RawStr("\"repository_selection\"" + ":")
			s.RepositorySelection.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				elem.Encode(e)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAppsListInstallationReposForAuthenticatedUserOK = [3]string{
	0: "total_count",
	1: "repository_selection",
	2: "repositories",
}

// Decode decodes AppsListInstallationReposForAuthenticatedUserOK from json.
func (s *AppsListInstallationReposForAuthenticatedUserOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListInstallationReposForAuthenticatedUserOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "repository_selection":
			if err := func() error {
				s.RepositorySelection.Reset()
				if err := s.RepositorySelection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_selection\"")
			}
		case "repositories":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Repositories = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Repository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsListInstallationReposForAuthenticatedUserOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsListInstallationReposForAuthenticatedUserOK) {
					name = jsonFieldsNameOfAppsListInstallationReposForAuthenticatedUserOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes AppsListPlansApplicationJSONNotFound as json.
func (s AppsListPlansApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListPlansApplicationJSONNotFound from json.
func (s *AppsListPlansApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListPlansApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListPlansApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsListPlansApplicationJSONUnauthorized as json.
func (s AppsListPlansApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListPlansApplicationJSONUnauthorized from json.
func (s *AppsListPlansApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListPlansApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListPlansApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes AppsListPlansOKApplicationJSON as json.
func (s AppsListPlansOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MarketplaceListingPlan(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes AppsListPlansOKApplicationJSON from json.
func (s *AppsListPlansOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListPlansOKApplicationJSON to nil")
	}
	var unwrapped []MarketplaceListingPlan
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MarketplaceListingPlan
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListPlansOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListPlansStubbedOKApplicationJSON as json.
func (s AppsListPlansStubbedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MarketplaceListingPlan(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes AppsListPlansStubbedOKApplicationJSON from json.
func (s *AppsListPlansStubbedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListPlansStubbedOKApplicationJSON to nil")
	}
	var unwrapped []MarketplaceListingPlan
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MarketplaceListingPlan
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListPlansStubbedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListReposAccessibleToInstallationApplicationJSONForbidden as json.
func (s AppsListReposAccessibleToInstallationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListReposAccessibleToInstallationApplicationJSONForbidden from json.
func (s *AppsListReposAccessibleToInstallationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListReposAccessibleToInstallationApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListReposAccessibleToInstallationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsListReposAccessibleToInstallationApplicationJSONUnauthorized as json.
func (s AppsListReposAccessibleToInstallationApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListReposAccessibleToInstallationApplicationJSONUnauthorized from json.
func (s *AppsListReposAccessibleToInstallationApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListReposAccessibleToInstallationApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListReposAccessibleToInstallationApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsListReposAccessibleToInstallationOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				elem.Encode(e)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.RepositorySelection.Set {
			e.Comma()
		}
		if s.RepositorySelection.Set {
			e.RawStr("\"repository_selection\"" + ":")
			s.RepositorySelection.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAppsListReposAccessibleToInstallationOK = [3]string{
	0: "total_count",
	1: "repositories",
	2: "repository_selection",
}

// Decode decodes AppsListReposAccessibleToInstallationOK from json.
func (s *AppsListReposAccessibleToInstallationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListReposAccessibleToInstallationOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "repositories":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Repositories = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Repository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		case "repository_selection":
			if err := func() error {
				s.RepositorySelection.Reset()
				if err := s.RepositorySelection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_selection\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsListReposAccessibleToInstallationOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsListReposAccessibleToInstallationOK) {
					name = jsonFieldsNameOfAppsListReposAccessibleToInstallationOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound as json.
func (s AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound from json.
func (s *AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON as json.
func (s AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []UserMarketplacePurchase(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON from json.
func (s *AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON to nil")
	}
	var unwrapped []UserMarketplacePurchase
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserMarketplacePurchase
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON as json.
func (s AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []UserMarketplacePurchase(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON from json.
func (s *AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON to nil")
	}
	var unwrapped []UserMarketplacePurchase
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserMarketplacePurchase
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListWebhookDeliveriesOKApplicationJSON as json.
func (s AppsListWebhookDeliveriesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []HookDeliveryItem(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes AppsListWebhookDeliveriesOKApplicationJSON from json.
func (s *AppsListWebhookDeliveriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsListWebhookDeliveriesOKApplicationJSON to nil")
	}
	var unwrapped []HookDeliveryItem
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HookDeliveryItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListWebhookDeliveriesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsRemoveRepoFromInstallationApplicationJSONForbidden as json.
func (s AppsRemoveRepoFromInstallationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsRemoveRepoFromInstallationApplicationJSONForbidden from json.
func (s *AppsRemoveRepoFromInstallationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsRemoveRepoFromInstallationApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsRemoveRepoFromInstallationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsRemoveRepoFromInstallationApplicationJSONNotFound as json.
func (s AppsRemoveRepoFromInstallationApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsRemoveRepoFromInstallationApplicationJSONNotFound from json.
func (s *AppsRemoveRepoFromInstallationApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsRemoveRepoFromInstallationApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsRemoveRepoFromInstallationApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsResetTokenReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"access_token\"" + ":")
		e.Str(s.AccessToken)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAppsResetTokenReq = [1]string{
	0: "access_token",
}

// Decode decodes AppsResetTokenReq from json.
func (s *AppsResetTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsResetTokenReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsResetTokenReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsResetTokenReq) {
					name = jsonFieldsNameOfAppsResetTokenReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes AppsScopeTokenApplicationJSONForbidden as json.
func (s AppsScopeTokenApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsScopeTokenApplicationJSONForbidden from json.
func (s *AppsScopeTokenApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsScopeTokenApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsScopeTokenApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsScopeTokenApplicationJSONNotFound as json.
func (s AppsScopeTokenApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsScopeTokenApplicationJSONNotFound from json.
func (s *AppsScopeTokenApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsScopeTokenApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsScopeTokenApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsScopeTokenApplicationJSONUnauthorized as json.
func (s AppsScopeTokenApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsScopeTokenApplicationJSONUnauthorized from json.
func (s *AppsScopeTokenApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsScopeTokenApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsScopeTokenApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsScopeTokenReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"access_token\"" + ":")
		e.Str(s.AccessToken)
	}
	{
		if s.Target.Set {
			e.Comma()
		}
		if s.Target.Set {
			e.RawStr("\"target\"" + ":")
			s.Target.Encode(e)
		}
	}
	{
		if s.TargetID.Set {
			e.Comma()
		}
		if s.TargetID.Set {
			e.RawStr("\"target_id\"" + ":")
			s.TargetID.Encode(e)
		}
	}
	{
		if s.Repositories != nil {
			e.Comma()
		}
		if s.Repositories != nil {
			e.RawStr("\"repositories\"" + ":")
			e.ArrStart()
			if len(s.Repositories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Repositories[0]
					e.Str(elem)
				}
				for _, elem := range s.Repositories[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RepositoryIds != nil {
			e.Comma()
		}
		if s.RepositoryIds != nil {
			e.RawStr("\"repository_ids\"" + ":")
			e.ArrStart()
			if len(s.RepositoryIds) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RepositoryIds[0]
					e.Int(elem)
				}
				for _, elem := range s.RepositoryIds[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAppsScopeTokenReq = [6]string{
	0: "access_token",
	1: "target",
	2: "target_id",
	3: "repositories",
	4: "repository_ids",
	5: "permissions",
}

// Decode decodes AppsScopeTokenReq from json.
func (s *AppsScopeTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsScopeTokenReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		case "target":
			if err := func() error {
				s.Target.Reset()
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "target_id":
			if err := func() error {
				s.TargetID.Reset()
				if err := s.TargetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_id\"")
			}
		case "repositories":
			if err := func() error {
				s.Repositories = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		case "repository_ids":
			if err := func() error {
				s.RepositoryIds = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.RepositoryIds = append(s.RepositoryIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_ids\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsScopeTokenReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAppsScopeTokenReq) {
					name = jsonFieldsNameOfAppsScopeTokenReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AppsUpdateWebhookConfigForAppReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAppsUpdateWebhookConfigForAppReq = [4]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
}

// Decode decodes AppsUpdateWebhookConfigForAppReq from json.
func (s *AppsUpdateWebhookConfigForAppReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppsUpdateWebhookConfigForAppReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppsUpdateWebhookConfigForAppReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Artifact) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"size_in_bytes\"" + ":")
		e.Int(s.SizeInBytes)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_download_url\"" + ":")
		e.Str(s.ArchiveDownloadURL)
	}
	{
		e.Comma()

		e.RawStr("\"expired\"" + ":")
		e.Bool(s.Expired)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"expires_at\"" + ":")
		s.ExpiresAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfArtifact = [10]string{
	0: "id",
	1: "node_id",
	2: "name",
	3: "size_in_bytes",
	4: "url",
	5: "archive_download_url",
	6: "expired",
	7: "created_at",
	8: "expires_at",
	9: "updated_at",
}

// Decode decodes Artifact from json.
func (s *Artifact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Artifact to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "size_in_bytes":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.SizeInBytes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size_in_bytes\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_download_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ArchiveDownloadURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_download_url\"")
			}
		case "expired":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Expired = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expired\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "expires_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Artifact")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfArtifact) {
					name = jsonFieldsNameOfArtifact[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AuditLogEvent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Timestamp.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Timestamp.Set {
			e.RawStr("\"@timestamp\"" + ":")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Action.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Action.Set {
			e.RawStr("\"action\"" + ":")
			s.Action.Encode(e)
		}
	}
	{
		if s.Active.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if s.ActiveWas.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ActiveWas.Set {
			e.RawStr("\"active_was\"" + ":")
			s.ActiveWas.Encode(e)
		}
	}
	{
		if s.Actor.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Actor.Set {
			e.RawStr("\"actor\"" + ":")
			s.Actor.Encode(e)
		}
	}
	{
		if s.ActorID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ActorID.Set {
			e.RawStr("\"actor_id\"" + ":")
			s.ActorID.Encode(e)
		}
	}
	{
		if s.ActorLocation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ActorLocation.Set {
			e.RawStr("\"actor_location\"" + ":")
			s.ActorLocation.Encode(e)
		}
	}
	{
		if s.Data.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Data.Set {
			e.RawStr("\"data\"" + ":")
			s.Data.Encode(e)
		}
	}
	{
		if s.OrgID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrgID.Set {
			e.RawStr("\"org_id\"" + ":")
			s.OrgID.Encode(e)
		}
	}
	{
		if s.BlockedUser.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BlockedUser.Set {
			e.RawStr("\"blocked_user\"" + ":")
			s.BlockedUser.Encode(e)
		}
	}
	{
		if s.Business.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Business.Set {
			e.RawStr("\"business\"" + ":")
			s.Business.Encode(e)
		}
	}
	{
		if s.Config != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Config != nil {
			e.RawStr("\"config\"" + ":")
			e.ArrStart()
			if len(s.Config) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Config[0]
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
				for _, elem := range s.Config[1:] {
					e.Comma()
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ConfigWas != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ConfigWas != nil {
			e.RawStr("\"config_was\"" + ":")
			e.ArrStart()
			if len(s.ConfigWas) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ConfigWas[0]
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
				for _, elem := range s.ConfigWas[1:] {
					e.Comma()
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ContentType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.DeployKeyFingerprint.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeployKeyFingerprint.Set {
			e.RawStr("\"deploy_key_fingerprint\"" + ":")
			s.DeployKeyFingerprint.Encode(e)
		}
	}
	{
		if s.DocumentID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentID.Set {
			e.RawStr("\"_document_id\"" + ":")
			s.DocumentID.Encode(e)
		}
	}
	{
		if s.Emoji.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Emoji.Set {
			e.RawStr("\"emoji\"" + ":")
			s.Emoji.Encode(e)
		}
	}
	{
		if s.Events != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Events != nil {
			e.RawStr("\"events\"" + ":")
			e.ArrStart()
			if len(s.Events) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Events[0]
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
				for _, elem := range s.Events[1:] {
					e.Comma()
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.EventsWere != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsWere != nil {
			e.RawStr("\"events_were\"" + ":")
			e.ArrStart()
			if len(s.EventsWere) >= 1 {
				// Encode first element without comma.
				{
					elem := s.EventsWere[0]
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
				for _, elem := range s.EventsWere[1:] {
					e.Comma()
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Explanation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Explanation.Set {
			e.RawStr("\"explanation\"" + ":")
			s.Explanation.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fingerprint.Set {
			e.RawStr("\"fingerprint\"" + ":")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.HookID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HookID.Set {
			e.RawStr("\"hook_id\"" + ":")
			s.HookID.Encode(e)
		}
	}
	{
		if s.LimitedAvailability.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LimitedAvailability.Set {
			e.RawStr("\"limited_availability\"" + ":")
			s.LimitedAvailability.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.OldUser.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OldUser.Set {
			e.RawStr("\"old_user\"" + ":")
			s.OldUser.Encode(e)
		}
	}
	{
		if s.OpensshPublicKey.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OpensshPublicKey.Set {
			e.RawStr("\"openssh_public_key\"" + ":")
			s.OpensshPublicKey.Encode(e)
		}
	}
	{
		if s.Org.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Org.Set {
			e.RawStr("\"org\"" + ":")
			s.Org.Encode(e)
		}
	}
	{
		if s.PreviousVisibility.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PreviousVisibility.Set {
			e.RawStr("\"previous_visibility\"" + ":")
			s.PreviousVisibility.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReadOnly.Set {
			e.RawStr("\"read_only\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.Repo.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Repo.Set {
			e.RawStr("\"repo\"" + ":")
			s.Repo.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Repository.Set {
			e.RawStr("\"repository\"" + ":")
			s.Repository.Encode(e)
		}
	}
	{
		if s.RepositoryPublic.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RepositoryPublic.Set {
			e.RawStr("\"repository_public\"" + ":")
			s.RepositoryPublic.Encode(e)
		}
	}
	{
		if s.TargetLogin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TargetLogin.Set {
			e.RawStr("\"target_login\"" + ":")
			s.TargetLogin.Encode(e)
		}
	}
	{
		if s.Team.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Team.Set {
			e.RawStr("\"team\"" + ":")
			s.Team.Encode(e)
		}
	}
	{
		if s.TransportProtocol.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TransportProtocol.Set {
			e.RawStr("\"transport_protocol\"" + ":")
			s.TransportProtocol.Encode(e)
		}
	}
	{
		if s.TransportProtocolName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TransportProtocolName.Set {
			e.RawStr("\"transport_protocol_name\"" + ":")
			s.TransportProtocolName.Encode(e)
		}
	}
	{
		if s.User.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAuditLogEvent = [40]string{
	0:  "@timestamp",
	1:  "action",
	2:  "active",
	3:  "active_was",
	4:  "actor",
	5:  "actor_id",
	6:  "actor_location",
	7:  "data",
	8:  "org_id",
	9:  "blocked_user",
	10: "business",
	11: "config",
	12: "config_was",
	13: "content_type",
	14: "created_at",
	15: "deploy_key_fingerprint",
	16: "_document_id",
	17: "emoji",
	18: "events",
	19: "events_were",
	20: "explanation",
	21: "fingerprint",
	22: "hook_id",
	23: "limited_availability",
	24: "message",
	25: "name",
	26: "old_user",
	27: "openssh_public_key",
	28: "org",
	29: "previous_visibility",
	30: "read_only",
	31: "repo",
	32: "repository",
	33: "repository_public",
	34: "target_login",
	35: "team",
	36: "transport_protocol",
	37: "transport_protocol_name",
	38: "user",
	39: "visibility",
}

// Decode decodes AuditLogEvent from json.
func (s *AuditLogEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditLogEvent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "@timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"@timestamp\"")
			}
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "active_was":
			if err := func() error {
				s.ActiveWas.Reset()
				if err := s.ActiveWas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_was\"")
			}
		case "actor":
			if err := func() error {
				s.Actor.Reset()
				if err := s.Actor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actor\"")
			}
		case "actor_id":
			if err := func() error {
				s.ActorID.Reset()
				if err := s.ActorID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actor_id\"")
			}
		case "actor_location":
			if err := func() error {
				s.ActorLocation.Reset()
				if err := s.ActorLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actor_location\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "org_id":
			if err := func() error {
				s.OrgID.Reset()
				if err := s.OrgID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"org_id\"")
			}
		case "blocked_user":
			if err := func() error {
				s.BlockedUser.Reset()
				if err := s.BlockedUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked_user\"")
			}
		case "business":
			if err := func() error {
				s.Business.Reset()
				if err := s.Business.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business\"")
			}
		case "config":
			if err := func() error {
				s.Config = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.Raw()
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Config = append(s.Config, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "config_was":
			if err := func() error {
				s.ConfigWas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.Raw()
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.ConfigWas = append(s.ConfigWas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config_was\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "deploy_key_fingerprint":
			if err := func() error {
				s.DeployKeyFingerprint.Reset()
				if err := s.DeployKeyFingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deploy_key_fingerprint\"")
			}
		case "_document_id":
			if err := func() error {
				s.DocumentID.Reset()
				if err := s.DocumentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_document_id\"")
			}
		case "emoji":
			if err := func() error {
				s.Emoji.Reset()
				if err := s.Emoji.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emoji\"")
			}
		case "events":
			if err := func() error {
				s.Events = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.Raw()
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "events_were":
			if err := func() error {
				s.EventsWere = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.Raw()
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.EventsWere = append(s.EventsWere, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_were\"")
			}
		case "explanation":
			if err := func() error {
				s.Explanation.Reset()
				if err := s.Explanation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explanation\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "hook_id":
			if err := func() error {
				s.HookID.Reset()
				if err := s.HookID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hook_id\"")
			}
		case "limited_availability":
			if err := func() error {
				s.LimitedAvailability.Reset()
				if err := s.LimitedAvailability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limited_availability\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "old_user":
			if err := func() error {
				s.OldUser.Reset()
				if err := s.OldUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_user\"")
			}
		case "openssh_public_key":
			if err := func() error {
				s.OpensshPublicKey.Reset()
				if err := s.OpensshPublicKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openssh_public_key\"")
			}
		case "org":
			if err := func() error {
				s.Org.Reset()
				if err := s.Org.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"org\"")
			}
		case "previous_visibility":
			if err := func() error {
				s.PreviousVisibility.Reset()
				if err := s.PreviousVisibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_visibility\"")
			}
		case "read_only":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"read_only\"")
			}
		case "repo":
			if err := func() error {
				s.Repo.Reset()
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		case "repository":
			if err := func() error {
				s.Repository.Reset()
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "repository_public":
			if err := func() error {
				s.RepositoryPublic.Reset()
				if err := s.RepositoryPublic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_public\"")
			}
		case "target_login":
			if err := func() error {
				s.TargetLogin.Reset()
				if err := s.TargetLogin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_login\"")
			}
		case "team":
			if err := func() error {
				s.Team.Reset()
				if err := s.Team.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team\"")
			}
		case "transport_protocol":
			if err := func() error {
				s.TransportProtocol.Reset()
				if err := s.TransportProtocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transport_protocol\"")
			}
		case "transport_protocol_name":
			if err := func() error {
				s.TransportProtocolName.Reset()
				if err := s.TransportProtocolName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transport_protocol_name\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditLogEvent")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AuditLogEventActorLocation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CountryName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CountryName.Set {
			e.RawStr("\"country_name\"" + ":")
			s.CountryName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAuditLogEventActorLocation = [1]string{
	0: "country_name",
}

// Decode decodes AuditLogEventActorLocation from json.
func (s *AuditLogEventActorLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditLogEventActorLocation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "country_name":
			if err := func() error {
				s.CountryName.Reset()
				if err := s.CountryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditLogEventActorLocation")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AuditLogEventData) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAuditLogEventData = [0]string{}

// Decode decodes AuditLogEventData from json.
func (s AuditLogEventData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditLogEventData to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditLogEventData")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AuthenticationToken) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"token\"" + ":")
		e.Str(s.Token)
	}
	{
		e.Comma()

		e.RawStr("\"expires_at\"" + ":")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		if s.Permissions != nil {
			e.Comma()
		}
		if s.Permissions != nil {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.Repositories != nil {
			e.Comma()
		}
		if s.Repositories != nil {
			e.RawStr("\"repositories\"" + ":")
			e.ArrStart()
			if len(s.Repositories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Repositories[0]
					elem.Encode(e)
				}
				for _, elem := range s.Repositories[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.SingleFile.Set {
			e.Comma()
		}
		if s.SingleFile.Set {
			e.RawStr("\"single_file\"" + ":")
			s.SingleFile.Encode(e)
		}
	}
	{
		if s.RepositorySelection.Set {
			e.Comma()
		}
		if s.RepositorySelection.Set {
			e.RawStr("\"repository_selection\"" + ":")
			s.RepositorySelection.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAuthenticationToken = [6]string{
	0: "token",
	1: "expires_at",
	2: "permissions",
	3: "repositories",
	4: "single_file",
	5: "repository_selection",
}

// Decode decodes AuthenticationToken from json.
func (s *AuthenticationToken) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationToken to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "expires_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions = nil
				var elem AuthenticationTokenPermissions
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Permissions = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "repositories":
			if err := func() error {
				s.Repositories = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Repository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		case "single_file":
			if err := func() error {
				s.SingleFile.Reset()
				if err := s.SingleFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"single_file\"")
			}
		case "repository_selection":
			if err := func() error {
				s.RepositorySelection.Reset()
				if err := s.RepositorySelection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_selection\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthenticationToken")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthenticationToken) {
					name = jsonFieldsNameOfAuthenticationToken[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AuthenticationTokenPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfAuthenticationTokenPermissions = [0]string{}

// Decode decodes AuthenticationTokenPermissions from json.
func (s *AuthenticationTokenPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationTokenPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthenticationTokenPermissions")
	}

	return nil
}

// Encode encodes AuthenticationTokenRepositorySelection as json.
func (s AuthenticationTokenRepositorySelection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AuthenticationTokenRepositorySelection from json.
func (s *AuthenticationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationTokenRepositorySelection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuthenticationTokenRepositorySelection(v) {
	case AuthenticationTokenRepositorySelectionAll:
		*s = AuthenticationTokenRepositorySelectionAll
	case AuthenticationTokenRepositorySelectionSelected:
		*s = AuthenticationTokenRepositorySelectionSelected
	default:
		*s = AuthenticationTokenRepositorySelection(v)
	}

	return nil
}

// Encode encodes AuthorAssociation as json.
func (s AuthorAssociation) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AuthorAssociation from json.
func (s *AuthorAssociation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthorAssociation to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuthorAssociation(v) {
	case AuthorAssociationCOLLABORATOR:
		*s = AuthorAssociationCOLLABORATOR
	case AuthorAssociationCONTRIBUTOR:
		*s = AuthorAssociationCONTRIBUTOR
	case AuthorAssociationFIRSTTIMER:
		*s = AuthorAssociationFIRSTTIMER
	case AuthorAssociationFIRSTTIMECONTRIBUTOR:
		*s = AuthorAssociationFIRSTTIMECONTRIBUTOR
	case AuthorAssociationMANNEQUIN:
		*s = AuthorAssociationMANNEQUIN
	case AuthorAssociationMEMBER:
		*s = AuthorAssociationMEMBER
	case AuthorAssociationNONE:
		*s = AuthorAssociationNONE
	case AuthorAssociationOWNER:
		*s = AuthorAssociationOWNER
	default:
		*s = AuthorAssociation(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Authorization) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"scopes\"" + ":")
		if s.Scopes == nil {
			e.Null()
		} else {
			e.ArrStart()
			if len(s.Scopes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Scopes[0]
					e.Str(elem)
				}
				for _, elem := range s.Scopes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"token\"" + ":")
		e.Str(s.Token)
	}
	{
		e.Comma()

		e.RawStr("\"token_last_eight\"" + ":")
		s.TokenLastEight.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"hashed_token\"" + ":")
		s.HashedToken.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"app\"" + ":")
		s.App.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"note\"" + ":")
		s.Note.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"note_url\"" + ":")
		s.NoteURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"fingerprint\"" + ":")
		s.Fingerprint.Encode(e)
	}
	{
		if s.User.Set {
			e.Comma()
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	{
		if s.Installation.Set {
			e.Comma()
		}
		if s.Installation.Set {
			e.RawStr("\"installation\"" + ":")
			s.Installation.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"expires_at\"" + ":")
		s.ExpiresAt.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAuthorization = [15]string{
	0:  "id",
	1:  "url",
	2:  "scopes",
	3:  "token",
	4:  "token_last_eight",
	5:  "hashed_token",
	6:  "app",
	7:  "note",
	8:  "note_url",
	9:  "updated_at",
	10: "created_at",
	11: "fingerprint",
	12: "user",
	13: "installation",
	14: "expires_at",
}

// Decode decodes Authorization from json.
func (s *Authorization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Authorization to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "scopes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Scopes = nil
				switch tt := d.Next(); tt {
				case jx.Null:
					if err := d.Skip(); err != nil {
						return err
					}
				default:
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem string
						v, err := d.Str()
						elem = string(v)
						if err != nil {
							return err
						}
						s.Scopes = append(s.Scopes, elem)
						return nil
					}); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "token_last_eight":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.TokenLastEight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token_last_eight\"")
			}
		case "hashed_token":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.HashedToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hashed_token\"")
			}
		case "app":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.App.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app\"")
			}
		case "note":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "note_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.NoteURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note_url\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "installation":
			if err := func() error {
				s.Installation.Reset()
				if err := s.Installation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"installation\"")
			}
		case "expires_at":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Authorization")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthorization) {
					name = jsonFieldsNameOfAuthorization[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AuthorizationApp) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"client_id\"" + ":")
		e.Str(s.ClientID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAuthorizationApp = [3]string{
	0: "client_id",
	1: "name",
	2: "url",
}

// Decode decodes AuthorizationApp from json.
func (s *AuthorizationApp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthorizationApp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClientID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthorizationApp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthorizationApp) {
					name = jsonFieldsNameOfAuthorizationApp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s AutoMerge) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled_by\"" + ":")
		s.EnabledBy.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"merge_method\"" + ":")
		s.MergeMethod.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commit_title\"" + ":")
		e.Str(s.CommitTitle)
	}
	{
		e.Comma()

		e.RawStr("\"commit_message\"" + ":")
		e.Str(s.CommitMessage)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAutoMerge = [4]string{
	0: "enabled_by",
	1: "merge_method",
	2: "commit_title",
	3: "commit_message",
}

// Decode decodes AutoMerge from json.
func (s *AutoMerge) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutoMerge to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_by":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EnabledBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled_by\"")
			}
		case "merge_method":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.MergeMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_method\"")
			}
		case "commit_title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CommitTitle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_title\"")
			}
		case "commit_message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CommitMessage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutoMerge")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutoMerge) {
					name = jsonFieldsNameOfAutoMerge[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes AutoMergeMergeMethod as json.
func (s AutoMergeMergeMethod) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes AutoMergeMergeMethod from json.
func (s *AutoMergeMergeMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutoMergeMergeMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AutoMergeMergeMethod(v) {
	case AutoMergeMergeMethodMerge:
		*s = AutoMergeMergeMethodMerge
	case AutoMergeMergeMethodSquash:
		*s = AutoMergeMergeMethodSquash
	case AutoMergeMergeMethodRebase:
		*s = AutoMergeMergeMethodRebase
	default:
		*s = AutoMergeMergeMethod(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Autolink) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"key_prefix\"" + ":")
		e.Str(s.KeyPrefix)
	}
	{
		e.Comma()

		e.RawStr("\"url_template\"" + ":")
		e.Str(s.URLTemplate)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfAutolink = [3]string{
	0: "id",
	1: "key_prefix",
	2: "url_template",
}

// Decode decodes Autolink from json.
func (s *Autolink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Autolink to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key_prefix":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.KeyPrefix = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_prefix\"")
			}
		case "url_template":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URLTemplate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url_template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Autolink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutolink) {
					name = jsonFieldsNameOfAutolink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BaseGist) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		json.EncodeURI(e, s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"git_pull_url\"" + ":")
		json.EncodeURI(e, s.GitPullURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_push_url\"" + ":")
		json.EncodeURI(e, s.GitPushURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"files\"" + ":")
		s.Files.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"public\"" + ":")
		e.Bool(s.Public)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comments\"" + ":")
		e.Int(s.Comments)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		if s.Owner.Set {
			e.Comma()
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Truncated.Set {
			e.Comma()
		}
		if s.Truncated.Set {
			e.RawStr("\"truncated\"" + ":")
			s.Truncated.Encode(e)
		}
	}
	{
		if s.Forks != nil {
			e.Comma()
		}
		if s.Forks != nil {
			e.RawStr("\"forks\"" + ":")
			e.ArrStart()
			if len(s.Forks) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Forks[0]
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
				for _, elem := range s.Forks[1:] {
					e.Comma()
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.History != nil {
			e.Comma()
		}
		if s.History != nil {
			e.RawStr("\"history\"" + ":")
			e.ArrStart()
			if len(s.History) >= 1 {
				// Encode first element without comma.
				{
					elem := s.History[0]
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
				for _, elem := range s.History[1:] {
					e.Comma()
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBaseGist = [20]string{
	0:  "url",
	1:  "forks_url",
	2:  "commits_url",
	3:  "id",
	4:  "node_id",
	5:  "git_pull_url",
	6:  "git_push_url",
	7:  "html_url",
	8:  "files",
	9:  "public",
	10: "created_at",
	11: "updated_at",
	12: "description",
	13: "comments",
	14: "user",
	15: "comments_url",
	16: "owner",
	17: "truncated",
	18: "forks",
	19: "history",
}

// Decode decodes BaseGist from json.
func (s *BaseGist) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BaseGist to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "forks_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "commits_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommitsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "git_pull_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.GitPullURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_pull_url\"")
			}
		case "git_push_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.GitPushURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_push_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "files":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Files = make(BaseGistFiles)
				if err := s.Files.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "public":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Public = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "comments":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Comments = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "comments_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "truncated":
			if err := func() error {
				s.Truncated.Reset()
				if err := s.Truncated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"truncated\"")
			}
		case "forks":
			if err := func() error {
				s.Forks = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.Raw()
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Forks = append(s.Forks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "history":
			if err := func() error {
				s.History = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.Raw()
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.History = append(s.History, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BaseGist")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBaseGist) {
					name = jsonFieldsNameOfBaseGist[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BaseGistFiles) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBaseGistFiles = [0]string{}

// Decode decodes BaseGistFiles from json.
func (s BaseGistFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BaseGistFiles to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem BaseGistFilesItem
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BaseGistFiles")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BaseGistFilesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Filename.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Filename.Set {
			e.RawStr("\"filename\"" + ":")
			s.Filename.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.Language.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Language.Set {
			e.RawStr("\"language\"" + ":")
			s.Language.Encode(e)
		}
	}
	{
		if s.RawURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RawURL.Set {
			e.RawStr("\"raw_url\"" + ":")
			s.RawURL.Encode(e)
		}
	}
	{
		if s.Size.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Size.Set {
			e.RawStr("\"size\"" + ":")
			s.Size.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBaseGistFilesItem = [5]string{
	0: "filename",
	1: "type",
	2: "language",
	3: "raw_url",
	4: "size",
}

// Decode decodes BaseGistFilesItem from json.
func (s *BaseGistFilesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BaseGistFilesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "filename":
			if err := func() error {
				s.Filename.Reset()
				if err := s.Filename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "raw_url":
			if err := func() error {
				s.RawURL.Reset()
				if err := s.RawURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_url\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BaseGistFilesItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BasicError) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBasicError = [4]string{
	0: "message",
	1: "documentation_url",
	2: "url",
	3: "status",
}

// Decode decodes BasicError from json.
func (s *BasicError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BasicError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BasicError")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Blob) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		e.Str(s.Content)
	}
	{
		e.Comma()

		e.RawStr("\"encoding\"" + ":")
		e.Str(s.Encoding)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		s.Size.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		if s.HighlightedContent.Set {
			e.Comma()
		}
		if s.HighlightedContent.Set {
			e.RawStr("\"highlighted_content\"" + ":")
			s.HighlightedContent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBlob = [7]string{
	0: "content",
	1: "encoding",
	2: "url",
	3: "sha",
	4: "size",
	5: "node_id",
	6: "highlighted_content",
}

// Decode decodes Blob from json.
func (s *Blob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Blob to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "encoding":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Encoding = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encoding\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "highlighted_content":
			if err := func() error {
				s.HighlightedContent.Reset()
				if err := s.HighlightedContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlighted_content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Blob")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBlob) {
					name = jsonFieldsNameOfBlob[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchProtection) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Enabled.Set {
			e.RawStr("\"enabled\"" + ":")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.RequiredStatusChecks.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredStatusChecks.Set {
			e.RawStr("\"required_status_checks\"" + ":")
			s.RequiredStatusChecks.Encode(e)
		}
	}
	{
		if s.EnforceAdmins.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EnforceAdmins.Set {
			e.RawStr("\"enforce_admins\"" + ":")
			s.EnforceAdmins.Encode(e)
		}
	}
	{
		if s.RequiredPullRequestReviews.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredPullRequestReviews.Set {
			e.RawStr("\"required_pull_request_reviews\"" + ":")
			s.RequiredPullRequestReviews.Encode(e)
		}
	}
	{
		if s.Restrictions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Restrictions.Set {
			e.RawStr("\"restrictions\"" + ":")
			s.Restrictions.Encode(e)
		}
	}
	{
		if s.RequiredLinearHistory.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredLinearHistory.Set {
			e.RawStr("\"required_linear_history\"" + ":")
			s.RequiredLinearHistory.Encode(e)
		}
	}
	{
		if s.AllowForcePushes.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowForcePushes.Set {
			e.RawStr("\"allow_force_pushes\"" + ":")
			s.AllowForcePushes.Encode(e)
		}
	}
	{
		if s.AllowDeletions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowDeletions.Set {
			e.RawStr("\"allow_deletions\"" + ":")
			s.AllowDeletions.Encode(e)
		}
	}
	{
		if s.RequiredConversationResolution.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredConversationResolution.Set {
			e.RawStr("\"required_conversation_resolution\"" + ":")
			s.RequiredConversationResolution.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.ProtectionURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ProtectionURL.Set {
			e.RawStr("\"protection_url\"" + ":")
			s.ProtectionURL.Encode(e)
		}
	}
	{
		if s.RequiredSignatures.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredSignatures.Set {
			e.RawStr("\"required_signatures\"" + ":")
			s.RequiredSignatures.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchProtection = [13]string{
	0:  "url",
	1:  "enabled",
	2:  "required_status_checks",
	3:  "enforce_admins",
	4:  "required_pull_request_reviews",
	5:  "restrictions",
	6:  "required_linear_history",
	7:  "allow_force_pushes",
	8:  "allow_deletions",
	9:  "required_conversation_resolution",
	10: "name",
	11: "protection_url",
	12: "required_signatures",
}

// Decode decodes BranchProtection from json.
func (s *BranchProtection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchProtection to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "required_status_checks":
			if err := func() error {
				s.RequiredStatusChecks.Reset()
				if err := s.RequiredStatusChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_status_checks\"")
			}
		case "enforce_admins":
			if err := func() error {
				s.EnforceAdmins.Reset()
				if err := s.EnforceAdmins.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforce_admins\"")
			}
		case "required_pull_request_reviews":
			if err := func() error {
				s.RequiredPullRequestReviews.Reset()
				if err := s.RequiredPullRequestReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_pull_request_reviews\"")
			}
		case "restrictions":
			if err := func() error {
				s.Restrictions.Reset()
				if err := s.Restrictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restrictions\"")
			}
		case "required_linear_history":
			if err := func() error {
				s.RequiredLinearHistory.Reset()
				if err := s.RequiredLinearHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_linear_history\"")
			}
		case "allow_force_pushes":
			if err := func() error {
				s.AllowForcePushes.Reset()
				if err := s.AllowForcePushes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_force_pushes\"")
			}
		case "allow_deletions":
			if err := func() error {
				s.AllowDeletions.Reset()
				if err := s.AllowDeletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_deletions\"")
			}
		case "required_conversation_resolution":
			if err := func() error {
				s.RequiredConversationResolution.Reset()
				if err := s.RequiredConversationResolution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_conversation_resolution\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "protection_url":
			if err := func() error {
				s.ProtectionURL.Reset()
				if err := s.ProtectionURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protection_url\"")
			}
		case "required_signatures":
			if err := func() error {
				s.RequiredSignatures.Reset()
				if err := s.RequiredSignatures.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_signatures\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchProtection")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchProtectionAllowDeletions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Enabled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Enabled.Set {
			e.RawStr("\"enabled\"" + ":")
			s.Enabled.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchProtectionAllowDeletions = [1]string{
	0: "enabled",
}

// Decode decodes BranchProtectionAllowDeletions from json.
func (s *BranchProtectionAllowDeletions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchProtectionAllowDeletions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchProtectionAllowDeletions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchProtectionAllowForcePushes) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Enabled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Enabled.Set {
			e.RawStr("\"enabled\"" + ":")
			s.Enabled.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchProtectionAllowForcePushes = [1]string{
	0: "enabled",
}

// Decode decodes BranchProtectionAllowForcePushes from json.
func (s *BranchProtectionAllowForcePushes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchProtectionAllowForcePushes to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchProtectionAllowForcePushes")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchProtectionRequiredConversationResolution) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Enabled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Enabled.Set {
			e.RawStr("\"enabled\"" + ":")
			s.Enabled.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchProtectionRequiredConversationResolution = [1]string{
	0: "enabled",
}

// Decode decodes BranchProtectionRequiredConversationResolution from json.
func (s *BranchProtectionRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchProtectionRequiredConversationResolution to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchProtectionRequiredConversationResolution")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchProtectionRequiredLinearHistory) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Enabled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Enabled.Set {
			e.RawStr("\"enabled\"" + ":")
			s.Enabled.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchProtectionRequiredLinearHistory = [1]string{
	0: "enabled",
}

// Decode decodes BranchProtectionRequiredLinearHistory from json.
func (s *BranchProtectionRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchProtectionRequiredLinearHistory to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchProtectionRequiredLinearHistory")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchProtectionRequiredSignatures) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"enabled\"" + ":")
		e.Bool(s.Enabled)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchProtectionRequiredSignatures = [2]string{
	0: "url",
	1: "enabled",
}

// Decode decodes BranchProtectionRequiredSignatures from json.
func (s *BranchProtectionRequiredSignatures) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchProtectionRequiredSignatures to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchProtectionRequiredSignatures")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchProtectionRequiredSignatures) {
					name = jsonFieldsNameOfBranchProtectionRequiredSignatures[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchProtectionRequiredStatusChecks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.EnforcementLevel.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EnforcementLevel.Set {
			e.RawStr("\"enforcement_level\"" + ":")
			s.EnforcementLevel.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"contexts\"" + ":")
		e.ArrStart()
		if len(s.Contexts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Contexts[0]
				e.Str(elem)
			}
			for _, elem := range s.Contexts[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.ContextsURL.Set {
			e.Comma()
		}
		if s.ContextsURL.Set {
			e.RawStr("\"contexts_url\"" + ":")
			s.ContextsURL.Encode(e)
		}
	}
	{
		if s.Strict.Set {
			e.Comma()
		}
		if s.Strict.Set {
			e.RawStr("\"strict\"" + ":")
			s.Strict.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchProtectionRequiredStatusChecks = [5]string{
	0: "url",
	1: "enforcement_level",
	2: "contexts",
	3: "contexts_url",
	4: "strict",
}

// Decode decodes BranchProtectionRequiredStatusChecks from json.
func (s *BranchProtectionRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchProtectionRequiredStatusChecks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "enforcement_level":
			if err := func() error {
				s.EnforcementLevel.Reset()
				if err := s.EnforcementLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforcement_level\"")
			}
		case "contexts":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Contexts = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		case "contexts_url":
			if err := func() error {
				s.ContextsURL.Reset()
				if err := s.ContextsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts_url\"")
			}
		case "strict":
			if err := func() error {
				s.Strict.Reset()
				if err := s.Strict.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strict\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchProtectionRequiredStatusChecks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchProtectionRequiredStatusChecks) {
					name = jsonFieldsNameOfBranchProtectionRequiredStatusChecks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"users_url\"" + ":")
		json.EncodeURI(e, s.UsersURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"apps_url\"" + ":")
		json.EncodeURI(e, s.AppsURL)
	}
	{
		e.Comma()

		e.RawStr("\"users\"" + ":")
		e.ArrStart()
		if len(s.Users) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Users[0]
				elem.Encode(e)
			}
			for _, elem := range s.Users[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"teams\"" + ":")
		e.ArrStart()
		if len(s.Teams) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Teams[0]
				elem.Encode(e)
			}
			for _, elem := range s.Teams[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"apps\"" + ":")
		e.ArrStart()
		if len(s.Apps) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Apps[0]
				elem.Encode(e)
			}
			for _, elem := range s.Apps[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchRestrictionPolicy = [7]string{
	0: "url",
	1: "users_url",
	2: "teams_url",
	3: "apps_url",
	4: "users",
	5: "teams",
	6: "apps",
}

// Decode decodes BranchRestrictionPolicy from json.
func (s *BranchRestrictionPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchRestrictionPolicy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "users_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.UsersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users_url\"")
			}
		case "teams_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "apps_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AppsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apps_url\"")
			}
		case "users":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Users = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BranchRestrictionPolicyUsersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "teams":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Teams = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BranchRestrictionPolicyTeamsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		case "apps":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.Apps = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BranchRestrictionPolicyAppsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Apps = append(s.Apps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchRestrictionPolicy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchRestrictionPolicy) {
					name = jsonFieldsNameOfBranchRestrictionPolicy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicyAppsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Slug.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Slug.Set {
			e.RawStr("\"slug\"" + ":")
			s.Slug.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.Owner.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.ExternalURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalURL.Set {
			e.RawStr("\"external_url\"" + ":")
			s.ExternalURL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.Permissions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.Events != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Events != nil {
			e.RawStr("\"events\"" + ":")
			e.ArrStart()
			if len(s.Events) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Events[0]
					e.Str(elem)
				}
				for _, elem := range s.Events[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchRestrictionPolicyAppsItem = [12]string{
	0:  "id",
	1:  "slug",
	2:  "node_id",
	3:  "owner",
	4:  "name",
	5:  "description",
	6:  "external_url",
	7:  "html_url",
	8:  "created_at",
	9:  "updated_at",
	10: "permissions",
	11: "events",
}

// Decode decodes BranchRestrictionPolicyAppsItem from json.
func (s *BranchRestrictionPolicyAppsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchRestrictionPolicyAppsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "external_url":
			if err := func() error {
				s.ExternalURL.Reset()
				if err := s.ExternalURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "events":
			if err := func() error {
				s.Events = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchRestrictionPolicyAppsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicyAppsItemOwner) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Login.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Login.Set {
			e.RawStr("\"login\"" + ":")
			s.Login.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ReposURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReposURL.Set {
			e.RawStr("\"repos_url\"" + ":")
			s.ReposURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsURL.Set {
			e.RawStr("\"events_url\"" + ":")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.HooksURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HooksURL.Set {
			e.RawStr("\"hooks_url\"" + ":")
			s.HooksURL.Encode(e)
		}
	}
	{
		if s.IssuesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IssuesURL.Set {
			e.RawStr("\"issues_url\"" + ":")
			s.IssuesURL.Encode(e)
		}
	}
	{
		if s.MembersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersURL.Set {
			e.RawStr("\"members_url\"" + ":")
			s.MembersURL.Encode(e)
		}
	}
	{
		if s.PublicMembersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PublicMembersURL.Set {
			e.RawStr("\"public_members_url\"" + ":")
			s.PublicMembersURL.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvatarURL.Set {
			e.RawStr("\"avatar_url\"" + ":")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.GravatarID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GravatarID.Set {
			e.RawStr("\"gravatar_id\"" + ":")
			s.GravatarID.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.FollowersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowersURL.Set {
			e.RawStr("\"followers_url\"" + ":")
			s.FollowersURL.Encode(e)
		}
	}
	{
		if s.FollowingURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowingURL.Set {
			e.RawStr("\"following_url\"" + ":")
			s.FollowingURL.Encode(e)
		}
	}
	{
		if s.GistsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GistsURL.Set {
			e.RawStr("\"gists_url\"" + ":")
			s.GistsURL.Encode(e)
		}
	}
	{
		if s.StarredURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StarredURL.Set {
			e.RawStr("\"starred_url\"" + ":")
			s.StarredURL.Encode(e)
		}
	}
	{
		if s.SubscriptionsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscriptionsURL.Set {
			e.RawStr("\"subscriptions_url\"" + ":")
			s.SubscriptionsURL.Encode(e)
		}
	}
	{
		if s.OrganizationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationsURL.Set {
			e.RawStr("\"organizations_url\"" + ":")
			s.OrganizationsURL.Encode(e)
		}
	}
	{
		if s.ReceivedEventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReceivedEventsURL.Set {
			e.RawStr("\"received_events_url\"" + ":")
			s.ReceivedEventsURL.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.SiteAdmin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SiteAdmin.Set {
			e.RawStr("\"site_admin\"" + ":")
			s.SiteAdmin.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchRestrictionPolicyAppsItemOwner = [23]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "url",
	4:  "repos_url",
	5:  "events_url",
	6:  "hooks_url",
	7:  "issues_url",
	8:  "members_url",
	9:  "public_members_url",
	10: "avatar_url",
	11: "description",
	12: "gravatar_id",
	13: "html_url",
	14: "followers_url",
	15: "following_url",
	16: "gists_url",
	17: "starred_url",
	18: "subscriptions_url",
	19: "organizations_url",
	20: "received_events_url",
	21: "type",
	22: "site_admin",
}

// Decode decodes BranchRestrictionPolicyAppsItemOwner from json.
func (s *BranchRestrictionPolicyAppsItemOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchRestrictionPolicyAppsItemOwner to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			if err := func() error {
				s.Login.Reset()
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "repos_url":
			if err := func() error {
				s.ReposURL.Reset()
				if err := s.ReposURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			if err := func() error {
				s.EventsURL.Reset()
				if err := s.EventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "hooks_url":
			if err := func() error {
				s.HooksURL.Reset()
				if err := s.HooksURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "issues_url":
			if err := func() error {
				s.IssuesURL.Reset()
				if err := s.IssuesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "members_url":
			if err := func() error {
				s.MembersURL.Reset()
				if err := s.MembersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "public_members_url":
			if err := func() error {
				s.PublicMembersURL.Reset()
				if err := s.PublicMembersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_members_url\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "gravatar_id":
			if err := func() error {
				s.GravatarID.Reset()
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			if err := func() error {
				s.FollowersURL.Reset()
				if err := s.FollowersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			if err := func() error {
				s.FollowingURL.Reset()
				if err := s.FollowingURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			if err := func() error {
				s.GistsURL.Reset()
				if err := s.GistsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			if err := func() error {
				s.StarredURL.Reset()
				if err := s.StarredURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			if err := func() error {
				s.SubscriptionsURL.Reset()
				if err := s.SubscriptionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			if err := func() error {
				s.OrganizationsURL.Reset()
				if err := s.OrganizationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "received_events_url":
			if err := func() error {
				s.ReceivedEventsURL.Reset()
				if err := s.ReceivedEventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			if err := func() error {
				s.SiteAdmin.Reset()
				if err := s.SiteAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchRestrictionPolicyAppsItemOwner")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicyAppsItemPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Metadata.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Contents.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Contents.Set {
			e.RawStr("\"contents\"" + ":")
			s.Contents.Encode(e)
		}
	}
	{
		if s.Issues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Issues.Set {
			e.RawStr("\"issues\"" + ":")
			s.Issues.Encode(e)
		}
	}
	{
		if s.SingleFile.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SingleFile.Set {
			e.RawStr("\"single_file\"" + ":")
			s.SingleFile.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchRestrictionPolicyAppsItemPermissions = [4]string{
	0: "metadata",
	1: "contents",
	2: "issues",
	3: "single_file",
}

// Decode decodes BranchRestrictionPolicyAppsItemPermissions from json.
func (s *BranchRestrictionPolicyAppsItemPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchRestrictionPolicyAppsItemPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "contents":
			if err := func() error {
				s.Contents.Reset()
				if err := s.Contents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents\"")
			}
		case "issues":
			if err := func() error {
				s.Issues.Reset()
				if err := s.Issues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues\"")
			}
		case "single_file":
			if err := func() error {
				s.SingleFile.Reset()
				if err := s.SingleFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"single_file\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchRestrictionPolicyAppsItemPermissions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicyTeamsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Slug.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Slug.Set {
			e.RawStr("\"slug\"" + ":")
			s.Slug.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Privacy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	{
		if s.MembersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersURL.Set {
			e.RawStr("\"members_url\"" + ":")
			s.MembersURL.Encode(e)
		}
	}
	{
		if s.RepositoriesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RepositoriesURL.Set {
			e.RawStr("\"repositories_url\"" + ":")
			s.RepositoriesURL.Encode(e)
		}
	}
	{
		if s.Parent.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Parent.Set {
			e.RawStr("\"parent\"" + ":")
			s.Parent.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchRestrictionPolicyTeamsItem = [12]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "html_url",
	4:  "name",
	5:  "slug",
	6:  "description",
	7:  "privacy",
	8:  "permission",
	9:  "members_url",
	10: "repositories_url",
	11: "parent",
}

// Decode decodes BranchRestrictionPolicyTeamsItem from json.
func (s *BranchRestrictionPolicyTeamsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchRestrictionPolicyTeamsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "members_url":
			if err := func() error {
				s.MembersURL.Reset()
				if err := s.MembersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "repositories_url":
			if err := func() error {
				s.RepositoriesURL.Reset()
				if err := s.RepositoriesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories_url\"")
			}
		case "parent":
			if err := func() error {
				s.Parent.Reset()
				if err := s.Parent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchRestrictionPolicyTeamsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicyUsersItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Login.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Login.Set {
			e.RawStr("\"login\"" + ":")
			s.Login.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvatarURL.Set {
			e.RawStr("\"avatar_url\"" + ":")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.GravatarID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GravatarID.Set {
			e.RawStr("\"gravatar_id\"" + ":")
			s.GravatarID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.FollowersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowersURL.Set {
			e.RawStr("\"followers_url\"" + ":")
			s.FollowersURL.Encode(e)
		}
	}
	{
		if s.FollowingURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowingURL.Set {
			e.RawStr("\"following_url\"" + ":")
			s.FollowingURL.Encode(e)
		}
	}
	{
		if s.GistsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GistsURL.Set {
			e.RawStr("\"gists_url\"" + ":")
			s.GistsURL.Encode(e)
		}
	}
	{
		if s.StarredURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StarredURL.Set {
			e.RawStr("\"starred_url\"" + ":")
			s.StarredURL.Encode(e)
		}
	}
	{
		if s.SubscriptionsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscriptionsURL.Set {
			e.RawStr("\"subscriptions_url\"" + ":")
			s.SubscriptionsURL.Encode(e)
		}
	}
	{
		if s.OrganizationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationsURL.Set {
			e.RawStr("\"organizations_url\"" + ":")
			s.OrganizationsURL.Encode(e)
		}
	}
	{
		if s.ReposURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReposURL.Set {
			e.RawStr("\"repos_url\"" + ":")
			s.ReposURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsURL.Set {
			e.RawStr("\"events_url\"" + ":")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ReceivedEventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReceivedEventsURL.Set {
			e.RawStr("\"received_events_url\"" + ":")
			s.ReceivedEventsURL.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.SiteAdmin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SiteAdmin.Set {
			e.RawStr("\"site_admin\"" + ":")
			s.SiteAdmin.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchRestrictionPolicyUsersItem = [18]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "avatar_url",
	4:  "gravatar_id",
	5:  "url",
	6:  "html_url",
	7:  "followers_url",
	8:  "following_url",
	9:  "gists_url",
	10: "starred_url",
	11: "subscriptions_url",
	12: "organizations_url",
	13: "repos_url",
	14: "events_url",
	15: "received_events_url",
	16: "type",
	17: "site_admin",
}

// Decode decodes BranchRestrictionPolicyUsersItem from json.
func (s *BranchRestrictionPolicyUsersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchRestrictionPolicyUsersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			if err := func() error {
				s.Login.Reset()
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			if err := func() error {
				s.GravatarID.Reset()
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			if err := func() error {
				s.FollowersURL.Reset()
				if err := s.FollowersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			if err := func() error {
				s.FollowingURL.Reset()
				if err := s.FollowingURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			if err := func() error {
				s.GistsURL.Reset()
				if err := s.GistsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			if err := func() error {
				s.StarredURL.Reset()
				if err := s.StarredURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			if err := func() error {
				s.SubscriptionsURL.Reset()
				if err := s.SubscriptionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			if err := func() error {
				s.OrganizationsURL.Reset()
				if err := s.OrganizationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			if err := func() error {
				s.ReposURL.Reset()
				if err := s.ReposURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			if err := func() error {
				s.EventsURL.Reset()
				if err := s.EventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			if err := func() error {
				s.ReceivedEventsURL.Reset()
				if err := s.ReceivedEventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			if err := func() error {
				s.SiteAdmin.Reset()
				if err := s.SiteAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchRestrictionPolicyUsersItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchShort) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		s.Commit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"protected\"" + ":")
		e.Bool(s.Protected)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchShort = [3]string{
	0: "name",
	1: "commit",
	2: "protected",
}

// Decode decodes BranchShort from json.
func (s *BranchShort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchShort to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "protected":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Protected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protected\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchShort")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchShort) {
					name = jsonFieldsNameOfBranchShort[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchShortCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchShortCommit = [2]string{
	0: "sha",
	1: "url",
}

// Decode decodes BranchShortCommit from json.
func (s *BranchShortCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchShortCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchShortCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchShortCommit) {
					name = jsonFieldsNameOfBranchShortCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchWithProtection) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		s.Commit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"protected\"" + ":")
		e.Bool(s.Protected)
	}
	{
		e.Comma()

		e.RawStr("\"protection\"" + ":")
		s.Protection.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"protection_url\"" + ":")
		json.EncodeURI(e, s.ProtectionURL)
	}
	{
		if s.Pattern.Set {
			e.Comma()
		}
		if s.Pattern.Set {
			e.RawStr("\"pattern\"" + ":")
			s.Pattern.Encode(e)
		}
	}
	{
		if s.RequiredApprovingReviewCount.Set {
			e.Comma()
		}
		if s.RequiredApprovingReviewCount.Set {
			e.RawStr("\"required_approving_review_count\"" + ":")
			s.RequiredApprovingReviewCount.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchWithProtection = [8]string{
	0: "name",
	1: "commit",
	2: "_links",
	3: "protected",
	4: "protection",
	5: "protection_url",
	6: "pattern",
	7: "required_approving_review_count",
}

// Decode decodes BranchWithProtection from json.
func (s *BranchWithProtection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchWithProtection to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "_links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "protected":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Protected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protected\"")
			}
		case "protection":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Protection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protection\"")
			}
		case "protection_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ProtectionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protection_url\"")
			}
		case "pattern":
			if err := func() error {
				s.Pattern.Reset()
				if err := s.Pattern.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pattern\"")
			}
		case "required_approving_review_count":
			if err := func() error {
				s.RequiredApprovingReviewCount.Reset()
				if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_approving_review_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchWithProtection")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchWithProtection) {
					name = jsonFieldsNameOfBranchWithProtection[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BranchWithProtectionLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"html\"" + ":")
		e.Str(s.HTML)
	}
	{
		e.Comma()

		e.RawStr("\"self\"" + ":")
		json.EncodeURI(e, s.Self)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBranchWithProtectionLinks = [2]string{
	0: "html",
	1: "self",
}

// Decode decodes BranchWithProtectionLinks from json.
func (s *BranchWithProtectionLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BranchWithProtectionLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "html":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HTML = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "self":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.Self = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BranchWithProtectionLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBranchWithProtectionLinks) {
					name = jsonFieldsNameOfBranchWithProtectionLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CheckAnnotation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"start_line\"" + ":")
		e.Int(s.StartLine)
	}
	{
		e.Comma()

		e.RawStr("\"end_line\"" + ":")
		e.Int(s.EndLine)
	}
	{
		e.Comma()

		e.RawStr("\"start_column\"" + ":")
		s.StartColumn.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"end_column\"" + ":")
		s.EndColumn.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"annotation_level\"" + ":")
		s.AnnotationLevel.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		s.Title.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		s.Message.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"raw_details\"" + ":")
		s.RawDetails.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"blob_href\"" + ":")
		e.Str(s.BlobHref)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCheckAnnotation = [10]string{
	0: "path",
	1: "start_line",
	2: "end_line",
	3: "start_column",
	4: "end_column",
	5: "annotation_level",
	6: "title",
	7: "message",
	8: "raw_details",
	9: "blob_href",
}

// Decode decodes CheckAnnotation from json.
func (s *CheckAnnotation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckAnnotation to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "start_line":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.StartLine = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_line\"")
			}
		case "end_line":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.EndLine = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_line\"")
			}
		case "start_column":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.StartColumn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_column\"")
			}
		case "end_column":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.EndColumn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_column\"")
			}
		case "annotation_level":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.AnnotationLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotation_level\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "raw_details":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.RawDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_details\"")
			}
		case "blob_href":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BlobHref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blob_href\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckAnnotation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckAnnotation) {
					name = jsonFieldsNameOfCheckAnnotation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CheckRun) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"head_sha\"" + ":")
		e.Str(s.HeadSha)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"external_id\"" + ":")
		s.ExternalID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"details_url\"" + ":")
		s.DetailsURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"conclusion\"" + ":")
		s.Conclusion.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"started_at\"" + ":")
		s.StartedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"completed_at\"" + ":")
		s.CompletedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"output\"" + ":")
		s.Output.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"check_suite\"" + ":")
		s.CheckSuite.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"app\"" + ":")
		s.App.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pull_requests\"" + ":")
		e.ArrStart()
		if len(s.PullRequests) >= 1 {
			// Encode first element without comma.
			{
				elem := s.PullRequests[0]
				elem.Encode(e)
			}
			for _, elem := range s.PullRequests[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Deployment.Set {
			e.Comma()
		}
		if s.Deployment.Set {
			e.RawStr("\"deployment\"" + ":")
			s.Deployment.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCheckRun = [17]string{
	0:  "id",
	1:  "head_sha",
	2:  "node_id",
	3:  "external_id",
	4:  "url",
	5:  "html_url",
	6:  "details_url",
	7:  "status",
	8:  "conclusion",
	9:  "started_at",
	10: "completed_at",
	11: "output",
	12: "name",
	13: "check_suite",
	14: "app",
	15: "pull_requests",
	16: "deployment",
}

// Decode decodes CheckRun from json.
func (s *CheckRun) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckRun to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "head_sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.HeadSha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_sha\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "external_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ExternalID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "details_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.DetailsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details_url\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "conclusion":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Conclusion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conclusion\"")
			}
		case "started_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "completed_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		case "output":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "check_suite":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.CheckSuite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_suite\"")
			}
		case "app":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.App.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app\"")
			}
		case "pull_requests":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				s.PullRequests = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PullRequestMinimal
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PullRequests = append(s.PullRequests, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_requests\"")
			}
		case "deployment":
			if err := func() error {
				s.Deployment.Reset()
				if err := s.Deployment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckRun")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckRun) {
					name = jsonFieldsNameOfCheckRun[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CheckRunCheckSuite) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCheckRunCheckSuite = [1]string{
	0: "id",
}

// Decode decodes CheckRunCheckSuite from json.
func (s *CheckRunCheckSuite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckRunCheckSuite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckRunCheckSuite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckRunCheckSuite) {
					name = jsonFieldsNameOfCheckRunCheckSuite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes CheckRunConclusion as json.
func (s CheckRunConclusion) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CheckRunConclusion from json.
func (s *CheckRunConclusion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckRunConclusion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CheckRunConclusion(v) {
	case CheckRunConclusionSuccess:
		*s = CheckRunConclusionSuccess
	case CheckRunConclusionFailure:
		*s = CheckRunConclusionFailure
	case CheckRunConclusionNeutral:
		*s = CheckRunConclusionNeutral
	case CheckRunConclusionCancelled:
		*s = CheckRunConclusionCancelled
	case CheckRunConclusionSkipped:
		*s = CheckRunConclusionSkipped
	case CheckRunConclusionTimedOut:
		*s = CheckRunConclusionTimedOut
	case CheckRunConclusionActionRequired:
		*s = CheckRunConclusionActionRequired
	default:
		*s = CheckRunConclusion(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CheckRunOutput) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		s.Title.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"summary\"" + ":")
		s.Summary.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"text\"" + ":")
		s.Text.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"annotations_count\"" + ":")
		e.Int(s.AnnotationsCount)
	}
	{
		e.Comma()

		e.RawStr("\"annotations_url\"" + ":")
		json.EncodeURI(e, s.AnnotationsURL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCheckRunOutput = [5]string{
	0: "title",
	1: "summary",
	2: "text",
	3: "annotations_count",
	4: "annotations_url",
}

// Decode decodes CheckRunOutput from json.
func (s *CheckRunOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckRunOutput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "summary":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "annotations_count":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.AnnotationsCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotations_count\"")
			}
		case "annotations_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AnnotationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotations_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckRunOutput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckRunOutput) {
					name = jsonFieldsNameOfCheckRunOutput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes CheckRunStatus as json.
func (s CheckRunStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CheckRunStatus from json.
func (s *CheckRunStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckRunStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CheckRunStatus(v) {
	case CheckRunStatusQueued:
		*s = CheckRunStatusQueued
	case CheckRunStatusInProgress:
		*s = CheckRunStatusInProgress
	case CheckRunStatusCompleted:
		*s = CheckRunStatusCompleted
	default:
		*s = CheckRunStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CheckSuite) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"head_branch\"" + ":")
		s.HeadBranch.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"head_sha\"" + ":")
		e.Str(s.HeadSha)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"conclusion\"" + ":")
		s.Conclusion.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"before\"" + ":")
		s.Before.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"after\"" + ":")
		s.After.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pull_requests\"" + ":")
		if s.PullRequests == nil {
			e.Null()
		} else {
			e.ArrStart()
			if len(s.PullRequests) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PullRequests[0]
					elem.Encode(e)
				}
				for _, elem := range s.PullRequests[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"app\"" + ":")
		s.App.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"head_commit\"" + ":")
		s.HeadCommit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"latest_check_runs_count\"" + ":")
		e.Int(s.LatestCheckRunsCount)
	}
	{
		e.Comma()

		e.RawStr("\"check_runs_url\"" + ":")
		e.Str(s.CheckRunsURL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCheckSuite = [17]string{
	0:  "id",
	1:  "node_id",
	2:  "head_branch",
	3:  "head_sha",
	4:  "status",
	5:  "conclusion",
	6:  "url",
	7:  "before",
	8:  "after",
	9:  "pull_requests",
	10: "app",
	11: "repository",
	12: "created_at",
	13: "updated_at",
	14: "head_commit",
	15: "latest_check_runs_count",
	16: "check_runs_url",
}

// Decode decodes CheckSuite from json.
func (s *CheckSuite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSuite to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "head_branch":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.HeadBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_branch\"")
			}
		case "head_sha":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.HeadSha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_sha\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "conclusion":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Conclusion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conclusion\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "before":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Before.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"before\"")
			}
		case "after":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.After.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"after\"")
			}
		case "pull_requests":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				s.PullRequests = nil
				switch tt := d.Next(); tt {
				case jx.Null:
					if err := d.Skip(); err != nil {
						return err
					}
				default:
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem PullRequestMinimal
						if err := elem.Decode(d); err != nil {
							return err
						}
						s.PullRequests = append(s.PullRequests, elem)
						return nil
					}); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_requests\"")
			}
		case "app":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.App.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app\"")
			}
		case "repository":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "head_commit":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.HeadCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_commit\"")
			}
		case "latest_check_runs_count":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.LatestCheckRunsCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_check_runs_count\"")
			}
		case "check_runs_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CheckRunsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_runs_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSuite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckSuite) {
					name = jsonFieldsNameOfCheckSuite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes CheckSuiteConclusion as json.
func (s CheckSuiteConclusion) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CheckSuiteConclusion from json.
func (s *CheckSuiteConclusion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSuiteConclusion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CheckSuiteConclusion(v) {
	case CheckSuiteConclusionSuccess:
		*s = CheckSuiteConclusionSuccess
	case CheckSuiteConclusionFailure:
		*s = CheckSuiteConclusionFailure
	case CheckSuiteConclusionNeutral:
		*s = CheckSuiteConclusionNeutral
	case CheckSuiteConclusionCancelled:
		*s = CheckSuiteConclusionCancelled
	case CheckSuiteConclusionSkipped:
		*s = CheckSuiteConclusionSkipped
	case CheckSuiteConclusionTimedOut:
		*s = CheckSuiteConclusionTimedOut
	case CheckSuiteConclusionActionRequired:
		*s = CheckSuiteConclusionActionRequired
	default:
		*s = CheckSuiteConclusion(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CheckSuitePreference) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"preferences\"" + ":")
		s.Preferences.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCheckSuitePreference = [2]string{
	0: "preferences",
	1: "repository",
}

// Decode decodes CheckSuitePreference from json.
func (s *CheckSuitePreference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSuitePreference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferences":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Preferences.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferences\"")
			}
		case "repository":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSuitePreference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckSuitePreference) {
					name = jsonFieldsNameOfCheckSuitePreference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CheckSuitePreferencePreferences) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AutoTriggerChecks != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AutoTriggerChecks != nil {
			e.RawStr("\"auto_trigger_checks\"" + ":")
			e.ArrStart()
			if len(s.AutoTriggerChecks) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AutoTriggerChecks[0]
					elem.Encode(e)
				}
				for _, elem := range s.AutoTriggerChecks[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCheckSuitePreferencePreferences = [1]string{
	0: "auto_trigger_checks",
}

// Decode decodes CheckSuitePreferencePreferences from json.
func (s *CheckSuitePreferencePreferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSuitePreferencePreferences to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auto_trigger_checks":
			if err := func() error {
				s.AutoTriggerChecks = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CheckSuitePreferencePreferencesAutoTriggerChecksItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AutoTriggerChecks = append(s.AutoTriggerChecks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_trigger_checks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSuitePreferencePreferences")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CheckSuitePreferencePreferencesAutoTriggerChecksItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"app_id\"" + ":")
		e.Int(s.AppID)
	}
	{
		e.Comma()

		e.RawStr("\"setting\"" + ":")
		e.Bool(s.Setting)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCheckSuitePreferencePreferencesAutoTriggerChecksItem = [2]string{
	0: "app_id",
	1: "setting",
}

// Decode decodes CheckSuitePreferencePreferencesAutoTriggerChecksItem from json.
func (s *CheckSuitePreferencePreferencesAutoTriggerChecksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSuitePreferencePreferencesAutoTriggerChecksItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "app_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AppID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app_id\"")
			}
		case "setting":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Setting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"setting\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckSuitePreferencePreferencesAutoTriggerChecksItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckSuitePreferencePreferencesAutoTriggerChecksItem) {
					name = jsonFieldsNameOfCheckSuitePreferencePreferencesAutoTriggerChecksItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes CheckSuiteStatus as json.
func (s CheckSuiteStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CheckSuiteStatus from json.
func (s *CheckSuiteStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckSuiteStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CheckSuiteStatus(v) {
	case CheckSuiteStatusQueued:
		*s = CheckSuiteStatusQueued
	case CheckSuiteStatusInProgress:
		*s = CheckSuiteStatusInProgress
	case CheckSuiteStatusCompleted:
		*s = CheckSuiteStatusCompleted
	default:
		*s = CheckSuiteStatus(v)
	}

	return nil
}

// Encode encodes ChecksCreateSuiteApplicationJSONCreated as json.
func (s ChecksCreateSuiteApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := CheckSuite(s)
	unwrapped.Encode(e)
}

// Decode decodes ChecksCreateSuiteApplicationJSONCreated from json.
func (s *ChecksCreateSuiteApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksCreateSuiteApplicationJSONCreated to nil")
	}
	var unwrapped CheckSuite
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ChecksCreateSuiteApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ChecksCreateSuiteApplicationJSONOK as json.
func (s ChecksCreateSuiteApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := CheckSuite(s)
	unwrapped.Encode(e)
}

// Decode decodes ChecksCreateSuiteApplicationJSONOK from json.
func (s *ChecksCreateSuiteApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksCreateSuiteApplicationJSONOK to nil")
	}
	var unwrapped CheckSuite
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ChecksCreateSuiteApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ChecksCreateSuiteReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"head_sha\"" + ":")
		e.Str(s.HeadSha)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChecksCreateSuiteReq = [1]string{
	0: "head_sha",
}

// Decode decodes ChecksCreateSuiteReq from json.
func (s *ChecksCreateSuiteReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksCreateSuiteReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "head_sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HeadSha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_sha\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChecksCreateSuiteReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChecksCreateSuiteReq) {
					name = jsonFieldsNameOfChecksCreateSuiteReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChecksListForRefOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"check_runs\"" + ":")
		e.ArrStart()
		if len(s.CheckRuns) >= 1 {
			// Encode first element without comma.
			{
				elem := s.CheckRuns[0]
				elem.Encode(e)
			}
			for _, elem := range s.CheckRuns[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChecksListForRefOK = [2]string{
	0: "total_count",
	1: "check_runs",
}

// Decode decodes ChecksListForRefOK from json.
func (s *ChecksListForRefOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksListForRefOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "check_runs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.CheckRuns = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CheckRun
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CheckRuns = append(s.CheckRuns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_runs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChecksListForRefOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChecksListForRefOK) {
					name = jsonFieldsNameOfChecksListForRefOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChecksListForSuiteOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"check_runs\"" + ":")
		e.ArrStart()
		if len(s.CheckRuns) >= 1 {
			// Encode first element without comma.
			{
				elem := s.CheckRuns[0]
				elem.Encode(e)
			}
			for _, elem := range s.CheckRuns[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChecksListForSuiteOK = [2]string{
	0: "total_count",
	1: "check_runs",
}

// Decode decodes ChecksListForSuiteOK from json.
func (s *ChecksListForSuiteOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksListForSuiteOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "check_runs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.CheckRuns = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CheckRun
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CheckRuns = append(s.CheckRuns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_runs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChecksListForSuiteOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChecksListForSuiteOK) {
					name = jsonFieldsNameOfChecksListForSuiteOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChecksListSuitesForRefOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"check_suites\"" + ":")
		e.ArrStart()
		if len(s.CheckSuites) >= 1 {
			// Encode first element without comma.
			{
				elem := s.CheckSuites[0]
				elem.Encode(e)
			}
			for _, elem := range s.CheckSuites[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChecksListSuitesForRefOK = [2]string{
	0: "total_count",
	1: "check_suites",
}

// Decode decodes ChecksListSuitesForRefOK from json.
func (s *ChecksListSuitesForRefOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksListSuitesForRefOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "check_suites":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.CheckSuites = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CheckSuite
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CheckSuites = append(s.CheckSuites, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_suites\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChecksListSuitesForRefOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChecksListSuitesForRefOK) {
					name = jsonFieldsNameOfChecksListSuitesForRefOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChecksRerequestSuiteCreated) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChecksRerequestSuiteCreated = [0]string{}

// Decode decodes ChecksRerequestSuiteCreated from json.
func (s ChecksRerequestSuiteCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksRerequestSuiteCreated to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChecksRerequestSuiteCreated")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChecksSetSuitesPreferencesReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AutoTriggerChecks != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AutoTriggerChecks != nil {
			e.RawStr("\"auto_trigger_checks\"" + ":")
			e.ArrStart()
			if len(s.AutoTriggerChecks) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AutoTriggerChecks[0]
					elem.Encode(e)
				}
				for _, elem := range s.AutoTriggerChecks[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChecksSetSuitesPreferencesReq = [1]string{
	0: "auto_trigger_checks",
}

// Decode decodes ChecksSetSuitesPreferencesReq from json.
func (s *ChecksSetSuitesPreferencesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksSetSuitesPreferencesReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auto_trigger_checks":
			if err := func() error {
				s.AutoTriggerChecks = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ChecksSetSuitesPreferencesReqAutoTriggerChecksItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AutoTriggerChecks = append(s.AutoTriggerChecks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_trigger_checks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChecksSetSuitesPreferencesReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ChecksSetSuitesPreferencesReqAutoTriggerChecksItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"app_id\"" + ":")
		e.Int(s.AppID)
	}
	{
		e.Comma()

		e.RawStr("\"setting\"" + ":")
		e.Bool(s.Setting)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfChecksSetSuitesPreferencesReqAutoTriggerChecksItem = [2]string{
	0: "app_id",
	1: "setting",
}

// Decode decodes ChecksSetSuitesPreferencesReqAutoTriggerChecksItem from json.
func (s *ChecksSetSuitesPreferencesReqAutoTriggerChecksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChecksSetSuitesPreferencesReqAutoTriggerChecksItem to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "app_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AppID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app_id\"")
			}
		case "setting":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Setting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"setting\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChecksSetSuitesPreferencesReqAutoTriggerChecksItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChecksSetSuitesPreferencesReqAutoTriggerChecksItem) {
					name = jsonFieldsNameOfChecksSetSuitesPreferencesReqAutoTriggerChecksItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CloneTraffic) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"count\"" + ":")
		e.Int(s.Count)
	}
	{
		e.Comma()

		e.RawStr("\"uniques\"" + ":")
		e.Int(s.Uniques)
	}
	{
		e.Comma()

		e.RawStr("\"clones\"" + ":")
		e.ArrStart()
		if len(s.Clones) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Clones[0]
				elem.Encode(e)
			}
			for _, elem := range s.Clones[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCloneTraffic = [3]string{
	0: "count",
	1: "uniques",
	2: "clones",
}

// Decode decodes CloneTraffic from json.
func (s *CloneTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CloneTraffic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "uniques":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Uniques = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniques\"")
			}
		case "clones":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Clones = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Traffic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Clones = append(s.Clones, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clones\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CloneTraffic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCloneTraffic) {
					name = jsonFieldsNameOfCloneTraffic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes CodeFrequencyStat as json.
func (s CodeFrequencyStat) Encode(e *jx.Writer) {
	unwrapped := []int(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			e.Int(elem)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			e.Int(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes CodeFrequencyStat from json.
func (s *CodeFrequencyStat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeFrequencyStat to nil")
	}
	var unwrapped []int
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem int
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeFrequencyStat(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeOfConduct) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeOfConduct = [5]string{
	0: "key",
	1: "name",
	2: "url",
	3: "body",
	4: "html_url",
}

// Decode decodes CodeOfConduct from json.
func (s *CodeOfConduct) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeOfConduct to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeOfConduct")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeOfConduct) {
					name = jsonFieldsNameOfCodeOfConduct[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CodeOfConductSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeOfConductSimple = [4]string{
	0: "url",
	1: "key",
	2: "name",
	3: "html_url",
}

// Decode decodes CodeOfConductSimple from json.
func (s *CodeOfConductSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeOfConductSimple to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeOfConductSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeOfConductSimple) {
					name = jsonFieldsNameOfCodeOfConductSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAlert) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"number\"" + ":")
		s.Number.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		if len(s.Instances) != 0 {
			e.Comma()
		}

		if len(s.Instances) != 0 {
			e.RawStr("\"instances\"" + ":")
			e.Raw(s.Instances)
		}
	}
	{
		e.Comma()

		e.RawStr("\"instances_url\"" + ":")
		s.InstancesURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"dismissed_by\"" + ":")
		s.DismissedBy.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"dismissed_at\"" + ":")
		s.DismissedAt.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"dismissed_reason\"" + ":")
		s.DismissedReason.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"rule\"" + ":")
		s.Rule.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"tool\"" + ":")
		s.Tool.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"most_recent_instance\"" + ":")
		s.MostRecentInstance.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeScanningAlert = [13]string{
	0:  "number",
	1:  "created_at",
	2:  "url",
	3:  "html_url",
	4:  "instances",
	5:  "instances_url",
	6:  "state",
	7:  "dismissed_by",
	8:  "dismissed_at",
	9:  "dismissed_reason",
	10: "rule",
	11: "tool",
	12: "most_recent_instance",
}

// Decode decodes CodeScanningAlert from json.
func (s *CodeScanningAlert) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlert to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				{
					var unwrapped int
					v, err := d.Int()
					unwrapped = int(v)
					if err != nil {
						return err
					}
					s.Number = AlertNumber(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				{
					var unwrapped time.Time
					v, err := json.DecodeDateTime(d)
					unwrapped = v
					if err != nil {
						return err
					}
					s.CreatedAt = AlertCreatedAt(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				{
					var unwrapped url.URL
					v, err := json.DecodeURI(d)
					unwrapped = v
					if err != nil {
						return err
					}
					s.URL = AlertURL(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				{
					var unwrapped url.URL
					v, err := json.DecodeURI(d)
					unwrapped = v
					if err != nil {
						return err
					}
					s.HTMLURL = AlertHTMLURL(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "instances":
			if err := func() error {
				v, err := d.Raw()
				s.Instances = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instances\"")
			}
		case "instances_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				{
					var unwrapped url.URL
					v, err := json.DecodeURI(d)
					unwrapped = v
					if err != nil {
						return err
					}
					s.InstancesURL = AlertInstancesURL(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instances_url\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "dismissed_by":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.DismissedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_by\"")
			}
		case "dismissed_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.DismissedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_at\"")
			}
		case "dismissed_reason":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.DismissedReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_reason\"")
			}
		case "rule":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Rule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		case "tool":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Tool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool\"")
			}
		case "most_recent_instance":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.MostRecentInstance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"most_recent_instance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAlert")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeScanningAlert) {
					name = jsonFieldsNameOfCodeScanningAlert[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes CodeScanningAlertClassification as json.
func (s CodeScanningAlertClassification) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertClassification from json.
func (s *CodeScanningAlertClassification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertClassification to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertClassification(v) {
	case CodeScanningAlertClassificationSource:
		*s = CodeScanningAlertClassificationSource
	case CodeScanningAlertClassificationGenerated:
		*s = CodeScanningAlertClassificationGenerated
	case CodeScanningAlertClassificationTest:
		*s = CodeScanningAlertClassificationTest
	case CodeScanningAlertClassificationLibrary:
		*s = CodeScanningAlertClassificationLibrary
	default:
		*s = CodeScanningAlertClassification(v)
	}

	return nil
}

// Encode encodes CodeScanningAlertDismissedAt as json.
func (s CodeScanningAlertDismissedAt) Encode(e *jx.Writer) {
	unwrapped := time.Time(s)
	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes CodeScanningAlertDismissedAt from json.
func (s *CodeScanningAlertDismissedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertDismissedAt to nil")
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAlertDismissedAt(unwrapped)
	return nil
}

// Encode encodes CodeScanningAlertDismissedReason as json.
func (s CodeScanningAlertDismissedReason) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertDismissedReason from json.
func (s *CodeScanningAlertDismissedReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertDismissedReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertDismissedReason(v) {
	case CodeScanningAlertDismissedReasonFalsePositive:
		*s = CodeScanningAlertDismissedReasonFalsePositive
	case CodeScanningAlertDismissedReasonWonTFix:
		*s = CodeScanningAlertDismissedReasonWonTFix
	case CodeScanningAlertDismissedReasonUsedInTests:
		*s = CodeScanningAlertDismissedReasonUsedInTests
	default:
		*s = CodeScanningAlertDismissedReason(v)
	}

	return nil
}

// Encode encodes CodeScanningAlertEnvironment as json.
func (s CodeScanningAlertEnvironment) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAlertEnvironment from json.
func (s *CodeScanningAlertEnvironment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertEnvironment to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAlertEnvironment(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertInstance) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ref.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ref.Set {
			e.RawStr("\"ref\"" + ":")
			s.Ref.Encode(e)
		}
	}
	{
		if s.AnalysisKey.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AnalysisKey.Set {
			e.RawStr("\"analysis_key\"" + ":")
			s.AnalysisKey.Encode(e)
		}
	}
	{
		if s.Environment.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Environment.Set {
			e.RawStr("\"environment\"" + ":")
			s.Environment.Encode(e)
		}
	}
	{
		if s.Category.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Category.Set {
			e.RawStr("\"category\"" + ":")
			s.Category.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.CommitSha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommitSha.Set {
			e.RawStr("\"commit_sha\"" + ":")
			s.CommitSha.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Location.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Classifications != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Classifications != nil {
			e.RawStr("\"classifications\"" + ":")
			e.ArrStart()
			if len(s.Classifications) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Classifications[0]
					elem.Encode(e)
				}
				for _, elem := range s.Classifications[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeScanningAlertInstance = [10]string{
	0: "ref",
	1: "analysis_key",
	2: "environment",
	3: "category",
	4: "state",
	5: "commit_sha",
	6: "message",
	7: "location",
	8: "html_url",
	9: "classifications",
}

// Decode decodes CodeScanningAlertInstance from json.
func (s *CodeScanningAlertInstance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertInstance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			if err := func() error {
				s.Ref.Reset()
				if err := s.Ref.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "analysis_key":
			if err := func() error {
				s.AnalysisKey.Reset()
				if err := s.AnalysisKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analysis_key\"")
			}
		case "environment":
			if err := func() error {
				s.Environment.Reset()
				if err := s.Environment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "commit_sha":
			if err := func() error {
				s.CommitSha.Reset()
				if err := s.CommitSha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_sha\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "classifications":
			if err := func() error {
				s.Classifications = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CodeScanningAlertClassification
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Classifications = append(s.Classifications, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classifications\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAlertInstance")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertInstanceMessage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Text.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Text.Set {
			e.RawStr("\"text\"" + ":")
			s.Text.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeScanningAlertInstanceMessage = [1]string{
	0: "text",
}

// Decode decodes CodeScanningAlertInstanceMessage from json.
func (s *CodeScanningAlertInstanceMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertInstanceMessage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAlertInstanceMessage")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertItems) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"number\"" + ":")
		s.Number.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"instances_url\"" + ":")
		s.InstancesURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"dismissed_by\"" + ":")
		s.DismissedBy.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"dismissed_at\"" + ":")
		s.DismissedAt.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"dismissed_reason\"" + ":")
		s.DismissedReason.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"rule\"" + ":")
		s.Rule.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"tool\"" + ":")
		s.Tool.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"most_recent_instance\"" + ":")
		s.MostRecentInstance.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeScanningAlertItems = [12]string{
	0:  "number",
	1:  "created_at",
	2:  "url",
	3:  "html_url",
	4:  "instances_url",
	5:  "state",
	6:  "dismissed_by",
	7:  "dismissed_at",
	8:  "dismissed_reason",
	9:  "rule",
	10: "tool",
	11: "most_recent_instance",
}

// Decode decodes CodeScanningAlertItems from json.
func (s *CodeScanningAlertItems) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertItems to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				{
					var unwrapped int
					v, err := d.Int()
					unwrapped = int(v)
					if err != nil {
						return err
					}
					s.Number = AlertNumber(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				{
					var unwrapped time.Time
					v, err := json.DecodeDateTime(d)
					unwrapped = v
					if err != nil {
						return err
					}
					s.CreatedAt = AlertCreatedAt(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				{
					var unwrapped url.URL
					v, err := json.DecodeURI(d)
					unwrapped = v
					if err != nil {
						return err
					}
					s.URL = AlertURL(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				{
					var unwrapped url.URL
					v, err := json.DecodeURI(d)
					unwrapped = v
					if err != nil {
						return err
					}
					s.HTMLURL = AlertHTMLURL(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "instances_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				{
					var unwrapped url.URL
					v, err := json.DecodeURI(d)
					unwrapped = v
					if err != nil {
						return err
					}
					s.InstancesURL = AlertInstancesURL(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instances_url\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "dismissed_by":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.DismissedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_by\"")
			}
		case "dismissed_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.DismissedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_at\"")
			}
		case "dismissed_reason":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.DismissedReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_reason\"")
			}
		case "rule":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Rule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		case "tool":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Tool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool\"")
			}
		case "most_recent_instance":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.MostRecentInstance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"most_recent_instance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAlertItems")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeScanningAlertItems) {
					name = jsonFieldsNameOfCodeScanningAlertItems[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertLocation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Path.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.StartLine.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StartLine.Set {
			e.RawStr("\"start_line\"" + ":")
			s.StartLine.Encode(e)
		}
	}
	{
		if s.EndLine.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EndLine.Set {
			e.RawStr("\"end_line\"" + ":")
			s.EndLine.Encode(e)
		}
	}
	{
		if s.StartColumn.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StartColumn.Set {
			e.RawStr("\"start_column\"" + ":")
			s.StartColumn.Encode(e)
		}
	}
	{
		if s.EndColumn.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EndColumn.Set {
			e.RawStr("\"end_column\"" + ":")
			s.EndColumn.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeScanningAlertLocation = [5]string{
	0: "path",
	1: "start_line",
	2: "end_line",
	3: "start_column",
	4: "end_column",
}

// Decode decodes CodeScanningAlertLocation from json.
func (s *CodeScanningAlertLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertLocation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "start_line":
			if err := func() error {
				s.StartLine.Reset()
				if err := s.StartLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_line\"")
			}
		case "end_line":
			if err := func() error {
				s.EndLine.Reset()
				if err := s.EndLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_line\"")
			}
		case "start_column":
			if err := func() error {
				s.StartColumn.Reset()
				if err := s.StartColumn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_column\"")
			}
		case "end_column":
			if err := func() error {
				s.EndColumn.Reset()
				if err := s.EndColumn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_column\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAlertLocation")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertRule) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Severity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Severity.Set {
			e.RawStr("\"severity\"" + ":")
			s.Severity.Encode(e)
		}
	}
	{
		if s.SecuritySeverityLevel.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecuritySeverityLevel.Set {
			e.RawStr("\"security_severity_level\"" + ":")
			s.SecuritySeverityLevel.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.FullDescription.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FullDescription.Set {
			e.RawStr("\"full_description\"" + ":")
			s.FullDescription.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Tags.Set {
			e.RawStr("\"tags\"" + ":")
			s.Tags.Encode(e)
		}
	}
	{
		if s.Help.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Help.Set {
			e.RawStr("\"help\"" + ":")
			s.Help.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeScanningAlertRule = [8]string{
	0: "id",
	1: "name",
	2: "severity",
	3: "security_severity_level",
	4: "description",
	5: "full_description",
	6: "tags",
	7: "help",
}

// Decode decodes CodeScanningAlertRule from json.
func (s *CodeScanningAlertRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertRule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "security_severity_level":
			if err := func() error {
				s.SecuritySeverityLevel.Reset()
				if err := s.SecuritySeverityLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_severity_level\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "full_description":
			if err := func() error {
				s.FullDescription.Reset()
				if err := s.FullDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_description\"")
			}
		case "tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "help":
			if err := func() error {
				s.Help.Reset()
				if err := s.Help.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"help\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAlertRule")
	}

	return nil
}

// Encode encodes CodeScanningAlertRuleSecuritySeverityLevel as json.
func (s CodeScanningAlertRuleSecuritySeverityLevel) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertRuleSecuritySeverityLevel from json.
func (s *CodeScanningAlertRuleSecuritySeverityLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertRuleSecuritySeverityLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertRuleSecuritySeverityLevel(v) {
	case CodeScanningAlertRuleSecuritySeverityLevelLow:
		*s = CodeScanningAlertRuleSecuritySeverityLevelLow
	case CodeScanningAlertRuleSecuritySeverityLevelMedium:
		*s = CodeScanningAlertRuleSecuritySeverityLevelMedium
	case CodeScanningAlertRuleSecuritySeverityLevelHigh:
		*s = CodeScanningAlertRuleSecuritySeverityLevelHigh
	case CodeScanningAlertRuleSecuritySeverityLevelCritical:
		*s = CodeScanningAlertRuleSecuritySeverityLevelCritical
	default:
		*s = CodeScanningAlertRuleSecuritySeverityLevel(v)
	}

	return nil
}

// Encode encodes CodeScanningAlertRuleSeverity as json.
func (s CodeScanningAlertRuleSeverity) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertRuleSeverity from json.
func (s *CodeScanningAlertRuleSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertRuleSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertRuleSeverity(v) {
	case CodeScanningAlertRuleSeverityNone:
		*s = CodeScanningAlertRuleSeverityNone
	case CodeScanningAlertRuleSeverityNote:
		*s = CodeScanningAlertRuleSeverityNote
	case CodeScanningAlertRuleSeverityWarning:
		*s = CodeScanningAlertRuleSeverityWarning
	case CodeScanningAlertRuleSeverityError:
		*s = CodeScanningAlertRuleSeverityError
	default:
		*s = CodeScanningAlertRuleSeverity(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertRuleSummary) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Severity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Severity.Set {
			e.RawStr("\"severity\"" + ":")
			s.Severity.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeScanningAlertRuleSummary = [4]string{
	0: "id",
	1: "name",
	2: "severity",
	3: "description",
}

// Decode decodes CodeScanningAlertRuleSummary from json.
func (s *CodeScanningAlertRuleSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertRuleSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAlertRuleSummary")
	}

	return nil
}

// Encode encodes CodeScanningAlertRuleSummarySeverity as json.
func (s CodeScanningAlertRuleSummarySeverity) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertRuleSummarySeverity from json.
func (s *CodeScanningAlertRuleSummarySeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertRuleSummarySeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertRuleSummarySeverity(v) {
	case CodeScanningAlertRuleSummarySeverityNone:
		*s = CodeScanningAlertRuleSummarySeverityNone
	case CodeScanningAlertRuleSummarySeverityNote:
		*s = CodeScanningAlertRuleSummarySeverityNote
	case CodeScanningAlertRuleSummarySeverityWarning:
		*s = CodeScanningAlertRuleSummarySeverityWarning
	case CodeScanningAlertRuleSummarySeverityError:
		*s = CodeScanningAlertRuleSummarySeverityError
	default:
		*s = CodeScanningAlertRuleSummarySeverity(v)
	}

	return nil
}

// Encode encodes CodeScanningAlertSetState as json.
func (s CodeScanningAlertSetState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertSetState from json.
func (s *CodeScanningAlertSetState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertSetState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertSetState(v) {
	case CodeScanningAlertSetStateOpen:
		*s = CodeScanningAlertSetStateOpen
	case CodeScanningAlertSetStateDismissed:
		*s = CodeScanningAlertSetStateDismissed
	default:
		*s = CodeScanningAlertSetState(v)
	}

	return nil
}

// Encode encodes CodeScanningAlertState as json.
func (s CodeScanningAlertState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertState from json.
func (s *CodeScanningAlertState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAlertState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningAlertState(v) {
	case CodeScanningAlertStateOpen:
		*s = CodeScanningAlertStateOpen
	case CodeScanningAlertStateClosed:
		*s = CodeScanningAlertStateClosed
	case CodeScanningAlertStateDismissed:
		*s = CodeScanningAlertStateDismissed
	case CodeScanningAlertStateFixed:
		*s = CodeScanningAlertStateFixed
	default:
		*s = CodeScanningAlertState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAnalysis) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ref\"" + ":")
		s.Ref.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commit_sha\"" + ":")
		s.CommitSha.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"analysis_key\"" + ":")
		s.AnalysisKey.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"environment\"" + ":")
		s.Environment.Encode(e)
	}
	{
		if s.Category.Set {
			e.Comma()
		}
		if s.Category.Set {
			e.RawStr("\"category\"" + ":")
			s.Category.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"error\"" + ":")
		e.Str(s.Error)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"results_count\"" + ":")
		e.Int(s.ResultsCount)
	}
	{
		e.Comma()

		e.RawStr("\"rules_count\"" + ":")
		e.Int(s.RulesCount)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sarif_id\"" + ":")
		s.SarifID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"tool\"" + ":")
		s.Tool.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"deletable\"" + ":")
		e.Bool(s.Deletable)
	}
	{
		e.Comma()

		e.RawStr("\"warning\"" + ":")
		e.Str(s.Warning)
	}
	{
		if s.ToolName.Set {
			e.Comma()
		}
		if s.ToolName.Set {
			e.RawStr("\"tool_name\"" + ":")
			s.ToolName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeScanningAnalysis = [16]string{
	0:  "ref",
	1:  "commit_sha",
	2:  "analysis_key",
	3:  "environment",
	4:  "category",
	5:  "error",
	6:  "created_at",
	7:  "results_count",
	8:  "rules_count",
	9:  "id",
	10: "url",
	11: "sarif_id",
	12: "tool",
	13: "deletable",
	14: "warning",
	15: "tool_name",
}

// Decode decodes CodeScanningAnalysis from json.
func (s *CodeScanningAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysis to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				{
					var unwrapped string
					v, err := d.Str()
					unwrapped = string(v)
					if err != nil {
						return err
					}
					s.Ref = CodeScanningRef(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "commit_sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				{
					var unwrapped string
					v, err := d.Str()
					unwrapped = string(v)
					if err != nil {
						return err
					}
					s.CommitSha = CodeScanningAnalysisCommitSha(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_sha\"")
			}
		case "analysis_key":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				{
					var unwrapped string
					v, err := d.Str()
					unwrapped = string(v)
					if err != nil {
						return err
					}
					s.AnalysisKey = CodeScanningAnalysisAnalysisKey(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analysis_key\"")
			}
		case "environment":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				{
					var unwrapped string
					v, err := d.Str()
					unwrapped = string(v)
					if err != nil {
						return err
					}
					s.Environment = CodeScanningAnalysisEnvironment(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "error":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Error = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				{
					var unwrapped time.Time
					v, err := json.DecodeDateTime(d)
					unwrapped = v
					if err != nil {
						return err
					}
					s.CreatedAt = CodeScanningAnalysisCreatedAt(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "results_count":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ResultsCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results_count\"")
			}
		case "rules_count":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.RulesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules_count\"")
			}
		case "id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				{
					var unwrapped url.URL
					v, err := json.DecodeURI(d)
					unwrapped = v
					if err != nil {
						return err
					}
					s.URL = CodeScanningAnalysisURL(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "sarif_id":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				{
					var unwrapped string
					v, err := d.Str()
					unwrapped = string(v)
					if err != nil {
						return err
					}
					s.SarifID = CodeScanningAnalysisSarifID(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sarif_id\"")
			}
		case "tool":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Tool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool\"")
			}
		case "deletable":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Deletable = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletable\"")
			}
		case "warning":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Warning = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warning\"")
			}
		case "tool_name":
			if err := func() error {
				s.ToolName.Reset()
				if err := s.ToolName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAnalysis")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeScanningAnalysis) {
					name = jsonFieldsNameOfCodeScanningAnalysis[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes CodeScanningAnalysisAnalysisKey as json.
func (s CodeScanningAnalysisAnalysisKey) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisAnalysisKey from json.
func (s *CodeScanningAnalysisAnalysisKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisAnalysisKey to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisAnalysisKey(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisCategory as json.
func (s CodeScanningAnalysisCategory) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisCategory from json.
func (s *CodeScanningAnalysisCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisCategory to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisCategory(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisCommitSha as json.
func (s CodeScanningAnalysisCommitSha) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisCommitSha from json.
func (s *CodeScanningAnalysisCommitSha) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisCommitSha to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisCommitSha(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisCreatedAt as json.
func (s CodeScanningAnalysisCreatedAt) Encode(e *jx.Writer) {
	unwrapped := time.Time(s)
	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes CodeScanningAnalysisCreatedAt from json.
func (s *CodeScanningAnalysisCreatedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisCreatedAt to nil")
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisCreatedAt(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAnalysisDeletion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"next_analysis_url\"" + ":")
		s.NextAnalysisURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"confirm_delete_url\"" + ":")
		s.ConfirmDeleteURL.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeScanningAnalysisDeletion = [2]string{
	0: "next_analysis_url",
	1: "confirm_delete_url",
}

// Decode decodes CodeScanningAnalysisDeletion from json.
func (s *CodeScanningAnalysisDeletion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisDeletion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "next_analysis_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.NextAnalysisURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_analysis_url\"")
			}
		case "confirm_delete_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfirmDeleteURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confirm_delete_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAnalysisDeletion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeScanningAnalysisDeletion) {
					name = jsonFieldsNameOfCodeScanningAnalysisDeletion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes CodeScanningAnalysisEnvironment as json.
func (s CodeScanningAnalysisEnvironment) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisEnvironment from json.
func (s *CodeScanningAnalysisEnvironment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisEnvironment to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisEnvironment(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisSarifFile as json.
func (s CodeScanningAnalysisSarifFile) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisSarifFile from json.
func (s *CodeScanningAnalysisSarifFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisSarifFile to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisSarifFile(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisSarifID as json.
func (s CodeScanningAnalysisSarifID) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisSarifID from json.
func (s *CodeScanningAnalysisSarifID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisSarifID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisSarifID(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAnalysisTool) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Version.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Version.Set {
			e.RawStr("\"version\"" + ":")
			s.Version.Encode(e)
		}
	}
	{
		if s.GUID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GUID.Set {
			e.RawStr("\"guid\"" + ":")
			s.GUID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeScanningAnalysisTool = [3]string{
	0: "name",
	1: "version",
	2: "guid",
}

// Decode decodes CodeScanningAnalysisTool from json.
func (s *CodeScanningAnalysisTool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisTool to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "guid":
			if err := func() error {
				s.GUID.Reset()
				if err := s.GUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningAnalysisTool")
	}

	return nil
}

// Encode encodes CodeScanningAnalysisToolGUID as json.
func (s CodeScanningAnalysisToolGUID) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisToolGUID from json.
func (s *CodeScanningAnalysisToolGUID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisToolGUID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisToolGUID(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisToolName as json.
func (s CodeScanningAnalysisToolName) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisToolName from json.
func (s *CodeScanningAnalysisToolName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisToolName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisToolName(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisToolVersion as json.
func (s CodeScanningAnalysisToolVersion) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisToolVersion from json.
func (s *CodeScanningAnalysisToolVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisToolVersion to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisToolVersion(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisURL as json.
func (s CodeScanningAnalysisURL) Encode(e *jx.Writer) {
	unwrapped := url.URL(s)
	json.EncodeURI(e, unwrapped)
}

// Decode decodes CodeScanningAnalysisURL from json.
func (s *CodeScanningAnalysisURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningAnalysisURL to nil")
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisURL(unwrapped)
	return nil
}

// Encode encodes CodeScanningDeleteAnalysisApplicationJSONBadRequest as json.
func (s CodeScanningDeleteAnalysisApplicationJSONBadRequest) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningDeleteAnalysisApplicationJSONBadRequest from json.
func (s *CodeScanningDeleteAnalysisApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningDeleteAnalysisApplicationJSONBadRequest to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningDeleteAnalysisApplicationJSONBadRequest(unwrapped)
	return nil
}

// Encode encodes CodeScanningDeleteAnalysisApplicationJSONForbidden as json.
func (s CodeScanningDeleteAnalysisApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningDeleteAnalysisApplicationJSONForbidden from json.
func (s *CodeScanningDeleteAnalysisApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningDeleteAnalysisApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningDeleteAnalysisApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningDeleteAnalysisApplicationJSONNotFound as json.
func (s CodeScanningDeleteAnalysisApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningDeleteAnalysisApplicationJSONNotFound from json.
func (s *CodeScanningDeleteAnalysisApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningDeleteAnalysisApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningDeleteAnalysisApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningGetAlertApplicationJSONForbidden as json.
func (s CodeScanningGetAlertApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAlertApplicationJSONForbidden from json.
func (s *CodeScanningGetAlertApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningGetAlertApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAlertApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningGetAlertApplicationJSONNotFound as json.
func (s CodeScanningGetAlertApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAlertApplicationJSONNotFound from json.
func (s *CodeScanningGetAlertApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningGetAlertApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAlertApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningGetAnalysisApplicationJSONForbidden as json.
func (s CodeScanningGetAnalysisApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAnalysisApplicationJSONForbidden from json.
func (s *CodeScanningGetAnalysisApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningGetAnalysisApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAnalysisApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningGetAnalysisApplicationJSONNotFound as json.
func (s CodeScanningGetAnalysisApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAnalysisApplicationJSONNotFound from json.
func (s *CodeScanningGetAnalysisApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningGetAnalysisApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAnalysisApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertInstancesApplicationJSONForbidden as json.
func (s CodeScanningListAlertInstancesApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertInstancesApplicationJSONForbidden from json.
func (s *CodeScanningListAlertInstancesApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListAlertInstancesApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertInstancesApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertInstancesApplicationJSONNotFound as json.
func (s CodeScanningListAlertInstancesApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertInstancesApplicationJSONNotFound from json.
func (s *CodeScanningListAlertInstancesApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListAlertInstancesApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertInstancesApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertInstancesOKApplicationJSON as json.
func (s CodeScanningListAlertInstancesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CodeScanningAlertInstance(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes CodeScanningListAlertInstancesOKApplicationJSON from json.
func (s *CodeScanningListAlertInstancesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListAlertInstancesOKApplicationJSON to nil")
	}
	var unwrapped []CodeScanningAlertInstance
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeScanningAlertInstance
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertInstancesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertsForRepoApplicationJSONForbidden as json.
func (s CodeScanningListAlertsForRepoApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertsForRepoApplicationJSONForbidden from json.
func (s *CodeScanningListAlertsForRepoApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListAlertsForRepoApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertsForRepoApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertsForRepoApplicationJSONNotFound as json.
func (s CodeScanningListAlertsForRepoApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertsForRepoApplicationJSONNotFound from json.
func (s *CodeScanningListAlertsForRepoApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListAlertsForRepoApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertsForRepoApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertsForRepoOKApplicationJSON as json.
func (s CodeScanningListAlertsForRepoOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CodeScanningAlertItems(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes CodeScanningListAlertsForRepoOKApplicationJSON from json.
func (s *CodeScanningListAlertsForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListAlertsForRepoOKApplicationJSON to nil")
	}
	var unwrapped []CodeScanningAlertItems
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeScanningAlertItems
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertsForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes CodeScanningListRecentAnalysesApplicationJSONForbidden as json.
func (s CodeScanningListRecentAnalysesApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListRecentAnalysesApplicationJSONForbidden from json.
func (s *CodeScanningListRecentAnalysesApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListRecentAnalysesApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListRecentAnalysesApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningListRecentAnalysesApplicationJSONNotFound as json.
func (s CodeScanningListRecentAnalysesApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListRecentAnalysesApplicationJSONNotFound from json.
func (s *CodeScanningListRecentAnalysesApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListRecentAnalysesApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListRecentAnalysesApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningListRecentAnalysesOKApplicationJSON as json.
func (s CodeScanningListRecentAnalysesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CodeScanningAnalysis(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes CodeScanningListRecentAnalysesOKApplicationJSON from json.
func (s *CodeScanningListRecentAnalysesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningListRecentAnalysesOKApplicationJSON to nil")
	}
	var unwrapped []CodeScanningAnalysis
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeScanningAnalysis
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListRecentAnalysesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes CodeScanningRef as json.
func (s CodeScanningRef) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningRef from json.
func (s *CodeScanningRef) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningRef to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningRef(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningSarifsReceipt) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeScanningSarifsReceipt = [2]string{
	0: "id",
	1: "url",
}

// Decode decodes CodeScanningSarifsReceipt from json.
func (s *CodeScanningSarifsReceipt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningSarifsReceipt to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningSarifsReceipt")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningSarifsStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ProcessingStatus.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ProcessingStatus.Set {
			e.RawStr("\"processing_status\"" + ":")
			s.ProcessingStatus.Encode(e)
		}
	}
	{
		if s.AnalysesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AnalysesURL.Set {
			e.RawStr("\"analyses_url\"" + ":")
			s.AnalysesURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeScanningSarifsStatus = [2]string{
	0: "processing_status",
	1: "analyses_url",
}

// Decode decodes CodeScanningSarifsStatus from json.
func (s *CodeScanningSarifsStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningSarifsStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "processing_status":
			if err := func() error {
				s.ProcessingStatus.Reset()
				if err := s.ProcessingStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing_status\"")
			}
		case "analyses_url":
			if err := func() error {
				s.AnalysesURL.Reset()
				if err := s.AnalysesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analyses_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningSarifsStatus")
	}

	return nil
}

// Encode encodes CodeScanningSarifsStatusProcessingStatus as json.
func (s CodeScanningSarifsStatusProcessingStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CodeScanningSarifsStatusProcessingStatus from json.
func (s *CodeScanningSarifsStatusProcessingStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningSarifsStatusProcessingStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CodeScanningSarifsStatusProcessingStatus(v) {
	case CodeScanningSarifsStatusProcessingStatusPending:
		*s = CodeScanningSarifsStatusProcessingStatusPending
	case CodeScanningSarifsStatusProcessingStatusComplete:
		*s = CodeScanningSarifsStatusProcessingStatusComplete
	default:
		*s = CodeScanningSarifsStatusProcessingStatus(v)
	}

	return nil
}

// Encode encodes CodeScanningUpdateAlertApplicationJSONForbidden as json.
func (s CodeScanningUpdateAlertApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUpdateAlertApplicationJSONForbidden from json.
func (s *CodeScanningUpdateAlertApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningUpdateAlertApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUpdateAlertApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningUpdateAlertApplicationJSONNotFound as json.
func (s CodeScanningUpdateAlertApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUpdateAlertApplicationJSONNotFound from json.
func (s *CodeScanningUpdateAlertApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningUpdateAlertApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUpdateAlertApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningUpdateAlertReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		if s.DismissedReason.Set {
			e.Comma()
		}
		if s.DismissedReason.Set {
			e.RawStr("\"dismissed_reason\"" + ":")
			s.DismissedReason.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeScanningUpdateAlertReq = [2]string{
	0: "state",
	1: "dismissed_reason",
}

// Decode decodes CodeScanningUpdateAlertReq from json.
func (s *CodeScanningUpdateAlertReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningUpdateAlertReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "dismissed_reason":
			if err := func() error {
				s.DismissedReason.Reset()
				if err := s.DismissedReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningUpdateAlertReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeScanningUpdateAlertReq) {
					name = jsonFieldsNameOfCodeScanningUpdateAlertReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes CodeScanningUploadSarifApplicationJSONForbidden as json.
func (s CodeScanningUploadSarifApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUploadSarifApplicationJSONForbidden from json.
func (s *CodeScanningUploadSarifApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningUploadSarifApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUploadSarifApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningUploadSarifApplicationJSONNotFound as json.
func (s CodeScanningUploadSarifApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUploadSarifApplicationJSONNotFound from json.
func (s *CodeScanningUploadSarifApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningUploadSarifApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUploadSarifApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningUploadSarifReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"commit_sha\"" + ":")
		s.CommitSha.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"ref\"" + ":")
		s.Ref.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sarif\"" + ":")
		s.Sarif.Encode(e)
	}
	{
		if s.CheckoutURI.Set {
			e.Comma()
		}
		if s.CheckoutURI.Set {
			e.RawStr("\"checkout_uri\"" + ":")
			s.CheckoutURI.Encode(e)
		}
	}
	{
		if s.StartedAt.Set {
			e.Comma()
		}
		if s.StartedAt.Set {
			e.RawStr("\"started_at\"" + ":")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ToolName.Set {
			e.Comma()
		}
		if s.ToolName.Set {
			e.RawStr("\"tool_name\"" + ":")
			s.ToolName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeScanningUploadSarifReq = [6]string{
	0: "commit_sha",
	1: "ref",
	2: "sarif",
	3: "checkout_uri",
	4: "started_at",
	5: "tool_name",
}

// Decode decodes CodeScanningUploadSarifReq from json.
func (s *CodeScanningUploadSarifReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeScanningUploadSarifReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commit_sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				{
					var unwrapped string
					v, err := d.Str()
					unwrapped = string(v)
					if err != nil {
						return err
					}
					s.CommitSha = CodeScanningAnalysisCommitSha(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_sha\"")
			}
		case "ref":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				{
					var unwrapped string
					v, err := d.Str()
					unwrapped = string(v)
					if err != nil {
						return err
					}
					s.Ref = CodeScanningRef(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "sarif":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				{
					var unwrapped string
					v, err := d.Str()
					unwrapped = string(v)
					if err != nil {
						return err
					}
					s.Sarif = CodeScanningAnalysisSarifFile(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sarif\"")
			}
		case "checkout_uri":
			if err := func() error {
				s.CheckoutURI.Reset()
				if err := s.CheckoutURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkout_uri\"")
			}
		case "started_at":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "tool_name":
			if err := func() error {
				s.ToolName.Reset()
				if err := s.ToolName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeScanningUploadSarifReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeScanningUploadSarifReq) {
					name = jsonFieldsNameOfCodeScanningUploadSarifReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CodeSearchResultItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		json.EncodeURI(e, s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Float64(s.Score)
	}
	{
		if s.FileSize.Set {
			e.Comma()
		}
		if s.FileSize.Set {
			e.RawStr("\"file_size\"" + ":")
			s.FileSize.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.Comma()
		}
		if s.Language.Set {
			e.RawStr("\"language\"" + ":")
			s.Language.Encode(e)
		}
	}
	{
		if s.LastModifiedAt.Set {
			e.Comma()
		}
		if s.LastModifiedAt.Set {
			e.RawStr("\"last_modified_at\"" + ":")
			s.LastModifiedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LineNumbers != nil {
			e.Comma()
		}
		if s.LineNumbers != nil {
			e.RawStr("\"line_numbers\"" + ":")
			e.ArrStart()
			if len(s.LineNumbers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.LineNumbers[0]
					e.Str(elem)
				}
				for _, elem := range s.LineNumbers[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.TextMatches != nil {
			e.Comma()
		}
		if s.TextMatches != nil {
			e.RawStr("\"text_matches\"" + ":")
			s.TextMatches.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCodeSearchResultItem = [13]string{
	0:  "name",
	1:  "path",
	2:  "sha",
	3:  "url",
	4:  "git_url",
	5:  "html_url",
	6:  "repository",
	7:  "score",
	8:  "file_size",
	9:  "language",
	10: "last_modified_at",
	11: "line_numbers",
	12: "text_matches",
}

// Decode decodes CodeSearchResultItem from json.
func (s *CodeSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodeSearchResultItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "git_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.GitURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "repository":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "score":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float64()
				s.Score = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "file_size":
			if err := func() error {
				s.FileSize.Reset()
				if err := s.FileSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "last_modified_at":
			if err := func() error {
				s.LastModifiedAt.Reset()
				if err := s.LastModifiedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_modified_at\"")
			}
		case "line_numbers":
			if err := func() error {
				s.LineNumbers = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.LineNumbers = append(s.LineNumbers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"line_numbers\"")
			}
		case "text_matches":
			if err := func() error {
				s.TextMatches = nil
				var elem SearchResultTextMatches
				{
					var unwrapped []SearchResultTextMatchesItem
					unwrapped = nil
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem SearchResultTextMatchesItem
						if err := elem.Decode(d); err != nil {
							return err
						}
						unwrapped = append(unwrapped, elem)
						return nil
					}); err != nil {
						return err
					}
					elem = SearchResultTextMatches(unwrapped)
				}
				s.TextMatches = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_matches\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CodeSearchResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCodeSearchResultItem) {
					name = jsonFieldsNameOfCodeSearchResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes CodesOfConductGetAllCodesOfConductOKApplicationJSON as json.
func (s CodesOfConductGetAllCodesOfConductOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CodeOfConduct(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes CodesOfConductGetAllCodesOfConductOKApplicationJSON from json.
func (s *CodesOfConductGetAllCodesOfConductOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CodesOfConductGetAllCodesOfConductOKApplicationJSON to nil")
	}
	var unwrapped []CodeOfConduct
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeOfConduct
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodesOfConductGetAllCodesOfConductOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s Collaborator) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		if s.Email.Set {
			e.Comma()
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCollaborator = [21]string{
	0:  "login",
	1:  "id",
	2:  "email",
	3:  "name",
	4:  "node_id",
	5:  "avatar_url",
	6:  "gravatar_id",
	7:  "url",
	8:  "html_url",
	9:  "followers_url",
	10: "following_url",
	11: "gists_url",
	12: "starred_url",
	13: "subscriptions_url",
	14: "organizations_url",
	15: "repos_url",
	16: "events_url",
	17: "received_events_url",
	18: "type",
	19: "site_admin",
	20: "permissions",
}

// Decode decodes Collaborator from json.
func (s *Collaborator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Collaborator to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Collaborator")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11110011,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCollaborator) {
					name = jsonFieldsNameOfCollaborator[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CollaboratorPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCollaboratorPermissions = [5]string{
	0: "pull",
	1: "triage",
	2: "push",
	3: "maintain",
	4: "admin",
}

// Decode decodes CollaboratorPermissions from json.
func (s *CollaboratorPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CollaboratorPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pull":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "admin":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CollaboratorPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCollaboratorPermissions) {
					name = jsonFieldsNameOfCollaboratorPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CombinedBillingUsage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"days_left_in_billing_cycle\"" + ":")
		e.Int(s.DaysLeftInBillingCycle)
	}
	{
		e.Comma()

		e.RawStr("\"estimated_paid_storage_for_month\"" + ":")
		e.Int(s.EstimatedPaidStorageForMonth)
	}
	{
		e.Comma()

		e.RawStr("\"estimated_storage_for_month\"" + ":")
		e.Int(s.EstimatedStorageForMonth)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCombinedBillingUsage = [3]string{
	0: "days_left_in_billing_cycle",
	1: "estimated_paid_storage_for_month",
	2: "estimated_storage_for_month",
}

// Decode decodes CombinedBillingUsage from json.
func (s *CombinedBillingUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombinedBillingUsage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "days_left_in_billing_cycle":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DaysLeftInBillingCycle = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"days_left_in_billing_cycle\"")
			}
		case "estimated_paid_storage_for_month":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.EstimatedPaidStorageForMonth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"estimated_paid_storage_for_month\"")
			}
		case "estimated_storage_for_month":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.EstimatedStorageForMonth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"estimated_storage_for_month\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombinedBillingUsage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombinedBillingUsage) {
					name = jsonFieldsNameOfCombinedBillingUsage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CombinedCommitStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"statuses\"" + ":")
		e.ArrStart()
		if len(s.Statuses) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Statuses[0]
				elem.Encode(e)
			}
			for _, elem := range s.Statuses[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commit_url\"" + ":")
		json.EncodeURI(e, s.CommitURL)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCombinedCommitStatus = [7]string{
	0: "state",
	1: "statuses",
	2: "sha",
	3: "total_count",
	4: "repository",
	5: "commit_url",
	6: "url",
}

// Decode decodes CombinedCommitStatus from json.
func (s *CombinedCommitStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CombinedCommitStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "statuses":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Statuses = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleCommitStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Statuses = append(s.Statuses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "total_count":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "repository":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "commit_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommitURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_url\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CombinedCommitStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCombinedCommitStatus) {
					name = jsonFieldsNameOfCombinedCommitStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Commit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		s.Commit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committer\"" + ":")
		s.Committer.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"parents\"" + ":")
		e.ArrStart()
		if len(s.Parents) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Parents[0]
				elem.Encode(e)
			}
			for _, elem := range s.Parents[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Stats.Set {
			e.Comma()
		}
		if s.Stats.Set {
			e.RawStr("\"stats\"" + ":")
			s.Stats.Encode(e)
		}
	}
	{
		if s.Files != nil {
			e.Comma()
		}
		if s.Files != nil {
			e.RawStr("\"files\"" + ":")
			e.ArrStart()
			if len(s.Files) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Files[0]
					elem.Encode(e)
				}
				for _, elem := range s.Files[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommit = [11]string{
	0:  "url",
	1:  "sha",
	2:  "node_id",
	3:  "html_url",
	4:  "comments_url",
	5:  "commit",
	6:  "author",
	7:  "committer",
	8:  "parents",
	9:  "stats",
	10: "files",
}

// Decode decodes Commit from json.
func (s *Commit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Commit to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "parents":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Parents = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CommitParentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parents = append(s.Parents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parents\"")
			}
		case "stats":
			if err := func() error {
				s.Stats.Reset()
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		case "files":
			if err := func() error {
				s.Files = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CommitFilesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Files = append(s.Files, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Commit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommit) {
					name = jsonFieldsNameOfCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommitActivity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"days\"" + ":")
		e.ArrStart()
		if len(s.Days) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Days[0]
				e.Int(elem)
			}
			for _, elem := range s.Days[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"total\"" + ":")
		e.Int(s.Total)
	}
	{
		e.Comma()

		e.RawStr("\"week\"" + ":")
		e.Int(s.Week)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommitActivity = [3]string{
	0: "days",
	1: "total",
	2: "week",
}

// Decode decodes CommitActivity from json.
func (s *CommitActivity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitActivity to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "days":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Days = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Days = append(s.Days, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"days\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "week":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Week = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"week\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitActivity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitActivity) {
					name = jsonFieldsNameOfCommitActivity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommitComment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		s.Path.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"position\"" + ":")
		s.Position.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"line\"" + ":")
		s.Line.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commit_id\"" + ":")
		e.Str(s.CommitID)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommitComment = [14]string{
	0:  "html_url",
	1:  "url",
	2:  "id",
	3:  "node_id",
	4:  "body",
	5:  "path",
	6:  "position",
	7:  "line",
	8:  "commit_id",
	9:  "user",
	10: "created_at",
	11: "updated_at",
	12: "author_association",
	13: "reactions",
}

// Decode decodes CommitComment from json.
func (s *CommitComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitComment to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "html_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "position":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "line":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Line.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"line\"")
			}
		case "commit_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CommitID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_id\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "author_association":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitComment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitComment) {
					name = jsonFieldsNameOfCommitComment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommitCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committer\"" + ":")
		s.Committer.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"comment_count\"" + ":")
		e.Int(s.CommentCount)
	}
	{
		e.Comma()

		e.RawStr("\"tree\"" + ":")
		s.Tree.Encode(e)
	}
	{
		if s.Verification.Set {
			e.Comma()
		}
		if s.Verification.Set {
			e.RawStr("\"verification\"" + ":")
			s.Verification.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommitCommit = [7]string{
	0: "url",
	1: "author",
	2: "committer",
	3: "message",
	4: "comment_count",
	5: "tree",
	6: "verification",
}

// Decode decodes CommitCommit from json.
func (s *CommitCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "comment_count":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CommentCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment_count\"")
			}
		case "tree":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Tree.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree\"")
			}
		case "verification":
			if err := func() error {
				s.Verification.Reset()
				if err := s.Verification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitCommit) {
					name = jsonFieldsNameOfCommitCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommitCommitTree) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommitCommitTree = [2]string{
	0: "sha",
	1: "url",
}

// Decode decodes CommitCommitTree from json.
func (s *CommitCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitCommitTree to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitCommitTree")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitCommitTree) {
					name = jsonFieldsNameOfCommitCommitTree[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommitComparison) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"permalink_url\"" + ":")
		json.EncodeURI(e, s.PermalinkURL)
	}
	{
		e.Comma()

		e.RawStr("\"diff_url\"" + ":")
		json.EncodeURI(e, s.DiffURL)
	}
	{
		e.Comma()

		e.RawStr("\"patch_url\"" + ":")
		json.EncodeURI(e, s.PatchURL)
	}
	{
		e.Comma()

		e.RawStr("\"base_commit\"" + ":")
		s.BaseCommit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"merge_base_commit\"" + ":")
		s.MergeBaseCommit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"ahead_by\"" + ":")
		e.Int(s.AheadBy)
	}
	{
		e.Comma()

		e.RawStr("\"behind_by\"" + ":")
		e.Int(s.BehindBy)
	}
	{
		e.Comma()

		e.RawStr("\"total_commits\"" + ":")
		e.Int(s.TotalCommits)
	}
	{
		e.Comma()

		e.RawStr("\"commits\"" + ":")
		e.ArrStart()
		if len(s.Commits) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Commits[0]
				elem.Encode(e)
			}
			for _, elem := range s.Commits[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Files != nil {
			e.Comma()
		}
		if s.Files != nil {
			e.RawStr("\"files\"" + ":")
			e.ArrStart()
			if len(s.Files) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Files[0]
					elem.Encode(e)
				}
				for _, elem := range s.Files[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommitComparison = [13]string{
	0:  "url",
	1:  "html_url",
	2:  "permalink_url",
	3:  "diff_url",
	4:  "patch_url",
	5:  "base_commit",
	6:  "merge_base_commit",
	7:  "status",
	8:  "ahead_by",
	9:  "behind_by",
	10: "total_commits",
	11: "commits",
	12: "files",
}

// Decode decodes CommitComparison from json.
func (s *CommitComparison) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitComparison to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "permalink_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PermalinkURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permalink_url\"")
			}
		case "diff_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DiffURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_url\"")
			}
		case "patch_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PatchURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch_url\"")
			}
		case "base_commit":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.BaseCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_commit\"")
			}
		case "merge_base_commit":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.MergeBaseCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_base_commit\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "ahead_by":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AheadBy = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ahead_by\"")
			}
		case "behind_by":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.BehindBy = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"behind_by\"")
			}
		case "total_commits":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.TotalCommits = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_commits\"")
			}
		case "commits":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.Commits = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Commit
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Commits = append(s.Commits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits\"")
			}
		case "files":
			if err := func() error {
				s.Files = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DiffEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Files = append(s.Files, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitComparison")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitComparison) {
					name = jsonFieldsNameOfCommitComparison[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes CommitComparisonStatus as json.
func (s CommitComparisonStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CommitComparisonStatus from json.
func (s *CommitComparisonStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitComparisonStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CommitComparisonStatus(v) {
	case CommitComparisonStatusDiverged:
		*s = CommitComparisonStatusDiverged
	case CommitComparisonStatusAhead:
		*s = CommitComparisonStatusAhead
	case CommitComparisonStatusBehind:
		*s = CommitComparisonStatusBehind
	case CommitComparisonStatusIdentical:
		*s = CommitComparisonStatusIdentical
	default:
		*s = CommitComparisonStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommitFilesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Filename.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Filename.Set {
			e.RawStr("\"filename\"" + ":")
			s.Filename.Encode(e)
		}
	}
	{
		if s.Additions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Additions.Set {
			e.RawStr("\"additions\"" + ":")
			s.Additions.Encode(e)
		}
	}
	{
		if s.Deletions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Deletions.Set {
			e.RawStr("\"deletions\"" + ":")
			s.Deletions.Encode(e)
		}
	}
	{
		if s.Changes.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Changes.Set {
			e.RawStr("\"changes\"" + ":")
			s.Changes.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	{
		if s.RawURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RawURL.Set {
			e.RawStr("\"raw_url\"" + ":")
			s.RawURL.Encode(e)
		}
	}
	{
		if s.BlobURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BlobURL.Set {
			e.RawStr("\"blob_url\"" + ":")
			s.BlobURL.Encode(e)
		}
	}
	{
		if s.Patch.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Patch.Set {
			e.RawStr("\"patch\"" + ":")
			s.Patch.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.ContentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentsURL.Set {
			e.RawStr("\"contents_url\"" + ":")
			s.ContentsURL.Encode(e)
		}
	}
	{
		if s.PreviousFilename.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PreviousFilename.Set {
			e.RawStr("\"previous_filename\"" + ":")
			s.PreviousFilename.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommitFilesItem = [11]string{
	0:  "filename",
	1:  "additions",
	2:  "deletions",
	3:  "changes",
	4:  "status",
	5:  "raw_url",
	6:  "blob_url",
	7:  "patch",
	8:  "sha",
	9:  "contents_url",
	10: "previous_filename",
}

// Decode decodes CommitFilesItem from json.
func (s *CommitFilesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitFilesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "filename":
			if err := func() error {
				s.Filename.Reset()
				if err := s.Filename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "additions":
			if err := func() error {
				s.Additions.Reset()
				if err := s.Additions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additions\"")
			}
		case "deletions":
			if err := func() error {
				s.Deletions.Reset()
				if err := s.Deletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletions\"")
			}
		case "changes":
			if err := func() error {
				s.Changes.Reset()
				if err := s.Changes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changes\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "raw_url":
			if err := func() error {
				s.RawURL.Reset()
				if err := s.RawURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_url\"")
			}
		case "blob_url":
			if err := func() error {
				s.BlobURL.Reset()
				if err := s.BlobURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blob_url\"")
			}
		case "patch":
			if err := func() error {
				s.Patch.Reset()
				if err := s.Patch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "contents_url":
			if err := func() error {
				s.ContentsURL.Reset()
				if err := s.ContentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "previous_filename":
			if err := func() error {
				s.PreviousFilename.Reset()
				if err := s.PreviousFilename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_filename\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitFilesItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommitParentsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.HTMLURL.Set {
			e.Comma()
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommitParentsItem = [3]string{
	0: "sha",
	1: "url",
	2: "html_url",
}

// Decode decodes CommitParentsItem from json.
func (s *CommitParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitParentsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitParentsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitParentsItem) {
					name = jsonFieldsNameOfCommitParentsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommitSearchResultItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		s.Commit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committer\"" + ":")
		s.Committer.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"parents\"" + ":")
		e.ArrStart()
		if len(s.Parents) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Parents[0]
				elem.Encode(e)
			}
			for _, elem := range s.Parents[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Float64(s.Score)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		if s.TextMatches != nil {
			e.Comma()
		}
		if s.TextMatches != nil {
			e.RawStr("\"text_matches\"" + ":")
			s.TextMatches.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommitSearchResultItem = [12]string{
	0:  "url",
	1:  "sha",
	2:  "html_url",
	3:  "comments_url",
	4:  "commit",
	5:  "author",
	6:  "committer",
	7:  "parents",
	8:  "repository",
	9:  "score",
	10: "node_id",
	11: "text_matches",
}

// Decode decodes CommitSearchResultItem from json.
func (s *CommitSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitSearchResultItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "parents":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.Parents = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CommitSearchResultItemParentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parents = append(s.Parents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parents\"")
			}
		case "repository":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "score":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Score = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "text_matches":
			if err := func() error {
				s.TextMatches = nil
				var elem SearchResultTextMatches
				{
					var unwrapped []SearchResultTextMatchesItem
					unwrapped = nil
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem SearchResultTextMatchesItem
						if err := elem.Decode(d); err != nil {
							return err
						}
						unwrapped = append(unwrapped, elem)
						return nil
					}); err != nil {
						return err
					}
					elem = SearchResultTextMatches(unwrapped)
				}
				s.TextMatches = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_matches\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitSearchResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitSearchResultItem) {
					name = jsonFieldsNameOfCommitSearchResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommitSearchResultItemCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committer\"" + ":")
		s.Committer.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comment_count\"" + ":")
		e.Int(s.CommentCount)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"tree\"" + ":")
		s.Tree.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Verification.Set {
			e.Comma()
		}
		if s.Verification.Set {
			e.RawStr("\"verification\"" + ":")
			s.Verification.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommitSearchResultItemCommit = [7]string{
	0: "author",
	1: "committer",
	2: "comment_count",
	3: "message",
	4: "tree",
	5: "url",
	6: "verification",
}

// Decode decodes CommitSearchResultItemCommit from json.
func (s *CommitSearchResultItemCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitSearchResultItemCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "comment_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CommentCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment_count\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "tree":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Tree.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "verification":
			if err := func() error {
				s.Verification.Reset()
				if err := s.Verification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitSearchResultItemCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitSearchResultItemCommit) {
					name = jsonFieldsNameOfCommitSearchResultItemCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommitSearchResultItemCommitAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		e.Comma()

		e.RawStr("\"date\"" + ":")
		json.EncodeDateTime(e, s.Date)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommitSearchResultItemCommitAuthor = [3]string{
	0: "name",
	1: "email",
	2: "date",
}

// Decode decodes CommitSearchResultItemCommitAuthor from json.
func (s *CommitSearchResultItemCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitSearchResultItemCommitAuthor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Date = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitSearchResultItemCommitAuthor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitSearchResultItemCommitAuthor) {
					name = jsonFieldsNameOfCommitSearchResultItemCommitAuthor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommitSearchResultItemCommitTree) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommitSearchResultItemCommitTree = [2]string{
	0: "sha",
	1: "url",
}

// Decode decodes CommitSearchResultItemCommitTree from json.
func (s *CommitSearchResultItemCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitSearchResultItemCommitTree to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitSearchResultItemCommitTree")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommitSearchResultItemCommitTree) {
					name = jsonFieldsNameOfCommitSearchResultItemCommitTree[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommitSearchResultItemParentsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommitSearchResultItemParentsItem = [3]string{
	0: "url",
	1: "html_url",
	2: "sha",
}

// Decode decodes CommitSearchResultItemParentsItem from json.
func (s *CommitSearchResultItemParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitSearchResultItemParentsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitSearchResultItemParentsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommitStats) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Additions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Additions.Set {
			e.RawStr("\"additions\"" + ":")
			s.Additions.Encode(e)
		}
	}
	{
		if s.Deletions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Deletions.Set {
			e.RawStr("\"deletions\"" + ":")
			s.Deletions.Encode(e)
		}
	}
	{
		if s.Total.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Total.Set {
			e.RawStr("\"total\"" + ":")
			s.Total.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommitStats = [3]string{
	0: "additions",
	1: "deletions",
	2: "total",
}

// Decode decodes CommitStats from json.
func (s *CommitStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommitStats to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "additions":
			if err := func() error {
				s.Additions.Reset()
				if err := s.Additions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additions\"")
			}
		case "deletions":
			if err := func() error {
				s.Deletions.Reset()
				if err := s.Deletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletions\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommitStats")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommunityProfile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"health_percentage\"" + ":")
		e.Int(s.HealthPercentage)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"documentation\"" + ":")
		s.Documentation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"files\"" + ":")
		s.Files.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.ContentReportsEnabled.Set {
			e.Comma()
		}
		if s.ContentReportsEnabled.Set {
			e.RawStr("\"content_reports_enabled\"" + ":")
			s.ContentReportsEnabled.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommunityProfile = [6]string{
	0: "health_percentage",
	1: "description",
	2: "documentation",
	3: "files",
	4: "updated_at",
	5: "content_reports_enabled",
}

// Decode decodes CommunityProfile from json.
func (s *CommunityProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommunityProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "health_percentage":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.HealthPercentage = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health_percentage\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "documentation":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Documentation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation\"")
			}
		case "files":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Files.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "content_reports_enabled":
			if err := func() error {
				s.ContentReportsEnabled.Reset()
				if err := s.ContentReportsEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_reports_enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommunityProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommunityProfile) {
					name = jsonFieldsNameOfCommunityProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CommunityProfileFiles) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code_of_conduct\"" + ":")
		s.CodeOfConduct.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"code_of_conduct_file\"" + ":")
		s.CodeOfConductFile.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"contributing\"" + ":")
		s.Contributing.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"readme\"" + ":")
		s.Readme.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"issue_template\"" + ":")
		s.IssueTemplate.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request_template\"" + ":")
		s.PullRequestTemplate.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCommunityProfileFiles = [7]string{
	0: "code_of_conduct",
	1: "code_of_conduct_file",
	2: "license",
	3: "contributing",
	4: "readme",
	5: "issue_template",
	6: "pull_request_template",
}

// Decode decodes CommunityProfileFiles from json.
func (s *CommunityProfileFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommunityProfileFiles to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code_of_conduct":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CodeOfConduct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_of_conduct\"")
			}
		case "code_of_conduct_file":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CodeOfConductFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_of_conduct_file\"")
			}
		case "license":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "contributing":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Contributing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributing\"")
			}
		case "readme":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Readme.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readme\"")
			}
		case "issue_template":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.IssueTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_template\"")
			}
		case "pull_request_template":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.PullRequestTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request_template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommunityProfileFiles")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommunityProfileFiles) {
					name = jsonFieldsNameOfCommunityProfileFiles[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ContentFile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"encoding\"" + ":")
		e.Str(s.Encoding)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"content\"" + ":")
		e.Str(s.Content)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		s.GitURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"download_url\"" + ":")
		s.DownloadURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		if s.Target.Set {
			e.Comma()
		}
		if s.Target.Set {
			e.RawStr("\"target\"" + ":")
			s.Target.Encode(e)
		}
	}
	{
		if s.SubmoduleGitURL.Set {
			e.Comma()
		}
		if s.SubmoduleGitURL.Set {
			e.RawStr("\"submodule_git_url\"" + ":")
			s.SubmoduleGitURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfContentFile = [14]string{
	0:  "type",
	1:  "encoding",
	2:  "size",
	3:  "name",
	4:  "path",
	5:  "content",
	6:  "sha",
	7:  "url",
	8:  "git_url",
	9:  "html_url",
	10: "download_url",
	11: "_links",
	12: "target",
	13: "submodule_git_url",
}

// Decode decodes ContentFile from json.
func (s *ContentFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentFile to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "encoding":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Encoding = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encoding\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "git_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.GitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "download_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.DownloadURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download_url\"")
			}
		case "_links":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "target":
			if err := func() error {
				s.Target.Reset()
				if err := s.Target.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "submodule_git_url":
			if err := func() error {
				s.SubmoduleGitURL.Reset()
				if err := s.SubmoduleGitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"submodule_git_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContentFile) {
					name = jsonFieldsNameOfContentFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ContentFileLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"git\"" + ":")
		s.Git.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html\"" + ":")
		s.HTML.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"self\"" + ":")
		json.EncodeURI(e, s.Self)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfContentFileLinks = [3]string{
	0: "git",
	1: "html",
	2: "self",
}

// Decode decodes ContentFileLinks from json.
func (s *ContentFileLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentFileLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "git":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Git.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git\"")
			}
		case "html":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "self":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.Self = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentFileLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContentFileLinks) {
					name = jsonFieldsNameOfContentFileLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ContentReferenceAttachment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		if s.NodeID.Set {
			e.Comma()
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfContentReferenceAttachment = [4]string{
	0: "id",
	1: "title",
	2: "body",
	3: "node_id",
}

// Decode decodes ContentReferenceAttachment from json.
func (s *ContentReferenceAttachment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentReferenceAttachment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentReferenceAttachment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContentReferenceAttachment) {
					name = jsonFieldsNameOfContentReferenceAttachment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ContentTraffic) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"count\"" + ":")
		e.Int(s.Count)
	}
	{
		e.Comma()

		e.RawStr("\"uniques\"" + ":")
		e.Int(s.Uniques)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfContentTraffic = [4]string{
	0: "path",
	1: "title",
	2: "count",
	3: "uniques",
}

// Decode decodes ContentTraffic from json.
func (s *ContentTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentTraffic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "uniques":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Uniques = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniques\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentTraffic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContentTraffic) {
					name = jsonFieldsNameOfContentTraffic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Contributor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Login.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Login.Set {
			e.RawStr("\"login\"" + ":")
			s.Login.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvatarURL.Set {
			e.RawStr("\"avatar_url\"" + ":")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.GravatarID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GravatarID.Set {
			e.RawStr("\"gravatar_id\"" + ":")
			s.GravatarID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.FollowersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowersURL.Set {
			e.RawStr("\"followers_url\"" + ":")
			s.FollowersURL.Encode(e)
		}
	}
	{
		if s.FollowingURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowingURL.Set {
			e.RawStr("\"following_url\"" + ":")
			s.FollowingURL.Encode(e)
		}
	}
	{
		if s.GistsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GistsURL.Set {
			e.RawStr("\"gists_url\"" + ":")
			s.GistsURL.Encode(e)
		}
	}
	{
		if s.StarredURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StarredURL.Set {
			e.RawStr("\"starred_url\"" + ":")
			s.StarredURL.Encode(e)
		}
	}
	{
		if s.SubscriptionsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscriptionsURL.Set {
			e.RawStr("\"subscriptions_url\"" + ":")
			s.SubscriptionsURL.Encode(e)
		}
	}
	{
		if s.OrganizationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationsURL.Set {
			e.RawStr("\"organizations_url\"" + ":")
			s.OrganizationsURL.Encode(e)
		}
	}
	{
		if s.ReposURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReposURL.Set {
			e.RawStr("\"repos_url\"" + ":")
			s.ReposURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsURL.Set {
			e.RawStr("\"events_url\"" + ":")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ReceivedEventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReceivedEventsURL.Set {
			e.RawStr("\"received_events_url\"" + ":")
			s.ReceivedEventsURL.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		if s.SiteAdmin.Set {
			e.Comma()
		}
		if s.SiteAdmin.Set {
			e.RawStr("\"site_admin\"" + ":")
			s.SiteAdmin.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"contributions\"" + ":")
		e.Int(s.Contributions)
	}
	{
		if s.Email.Set {
			e.Comma()
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfContributor = [21]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "avatar_url",
	4:  "gravatar_id",
	5:  "url",
	6:  "html_url",
	7:  "followers_url",
	8:  "following_url",
	9:  "gists_url",
	10: "starred_url",
	11: "subscriptions_url",
	12: "organizations_url",
	13: "repos_url",
	14: "events_url",
	15: "received_events_url",
	16: "type",
	17: "site_admin",
	18: "contributions",
	19: "email",
	20: "name",
}

// Decode decodes Contributor from json.
func (s *Contributor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Contributor to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			if err := func() error {
				s.Login.Reset()
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			if err := func() error {
				s.GravatarID.Reset()
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			if err := func() error {
				s.FollowersURL.Reset()
				if err := s.FollowersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			if err := func() error {
				s.FollowingURL.Reset()
				if err := s.FollowingURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			if err := func() error {
				s.GistsURL.Reset()
				if err := s.GistsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			if err := func() error {
				s.StarredURL.Reset()
				if err := s.StarredURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			if err := func() error {
				s.SubscriptionsURL.Reset()
				if err := s.SubscriptionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			if err := func() error {
				s.OrganizationsURL.Reset()
				if err := s.OrganizationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			if err := func() error {
				s.ReposURL.Reset()
				if err := s.ReposURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			if err := func() error {
				s.EventsURL.Reset()
				if err := s.EventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			if err := func() error {
				s.ReceivedEventsURL.Reset()
				if err := s.ReceivedEventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			if err := func() error {
				s.SiteAdmin.Reset()
				if err := s.SiteAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "contributions":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Contributions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributions\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Contributor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000000,
		0b00000000,
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContributor) {
					name = jsonFieldsNameOfContributor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ContributorActivity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"total\"" + ":")
		e.Int(s.Total)
	}
	{
		e.Comma()

		e.RawStr("\"weeks\"" + ":")
		e.ArrStart()
		if len(s.Weeks) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Weeks[0]
				elem.Encode(e)
			}
			for _, elem := range s.Weeks[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfContributorActivity = [3]string{
	0: "author",
	1: "total",
	2: "weeks",
}

// Decode decodes ContributorActivity from json.
func (s *ContributorActivity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContributorActivity to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "weeks":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Weeks = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ContributorActivityWeeksItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Weeks = append(s.Weeks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weeks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContributorActivity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContributorActivity) {
					name = jsonFieldsNameOfContributorActivity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ContributorActivityWeeksItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.W.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.W.Set {
			e.RawStr("\"w\"" + ":")
			s.W.Encode(e)
		}
	}
	{
		if s.A.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.A.Set {
			e.RawStr("\"a\"" + ":")
			s.A.Encode(e)
		}
	}
	{
		if s.D.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.D.Set {
			e.RawStr("\"d\"" + ":")
			s.D.Encode(e)
		}
	}
	{
		if s.C.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.C.Set {
			e.RawStr("\"c\"" + ":")
			s.C.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfContributorActivityWeeksItem = [4]string{
	0: "w",
	1: "a",
	2: "d",
	3: "c",
}

// Decode decodes ContributorActivityWeeksItem from json.
func (s *ContributorActivityWeeksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContributorActivityWeeksItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "w":
			if err := func() error {
				s.W.Reset()
				if err := s.W.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"w\"")
			}
		case "a":
			if err := func() error {
				s.A.Reset()
				if err := s.A.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"a\"")
			}
		case "d":
			if err := func() error {
				s.D.Reset()
				if err := s.D.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"d\"")
			}
		case "c":
			if err := func() error {
				s.C.Reset()
				if err := s.C.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"c\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContributorActivityWeeksItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CredentialAuthorization) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"credential_id\"" + ":")
		e.Int(s.CredentialID)
	}
	{
		e.Comma()

		e.RawStr("\"credential_type\"" + ":")
		e.Str(s.CredentialType)
	}
	{
		if s.TokenLastEight.Set {
			e.Comma()
		}
		if s.TokenLastEight.Set {
			e.RawStr("\"token_last_eight\"" + ":")
			s.TokenLastEight.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"credential_authorized_at\"" + ":")
		json.EncodeDateTime(e, s.CredentialAuthorizedAt)
	}
	{
		if s.Scopes != nil {
			e.Comma()
		}
		if s.Scopes != nil {
			e.RawStr("\"scopes\"" + ":")
			e.ArrStart()
			if len(s.Scopes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Scopes[0]
					e.Str(elem)
				}
				for _, elem := range s.Scopes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Fingerprint.Set {
			e.Comma()
		}
		if s.Fingerprint.Set {
			e.RawStr("\"fingerprint\"" + ":")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.CredentialAccessedAt.Set {
			e.Comma()
		}
		if s.CredentialAccessedAt.Set {
			e.RawStr("\"credential_accessed_at\"" + ":")
			s.CredentialAccessedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AuthorizedCredentialID.Set {
			e.Comma()
		}
		if s.AuthorizedCredentialID.Set {
			e.RawStr("\"authorized_credential_id\"" + ":")
			s.AuthorizedCredentialID.Encode(e)
		}
	}
	{
		if s.AuthorizedCredentialTitle.Set {
			e.Comma()
		}
		if s.AuthorizedCredentialTitle.Set {
			e.RawStr("\"authorized_credential_title\"" + ":")
			s.AuthorizedCredentialTitle.Encode(e)
		}
	}
	{
		if s.AuthorizedCredentialNote.Set {
			e.Comma()
		}
		if s.AuthorizedCredentialNote.Set {
			e.RawStr("\"authorized_credential_note\"" + ":")
			s.AuthorizedCredentialNote.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCredentialAuthorization = [11]string{
	0:  "login",
	1:  "credential_id",
	2:  "credential_type",
	3:  "token_last_eight",
	4:  "credential_authorized_at",
	5:  "scopes",
	6:  "fingerprint",
	7:  "credential_accessed_at",
	8:  "authorized_credential_id",
	9:  "authorized_credential_title",
	10: "authorized_credential_note",
}

// Decode decodes CredentialAuthorization from json.
func (s *CredentialAuthorization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CredentialAuthorization to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "credential_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CredentialID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credential_id\"")
			}
		case "credential_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CredentialType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credential_type\"")
			}
		case "token_last_eight":
			if err := func() error {
				s.TokenLastEight.Reset()
				if err := s.TokenLastEight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token_last_eight\"")
			}
		case "credential_authorized_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CredentialAuthorizedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credential_authorized_at\"")
			}
		case "scopes":
			if err := func() error {
				s.Scopes = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Scopes = append(s.Scopes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "credential_accessed_at":
			if err := func() error {
				s.CredentialAccessedAt.Reset()
				if err := s.CredentialAccessedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credential_accessed_at\"")
			}
		case "authorized_credential_id":
			if err := func() error {
				s.AuthorizedCredentialID.Reset()
				if err := s.AuthorizedCredentialID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorized_credential_id\"")
			}
		case "authorized_credential_title":
			if err := func() error {
				s.AuthorizedCredentialTitle.Reset()
				if err := s.AuthorizedCredentialTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorized_credential_title\"")
			}
		case "authorized_credential_note":
			if err := func() error {
				s.AuthorizedCredentialNote.Reset()
				if err := s.AuthorizedCredentialNote.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorized_credential_note\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CredentialAuthorization")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCredentialAuthorization) {
					name = jsonFieldsNameOfCredentialAuthorization[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s DeployKey) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"verified\"" + ":")
		e.Bool(s.Verified)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		e.Str(s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"read_only\"" + ":")
		e.Bool(s.ReadOnly)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDeployKey = [7]string{
	0: "id",
	1: "key",
	2: "url",
	3: "title",
	4: "verified",
	5: "created_at",
	6: "read_only",
}

// Decode decodes DeployKey from json.
func (s *DeployKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeployKey to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "verified":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Verified = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "read_only":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.ReadOnly = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"read_only\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeployKey")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeployKey) {
					name = jsonFieldsNameOfDeployKey[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Deployment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"task\"" + ":")
		e.Str(s.Task)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	{
		if s.OriginalEnvironment.Set {
			e.Comma()
		}
		if s.OriginalEnvironment.Set {
			e.RawStr("\"original_environment\"" + ":")
			s.OriginalEnvironment.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"environment\"" + ":")
		e.Str(s.Environment)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		json.EncodeURI(e, s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		if s.TransientEnvironment.Set {
			e.Comma()
		}
		if s.TransientEnvironment.Set {
			e.RawStr("\"transient_environment\"" + ":")
			s.TransientEnvironment.Encode(e)
		}
	}
	{
		if s.ProductionEnvironment.Set {
			e.Comma()
		}
		if s.ProductionEnvironment.Set {
			e.RawStr("\"production_environment\"" + ":")
			s.ProductionEnvironment.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDeployment = [18]string{
	0:  "url",
	1:  "id",
	2:  "node_id",
	3:  "sha",
	4:  "ref",
	5:  "task",
	6:  "payload",
	7:  "original_environment",
	8:  "environment",
	9:  "description",
	10: "creator",
	11: "created_at",
	12: "updated_at",
	13: "statuses_url",
	14: "repository_url",
	15: "transient_environment",
	16: "production_environment",
	17: "performed_via_github_app",
}

// Decode decodes Deployment from json.
func (s *Deployment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Deployment to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "ref":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "task":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "original_environment":
			if err := func() error {
				s.OriginalEnvironment.Reset()
				if err := s.OriginalEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_environment\"")
			}
		case "environment":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Environment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "creator":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "statuses_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StatusesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "repository_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "transient_environment":
			if err := func() error {
				s.TransientEnvironment.Reset()
				if err := s.TransientEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transient_environment\"")
			}
		case "production_environment":
			if err := func() error {
				s.ProductionEnvironment.Reset()
				if err := s.ProductionEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"production_environment\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Deployment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01111111,
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeployment) {
					name = jsonFieldsNameOfDeployment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s DeploymentBranchPolicy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"protected_branches\"" + ":")
		e.Bool(s.ProtectedBranches)
	}
	{
		e.Comma()

		e.RawStr("\"custom_branch_policies\"" + ":")
		e.Bool(s.CustomBranchPolicies)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDeploymentBranchPolicy = [2]string{
	0: "protected_branches",
	1: "custom_branch_policies",
}

// Decode decodes DeploymentBranchPolicy from json.
func (s *DeploymentBranchPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentBranchPolicy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "protected_branches":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.ProtectedBranches = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protected_branches\"")
			}
		case "custom_branch_policies":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.CustomBranchPolicies = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_branch_policies\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeploymentBranchPolicy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeploymentBranchPolicy) {
					name = jsonFieldsNameOfDeploymentBranchPolicy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes DeploymentPayload as json.
func (s DeploymentPayload) Encode(e *jx.Writer) {
	switch s.Type {
	case DeploymentPayload0DeploymentPayload:
		s.DeploymentPayload0.Encode(e)
	case StringDeploymentPayload:
		e.Str(s.String)
	}
}

// Decode decodes DeploymentPayload from json.
func (s *DeploymentPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentPayload to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		s.DeploymentPayload0 = make(DeploymentPayload0)
		if err := s.DeploymentPayload0.Decode(d); err != nil {
			return err
		}
		s.Type = DeploymentPayload0DeploymentPayload
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringDeploymentPayload
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s DeploymentPayload0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDeploymentPayload0 = [0]string{}

// Decode decodes DeploymentPayload0 from json.
func (s DeploymentPayload0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentPayload0 to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeploymentPayload0")
	}

	return nil
}

// Encode encodes DeploymentReviewerType as json.
func (s DeploymentReviewerType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes DeploymentReviewerType from json.
func (s *DeploymentReviewerType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentReviewerType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeploymentReviewerType(v) {
	case DeploymentReviewerTypeUser:
		*s = DeploymentReviewerTypeUser
	case DeploymentReviewerTypeTeam:
		*s = DeploymentReviewerTypeTeam
	default:
		*s = DeploymentReviewerType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s DeploymentSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"task\"" + ":")
		e.Str(s.Task)
	}
	{
		if s.OriginalEnvironment.Set {
			e.Comma()
		}
		if s.OriginalEnvironment.Set {
			e.RawStr("\"original_environment\"" + ":")
			s.OriginalEnvironment.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"environment\"" + ":")
		e.Str(s.Environment)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		json.EncodeURI(e, s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		if s.TransientEnvironment.Set {
			e.Comma()
		}
		if s.TransientEnvironment.Set {
			e.RawStr("\"transient_environment\"" + ":")
			s.TransientEnvironment.Encode(e)
		}
	}
	{
		if s.ProductionEnvironment.Set {
			e.Comma()
		}
		if s.ProductionEnvironment.Set {
			e.RawStr("\"production_environment\"" + ":")
			s.ProductionEnvironment.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDeploymentSimple = [14]string{
	0:  "url",
	1:  "id",
	2:  "node_id",
	3:  "task",
	4:  "original_environment",
	5:  "environment",
	6:  "description",
	7:  "created_at",
	8:  "updated_at",
	9:  "statuses_url",
	10: "repository_url",
	11: "transient_environment",
	12: "production_environment",
	13: "performed_via_github_app",
}

// Decode decodes DeploymentSimple from json.
func (s *DeploymentSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentSimple to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "task":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Task = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "original_environment":
			if err := func() error {
				s.OriginalEnvironment.Reset()
				if err := s.OriginalEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_environment\"")
			}
		case "environment":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Environment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "statuses_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StatusesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "repository_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "transient_environment":
			if err := func() error {
				s.TransientEnvironment.Reset()
				if err := s.TransientEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transient_environment\"")
			}
		case "production_environment":
			if err := func() error {
				s.ProductionEnvironment.Reset()
				if err := s.ProductionEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"production_environment\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeploymentSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeploymentSimple) {
					name = jsonFieldsNameOfDeploymentSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s DeploymentStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		if s.Environment.Set {
			e.Comma()
		}
		if s.Environment.Set {
			e.RawStr("\"environment\"" + ":")
			s.Environment.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"target_url\"" + ":")
		json.EncodeURI(e, s.TargetURL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"deployment_url\"" + ":")
		json.EncodeURI(e, s.DeploymentURL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		if s.EnvironmentURL.Set {
			e.Comma()
		}
		if s.EnvironmentURL.Set {
			e.RawStr("\"environment_url\"" + ":")
			s.EnvironmentURL.Encode(e)
		}
	}
	{
		if s.LogURL.Set {
			e.Comma()
		}
		if s.LogURL.Set {
			e.RawStr("\"log_url\"" + ":")
			s.LogURL.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDeploymentStatus = [15]string{
	0:  "url",
	1:  "id",
	2:  "node_id",
	3:  "state",
	4:  "creator",
	5:  "description",
	6:  "environment",
	7:  "target_url",
	8:  "created_at",
	9:  "updated_at",
	10: "deployment_url",
	11: "repository_url",
	12: "environment_url",
	13: "log_url",
	14: "performed_via_github_app",
}

// Decode decodes DeploymentStatus from json.
func (s *DeploymentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentStatus to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "creator":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "environment":
			if err := func() error {
				s.Environment.Reset()
				if err := s.Environment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "target_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TargetURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_url\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "deployment_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployment_url\"")
			}
		case "repository_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "environment_url":
			if err := func() error {
				s.EnvironmentURL.Reset()
				if err := s.EnvironmentURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment_url\"")
			}
		case "log_url":
			if err := func() error {
				s.LogURL.Reset()
				if err := s.LogURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"log_url\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeploymentStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeploymentStatus) {
					name = jsonFieldsNameOfDeploymentStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes DeploymentStatusState as json.
func (s DeploymentStatusState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes DeploymentStatusState from json.
func (s *DeploymentStatusState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentStatusState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeploymentStatusState(v) {
	case DeploymentStatusStateError:
		*s = DeploymentStatusStateError
	case DeploymentStatusStateFailure:
		*s = DeploymentStatusStateFailure
	case DeploymentStatusStateInactive:
		*s = DeploymentStatusStateInactive
	case DeploymentStatusStatePending:
		*s = DeploymentStatusStatePending
	case DeploymentStatusStateSuccess:
		*s = DeploymentStatusStateSuccess
	case DeploymentStatusStateQueued:
		*s = DeploymentStatusStateQueued
	case DeploymentStatusStateInProgress:
		*s = DeploymentStatusStateInProgress
	default:
		*s = DeploymentStatusState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s DiffEntry) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"filename\"" + ":")
		e.Str(s.Filename)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"additions\"" + ":")
		e.Int(s.Additions)
	}
	{
		e.Comma()

		e.RawStr("\"deletions\"" + ":")
		e.Int(s.Deletions)
	}
	{
		e.Comma()

		e.RawStr("\"changes\"" + ":")
		e.Int(s.Changes)
	}
	{
		e.Comma()

		e.RawStr("\"blob_url\"" + ":")
		json.EncodeURI(e, s.BlobURL)
	}
	{
		e.Comma()

		e.RawStr("\"raw_url\"" + ":")
		json.EncodeURI(e, s.RawURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		json.EncodeURI(e, s.ContentsURL)
	}
	{
		if s.Patch.Set {
			e.Comma()
		}
		if s.Patch.Set {
			e.RawStr("\"patch\"" + ":")
			s.Patch.Encode(e)
		}
	}
	{
		if s.PreviousFilename.Set {
			e.Comma()
		}
		if s.PreviousFilename.Set {
			e.RawStr("\"previous_filename\"" + ":")
			s.PreviousFilename.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDiffEntry = [11]string{
	0:  "sha",
	1:  "filename",
	2:  "status",
	3:  "additions",
	4:  "deletions",
	5:  "changes",
	6:  "blob_url",
	7:  "raw_url",
	8:  "contents_url",
	9:  "patch",
	10: "previous_filename",
}

// Decode decodes DiffEntry from json.
func (s *DiffEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DiffEntry to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "filename":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Filename = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "additions":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Additions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additions\"")
			}
		case "deletions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Deletions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletions\"")
			}
		case "changes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Changes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changes\"")
			}
		case "blob_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.BlobURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blob_url\"")
			}
		case "raw_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RawURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_url\"")
			}
		case "contents_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "patch":
			if err := func() error {
				s.Patch.Reset()
				if err := s.Patch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch\"")
			}
		case "previous_filename":
			if err := func() error {
				s.PreviousFilename.Reset()
				if err := s.PreviousFilename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_filename\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DiffEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDiffEntry) {
					name = jsonFieldsNameOfDiffEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes DiffEntryStatus as json.
func (s DiffEntryStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes DiffEntryStatus from json.
func (s *DiffEntryStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DiffEntryStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DiffEntryStatus(v) {
	case DiffEntryStatusAdded:
		*s = DiffEntryStatusAdded
	case DiffEntryStatusRemoved:
		*s = DiffEntryStatusRemoved
	case DiffEntryStatusModified:
		*s = DiffEntryStatusModified
	case DiffEntryStatusRenamed:
		*s = DiffEntryStatusRenamed
	case DiffEntryStatusCopied:
		*s = DiffEntryStatusCopied
	case DiffEntryStatusChanged:
		*s = DiffEntryStatusChanged
	case DiffEntryStatusUnchanged:
		*s = DiffEntryStatusUnchanged
	default:
		*s = DiffEntryStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Email) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		e.Comma()

		e.RawStr("\"primary\"" + ":")
		e.Bool(s.Primary)
	}
	{
		e.Comma()

		e.RawStr("\"verified\"" + ":")
		e.Bool(s.Verified)
	}
	{
		e.Comma()

		e.RawStr("\"visibility\"" + ":")
		s.Visibility.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEmail = [4]string{
	0: "email",
	1: "primary",
	2: "verified",
	3: "visibility",
}

// Decode decodes Email from json.
func (s *Email) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Email to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "primary":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Primary = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary\"")
			}
		case "verified":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Verified = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified\"")
			}
		case "visibility":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Email")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEmail) {
					name = jsonFieldsNameOfEmail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EmojisGetOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEmojisGetOK = [0]string{}

// Decode decodes EmojisGetOK from json.
func (s EmojisGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EmojisGetOK to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EmojisGetOK")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EmptyObject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEmptyObject = [0]string{}

// Decode decodes EmptyObject from json.
func (s EmptyObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EmptyObject to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EmptyObject")
	}

	return nil
}

// Encode encodes EnabledOrganizations as json.
func (s EnabledOrganizations) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes EnabledOrganizations from json.
func (s *EnabledOrganizations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnabledOrganizations to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnabledOrganizations(v) {
	case EnabledOrganizationsAll:
		*s = EnabledOrganizationsAll
	case EnabledOrganizationsNone:
		*s = EnabledOrganizationsNone
	case EnabledOrganizationsSelected:
		*s = EnabledOrganizationsSelected
	default:
		*s = EnabledOrganizations(v)
	}

	return nil
}

// Encode encodes EnabledRepositories as json.
func (s EnabledRepositories) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes EnabledRepositories from json.
func (s *EnabledRepositories) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnabledRepositories to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnabledRepositories(v) {
	case EnabledRepositoriesAll:
		*s = EnabledRepositoriesAll
	case EnabledRepositoriesNone:
		*s = EnabledRepositoriesNone
	case EnabledRepositoriesSelected:
		*s = EnabledRepositoriesSelected
	default:
		*s = EnabledRepositories(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.SelectedOrganizationIds != nil {
			e.Comma()
		}
		if s.SelectedOrganizationIds != nil {
			e.RawStr("\"selected_organization_ids\"" + ":")
			e.ArrStart()
			if len(s.SelectedOrganizationIds) >= 1 {
				// Encode first element without comma.
				{
					elem := s.SelectedOrganizationIds[0]
					e.Int(elem)
				}
				for _, elem := range s.SelectedOrganizationIds[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Runners != nil {
			e.Comma()
		}
		if s.Runners != nil {
			e.RawStr("\"runners\"" + ":")
			e.ArrStart()
			if len(s.Runners) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Runners[0]
					e.Int(elem)
				}
				for _, elem := range s.Runners[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq = [4]string{
	0: "name",
	1: "visibility",
	2: "selected_organization_ids",
	3: "runners",
}

// Decode decodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq from json.
func (s *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "selected_organization_ids":
			if err := func() error {
				s.SelectedOrganizationIds = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SelectedOrganizationIds = append(s.SelectedOrganizationIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_organization_ids\"")
			}
		case "runners":
			if err := func() error {
				s.Runners = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq) {
					name = jsonFieldsNameOfEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (s EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (s *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility(v) {
	case EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibilitySelected:
		*s = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibilitySelected
	case EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibilityAll:
		*s = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibilityAll
	default:
		*s = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"organizations\"" + ":")
		e.ArrStart()
		if len(s.Organizations) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Organizations[0]
				elem.Encode(e)
			}
			for _, elem := range s.Organizations[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK = [2]string{
	0: "total_count",
	1: "organizations",
}

// Decode decodes EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK from json.
func (s *EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "organizations":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Organizations = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem OrganizationSimple
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Organizations = append(s.Organizations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK) {
					name = jsonFieldsNameOfEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"organizations\"" + ":")
		e.ArrStart()
		if len(s.Organizations) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Organizations[0]
				elem.Encode(e)
			}
			for _, elem := range s.Organizations[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK = [2]string{
	0: "total_count",
	1: "organizations",
}

// Decode decodes EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK from json.
func (s *EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "organizations":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Organizations = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem OrganizationSimple
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Organizations = append(s.Organizations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK) {
					name = jsonFieldsNameOfEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"runner_groups\"" + ":")
		e.ArrStart()
		if len(s.RunnerGroups) >= 1 {
			// Encode first element without comma.
			{
				elem := s.RunnerGroups[0]
				elem.Encode(e)
			}
			for _, elem := range s.RunnerGroups[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK = [2]string{
	0: "total_count",
	1: "runner_groups",
}

// Decode decodes EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK from json.
func (s *EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "runner_groups":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.RunnerGroups = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RunnerGroupsEnterprise
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RunnerGroups = append(s.RunnerGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runner_groups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK) {
					name = jsonFieldsNameOfEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminListSelfHostedRunnersForEnterpriseOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.TotalCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TotalCount.Set {
			e.RawStr("\"total_count\"" + ":")
			s.TotalCount.Encode(e)
		}
	}
	{
		if s.Runners != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Runners != nil {
			e.RawStr("\"runners\"" + ":")
			e.ArrStart()
			if len(s.Runners) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Runners[0]
					elem.Encode(e)
				}
				for _, elem := range s.Runners[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminListSelfHostedRunnersForEnterpriseOK = [2]string{
	0: "total_count",
	1: "runners",
}

// Decode decodes EnterpriseAdminListSelfHostedRunnersForEnterpriseOK from json.
func (s *EnterpriseAdminListSelfHostedRunnersForEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminListSelfHostedRunnersForEnterpriseOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			if err := func() error {
				s.TotalCount.Reset()
				if err := s.TotalCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "runners":
			if err := func() error {
				s.Runners = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Runner
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminListSelfHostedRunnersForEnterpriseOK")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Float64(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"runners\"" + ":")
		e.ArrStart()
		if len(s.Runners) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Runners[0]
				elem.Encode(e)
			}
			for _, elem := range s.Runners[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK = [2]string{
	0: "total_count",
	1: "runners",
}

// Decode decodes EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK from json.
func (s *EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "runners":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Runners = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Runner
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK) {
					name = jsonFieldsNameOfEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseGroupReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"displayName\"" + ":")
		e.Str(s.DisplayName)
	}
	{
		if s.Members != nil {
			e.Comma()
		}
		if s.Members != nil {
			e.RawStr("\"members\"" + ":")
			e.ArrStart()
			if len(s.Members) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Members[0]
					elem.Encode(e)
				}
				for _, elem := range s.Members[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseGroupReq = [3]string{
	0: "schemas",
	1: "displayName",
	2: "members",
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseGroupReq from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseGroupReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "displayName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "members":
			if err := func() error {
				s.Members = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Members = append(s.Members, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminProvisionAndInviteEnterpriseGroupReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseGroupReq) {
					name = jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseGroupReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem = [1]string{
	0: "value",
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem) {
					name = jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"userName\"" + ":")
		e.Str(s.UserName)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		s.Name.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"emails\"" + ":")
		e.ArrStart()
		if len(s.Emails) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Emails[0]
				elem.Encode(e)
			}
			for _, elem := range s.Emails[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Groups != nil {
			e.Comma()
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					elem.Encode(e)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReq = [5]string{
	0: "schemas",
	1: "userName",
	2: "name",
	3: "emails",
	4: "groups",
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReq from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "userName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UserName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userName\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "emails":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Emails = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		case "groups":
			if err := func() error {
				s.Groups = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminProvisionAndInviteEnterpriseUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReq) {
					name = jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"primary\"" + ":")
		e.Bool(s.Primary)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem = [3]string{
	0: "value",
	1: "type",
	2: "primary",
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "primary":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Primary = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem) {
					name = jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem = [1]string{
	0: "value",
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseUserReqName) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"givenName\"" + ":")
		e.Str(s.GivenName)
	}
	{
		e.Comma()

		e.RawStr("\"familyName\"" + ":")
		e.Str(s.FamilyName)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReqName = [2]string{
	0: "givenName",
	1: "familyName",
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReqName from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqName to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GivenName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"givenName\"")
			}
		case "familyName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FamilyName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"familyName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqName")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReqName) {
					name = jsonFieldsNameOfEnterpriseAdminProvisionAndInviteEnterpriseUserReqName[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"enabled_organizations\"" + ":")
		s.EnabledOrganizations.Encode(e)
	}
	{
		if s.AllowedActions.Set {
			e.Comma()
		}
		if s.AllowedActions.Set {
			e.RawStr("\"allowed_actions\"" + ":")
			s.AllowedActions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminSetGithubActionsPermissionsEnterpriseReq = [2]string{
	0: "enabled_organizations",
	1: "allowed_actions",
}

// Decode decodes EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq from json.
func (s *EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_organizations":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EnabledOrganizations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled_organizations\"")
			}
		case "allowed_actions":
			if err := func() error {
				s.AllowedActions.Reset()
				if err := s.AllowedActions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_actions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetGithubActionsPermissionsEnterpriseReq) {
					name = jsonFieldsNameOfEnterpriseAdminSetGithubActionsPermissionsEnterpriseReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"displayName\"" + ":")
		e.Str(s.DisplayName)
	}
	{
		if s.Members != nil {
			e.Comma()
		}
		if s.Members != nil {
			e.RawStr("\"members\"" + ":")
			e.ArrStart()
			if len(s.Members) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Members[0]
					elem.Encode(e)
				}
				for _, elem := range s.Members[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq = [3]string{
	0: "schemas",
	1: "displayName",
	2: "members",
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "displayName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "members":
			if err := func() error {
				s.Members = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Members = append(s.Members, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq) {
					name = jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem = [1]string{
	0: "value",
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem) {
					name = jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"userName\"" + ":")
		e.Str(s.UserName)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		s.Name.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"emails\"" + ":")
		e.ArrStart()
		if len(s.Emails) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Emails[0]
				elem.Encode(e)
			}
			for _, elem := range s.Emails[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Groups != nil {
			e.Comma()
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					elem.Encode(e)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReq = [5]string{
	0: "schemas",
	1: "userName",
	2: "name",
	3: "emails",
	4: "groups",
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "userName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UserName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userName\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "emails":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Emails = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		case "groups":
			if err := func() error {
				s.Groups = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReq) {
					name = jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"primary\"" + ":")
		e.Bool(s.Primary)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem = [3]string{
	0: "value",
	1: "type",
	2: "primary",
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "primary":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Primary = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem) {
					name = jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem = [1]string{
	0: "value",
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"givenName\"" + ":")
		e.Str(s.GivenName)
	}
	{
		e.Comma()

		e.RawStr("\"familyName\"" + ":")
		e.Str(s.FamilyName)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName = [2]string{
	0: "givenName",
	1: "familyName",
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GivenName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"givenName\"")
			}
		case "familyName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FamilyName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"familyName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName) {
					name = jsonFieldsNameOfEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selected_organization_ids\"" + ":")
		e.ArrStart()
		if len(s.SelectedOrganizationIds) >= 1 {
			// Encode first element without comma.
			{
				elem := s.SelectedOrganizationIds[0]
				e.Int(elem)
			}
			for _, elem := range s.SelectedOrganizationIds[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq = [1]string{
	0: "selected_organization_ids",
}

// Decode decodes EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq from json.
func (s *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_organization_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.SelectedOrganizationIds = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SelectedOrganizationIds = append(s.SelectedOrganizationIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_organization_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq) {
					name = jsonFieldsNameOfEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"selected_organization_ids\"" + ":")
		e.ArrStart()
		if len(s.SelectedOrganizationIds) >= 1 {
			// Encode first element without comma.
			{
				elem := s.SelectedOrganizationIds[0]
				e.Int(elem)
			}
			for _, elem := range s.SelectedOrganizationIds[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq = [1]string{
	0: "selected_organization_ids",
}

// Decode decodes EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq from json.
func (s *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_organization_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.SelectedOrganizationIds = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.SelectedOrganizationIds = append(s.SelectedOrganizationIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_organization_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq) {
					name = jsonFieldsNameOfEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"runners\"" + ":")
		e.ArrStart()
		if len(s.Runners) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Runners[0]
				e.Int(elem)
			}
			for _, elem := range s.Runners[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq = [1]string{
	0: "runners",
}

// Decode decodes EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq from json.
func (s *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "runners":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Runners = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Runners = append(s.Runners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq) {
					name = jsonFieldsNameOfEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminUpdateAttributeForEnterpriseGroupReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"Operations\"" + ":")
		e.ArrStart()
		if len(s.Operations) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Operations[0]
				elem.Encode(e)
			}
			for _, elem := range s.Operations[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseGroupReq = [2]string{
	0: "schemas",
	1: "Operations",
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReq from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "Operations":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Operations = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Operations = append(s.Operations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Operations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseGroupReq) {
					name = jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseGroupReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"op\"" + ":")
		s.Op.Encode(e)
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.Comma()
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem = [3]string{
	0: "op",
	1: "path",
	2: "value",
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "op":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Op.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"op\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem) {
					name = jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp as json.
func (s EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp(v) {
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Add:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Add
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Add:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Add
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Remove:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Remove
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Remove:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Remove
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Replace:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Replace
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Replace:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_Replace
	default:
		*s = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp(v)
	}

	return nil
}

// Encode encodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue as json.
func (s EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) Encode(e *jx.Writer) {
	switch s.Type {
	case StringEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue:
		e.Str(s.String)
	case EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue:
		s.EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1.Encode(e)
	case ArrayAnyEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue:
		e.ArrStart()
		if len(s.ArrayAny) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayAny[0]
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			for _, elem := range s.ArrayAny[1:] {
				e.Comma()
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue
	case jx.Object:
		if err := s.EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1.Decode(d); err != nil {
			return err
		}
		s.Type = EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue
	case jx.Array:
		s.ArrayAny = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem jx.Raw
			v, err := d.Raw()
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			s.ArrayAny = append(s.ArrayAny, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayAnyEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1 = [0]string{}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1 from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminUpdateAttributeForEnterpriseUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"Operations\"" + ":")
		e.ArrStart()
		if len(s.Operations) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Operations[0]
				elem.Encode(e)
			}
			for _, elem := range s.Operations[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseUserReq = [2]string{
	0: "schemas",
	1: "Operations",
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseUserReq from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "Operations":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Operations = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Operations = append(s.Operations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Operations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminUpdateAttributeForEnterpriseUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseUserReq) {
					name = jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem = [0]string{}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq = [2]string{
	0: "name",
	1: "visibility",
}

// Decode decodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq from json.
func (s *EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq")
	}

	return nil
}

// Encode encodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (s EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (s *EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility(v) {
	case EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibilitySelected:
		*s = EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibilitySelected
	case EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibilityAll:
		*s = EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibilityAll
	default:
		*s = EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnvironmentApprovals) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"environments\"" + ":")
		e.ArrStart()
		if len(s.Environments) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Environments[0]
				elem.Encode(e)
			}
			for _, elem := range s.Environments[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comment\"" + ":")
		e.Str(s.Comment)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnvironmentApprovals = [4]string{
	0: "environments",
	1: "state",
	2: "user",
	3: "comment",
}

// Decode decodes EnvironmentApprovals from json.
func (s *EnvironmentApprovals) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentApprovals to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "environments":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Environments = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnvironmentApprovalsEnvironmentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Environments = append(s.Environments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environments\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "comment":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Comment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvironmentApprovals")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnvironmentApprovals) {
					name = jsonFieldsNameOfEnvironmentApprovals[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EnvironmentApprovalsEnvironmentsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEnvironmentApprovalsEnvironmentsItem = [7]string{
	0: "id",
	1: "node_id",
	2: "name",
	3: "url",
	4: "html_url",
	5: "created_at",
	6: "updated_at",
}

// Decode decodes EnvironmentApprovalsEnvironmentsItem from json.
func (s *EnvironmentApprovalsEnvironmentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentApprovalsEnvironmentsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvironmentApprovalsEnvironmentsItem")
	}

	return nil
}

// Encode encodes EnvironmentApprovalsState as json.
func (s EnvironmentApprovalsState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes EnvironmentApprovalsState from json.
func (s *EnvironmentApprovalsState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvironmentApprovalsState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnvironmentApprovalsState(v) {
	case EnvironmentApprovalsStateApproved:
		*s = EnvironmentApprovalsStateApproved
	case EnvironmentApprovalsStateRejected:
		*s = EnvironmentApprovalsStateRejected
	default:
		*s = EnvironmentApprovalsState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Event) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"actor\"" + ":")
		s.Actor.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"repo\"" + ":")
		s.Repo.Encode(e)
	}
	{
		if s.Org.Set {
			e.Comma()
		}
		if s.Org.Set {
			e.RawStr("\"org\"" + ":")
			s.Org.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"public\"" + ":")
		e.Bool(s.Public)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEvent = [8]string{
	0: "id",
	1: "type",
	2: "actor",
	3: "repo",
	4: "org",
	5: "payload",
	6: "public",
	7: "created_at",
}

// Decode decodes Event from json.
func (s *Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Event to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "actor":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Actor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actor\"")
			}
		case "repo":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		case "org":
			if err := func() error {
				s.Org.Reset()
				if err := s.Org.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"org\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "public":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Public = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Event")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEvent) {
					name = jsonFieldsNameOfEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EventPayload) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Action.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Action.Set {
			e.RawStr("\"action\"" + ":")
			s.Action.Encode(e)
		}
	}
	{
		if s.Issue.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Issue.Set {
			e.RawStr("\"issue\"" + ":")
			s.Issue.Encode(e)
		}
	}
	{
		if s.Comment.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Comment.Set {
			e.RawStr("\"comment\"" + ":")
			s.Comment.Encode(e)
		}
	}
	{
		if s.Pages != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pages != nil {
			e.RawStr("\"pages\"" + ":")
			e.ArrStart()
			if len(s.Pages) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Pages[0]
					elem.Encode(e)
				}
				for _, elem := range s.Pages[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEventPayload = [4]string{
	0: "action",
	1: "issue",
	2: "comment",
	3: "pages",
}

// Decode decodes EventPayload from json.
func (s *EventPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventPayload to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "issue":
			if err := func() error {
				s.Issue.Reset()
				if err := s.Issue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue\"")
			}
		case "comment":
			if err := func() error {
				s.Comment.Reset()
				if err := s.Comment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		case "pages":
			if err := func() error {
				s.Pages = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EventPayloadPagesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Pages = append(s.Pages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventPayload")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EventPayloadPagesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.PageName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PageName.Set {
			e.RawStr("\"page_name\"" + ":")
			s.PageName.Encode(e)
		}
	}
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Summary.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Summary.Set {
			e.RawStr("\"summary\"" + ":")
			s.Summary.Encode(e)
		}
	}
	{
		if s.Action.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Action.Set {
			e.RawStr("\"action\"" + ":")
			s.Action.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEventPayloadPagesItem = [6]string{
	0: "page_name",
	1: "title",
	2: "summary",
	3: "action",
	4: "sha",
	5: "html_url",
}

// Decode decodes EventPayloadPagesItem from json.
func (s *EventPayloadPagesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventPayloadPagesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page_name":
			if err := func() error {
				s.PageName.Reset()
				if err := s.PageName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_name\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventPayloadPagesItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EventRepo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEventRepo = [3]string{
	0: "id",
	1: "name",
	2: "url",
}

// Decode decodes EventRepo from json.
func (s *EventRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventRepo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventRepo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEventRepo) {
					name = jsonFieldsNameOfEventRepo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Feed) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"timeline_url\"" + ":")
		e.Str(s.TimelineURL)
	}
	{
		e.Comma()

		e.RawStr("\"user_url\"" + ":")
		e.Str(s.UserURL)
	}
	{
		if s.CurrentUserPublicURL.Set {
			e.Comma()
		}
		if s.CurrentUserPublicURL.Set {
			e.RawStr("\"current_user_public_url\"" + ":")
			s.CurrentUserPublicURL.Encode(e)
		}
	}
	{
		if s.CurrentUserURL.Set {
			e.Comma()
		}
		if s.CurrentUserURL.Set {
			e.RawStr("\"current_user_url\"" + ":")
			s.CurrentUserURL.Encode(e)
		}
	}
	{
		if s.CurrentUserActorURL.Set {
			e.Comma()
		}
		if s.CurrentUserActorURL.Set {
			e.RawStr("\"current_user_actor_url\"" + ":")
			s.CurrentUserActorURL.Encode(e)
		}
	}
	{
		if s.CurrentUserOrganizationURL.Set {
			e.Comma()
		}
		if s.CurrentUserOrganizationURL.Set {
			e.RawStr("\"current_user_organization_url\"" + ":")
			s.CurrentUserOrganizationURL.Encode(e)
		}
	}
	{
		if s.CurrentUserOrganizationUrls != nil {
			e.Comma()
		}
		if s.CurrentUserOrganizationUrls != nil {
			e.RawStr("\"current_user_organization_urls\"" + ":")
			e.ArrStart()
			if len(s.CurrentUserOrganizationUrls) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CurrentUserOrganizationUrls[0]
					json.EncodeURI(e, elem)
				}
				for _, elem := range s.CurrentUserOrganizationUrls[1:] {
					e.Comma()
					json.EncodeURI(e, elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.SecurityAdvisoriesURL.Set {
			e.Comma()
		}
		if s.SecurityAdvisoriesURL.Set {
			e.RawStr("\"security_advisories_url\"" + ":")
			s.SecurityAdvisoriesURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFeed = [9]string{
	0: "timeline_url",
	1: "user_url",
	2: "current_user_public_url",
	3: "current_user_url",
	4: "current_user_actor_url",
	5: "current_user_organization_url",
	6: "current_user_organization_urls",
	7: "security_advisories_url",
	8: "_links",
}

// Decode decodes Feed from json.
func (s *Feed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Feed to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeline_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TimelineURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeline_url\"")
			}
		case "user_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UserURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_url\"")
			}
		case "current_user_public_url":
			if err := func() error {
				s.CurrentUserPublicURL.Reset()
				if err := s.CurrentUserPublicURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_public_url\"")
			}
		case "current_user_url":
			if err := func() error {
				s.CurrentUserURL.Reset()
				if err := s.CurrentUserURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_url\"")
			}
		case "current_user_actor_url":
			if err := func() error {
				s.CurrentUserActorURL.Reset()
				if err := s.CurrentUserActorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_actor_url\"")
			}
		case "current_user_organization_url":
			if err := func() error {
				s.CurrentUserOrganizationURL.Reset()
				if err := s.CurrentUserOrganizationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_organization_url\"")
			}
		case "current_user_organization_urls":
			if err := func() error {
				s.CurrentUserOrganizationUrls = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem url.URL
					v, err := json.DecodeURI(d)
					elem = v
					if err != nil {
						return err
					}
					s.CurrentUserOrganizationUrls = append(s.CurrentUserOrganizationUrls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_organization_urls\"")
			}
		case "security_advisories_url":
			if err := func() error {
				s.SecurityAdvisoriesURL.Reset()
				if err := s.SecurityAdvisoriesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_advisories_url\"")
			}
		case "_links":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Feed")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeed) {
					name = jsonFieldsNameOfFeed[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FeedLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"timeline\"" + ":")
		s.Timeline.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		if s.SecurityAdvisories.Set {
			e.Comma()
		}
		if s.SecurityAdvisories.Set {
			e.RawStr("\"security_advisories\"" + ":")
			s.SecurityAdvisories.Encode(e)
		}
	}
	{
		if s.CurrentUser.Set {
			e.Comma()
		}
		if s.CurrentUser.Set {
			e.RawStr("\"current_user\"" + ":")
			s.CurrentUser.Encode(e)
		}
	}
	{
		if s.CurrentUserPublic.Set {
			e.Comma()
		}
		if s.CurrentUserPublic.Set {
			e.RawStr("\"current_user_public\"" + ":")
			s.CurrentUserPublic.Encode(e)
		}
	}
	{
		if s.CurrentUserActor.Set {
			e.Comma()
		}
		if s.CurrentUserActor.Set {
			e.RawStr("\"current_user_actor\"" + ":")
			s.CurrentUserActor.Encode(e)
		}
	}
	{
		if s.CurrentUserOrganization.Set {
			e.Comma()
		}
		if s.CurrentUserOrganization.Set {
			e.RawStr("\"current_user_organization\"" + ":")
			s.CurrentUserOrganization.Encode(e)
		}
	}
	{
		if s.CurrentUserOrganizations != nil {
			e.Comma()
		}
		if s.CurrentUserOrganizations != nil {
			e.RawStr("\"current_user_organizations\"" + ":")
			e.ArrStart()
			if len(s.CurrentUserOrganizations) >= 1 {
				// Encode first element without comma.
				{
					elem := s.CurrentUserOrganizations[0]
					elem.Encode(e)
				}
				for _, elem := range s.CurrentUserOrganizations[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFeedLinks = [8]string{
	0: "timeline",
	1: "user",
	2: "security_advisories",
	3: "current_user",
	4: "current_user_public",
	5: "current_user_actor",
	6: "current_user_organization",
	7: "current_user_organizations",
}

// Decode decodes FeedLinks from json.
func (s *FeedLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeline":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Timeline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeline\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "security_advisories":
			if err := func() error {
				s.SecurityAdvisories.Reset()
				if err := s.SecurityAdvisories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_advisories\"")
			}
		case "current_user":
			if err := func() error {
				s.CurrentUser.Reset()
				if err := s.CurrentUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user\"")
			}
		case "current_user_public":
			if err := func() error {
				s.CurrentUserPublic.Reset()
				if err := s.CurrentUserPublic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_public\"")
			}
		case "current_user_actor":
			if err := func() error {
				s.CurrentUserActor.Reset()
				if err := s.CurrentUserActor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_actor\"")
			}
		case "current_user_organization":
			if err := func() error {
				s.CurrentUserOrganization.Reset()
				if err := s.CurrentUserOrganization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_organization\"")
			}
		case "current_user_organizations":
			if err := func() error {
				s.CurrentUserOrganizations = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LinkWithType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CurrentUserOrganizations = append(s.CurrentUserOrganizations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_organizations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedLinks) {
					name = jsonFieldsNameOfFeedLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FileCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		s.Commit.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFileCommit = [2]string{
	0: "content",
	1: "commit",
}

// Decode decodes FileCommit from json.
func (s *FileCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFileCommit) {
					name = jsonFieldsNameOfFileCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FileCommitCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Author.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Author.Set {
			e.RawStr("\"author\"" + ":")
			s.Author.Encode(e)
		}
	}
	{
		if s.Committer.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Committer.Set {
			e.RawStr("\"committer\"" + ":")
			s.Committer.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Tree.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Tree.Set {
			e.RawStr("\"tree\"" + ":")
			s.Tree.Encode(e)
		}
	}
	{
		if s.Parents != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Parents != nil {
			e.RawStr("\"parents\"" + ":")
			e.ArrStart()
			if len(s.Parents) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Parents[0]
					elem.Encode(e)
				}
				for _, elem := range s.Parents[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Verification.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Verification.Set {
			e.RawStr("\"verification\"" + ":")
			s.Verification.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFileCommitCommit = [10]string{
	0: "sha",
	1: "node_id",
	2: "url",
	3: "html_url",
	4: "author",
	5: "committer",
	6: "message",
	7: "tree",
	8: "parents",
	9: "verification",
}

// Decode decodes FileCommitCommit from json.
func (s *FileCommitCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitCommit to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			if err := func() error {
				s.Committer.Reset()
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "tree":
			if err := func() error {
				s.Tree.Reset()
				if err := s.Tree.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree\"")
			}
		case "parents":
			if err := func() error {
				s.Parents = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FileCommitCommitParentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parents = append(s.Parents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parents\"")
			}
		case "verification":
			if err := func() error {
				s.Verification.Reset()
				if err := s.Verification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitCommit")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FileCommitCommitAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Date.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFileCommitCommitAuthor = [3]string{
	0: "date",
	1: "name",
	2: "email",
}

// Decode decodes FileCommitCommitAuthor from json.
func (s *FileCommitCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitCommitAuthor to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitCommitAuthor")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FileCommitCommitCommitter) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Date.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFileCommitCommitCommitter = [3]string{
	0: "date",
	1: "name",
	2: "email",
}

// Decode decodes FileCommitCommitCommitter from json.
func (s *FileCommitCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitCommitCommitter to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitCommitCommitter")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FileCommitCommitParentsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFileCommitCommitParentsItem = [3]string{
	0: "url",
	1: "html_url",
	2: "sha",
}

// Decode decodes FileCommitCommitParentsItem from json.
func (s *FileCommitCommitParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitCommitParentsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitCommitParentsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FileCommitCommitTree) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFileCommitCommitTree = [2]string{
	0: "url",
	1: "sha",
}

// Decode decodes FileCommitCommitTree from json.
func (s *FileCommitCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitCommitTree to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitCommitTree")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FileCommitCommitVerification) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Verified.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Verified.Set {
			e.RawStr("\"verified\"" + ":")
			s.Verified.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Signature.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Signature.Set {
			e.RawStr("\"signature\"" + ":")
			s.Signature.Encode(e)
		}
	}
	{
		if s.Payload.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Payload.Set {
			e.RawStr("\"payload\"" + ":")
			s.Payload.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFileCommitCommitVerification = [4]string{
	0: "verified",
	1: "reason",
	2: "signature",
	3: "payload",
}

// Decode decodes FileCommitCommitVerification from json.
func (s *FileCommitCommitVerification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitCommitVerification to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verified":
			if err := func() error {
				s.Verified.Reset()
				if err := s.Verified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "signature":
			if err := func() error {
				s.Signature.Reset()
				if err := s.Signature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signature\"")
			}
		case "payload":
			if err := func() error {
				s.Payload.Reset()
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitCommitVerification")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FileCommitContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Path.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.Size.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Size.Set {
			e.RawStr("\"size\"" + ":")
			s.Size.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.GitURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitURL.Set {
			e.RawStr("\"git_url\"" + ":")
			s.GitURL.Encode(e)
		}
	}
	{
		if s.DownloadURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DownloadURL.Set {
			e.RawStr("\"download_url\"" + ":")
			s.DownloadURL.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.Links.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Links.Set {
			e.RawStr("\"_links\"" + ":")
			s.Links.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFileCommitContent = [10]string{
	0: "name",
	1: "path",
	2: "sha",
	3: "size",
	4: "url",
	5: "html_url",
	6: "git_url",
	7: "download_url",
	8: "type",
	9: "_links",
}

// Decode decodes FileCommitContent from json.
func (s *FileCommitContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitContent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "git_url":
			if err := func() error {
				s.GitURL.Reset()
				if err := s.GitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "download_url":
			if err := func() error {
				s.DownloadURL.Reset()
				if err := s.DownloadURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download_url\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "_links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitContent")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FileCommitContentLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Self.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Self.Set {
			e.RawStr("\"self\"" + ":")
			s.Self.Encode(e)
		}
	}
	{
		if s.Git.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Git.Set {
			e.RawStr("\"git\"" + ":")
			s.Git.Encode(e)
		}
	}
	{
		if s.HTML.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTML.Set {
			e.RawStr("\"html\"" + ":")
			s.HTML.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFileCommitContentLinks = [3]string{
	0: "self",
	1: "git",
	2: "html",
}

// Decode decodes FileCommitContentLinks from json.
func (s *FileCommitContentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileCommitContentLinks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			if err := func() error {
				s.Self.Reset()
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		case "git":
			if err := func() error {
				s.Git.Reset()
				if err := s.Git.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git\"")
			}
		case "html":
			if err := func() error {
				s.HTML.Reset()
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileCommitContentLinks")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ForbiddenGist) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Block.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Block.Set {
			e.RawStr("\"block\"" + ":")
			s.Block.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfForbiddenGist = [3]string{
	0: "block",
	1: "message",
	2: "documentation_url",
}

// Decode decodes ForbiddenGist from json.
func (s *ForbiddenGist) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForbiddenGist to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "block":
			if err := func() error {
				s.Block.Reset()
				if err := s.Block.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"block\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForbiddenGist")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ForbiddenGistBlock) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfForbiddenGistBlock = [3]string{
	0: "reason",
	1: "created_at",
	2: "html_url",
}

// Decode decodes ForbiddenGistBlock from json.
func (s *ForbiddenGistBlock) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForbiddenGistBlock to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForbiddenGistBlock")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FullRepository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		e.Str(s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		e.Comma()

		e.RawStr("\"ssh_url\"" + ":")
		e.Str(s.SSHURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		e.Comma()

		e.RawStr("\"clone_url\"" + ":")
		e.Str(s.CloneURL)
	}
	{
		e.Comma()

		e.RawStr("\"mirror_url\"" + ":")
		s.MirrorURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"svn_url\"" + ":")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		e.Comma()

		e.RawStr("\"homepage\"" + ":")
		s.Homepage.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"language\"" + ":")
		s.Language.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"forks_count\"" + ":")
		e.Int(s.ForksCount)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_count\"" + ":")
		e.Int(s.StargazersCount)
	}
	{
		e.Comma()

		e.RawStr("\"watchers_count\"" + ":")
		e.Int(s.WatchersCount)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"default_branch\"" + ":")
		e.Str(s.DefaultBranch)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues_count\"" + ":")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"has_issues\"" + ":")
		e.Bool(s.HasIssues)
	}
	{
		e.Comma()

		e.RawStr("\"has_projects\"" + ":")
		e.Bool(s.HasProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_wiki\"" + ":")
		e.Bool(s.HasWiki)
	}
	{
		e.Comma()

		e.RawStr("\"has_pages\"" + ":")
		e.Bool(s.HasPages)
	}
	{
		e.Comma()

		e.RawStr("\"has_downloads\"" + ":")
		e.Bool(s.HasDownloads)
	}
	{
		e.Comma()

		e.RawStr("\"archived\"" + ":")
		e.Bool(s.Archived)
	}
	{
		e.Comma()

		e.RawStr("\"disabled\"" + ":")
		e.Bool(s.Disabled)
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pushed_at\"" + ":")
		json.EncodeDateTime(e, s.PushedAt)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.Comma()
		}
		if s.TemplateRepository.Set {
			e.RawStr("\"template_repository\"" + ":")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.Comma()
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_count\"" + ":")
		e.Int(s.SubscribersCount)
	}
	{
		e.Comma()

		e.RawStr("\"network_count\"" + ":")
		e.Int(s.NetworkCount)
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		if s.Organization.Set {
			e.Comma()
		}
		if s.Organization.Set {
			e.RawStr("\"organization\"" + ":")
			s.Organization.Encode(e)
		}
	}
	{
		if s.Parent.Set {
			e.Comma()
		}
		if s.Parent.Set {
			e.RawStr("\"parent\"" + ":")
			s.Parent.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.Comma()
		}
		if s.Source.Set {
			e.RawStr("\"source\"" + ":")
			s.Source.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"forks\"" + ":")
		e.Int(s.Forks)
	}
	{
		if s.MasterBranch.Set {
			e.Comma()
		}
		if s.MasterBranch.Set {
			e.RawStr("\"master_branch\"" + ":")
			s.MasterBranch.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"watchers\"" + ":")
		e.Int(s.Watchers)
	}
	{
		if s.AnonymousAccessEnabled.Set {
			e.Comma()
		}
		if s.AnonymousAccessEnabled.Set {
			e.RawStr("\"anonymous_access_enabled\"" + ":")
			s.AnonymousAccessEnabled.Encode(e)
		}
	}
	{
		if s.CodeOfConduct.Set {
			e.Comma()
		}
		if s.CodeOfConduct.Set {
			e.RawStr("\"code_of_conduct\"" + ":")
			s.CodeOfConduct.Encode(e)
		}
	}
	{
		if s.SecurityAndAnalysis.Set {
			e.Comma()
		}
		if s.SecurityAndAnalysis.Set {
			e.RawStr("\"security_and_analysis\"" + ":")
			s.SecurityAndAnalysis.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFullRepository = [94]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "owner",
	5:  "private",
	6:  "html_url",
	7:  "description",
	8:  "fork",
	9:  "url",
	10: "archive_url",
	11: "assignees_url",
	12: "blobs_url",
	13: "branches_url",
	14: "collaborators_url",
	15: "comments_url",
	16: "commits_url",
	17: "compare_url",
	18: "contents_url",
	19: "contributors_url",
	20: "deployments_url",
	21: "downloads_url",
	22: "events_url",
	23: "forks_url",
	24: "git_commits_url",
	25: "git_refs_url",
	26: "git_tags_url",
	27: "git_url",
	28: "issue_comment_url",
	29: "issue_events_url",
	30: "issues_url",
	31: "keys_url",
	32: "labels_url",
	33: "languages_url",
	34: "merges_url",
	35: "milestones_url",
	36: "notifications_url",
	37: "pulls_url",
	38: "releases_url",
	39: "ssh_url",
	40: "stargazers_url",
	41: "statuses_url",
	42: "subscribers_url",
	43: "subscription_url",
	44: "tags_url",
	45: "teams_url",
	46: "trees_url",
	47: "clone_url",
	48: "mirror_url",
	49: "hooks_url",
	50: "svn_url",
	51: "homepage",
	52: "language",
	53: "forks_count",
	54: "stargazers_count",
	55: "watchers_count",
	56: "size",
	57: "default_branch",
	58: "open_issues_count",
	59: "is_template",
	60: "topics",
	61: "has_issues",
	62: "has_projects",
	63: "has_wiki",
	64: "has_pages",
	65: "has_downloads",
	66: "archived",
	67: "disabled",
	68: "visibility",
	69: "pushed_at",
	70: "created_at",
	71: "updated_at",
	72: "permissions",
	73: "allow_rebase_merge",
	74: "template_repository",
	75: "temp_clone_token",
	76: "allow_squash_merge",
	77: "allow_auto_merge",
	78: "delete_branch_on_merge",
	79: "allow_merge_commit",
	80: "allow_forking",
	81: "subscribers_count",
	82: "network_count",
	83: "license",
	84: "organization",
	85: "parent",
	86: "source",
	87: "forks",
	88: "master_branch",
	89: "open_issues",
	90: "watchers",
	91: "anonymous_access_enabled",
	92: "code_of_conduct",
	93: "security_and_analysis",
}

// Decode decodes FullRepository from json.
func (s *FullRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullRepository to nil")
	}
	var requiredBitSet [12]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.SSHURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.CloneURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SvnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ForksCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.StargazersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.WatchersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DefaultBranch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.OpenIssuesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.HasIssues = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.HasProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.HasWiki = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HasPages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasDownloads = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Archived = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.PushedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "template_repository":
			if err := func() error {
				s.TemplateRepository.Reset()
				if err := s.TemplateRepository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_repository\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		case "subscribers_count":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.SubscribersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.NetworkCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		case "license":
			requiredBitSet[10] |= 1 << 3
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "organization":
			if err := func() error {
				s.Organization.Reset()
				if err := s.Organization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		case "parent":
			if err := func() error {
				s.Parent.Reset()
				if err := s.Parent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "forks":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Forks = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "master_branch":
			if err := func() error {
				s.MasterBranch.Reset()
				if err := s.MasterBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master_branch\"")
			}
		case "open_issues":
			requiredBitSet[11] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "watchers":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Watchers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "anonymous_access_enabled":
			if err := func() error {
				s.AnonymousAccessEnabled.Reset()
				if err := s.AnonymousAccessEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anonymous_access_enabled\"")
			}
		case "code_of_conduct":
			if err := func() error {
				s.CodeOfConduct.Reset()
				if err := s.CodeOfConduct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_of_conduct\"")
			}
		case "security_and_analysis":
			if err := func() error {
				s.SecurityAndAnalysis.Reset()
				if err := s.SecurityAndAnalysis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_and_analysis\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FullRepository")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [12]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11100111,
		0b11101111,
		0b00000000,
		0b10001110,
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFullRepository) {
					name = jsonFieldsNameOfFullRepository[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FullRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFullRepositoryPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes FullRepositoryPermissions from json.
func (s *FullRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullRepositoryPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FullRepositoryPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFullRepositoryPermissions) {
					name = jsonFieldsNameOfFullRepositoryPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FullRepositorySecurityAndAnalysis) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AdvancedSecurity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AdvancedSecurity.Set {
			e.RawStr("\"advanced_security\"" + ":")
			s.AdvancedSecurity.Encode(e)
		}
	}
	{
		if s.SecretScanning.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretScanning.Set {
			e.RawStr("\"secret_scanning\"" + ":")
			s.SecretScanning.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFullRepositorySecurityAndAnalysis = [2]string{
	0: "advanced_security",
	1: "secret_scanning",
}

// Decode decodes FullRepositorySecurityAndAnalysis from json.
func (s *FullRepositorySecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullRepositorySecurityAndAnalysis to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "advanced_security":
			if err := func() error {
				s.AdvancedSecurity.Reset()
				if err := s.AdvancedSecurity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"advanced_security\"")
			}
		case "secret_scanning":
			if err := func() error {
				s.SecretScanning.Reset()
				if err := s.SecretScanning.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_scanning\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FullRepositorySecurityAndAnalysis")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FullRepositorySecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFullRepositorySecurityAndAnalysisAdvancedSecurity = [1]string{
	0: "status",
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurity from json.
func (s *FullRepositorySecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullRepositorySecurityAndAnalysisAdvancedSecurity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FullRepositorySecurityAndAnalysisAdvancedSecurity")
	}

	return nil
}

// Encode encodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus as json.
func (s FullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus from json.
func (s *FullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullRepositorySecurityAndAnalysisAdvancedSecurityStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FullRepositorySecurityAndAnalysisAdvancedSecurityStatus(v) {
	case FullRepositorySecurityAndAnalysisAdvancedSecurityStatusEnabled:
		*s = FullRepositorySecurityAndAnalysisAdvancedSecurityStatusEnabled
	case FullRepositorySecurityAndAnalysisAdvancedSecurityStatusDisabled:
		*s = FullRepositorySecurityAndAnalysisAdvancedSecurityStatusDisabled
	default:
		*s = FullRepositorySecurityAndAnalysisAdvancedSecurityStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FullRepositorySecurityAndAnalysisSecretScanning) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFullRepositorySecurityAndAnalysisSecretScanning = [1]string{
	0: "status",
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanning from json.
func (s *FullRepositorySecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullRepositorySecurityAndAnalysisSecretScanning to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FullRepositorySecurityAndAnalysisSecretScanning")
	}

	return nil
}

// Encode encodes FullRepositorySecurityAndAnalysisSecretScanningStatus as json.
func (s FullRepositorySecurityAndAnalysisSecretScanningStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanningStatus from json.
func (s *FullRepositorySecurityAndAnalysisSecretScanningStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullRepositorySecurityAndAnalysisSecretScanningStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FullRepositorySecurityAndAnalysisSecretScanningStatus(v) {
	case FullRepositorySecurityAndAnalysisSecretScanningStatusEnabled:
		*s = FullRepositorySecurityAndAnalysisSecretScanningStatusEnabled
	case FullRepositorySecurityAndAnalysisSecretScanningStatusDisabled:
		*s = FullRepositorySecurityAndAnalysisSecretScanningStatusDisabled
	default:
		*s = FullRepositorySecurityAndAnalysisSecretScanningStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistComment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistComment = [8]string{
	0: "id",
	1: "node_id",
	2: "url",
	3: "body",
	4: "user",
	5: "created_at",
	6: "updated_at",
	7: "author_association",
}

// Decode decodes GistComment from json.
func (s *GistComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistComment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "author_association":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistComment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGistComment) {
					name = jsonFieldsNameOfGistComment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"version\"" + ":")
		e.Str(s.Version)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"change_status\"" + ":")
		s.ChangeStatus.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committed_at\"" + ":")
		json.EncodeDateTime(e, s.CommittedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistCommit = [5]string{
	0: "url",
	1: "version",
	2: "user",
	3: "change_status",
	4: "committed_at",
}

// Decode decodes GistCommit from json.
func (s *GistCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "change_status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ChangeStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"change_status\"")
			}
		case "committed_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CommittedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committed_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGistCommit) {
					name = jsonFieldsNameOfGistCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistCommitChangeStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Total.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Total.Set {
			e.RawStr("\"total\"" + ":")
			s.Total.Encode(e)
		}
	}
	{
		if s.Additions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Additions.Set {
			e.RawStr("\"additions\"" + ":")
			s.Additions.Encode(e)
		}
	}
	{
		if s.Deletions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Deletions.Set {
			e.RawStr("\"deletions\"" + ":")
			s.Deletions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistCommitChangeStatus = [3]string{
	0: "total",
	1: "additions",
	2: "deletions",
}

// Decode decodes GistCommitChangeStatus from json.
func (s *GistCommitChangeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistCommitChangeStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "additions":
			if err := func() error {
				s.Additions.Reset()
				if err := s.Additions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additions\"")
			}
		case "deletions":
			if err := func() error {
				s.Deletions.Reset()
				if err := s.Deletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistCommitChangeStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistHistory) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.User.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	{
		if s.Version.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Version.Set {
			e.RawStr("\"version\"" + ":")
			s.Version.Encode(e)
		}
	}
	{
		if s.CommittedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommittedAt.Set {
			e.RawStr("\"committed_at\"" + ":")
			s.CommittedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ChangeStatus.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ChangeStatus.Set {
			e.RawStr("\"change_status\"" + ":")
			s.ChangeStatus.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistHistory = [5]string{
	0: "user",
	1: "version",
	2: "committed_at",
	3: "change_status",
	4: "url",
}

// Decode decodes GistHistory from json.
func (s *GistHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistHistory to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "committed_at":
			if err := func() error {
				s.CommittedAt.Reset()
				if err := s.CommittedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committed_at\"")
			}
		case "change_status":
			if err := func() error {
				s.ChangeStatus.Reset()
				if err := s.ChangeStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"change_status\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistHistory")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistHistoryChangeStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Total.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Total.Set {
			e.RawStr("\"total\"" + ":")
			s.Total.Encode(e)
		}
	}
	{
		if s.Additions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Additions.Set {
			e.RawStr("\"additions\"" + ":")
			s.Additions.Encode(e)
		}
	}
	{
		if s.Deletions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Deletions.Set {
			e.RawStr("\"deletions\"" + ":")
			s.Deletions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistHistoryChangeStatus = [3]string{
	0: "total",
	1: "additions",
	2: "deletions",
}

// Decode decodes GistHistoryChangeStatus from json.
func (s *GistHistoryChangeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistHistoryChangeStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "additions":
			if err := func() error {
				s.Additions.Reset()
				if err := s.Additions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additions\"")
			}
		case "deletions":
			if err := func() error {
				s.Deletions.Reset()
				if err := s.Deletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistHistoryChangeStatus")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Forks.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Forks.Set {
			e.RawStr("\"forks\"" + ":")
			s.Forks.Encode(e)
		}
	}
	{
		if s.History.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.History.Set {
			e.RawStr("\"history\"" + ":")
			s.History.Encode(e)
		}
	}
	{
		if s.ForkOf.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForkOf.Set {
			e.RawStr("\"fork_of\"" + ":")
			s.ForkOf.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ForksURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForksURL.Set {
			e.RawStr("\"forks_url\"" + ":")
			s.ForksURL.Encode(e)
		}
	}
	{
		if s.CommitsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommitsURL.Set {
			e.RawStr("\"commits_url\"" + ":")
			s.CommitsURL.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.GitPullURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitPullURL.Set {
			e.RawStr("\"git_pull_url\"" + ":")
			s.GitPullURL.Encode(e)
		}
	}
	{
		if s.GitPushURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitPushURL.Set {
			e.RawStr("\"git_push_url\"" + ":")
			s.GitPushURL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Files.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Files.Set {
			e.RawStr("\"files\"" + ":")
			s.Files.Encode(e)
		}
	}
	{
		if s.Public.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Public.Set {
			e.RawStr("\"public\"" + ":")
			s.Public.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Comments.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Comments.Set {
			e.RawStr("\"comments\"" + ":")
			s.Comments.Encode(e)
		}
	}
	{
		if s.User.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	{
		if s.CommentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommentsURL.Set {
			e.RawStr("\"comments_url\"" + ":")
			s.CommentsURL.Encode(e)
		}
	}
	{
		if s.Owner.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Truncated.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Truncated.Set {
			e.RawStr("\"truncated\"" + ":")
			s.Truncated.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistSimple = [21]string{
	0:  "forks",
	1:  "history",
	2:  "fork_of",
	3:  "url",
	4:  "forks_url",
	5:  "commits_url",
	6:  "id",
	7:  "node_id",
	8:  "git_pull_url",
	9:  "git_push_url",
	10: "html_url",
	11: "files",
	12: "public",
	13: "created_at",
	14: "updated_at",
	15: "description",
	16: "comments",
	17: "user",
	18: "comments_url",
	19: "owner",
	20: "truncated",
}

// Decode decodes GistSimple from json.
func (s *GistSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistSimple to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "forks":
			if err := func() error {
				s.Forks.Reset()
				if err := s.Forks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "history":
			if err := func() error {
				s.History.Reset()
				if err := s.History.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history\"")
			}
		case "fork_of":
			if err := func() error {
				s.ForkOf.Reset()
				if err := s.ForkOf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork_of\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "forks_url":
			if err := func() error {
				s.ForksURL.Reset()
				if err := s.ForksURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "commits_url":
			if err := func() error {
				s.CommitsURL.Reset()
				if err := s.CommitsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "git_pull_url":
			if err := func() error {
				s.GitPullURL.Reset()
				if err := s.GitPullURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_pull_url\"")
			}
		case "git_push_url":
			if err := func() error {
				s.GitPushURL.Reset()
				if err := s.GitPushURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_push_url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "files":
			if err := func() error {
				s.Files.Reset()
				if err := s.Files.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "public":
			if err := func() error {
				s.Public.Reset()
				if err := s.Public.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "comments":
			if err := func() error {
				s.Comments.Reset()
				if err := s.Comments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "comments_url":
			if err := func() error {
				s.CommentsURL.Reset()
				if err := s.CommentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "truncated":
			if err := func() error {
				s.Truncated.Reset()
				if err := s.Truncated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"truncated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistSimple")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistSimpleFiles) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistSimpleFiles = [0]string{}

// Decode decodes GistSimpleFiles from json.
func (s GistSimpleFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistSimpleFiles to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem GistSimpleFilesItem
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistSimpleFiles")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistSimpleFilesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Filename.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Filename.Set {
			e.RawStr("\"filename\"" + ":")
			s.Filename.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.Language.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Language.Set {
			e.RawStr("\"language\"" + ":")
			s.Language.Encode(e)
		}
	}
	{
		if s.RawURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RawURL.Set {
			e.RawStr("\"raw_url\"" + ":")
			s.RawURL.Encode(e)
		}
	}
	{
		if s.Size.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Size.Set {
			e.RawStr("\"size\"" + ":")
			s.Size.Encode(e)
		}
	}
	{
		if s.Truncated.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Truncated.Set {
			e.RawStr("\"truncated\"" + ":")
			s.Truncated.Encode(e)
		}
	}
	{
		if s.Content.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Content.Set {
			e.RawStr("\"content\"" + ":")
			s.Content.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistSimpleFilesItem = [7]string{
	0: "filename",
	1: "type",
	2: "language",
	3: "raw_url",
	4: "size",
	5: "truncated",
	6: "content",
}

// Decode decodes GistSimpleFilesItem from json.
func (s *GistSimpleFilesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistSimpleFilesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "filename":
			if err := func() error {
				s.Filename.Reset()
				if err := s.Filename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "raw_url":
			if err := func() error {
				s.RawURL.Reset()
				if err := s.RawURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_url\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "truncated":
			if err := func() error {
				s.Truncated.Reset()
				if err := s.Truncated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"truncated\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistSimpleFilesItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistSimpleForkOf) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		json.EncodeURI(e, s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"git_pull_url\"" + ":")
		json.EncodeURI(e, s.GitPullURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_push_url\"" + ":")
		json.EncodeURI(e, s.GitPushURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"files\"" + ":")
		s.Files.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"public\"" + ":")
		e.Bool(s.Public)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comments\"" + ":")
		e.Int(s.Comments)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		if s.Owner.Set {
			e.Comma()
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Truncated.Set {
			e.Comma()
		}
		if s.Truncated.Set {
			e.RawStr("\"truncated\"" + ":")
			s.Truncated.Encode(e)
		}
	}
	{
		if s.Forks != nil {
			e.Comma()
		}
		if s.Forks != nil {
			e.RawStr("\"forks\"" + ":")
			e.ArrStart()
			if len(s.Forks) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Forks[0]
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
				for _, elem := range s.Forks[1:] {
					e.Comma()
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.History != nil {
			e.Comma()
		}
		if s.History != nil {
			e.RawStr("\"history\"" + ":")
			e.ArrStart()
			if len(s.History) >= 1 {
				// Encode first element without comma.
				{
					elem := s.History[0]
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
				for _, elem := range s.History[1:] {
					e.Comma()
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistSimpleForkOf = [20]string{
	0:  "url",
	1:  "forks_url",
	2:  "commits_url",
	3:  "id",
	4:  "node_id",
	5:  "git_pull_url",
	6:  "git_push_url",
	7:  "html_url",
	8:  "files",
	9:  "public",
	10: "created_at",
	11: "updated_at",
	12: "description",
	13: "comments",
	14: "user",
	15: "comments_url",
	16: "owner",
	17: "truncated",
	18: "forks",
	19: "history",
}

// Decode decodes GistSimpleForkOf from json.
func (s *GistSimpleForkOf) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistSimpleForkOf to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "forks_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "commits_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommitsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "git_pull_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.GitPullURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_pull_url\"")
			}
		case "git_push_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.GitPushURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_push_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "files":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Files = make(GistSimpleForkOfFiles)
				if err := s.Files.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "public":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Public = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "comments":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Comments = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "comments_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "truncated":
			if err := func() error {
				s.Truncated.Reset()
				if err := s.Truncated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"truncated\"")
			}
		case "forks":
			if err := func() error {
				s.Forks = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.Raw()
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Forks = append(s.Forks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "history":
			if err := func() error {
				s.History = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.Raw()
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.History = append(s.History, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistSimpleForkOf")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGistSimpleForkOf) {
					name = jsonFieldsNameOfGistSimpleForkOf[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistSimpleForkOfFiles) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistSimpleForkOfFiles = [0]string{}

// Decode decodes GistSimpleForkOfFiles from json.
func (s GistSimpleForkOfFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistSimpleForkOfFiles to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem GistSimpleForkOfFilesItem
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistSimpleForkOfFiles")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistSimpleForkOfFilesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Filename.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Filename.Set {
			e.RawStr("\"filename\"" + ":")
			s.Filename.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.Language.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Language.Set {
			e.RawStr("\"language\"" + ":")
			s.Language.Encode(e)
		}
	}
	{
		if s.RawURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RawURL.Set {
			e.RawStr("\"raw_url\"" + ":")
			s.RawURL.Encode(e)
		}
	}
	{
		if s.Size.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Size.Set {
			e.RawStr("\"size\"" + ":")
			s.Size.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistSimpleForkOfFilesItem = [5]string{
	0: "filename",
	1: "type",
	2: "language",
	3: "raw_url",
	4: "size",
}

// Decode decodes GistSimpleForkOfFilesItem from json.
func (s *GistSimpleForkOfFilesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistSimpleForkOfFilesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "filename":
			if err := func() error {
				s.Filename.Reset()
				if err := s.Filename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "raw_url":
			if err := func() error {
				s.RawURL.Reset()
				if err := s.RawURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_url\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistSimpleForkOfFilesItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistSimpleForksItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.User.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.User.Set {
			e.RawStr("\"user\"" + ":")
			s.User.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistSimpleForksItem = [5]string{
	0: "id",
	1: "url",
	2: "user",
	3: "created_at",
	4: "updated_at",
}

// Decode decodes GistSimpleForksItem from json.
func (s *GistSimpleForksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistSimpleForksItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistSimpleForksItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistsCheckIsStarredNotFound) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistsCheckIsStarredNotFound = [0]string{}

// Decode decodes GistsCheckIsStarredNotFound from json.
func (s GistsCheckIsStarredNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCheckIsStarredNotFound to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistsCheckIsStarredNotFound")
	}

	return nil
}

// Encode encodes GistsCreateApplicationJSONForbidden as json.
func (s GistsCreateApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsCreateApplicationJSONForbidden from json.
func (s *GistsCreateApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsCreateApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsCreateApplicationJSONNotFound as json.
func (s GistsCreateApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsCreateApplicationJSONNotFound from json.
func (s *GistsCreateApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsCreateApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsCreateCommentApplicationJSONForbidden as json.
func (s GistsCreateCommentApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsCreateCommentApplicationJSONForbidden from json.
func (s *GistsCreateCommentApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateCommentApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsCreateCommentApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsCreateCommentApplicationJSONNotFound as json.
func (s GistsCreateCommentApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsCreateCommentApplicationJSONNotFound from json.
func (s *GistsCreateCommentApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateCommentApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsCreateCommentApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GistsCreateCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistsCreateCommentReq = [1]string{
	0: "body",
}

// Decode decodes GistsCreateCommentReq from json.
func (s *GistsCreateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistsCreateCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGistsCreateCommentReq) {
					name = jsonFieldsNameOfGistsCreateCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistsCreateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"files\"" + ":")
		s.Files.Encode(e)
	}
	{
		if s.Public.Set {
			e.Comma()
		}
		if s.Public.Set {
			e.RawStr("\"public\"" + ":")
			s.Public.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistsCreateReq = [3]string{
	0: "description",
	1: "files",
	2: "public",
}

// Decode decodes GistsCreateReq from json.
func (s *GistsCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "files":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Files = make(GistsCreateReqFiles)
				if err := s.Files.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "public":
			if err := func() error {
				s.Public.Reset()
				if err := s.Public.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistsCreateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGistsCreateReq) {
					name = jsonFieldsNameOfGistsCreateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistsCreateReqFiles) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		elem.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistsCreateReqFiles = [0]string{}

// Decode decodes GistsCreateReqFiles from json.
func (s GistsCreateReqFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateReqFiles to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem GistsCreateReqFilesItem
			if err := func() error {
				if err := elem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistsCreateReqFiles")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GistsCreateReqFilesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		e.Str(s.Content)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistsCreateReqFilesItem = [1]string{
	0: "content",
}

// Decode decodes GistsCreateReqFilesItem from json.
func (s *GistsCreateReqFilesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateReqFilesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistsCreateReqFilesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGistsCreateReqFilesItem) {
					name = jsonFieldsNameOfGistsCreateReqFilesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes GistsCreateReqPublic as json.
func (s GistsCreateReqPublic) Encode(e *jx.Writer) {
	switch s.Type {
	case BoolGistsCreateReqPublic:
		e.Bool(s.Bool)
	case GistsCreateReqPublic1GistsCreateReqPublic:
		s.GistsCreateReqPublic1.Encode(e)
	}
}

// Decode decodes GistsCreateReqPublic from json.
func (s *GistsCreateReqPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateReqPublic to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolGistsCreateReqPublic
	case jx.String:
		if err := s.GistsCreateReqPublic1.Decode(d); err != nil {
			return err
		}
		s.Type = GistsCreateReqPublic1GistsCreateReqPublic
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode encodes GistsCreateReqPublic1 as json.
func (s GistsCreateReqPublic1) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes GistsCreateReqPublic1 from json.
func (s *GistsCreateReqPublic1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsCreateReqPublic1 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GistsCreateReqPublic1(v) {
	case GistsCreateReqPublic1True:
		*s = GistsCreateReqPublic1True
	case GistsCreateReqPublic1False:
		*s = GistsCreateReqPublic1False
	default:
		*s = GistsCreateReqPublic1(v)
	}

	return nil
}

// Encode encodes GistsDeleteApplicationJSONForbidden as json.
func (s GistsDeleteApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteApplicationJSONForbidden from json.
func (s *GistsDeleteApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsDeleteApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsDeleteApplicationJSONNotFound as json.
func (s GistsDeleteApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteApplicationJSONNotFound from json.
func (s *GistsDeleteApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsDeleteApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsDeleteCommentApplicationJSONForbidden as json.
func (s GistsDeleteCommentApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteCommentApplicationJSONForbidden from json.
func (s *GistsDeleteCommentApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsDeleteCommentApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteCommentApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsDeleteCommentApplicationJSONNotFound as json.
func (s GistsDeleteCommentApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteCommentApplicationJSONNotFound from json.
func (s *GistsDeleteCommentApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsDeleteCommentApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteCommentApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsForkApplicationJSONForbidden as json.
func (s GistsForkApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsForkApplicationJSONForbidden from json.
func (s *GistsForkApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsForkApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsForkApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsForkApplicationJSONNotFound as json.
func (s GistsForkApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsForkApplicationJSONNotFound from json.
func (s *GistsForkApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsForkApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsForkApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsGetRevisionApplicationJSONForbidden as json.
func (s GistsGetRevisionApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsGetRevisionApplicationJSONForbidden from json.
func (s *GistsGetRevisionApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsGetRevisionApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsGetRevisionApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsGetRevisionApplicationJSONNotFound as json.
func (s GistsGetRevisionApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsGetRevisionApplicationJSONNotFound from json.
func (s *GistsGetRevisionApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsGetRevisionApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsGetRevisionApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsListCommentsApplicationJSONForbidden as json.
func (s GistsListCommentsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListCommentsApplicationJSONForbidden from json.
func (s *GistsListCommentsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListCommentsApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommentsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsListCommentsApplicationJSONNotFound as json.
func (s GistsListCommentsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListCommentsApplicationJSONNotFound from json.
func (s *GistsListCommentsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListCommentsApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommentsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsListCommentsOKApplicationJSON as json.
func (s GistsListCommentsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []GistComment(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes GistsListCommentsOKApplicationJSON from json.
func (s *GistsListCommentsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListCommentsOKApplicationJSON to nil")
	}
	var unwrapped []GistComment
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GistComment
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommentsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListCommitsApplicationJSONForbidden as json.
func (s GistsListCommitsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListCommitsApplicationJSONForbidden from json.
func (s *GistsListCommitsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListCommitsApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommitsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsListCommitsApplicationJSONNotFound as json.
func (s GistsListCommitsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListCommitsApplicationJSONNotFound from json.
func (s *GistsListCommitsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListCommitsApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommitsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsListCommitsOKApplicationJSON as json.
func (s GistsListCommitsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []GistCommit(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes GistsListCommitsOKApplicationJSON from json.
func (s *GistsListCommitsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListCommitsOKApplicationJSON to nil")
	}
	var unwrapped []GistCommit
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GistCommit
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommitsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListForUserOKApplicationJSON as json.
func (s GistsListForUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []BaseGist(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes GistsListForUserOKApplicationJSON from json.
func (s *GistsListForUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListForUserOKApplicationJSON to nil")
	}
	var unwrapped []BaseGist
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BaseGist
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListForUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListForksApplicationJSONForbidden as json.
func (s GistsListForksApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListForksApplicationJSONForbidden from json.
func (s *GistsListForksApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListForksApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListForksApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsListForksApplicationJSONNotFound as json.
func (s GistsListForksApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListForksApplicationJSONNotFound from json.
func (s *GistsListForksApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListForksApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListForksApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsListForksOKApplicationJSON as json.
func (s GistsListForksOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []GistSimple(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes GistsListForksOKApplicationJSON from json.
func (s *GistsListForksOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListForksOKApplicationJSON to nil")
	}
	var unwrapped []GistSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GistSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListForksOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListOKApplicationJSON as json.
func (s GistsListOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []BaseGist(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes GistsListOKApplicationJSON from json.
func (s *GistsListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListOKApplicationJSON to nil")
	}
	var unwrapped []BaseGist
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BaseGist
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListPublicOKApplicationJSON as json.
func (s GistsListPublicOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []BaseGist(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes GistsListPublicOKApplicationJSON from json.
func (s *GistsListPublicOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListPublicOKApplicationJSON to nil")
	}
	var unwrapped []BaseGist
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BaseGist
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListPublicOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListStarredApplicationJSONForbidden as json.
func (s GistsListStarredApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListStarredApplicationJSONForbidden from json.
func (s *GistsListStarredApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListStarredApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListStarredApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsListStarredApplicationJSONUnauthorized as json.
func (s GistsListStarredApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListStarredApplicationJSONUnauthorized from json.
func (s *GistsListStarredApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListStarredApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListStarredApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes GistsListStarredOKApplicationJSON as json.
func (s GistsListStarredOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []BaseGist(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes GistsListStarredOKApplicationJSON from json.
func (s *GistsListStarredOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsListStarredOKApplicationJSON to nil")
	}
	var unwrapped []BaseGist
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BaseGist
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListStarredOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsStarApplicationJSONForbidden as json.
func (s GistsStarApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsStarApplicationJSONForbidden from json.
func (s *GistsStarApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsStarApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsStarApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsStarApplicationJSONNotFound as json.
func (s GistsStarApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsStarApplicationJSONNotFound from json.
func (s *GistsStarApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsStarApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsStarApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsUnstarApplicationJSONForbidden as json.
func (s GistsUnstarApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsUnstarApplicationJSONForbidden from json.
func (s *GistsUnstarApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsUnstarApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsUnstarApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsUnstarApplicationJSONNotFound as json.
func (s GistsUnstarApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsUnstarApplicationJSONNotFound from json.
func (s *GistsUnstarApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsUnstarApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsUnstarApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GistsUpdateCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGistsUpdateCommentReq = [1]string{
	0: "body",
}

// Decode decodes GistsUpdateCommentReq from json.
func (s *GistsUpdateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GistsUpdateCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GistsUpdateCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGistsUpdateCommentReq) {
					name = jsonFieldsNameOfGistsUpdateCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committer\"" + ":")
		s.Committer.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"tree\"" + ":")
		s.Tree.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"parents\"" + ":")
		e.ArrStart()
		if len(s.Parents) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Parents[0]
				elem.Encode(e)
			}
			for _, elem := range s.Parents[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"verification\"" + ":")
		s.Verification.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitCommit = [10]string{
	0: "sha",
	1: "node_id",
	2: "url",
	3: "author",
	4: "committer",
	5: "message",
	6: "tree",
	7: "parents",
	8: "verification",
	9: "html_url",
}

// Decode decodes GitCommit from json.
func (s *GitCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCommit to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "tree":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Tree.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree\"")
			}
		case "parents":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.Parents = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GitCommitParentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parents = append(s.Parents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parents\"")
			}
		case "verification":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Verification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCommit) {
					name = jsonFieldsNameOfGitCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitCommitAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"date\"" + ":")
		json.EncodeDateTime(e, s.Date)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitCommitAuthor = [3]string{
	0: "date",
	1: "email",
	2: "name",
}

// Decode decodes GitCommitAuthor from json.
func (s *GitCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCommitAuthor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Date = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCommitAuthor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCommitAuthor) {
					name = jsonFieldsNameOfGitCommitAuthor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitCommitCommitter) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"date\"" + ":")
		json.EncodeDateTime(e, s.Date)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitCommitCommitter = [3]string{
	0: "date",
	1: "email",
	2: "name",
}

// Decode decodes GitCommitCommitter from json.
func (s *GitCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCommitCommitter to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Date = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCommitCommitter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCommitCommitter) {
					name = jsonFieldsNameOfGitCommitCommitter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitCommitParentsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitCommitParentsItem = [3]string{
	0: "sha",
	1: "url",
	2: "html_url",
}

// Decode decodes GitCommitParentsItem from json.
func (s *GitCommitParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCommitParentsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCommitParentsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCommitParentsItem) {
					name = jsonFieldsNameOfGitCommitParentsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitCommitTree) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitCommitTree = [2]string{
	0: "sha",
	1: "url",
}

// Decode decodes GitCommitTree from json.
func (s *GitCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCommitTree to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCommitTree")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCommitTree) {
					name = jsonFieldsNameOfGitCommitTree[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitCommitVerification) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"verified\"" + ":")
		e.Bool(s.Verified)
	}
	{
		e.Comma()

		e.RawStr("\"reason\"" + ":")
		e.Str(s.Reason)
	}
	{
		e.Comma()

		e.RawStr("\"signature\"" + ":")
		s.Signature.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitCommitVerification = [4]string{
	0: "verified",
	1: "reason",
	2: "signature",
	3: "payload",
}

// Decode decodes GitCommitVerification from json.
func (s *GitCommitVerification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCommitVerification to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verified":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Verified = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "signature":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Signature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signature\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCommitVerification")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCommitVerification) {
					name = jsonFieldsNameOfGitCommitVerification[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes GitCreateBlobApplicationJSONConflict as json.
func (s GitCreateBlobApplicationJSONConflict) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GitCreateBlobApplicationJSONConflict from json.
func (s *GitCreateBlobApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateBlobApplicationJSONConflict to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitCreateBlobApplicationJSONConflict(unwrapped)
	return nil
}

// Encode encodes GitCreateBlobApplicationJSONForbidden as json.
func (s GitCreateBlobApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GitCreateBlobApplicationJSONForbidden from json.
func (s *GitCreateBlobApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateBlobApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitCreateBlobApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GitCreateBlobApplicationJSONNotFound as json.
func (s GitCreateBlobApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GitCreateBlobApplicationJSONNotFound from json.
func (s *GitCreateBlobApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateBlobApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitCreateBlobApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GitCreateBlobReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		e.Str(s.Content)
	}
	{
		if s.Encoding.Set {
			e.Comma()
		}
		if s.Encoding.Set {
			e.RawStr("\"encoding\"" + ":")
			s.Encoding.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitCreateBlobReq = [2]string{
	0: "content",
	1: "encoding",
}

// Decode decodes GitCreateBlobReq from json.
func (s *GitCreateBlobReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateBlobReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "encoding":
			if err := func() error {
				s.Encoding.Reset()
				if err := s.Encoding.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encoding\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateBlobReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCreateBlobReq) {
					name = jsonFieldsNameOfGitCreateBlobReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitCreateCommitReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"tree\"" + ":")
		e.Str(s.Tree)
	}
	{
		if s.Parents != nil {
			e.Comma()
		}
		if s.Parents != nil {
			e.RawStr("\"parents\"" + ":")
			e.ArrStart()
			if len(s.Parents) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Parents[0]
					e.Str(elem)
				}
				for _, elem := range s.Parents[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Author.Set {
			e.Comma()
		}
		if s.Author.Set {
			e.RawStr("\"author\"" + ":")
			s.Author.Encode(e)
		}
	}
	{
		if s.Committer.Set {
			e.Comma()
		}
		if s.Committer.Set {
			e.RawStr("\"committer\"" + ":")
			s.Committer.Encode(e)
		}
	}
	{
		if s.Signature.Set {
			e.Comma()
		}
		if s.Signature.Set {
			e.RawStr("\"signature\"" + ":")
			s.Signature.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitCreateCommitReq = [6]string{
	0: "message",
	1: "tree",
	2: "parents",
	3: "author",
	4: "committer",
	5: "signature",
}

// Decode decodes GitCreateCommitReq from json.
func (s *GitCreateCommitReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateCommitReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "tree":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tree = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree\"")
			}
		case "parents":
			if err := func() error {
				s.Parents = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Parents = append(s.Parents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parents\"")
			}
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			if err := func() error {
				s.Committer.Reset()
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "signature":
			if err := func() error {
				s.Signature.Reset()
				if err := s.Signature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signature\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateCommitReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCreateCommitReq) {
					name = jsonFieldsNameOfGitCreateCommitReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitCreateCommitReqAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		if s.Date.Set {
			e.Comma()
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitCreateCommitReqAuthor = [3]string{
	0: "name",
	1: "email",
	2: "date",
}

// Decode decodes GitCreateCommitReqAuthor from json.
func (s *GitCreateCommitReqAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateCommitReqAuthor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateCommitReqAuthor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCreateCommitReqAuthor) {
					name = jsonFieldsNameOfGitCreateCommitReqAuthor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitCreateCommitReqCommitter) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Date.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitCreateCommitReqCommitter = [3]string{
	0: "name",
	1: "email",
	2: "date",
}

// Decode decodes GitCreateCommitReqCommitter from json.
func (s *GitCreateCommitReqCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateCommitReqCommitter to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateCommitReqCommitter")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitCreateRefReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		if s.Key.Set {
			e.Comma()
		}
		if s.Key.Set {
			e.RawStr("\"key\"" + ":")
			s.Key.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitCreateRefReq = [3]string{
	0: "ref",
	1: "sha",
	2: "key",
}

// Decode decodes GitCreateRefReq from json.
func (s *GitCreateRefReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateRefReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateRefReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCreateRefReq) {
					name = jsonFieldsNameOfGitCreateRefReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitCreateTagReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"tag\"" + ":")
		e.Str(s.Tag)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"object\"" + ":")
		e.Str(s.Object)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		if s.Tagger.Set {
			e.Comma()
		}
		if s.Tagger.Set {
			e.RawStr("\"tagger\"" + ":")
			s.Tagger.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitCreateTagReq = [5]string{
	0: "tag",
	1: "message",
	2: "object",
	3: "type",
	4: "tagger",
}

// Decode decodes GitCreateTagReq from json.
func (s *GitCreateTagReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTagReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Object = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "tagger":
			if err := func() error {
				s.Tagger.Reset()
				if err := s.Tagger.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagger\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateTagReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCreateTagReq) {
					name = jsonFieldsNameOfGitCreateTagReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitCreateTagReqTagger) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		if s.Date.Set {
			e.Comma()
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitCreateTagReqTagger = [3]string{
	0: "name",
	1: "email",
	2: "date",
}

// Decode decodes GitCreateTagReqTagger from json.
func (s *GitCreateTagReqTagger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTagReqTagger to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateTagReqTagger")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCreateTagReqTagger) {
					name = jsonFieldsNameOfGitCreateTagReqTagger[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes GitCreateTagReqType as json.
func (s GitCreateTagReqType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes GitCreateTagReqType from json.
func (s *GitCreateTagReqType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTagReqType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GitCreateTagReqType(v) {
	case GitCreateTagReqTypeCommit:
		*s = GitCreateTagReqTypeCommit
	case GitCreateTagReqTypeTree:
		*s = GitCreateTagReqTypeTree
	case GitCreateTagReqTypeBlob:
		*s = GitCreateTagReqTypeBlob
	default:
		*s = GitCreateTagReqType(v)
	}

	return nil
}

// Encode encodes GitCreateTreeApplicationJSONForbidden as json.
func (s GitCreateTreeApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GitCreateTreeApplicationJSONForbidden from json.
func (s *GitCreateTreeApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTreeApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitCreateTreeApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GitCreateTreeApplicationJSONNotFound as json.
func (s GitCreateTreeApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GitCreateTreeApplicationJSONNotFound from json.
func (s *GitCreateTreeApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTreeApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitCreateTreeApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GitCreateTreeReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"tree\"" + ":")
		e.ArrStart()
		if len(s.Tree) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Tree[0]
				elem.Encode(e)
			}
			for _, elem := range s.Tree[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.BaseTree.Set {
			e.Comma()
		}
		if s.BaseTree.Set {
			e.RawStr("\"base_tree\"" + ":")
			s.BaseTree.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitCreateTreeReq = [2]string{
	0: "tree",
	1: "base_tree",
}

// Decode decodes GitCreateTreeReq from json.
func (s *GitCreateTreeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTreeReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tree":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Tree = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GitCreateTreeReqTreeItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tree = append(s.Tree, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree\"")
			}
		case "base_tree":
			if err := func() error {
				s.BaseTree.Reset()
				if err := s.BaseTree.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_tree\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateTreeReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitCreateTreeReq) {
					name = jsonFieldsNameOfGitCreateTreeReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitCreateTreeReqTreeItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Path.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Mode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Mode.Set {
			e.RawStr("\"mode\"" + ":")
			s.Mode.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.Content.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Content.Set {
			e.RawStr("\"content\"" + ":")
			s.Content.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitCreateTreeReqTreeItem = [5]string{
	0: "path",
	1: "mode",
	2: "type",
	3: "sha",
	4: "content",
}

// Decode decodes GitCreateTreeReqTreeItem from json.
func (s *GitCreateTreeReqTreeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTreeReqTreeItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitCreateTreeReqTreeItem")
	}

	return nil
}

// Encode encodes GitCreateTreeReqTreeItemMode as json.
func (s GitCreateTreeReqTreeItemMode) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes GitCreateTreeReqTreeItemMode from json.
func (s *GitCreateTreeReqTreeItemMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTreeReqTreeItemMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GitCreateTreeReqTreeItemMode(v) {
	case GitCreateTreeReqTreeItemMode100644:
		*s = GitCreateTreeReqTreeItemMode100644
	case GitCreateTreeReqTreeItemMode100755:
		*s = GitCreateTreeReqTreeItemMode100755
	case GitCreateTreeReqTreeItemMode040000:
		*s = GitCreateTreeReqTreeItemMode040000
	case GitCreateTreeReqTreeItemMode160000:
		*s = GitCreateTreeReqTreeItemMode160000
	case GitCreateTreeReqTreeItemMode120000:
		*s = GitCreateTreeReqTreeItemMode120000
	default:
		*s = GitCreateTreeReqTreeItemMode(v)
	}

	return nil
}

// Encode encodes GitCreateTreeReqTreeItemType as json.
func (s GitCreateTreeReqTreeItemType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes GitCreateTreeReqTreeItemType from json.
func (s *GitCreateTreeReqTreeItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitCreateTreeReqTreeItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GitCreateTreeReqTreeItemType(v) {
	case GitCreateTreeReqTreeItemTypeBlob:
		*s = GitCreateTreeReqTreeItemTypeBlob
	case GitCreateTreeReqTreeItemTypeTree:
		*s = GitCreateTreeReqTreeItemTypeTree
	case GitCreateTreeReqTreeItemTypeCommit:
		*s = GitCreateTreeReqTreeItemTypeCommit
	default:
		*s = GitCreateTreeReqTreeItemType(v)
	}

	return nil
}

// Encode encodes GitGetBlobApplicationJSONForbidden as json.
func (s GitGetBlobApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GitGetBlobApplicationJSONForbidden from json.
func (s *GitGetBlobApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitGetBlobApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitGetBlobApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GitGetBlobApplicationJSONNotFound as json.
func (s GitGetBlobApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GitGetBlobApplicationJSONNotFound from json.
func (s *GitGetBlobApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitGetBlobApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitGetBlobApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GitRef) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"object\"" + ":")
		s.Object.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitRef = [4]string{
	0: "ref",
	1: "node_id",
	2: "url",
	3: "object",
}

// Decode decodes GitRef from json.
func (s *GitRef) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitRef to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitRef")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitRef) {
					name = jsonFieldsNameOfGitRef[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitRefObject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitRefObject = [3]string{
	0: "type",
	1: "sha",
	2: "url",
}

// Decode decodes GitRefObject from json.
func (s *GitRefObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitRefObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitRefObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitRefObject) {
					name = jsonFieldsNameOfGitRefObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitTag) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"tag\"" + ":")
		e.Str(s.Tag)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"tagger\"" + ":")
		s.Tagger.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"object\"" + ":")
		s.Object.Encode(e)
	}
	{
		if s.Verification.Set {
			e.Comma()
		}
		if s.Verification.Set {
			e.RawStr("\"verification\"" + ":")
			s.Verification.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitTag = [8]string{
	0: "node_id",
	1: "tag",
	2: "sha",
	3: "url",
	4: "message",
	5: "tagger",
	6: "object",
	7: "verification",
}

// Decode decodes GitTag from json.
func (s *GitTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitTag to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "node_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "tagger":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Tagger.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagger\"")
			}
		case "object":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "verification":
			if err := func() error {
				s.Verification.Reset()
				if err := s.Verification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitTag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitTag) {
					name = jsonFieldsNameOfGitTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitTagObject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitTagObject = [3]string{
	0: "sha",
	1: "type",
	2: "url",
}

// Decode decodes GitTagObject from json.
func (s *GitTagObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitTagObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitTagObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitTagObject) {
					name = jsonFieldsNameOfGitTagObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitTagTagger) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"date\"" + ":")
		e.Str(s.Date)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitTagTagger = [3]string{
	0: "date",
	1: "email",
	2: "name",
}

// Decode decodes GitTagTagger from json.
func (s *GitTagTagger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitTagTagger to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitTagTagger")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitTagTagger) {
					name = jsonFieldsNameOfGitTagTagger[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitTree) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"truncated\"" + ":")
		e.Bool(s.Truncated)
	}
	{
		e.Comma()

		e.RawStr("\"tree\"" + ":")
		e.ArrStart()
		if len(s.Tree) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Tree[0]
				elem.Encode(e)
			}
			for _, elem := range s.Tree[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitTree = [4]string{
	0: "sha",
	1: "url",
	2: "truncated",
	3: "tree",
}

// Decode decodes GitTree from json.
func (s *GitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitTree to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "truncated":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Truncated = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"truncated\"")
			}
		case "tree":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Tree = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GitTreeTreeItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tree = append(s.Tree, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitTree")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitTree) {
					name = jsonFieldsNameOfGitTree[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitTreeTreeItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Path.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Mode.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Mode.Set {
			e.RawStr("\"mode\"" + ":")
			s.Mode.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.Size.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Size.Set {
			e.RawStr("\"size\"" + ":")
			s.Size.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitTreeTreeItem = [6]string{
	0: "path",
	1: "mode",
	2: "type",
	3: "sha",
	4: "size",
	5: "url",
}

// Decode decodes GitTreeTreeItem from json.
func (s *GitTreeTreeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitTreeTreeItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitTreeTreeItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GitUpdateRefReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		if s.Force.Set {
			e.Comma()
		}
		if s.Force.Set {
			e.RawStr("\"force\"" + ":")
			s.Force.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitUpdateRefReq = [2]string{
	0: "sha",
	1: "force",
}

// Decode decodes GitUpdateRefReq from json.
func (s *GitUpdateRefReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitUpdateRefReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "force":
			if err := func() error {
				s.Force.Reset()
				if err := s.Force.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitUpdateRefReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitUpdateRefReq) {
					name = jsonFieldsNameOfGitUpdateRefReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes GitignoreGetAllTemplatesOKApplicationJSON as json.
func (s GitignoreGetAllTemplatesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []string(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			e.Str(elem)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			e.Str(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes GitignoreGetAllTemplatesOKApplicationJSON from json.
func (s *GitignoreGetAllTemplatesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitignoreGetAllTemplatesOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitignoreGetAllTemplatesOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GitignoreTemplate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"source\"" + ":")
		e.Str(s.Source)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGitignoreTemplate = [2]string{
	0: "name",
	1: "source",
}

// Decode decodes GitignoreTemplate from json.
func (s *GitignoreTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GitignoreTemplate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GitignoreTemplate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGitignoreTemplate) {
					name = jsonFieldsNameOfGitignoreTemplate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GpgKey) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"primary_key_id\"" + ":")
		s.PrimaryKeyID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"key_id\"" + ":")
		e.Str(s.KeyID)
	}
	{
		e.Comma()

		e.RawStr("\"public_key\"" + ":")
		e.Str(s.PublicKey)
	}
	{
		e.Comma()

		e.RawStr("\"emails\"" + ":")
		e.ArrStart()
		if len(s.Emails) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Emails[0]
				elem.Encode(e)
			}
			for _, elem := range s.Emails[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"subkeys\"" + ":")
		e.ArrStart()
		if len(s.Subkeys) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Subkeys[0]
				elem.Encode(e)
			}
			for _, elem := range s.Subkeys[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"can_sign\"" + ":")
		e.Bool(s.CanSign)
	}
	{
		e.Comma()

		e.RawStr("\"can_encrypt_comms\"" + ":")
		e.Bool(s.CanEncryptComms)
	}
	{
		e.Comma()

		e.RawStr("\"can_encrypt_storage\"" + ":")
		e.Bool(s.CanEncryptStorage)
	}
	{
		e.Comma()

		e.RawStr("\"can_certify\"" + ":")
		e.Bool(s.CanCertify)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"expires_at\"" + ":")
		s.ExpiresAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"raw_key\"" + ":")
		s.RawKey.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGpgKey = [13]string{
	0:  "id",
	1:  "primary_key_id",
	2:  "key_id",
	3:  "public_key",
	4:  "emails",
	5:  "subkeys",
	6:  "can_sign",
	7:  "can_encrypt_comms",
	8:  "can_encrypt_storage",
	9:  "can_certify",
	10: "created_at",
	11: "expires_at",
	12: "raw_key",
}

// Decode decodes GpgKey from json.
func (s *GpgKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GpgKey to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "primary_key_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PrimaryKeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary_key_id\"")
			}
		case "key_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.KeyID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_id\"")
			}
		case "public_key":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.PublicKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_key\"")
			}
		case "emails":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Emails = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GpgKeyEmailsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		case "subkeys":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Subkeys = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GpgKeySubkeysItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subkeys = append(s.Subkeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subkeys\"")
			}
		case "can_sign":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.CanSign = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_sign\"")
			}
		case "can_encrypt_comms":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.CanEncryptComms = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_encrypt_comms\"")
			}
		case "can_encrypt_storage":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CanEncryptStorage = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_encrypt_storage\"")
			}
		case "can_certify":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.CanCertify = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_certify\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "expires_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "raw_key":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.RawKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GpgKey")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGpgKey) {
					name = jsonFieldsNameOfGpgKey[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GpgKeyEmailsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Verified.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Verified.Set {
			e.RawStr("\"verified\"" + ":")
			s.Verified.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGpgKeyEmailsItem = [2]string{
	0: "email",
	1: "verified",
}

// Decode decodes GpgKeyEmailsItem from json.
func (s *GpgKeyEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GpgKeyEmailsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "verified":
			if err := func() error {
				s.Verified.Reset()
				if err := s.Verified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GpgKeyEmailsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GpgKeySubkeysItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.PrimaryKeyID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PrimaryKeyID.Set {
			e.RawStr("\"primary_key_id\"" + ":")
			s.PrimaryKeyID.Encode(e)
		}
	}
	{
		if s.KeyID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.KeyID.Set {
			e.RawStr("\"key_id\"" + ":")
			s.KeyID.Encode(e)
		}
	}
	{
		if s.PublicKey.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PublicKey.Set {
			e.RawStr("\"public_key\"" + ":")
			s.PublicKey.Encode(e)
		}
	}
	{
		if s.Emails != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Emails != nil {
			e.RawStr("\"emails\"" + ":")
			e.ArrStart()
			if len(s.Emails) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Emails[0]
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
				for _, elem := range s.Emails[1:] {
					e.Comma()
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Subkeys != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Subkeys != nil {
			e.RawStr("\"subkeys\"" + ":")
			e.ArrStart()
			if len(s.Subkeys) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Subkeys[0]
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
				for _, elem := range s.Subkeys[1:] {
					e.Comma()
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.CanSign.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanSign.Set {
			e.RawStr("\"can_sign\"" + ":")
			s.CanSign.Encode(e)
		}
	}
	{
		if s.CanEncryptComms.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanEncryptComms.Set {
			e.RawStr("\"can_encrypt_comms\"" + ":")
			s.CanEncryptComms.Encode(e)
		}
	}
	{
		if s.CanEncryptStorage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanEncryptStorage.Set {
			e.RawStr("\"can_encrypt_storage\"" + ":")
			s.CanEncryptStorage.Encode(e)
		}
	}
	{
		if s.CanCertify.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CanCertify.Set {
			e.RawStr("\"can_certify\"" + ":")
			s.CanCertify.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.ExpiresAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExpiresAt.Set {
			e.RawStr("\"expires_at\"" + ":")
			s.ExpiresAt.Encode(e)
		}
	}
	{
		if s.RawKey.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RawKey.Set {
			e.RawStr("\"raw_key\"" + ":")
			s.RawKey.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGpgKeySubkeysItem = [13]string{
	0:  "id",
	1:  "primary_key_id",
	2:  "key_id",
	3:  "public_key",
	4:  "emails",
	5:  "subkeys",
	6:  "can_sign",
	7:  "can_encrypt_comms",
	8:  "can_encrypt_storage",
	9:  "can_certify",
	10: "created_at",
	11: "expires_at",
	12: "raw_key",
}

// Decode decodes GpgKeySubkeysItem from json.
func (s *GpgKeySubkeysItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GpgKeySubkeysItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "primary_key_id":
			if err := func() error {
				s.PrimaryKeyID.Reset()
				if err := s.PrimaryKeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary_key_id\"")
			}
		case "key_id":
			if err := func() error {
				s.KeyID.Reset()
				if err := s.KeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_id\"")
			}
		case "public_key":
			if err := func() error {
				s.PublicKey.Reset()
				if err := s.PublicKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_key\"")
			}
		case "emails":
			if err := func() error {
				s.Emails = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.Raw()
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		case "subkeys":
			if err := func() error {
				s.Subkeys = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.Raw()
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Subkeys = append(s.Subkeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subkeys\"")
			}
		case "can_sign":
			if err := func() error {
				s.CanSign.Reset()
				if err := s.CanSign.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_sign\"")
			}
		case "can_encrypt_comms":
			if err := func() error {
				s.CanEncryptComms.Reset()
				if err := s.CanEncryptComms.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_encrypt_comms\"")
			}
		case "can_encrypt_storage":
			if err := func() error {
				s.CanEncryptStorage.Reset()
				if err := s.CanEncryptStorage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_encrypt_storage\"")
			}
		case "can_certify":
			if err := func() error {
				s.CanCertify.Reset()
				if err := s.CanCertify.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_certify\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "raw_key":
			if err := func() error {
				s.RawKey.Reset()
				if err := s.RawKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"raw_key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GpgKeySubkeysItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GroupMapping) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Groups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					elem.Encode(e)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGroupMapping = [1]string{
	0: "groups",
}

// Decode decodes GroupMapping from json.
func (s *GroupMapping) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupMapping to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups":
			if err := func() error {
				s.Groups = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GroupMappingGroupsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupMapping")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s GroupMappingGroupsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"group_id\"" + ":")
		e.Str(s.GroupID)
	}
	{
		e.Comma()

		e.RawStr("\"group_name\"" + ":")
		e.Str(s.GroupName)
	}
	{
		e.Comma()

		e.RawStr("\"group_description\"" + ":")
		e.Str(s.GroupDescription)
	}
	{
		if s.Status.Set {
			e.Comma()
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	{
		if s.SyncedAt.Set {
			e.Comma()
		}
		if s.SyncedAt.Set {
			e.RawStr("\"synced_at\"" + ":")
			s.SyncedAt.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfGroupMappingGroupsItem = [5]string{
	0: "group_id",
	1: "group_name",
	2: "group_description",
	3: "status",
	4: "synced_at",
}

// Decode decodes GroupMappingGroupsItem from json.
func (s *GroupMappingGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupMappingGroupsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GroupID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_id\"")
			}
		case "group_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GroupName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_name\"")
			}
		case "group_description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GroupDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_description\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "synced_at":
			if err := func() error {
				s.SyncedAt.Reset()
				if err := s.SyncedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synced_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupMappingGroupsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGroupMappingGroupsItem) {
					name = jsonFieldsNameOfGroupMappingGroupsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Hook) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"active\"" + ":")
		e.Bool(s.Active)
	}
	{
		e.Comma()

		e.RawStr("\"events\"" + ":")
		e.ArrStart()
		if len(s.Events) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Events[0]
				e.Str(elem)
			}
			for _, elem := range s.Events[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"config\"" + ":")
		s.Config.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"test_url\"" + ":")
		json.EncodeURI(e, s.TestURL)
	}
	{
		e.Comma()

		e.RawStr("\"ping_url\"" + ":")
		json.EncodeURI(e, s.PingURL)
	}
	{
		if s.DeliveriesURL.Set {
			e.Comma()
		}
		if s.DeliveriesURL.Set {
			e.RawStr("\"deliveries_url\"" + ":")
			s.DeliveriesURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"last_response\"" + ":")
		s.LastResponse.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfHook = [13]string{
	0:  "type",
	1:  "id",
	2:  "name",
	3:  "active",
	4:  "events",
	5:  "config",
	6:  "updated_at",
	7:  "created_at",
	8:  "url",
	9:  "test_url",
	10: "ping_url",
	11: "deliveries_url",
	12: "last_response",
}

// Decode decodes Hook from json.
func (s *Hook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Hook to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "active":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Active = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "events":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Events = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "test_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TestURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test_url\"")
			}
		case "ping_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PingURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ping_url\"")
			}
		case "deliveries_url":
			if err := func() error {
				s.DeliveriesURL.Reset()
				if err := s.DeliveriesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deliveries_url\"")
			}
		case "last_response":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.LastResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Hook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHook) {
					name = jsonFieldsNameOfHook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s HookConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Password.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Password.Set {
			e.RawStr("\"password\"" + ":")
			s.Password.Encode(e)
		}
	}
	{
		if s.Room.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Room.Set {
			e.RawStr("\"room\"" + ":")
			s.Room.Encode(e)
		}
	}
	{
		if s.Subdomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Subdomain.Set {
			e.RawStr("\"subdomain\"" + ":")
			s.Subdomain.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Digest.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Digest.Set {
			e.RawStr("\"digest\"" + ":")
			s.Digest.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.Token.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Token.Set {
			e.RawStr("\"token\"" + ":")
			s.Token.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfHookConfig = [10]string{
	0: "email",
	1: "password",
	2: "room",
	3: "subdomain",
	4: "url",
	5: "insecure_ssl",
	6: "content_type",
	7: "digest",
	8: "secret",
	9: "token",
}

// Decode decodes HookConfig from json.
func (s *HookConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "room":
			if err := func() error {
				s.Room.Reset()
				if err := s.Room.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"room\"")
			}
		case "subdomain":
			if err := func() error {
				s.Subdomain.Reset()
				if err := s.Subdomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subdomain\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "digest":
			if err := func() error {
				s.Digest.Reset()
				if err := s.Digest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"digest\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "token":
			if err := func() error {
				s.Token.Reset()
				if err := s.Token.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookConfig")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s HookDelivery) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"guid\"" + ":")
		e.Str(s.GUID)
	}
	{
		e.Comma()

		e.RawStr("\"delivered_at\"" + ":")
		json.EncodeDateTime(e, s.DeliveredAt)
	}
	{
		e.Comma()

		e.RawStr("\"redelivery\"" + ":")
		e.Bool(s.Redelivery)
	}
	{
		e.Comma()

		e.RawStr("\"duration\"" + ":")
		e.Float64(s.Duration)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"status_code\"" + ":")
		e.Int(s.StatusCode)
	}
	{
		e.Comma()

		e.RawStr("\"event\"" + ":")
		e.Str(s.Event)
	}
	{
		e.Comma()

		e.RawStr("\"action\"" + ":")
		s.Action.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"installation_id\"" + ":")
		s.InstallationID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"repository_id\"" + ":")
		s.RepositoryID.Encode(e)
	}
	{
		if s.URL.Set {
			e.Comma()
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"request\"" + ":")
		s.Request.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"response\"" + ":")
		s.Response.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfHookDelivery = [14]string{
	0:  "id",
	1:  "guid",
	2:  "delivered_at",
	3:  "redelivery",
	4:  "duration",
	5:  "status",
	6:  "status_code",
	7:  "event",
	8:  "action",
	9:  "installation_id",
	10: "repository_id",
	11: "url",
	12: "request",
	13: "response",
}

// Decode decodes HookDelivery from json.
func (s *HookDelivery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookDelivery to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "guid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guid\"")
			}
		case "delivered_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DeliveredAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delivered_at\"")
			}
		case "redelivery":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Redelivery = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redelivery\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Duration = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "status_code":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.StatusCode = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_code\"")
			}
		case "event":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Event = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		case "action":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "installation_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.InstallationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"installation_id\"")
			}
		case "repository_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.RepositoryID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "request":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Request.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request\"")
			}
		case "response":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookDelivery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHookDelivery) {
					name = jsonFieldsNameOfHookDelivery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s HookDeliveryItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"guid\"" + ":")
		e.Str(s.GUID)
	}
	{
		e.Comma()

		e.RawStr("\"delivered_at\"" + ":")
		json.EncodeDateTime(e, s.DeliveredAt)
	}
	{
		e.Comma()

		e.RawStr("\"redelivery\"" + ":")
		e.Bool(s.Redelivery)
	}
	{
		e.Comma()

		e.RawStr("\"duration\"" + ":")
		e.Float64(s.Duration)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"status_code\"" + ":")
		e.Int(s.StatusCode)
	}
	{
		e.Comma()

		e.RawStr("\"event\"" + ":")
		e.Str(s.Event)
	}
	{
		e.Comma()

		e.RawStr("\"action\"" + ":")
		s.Action.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"installation_id\"" + ":")
		s.InstallationID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"repository_id\"" + ":")
		s.RepositoryID.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfHookDeliveryItem = [11]string{
	0:  "id",
	1:  "guid",
	2:  "delivered_at",
	3:  "redelivery",
	4:  "duration",
	5:  "status",
	6:  "status_code",
	7:  "event",
	8:  "action",
	9:  "installation_id",
	10: "repository_id",
}

// Decode decodes HookDeliveryItem from json.
func (s *HookDeliveryItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookDeliveryItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "guid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guid\"")
			}
		case "delivered_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DeliveredAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delivered_at\"")
			}
		case "redelivery":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Redelivery = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redelivery\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Duration = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "status_code":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.StatusCode = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_code\"")
			}
		case "event":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Event = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		case "action":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "installation_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.InstallationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"installation_id\"")
			}
		case "repository_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.RepositoryID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookDeliveryItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHookDeliveryItem) {
					name = jsonFieldsNameOfHookDeliveryItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s HookDeliveryRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"headers\"" + ":")
		s.Headers.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfHookDeliveryRequest = [2]string{
	0: "headers",
	1: "payload",
}

// Decode decodes HookDeliveryRequest from json.
func (s *HookDeliveryRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookDeliveryRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookDeliveryRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHookDeliveryRequest) {
					name = jsonFieldsNameOfHookDeliveryRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s HookDeliveryRequestHeaders) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfHookDeliveryRequestHeaders = [0]string{}

// Decode decodes HookDeliveryRequestHeaders from json.
func (s HookDeliveryRequestHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookDeliveryRequestHeaders to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookDeliveryRequestHeaders")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s HookDeliveryRequestPayload) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfHookDeliveryRequestPayload = [0]string{}

// Decode decodes HookDeliveryRequestPayload from json.
func (s HookDeliveryRequestPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookDeliveryRequestPayload to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookDeliveryRequestPayload")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s HookDeliveryResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"headers\"" + ":")
		s.Headers.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfHookDeliveryResponse = [2]string{
	0: "headers",
	1: "payload",
}

// Decode decodes HookDeliveryResponse from json.
func (s *HookDeliveryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookDeliveryResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookDeliveryResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHookDeliveryResponse) {
					name = jsonFieldsNameOfHookDeliveryResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s HookDeliveryResponseHeaders) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfHookDeliveryResponseHeaders = [0]string{}

// Decode decodes HookDeliveryResponseHeaders from json.
func (s HookDeliveryResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookDeliveryResponseHeaders to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookDeliveryResponseHeaders")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s HookResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		s.Code.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		s.Message.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfHookResponse = [3]string{
	0: "code",
	1: "status",
	2: "message",
}

// Decode decodes HookResponse from json.
func (s *HookResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HookResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HookResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHookResponse) {
					name = jsonFieldsNameOfHookResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Hovercard) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"contexts\"" + ":")
		e.ArrStart()
		if len(s.Contexts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Contexts[0]
				elem.Encode(e)
			}
			for _, elem := range s.Contexts[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfHovercard = [1]string{
	0: "contexts",
}

// Decode decodes Hovercard from json.
func (s *Hovercard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Hovercard to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contexts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Contexts = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HovercardContextsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Hovercard")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHovercard) {
					name = jsonFieldsNameOfHovercard[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s HovercardContextsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"octicon\"" + ":")
		e.Str(s.Octicon)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfHovercardContextsItem = [2]string{
	0: "message",
	1: "octicon",
}

// Decode decodes HovercardContextsItem from json.
func (s *HovercardContextsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HovercardContextsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "octicon":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Octicon = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"octicon\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HovercardContextsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHovercardContextsItem) {
					name = jsonFieldsNameOfHovercardContextsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Import) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"vcs\"" + ":")
		s.Vcs.Encode(e)
	}
	{
		if s.UseLfs.Set {
			e.Comma()
		}
		if s.UseLfs.Set {
			e.RawStr("\"use_lfs\"" + ":")
			s.UseLfs.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"vcs_url\"" + ":")
		e.Str(s.VcsURL)
	}
	{
		if s.SvcRoot.Set {
			e.Comma()
		}
		if s.SvcRoot.Set {
			e.RawStr("\"svc_root\"" + ":")
			s.SvcRoot.Encode(e)
		}
	}
	{
		if s.TfvcProject.Set {
			e.Comma()
		}
		if s.TfvcProject.Set {
			e.RawStr("\"tfvc_project\"" + ":")
			s.TfvcProject.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		if s.StatusText.Set {
			e.Comma()
		}
		if s.StatusText.Set {
			e.RawStr("\"status_text\"" + ":")
			s.StatusText.Encode(e)
		}
	}
	{
		if s.FailedStep.Set {
			e.Comma()
		}
		if s.FailedStep.Set {
			e.RawStr("\"failed_step\"" + ":")
			s.FailedStep.Encode(e)
		}
	}
	{
		if s.ErrorMessage.Set {
			e.Comma()
		}
		if s.ErrorMessage.Set {
			e.RawStr("\"error_message\"" + ":")
			s.ErrorMessage.Encode(e)
		}
	}
	{
		if s.ImportPercent.Set {
			e.Comma()
		}
		if s.ImportPercent.Set {
			e.RawStr("\"import_percent\"" + ":")
			s.ImportPercent.Encode(e)
		}
	}
	{
		if s.CommitCount.Set {
			e.Comma()
		}
		if s.CommitCount.Set {
			e.RawStr("\"commit_count\"" + ":")
			s.CommitCount.Encode(e)
		}
	}
	{
		if s.PushPercent.Set {
			e.Comma()
		}
		if s.PushPercent.Set {
			e.RawStr("\"push_percent\"" + ":")
			s.PushPercent.Encode(e)
		}
	}
	{
		if s.HasLargeFiles.Set {
			e.Comma()
		}
		if s.HasLargeFiles.Set {
			e.RawStr("\"has_large_files\"" + ":")
			s.HasLargeFiles.Encode(e)
		}
	}
	{
		if s.LargeFilesSize.Set {
			e.Comma()
		}
		if s.LargeFilesSize.Set {
			e.RawStr("\"large_files_size\"" + ":")
			s.LargeFilesSize.Encode(e)
		}
	}
	{
		if s.LargeFilesCount.Set {
			e.Comma()
		}
		if s.LargeFilesCount.Set {
			e.RawStr("\"large_files_count\"" + ":")
			s.LargeFilesCount.Encode(e)
		}
	}
	{
		if s.ProjectChoices != nil {
			e.Comma()
		}
		if s.ProjectChoices != nil {
			e.RawStr("\"project_choices\"" + ":")
			e.ArrStart()
			if len(s.ProjectChoices) >= 1 {
				// Encode first element without comma.
				{
					elem := s.ProjectChoices[0]
					elem.Encode(e)
				}
				for _, elem := range s.ProjectChoices[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Message.Set {
			e.Comma()
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.AuthorsCount.Set {
			e.Comma()
		}
		if s.AuthorsCount.Set {
			e.RawStr("\"authors_count\"" + ":")
			s.AuthorsCount.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"authors_url\"" + ":")
		json.EncodeURI(e, s.AuthorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		if s.SvnRoot.Set {
			e.Comma()
		}
		if s.SvnRoot.Set {
			e.RawStr("\"svn_root\"" + ":")
			s.SvnRoot.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfImport = [23]string{
	0:  "vcs",
	1:  "use_lfs",
	2:  "vcs_url",
	3:  "svc_root",
	4:  "tfvc_project",
	5:  "status",
	6:  "status_text",
	7:  "failed_step",
	8:  "error_message",
	9:  "import_percent",
	10: "commit_count",
	11: "push_percent",
	12: "has_large_files",
	13: "large_files_size",
	14: "large_files_count",
	15: "project_choices",
	16: "message",
	17: "authors_count",
	18: "url",
	19: "html_url",
	20: "authors_url",
	21: "repository_url",
	22: "svn_root",
}

// Decode decodes Import from json.
func (s *Import) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Import to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Vcs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs\"")
			}
		case "use_lfs":
			if err := func() error {
				s.UseLfs.Reset()
				if err := s.UseLfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_lfs\"")
			}
		case "vcs_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VcsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs_url\"")
			}
		case "svc_root":
			if err := func() error {
				s.SvcRoot.Reset()
				if err := s.SvcRoot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svc_root\"")
			}
		case "tfvc_project":
			if err := func() error {
				s.TfvcProject.Reset()
				if err := s.TfvcProject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tfvc_project\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "status_text":
			if err := func() error {
				s.StatusText.Reset()
				if err := s.StatusText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_text\"")
			}
		case "failed_step":
			if err := func() error {
				s.FailedStep.Reset()
				if err := s.FailedStep.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_step\"")
			}
		case "error_message":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		case "import_percent":
			if err := func() error {
				s.ImportPercent.Reset()
				if err := s.ImportPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"import_percent\"")
			}
		case "commit_count":
			if err := func() error {
				s.CommitCount.Reset()
				if err := s.CommitCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_count\"")
			}
		case "push_percent":
			if err := func() error {
				s.PushPercent.Reset()
				if err := s.PushPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push_percent\"")
			}
		case "has_large_files":
			if err := func() error {
				s.HasLargeFiles.Reset()
				if err := s.HasLargeFiles.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_large_files\"")
			}
		case "large_files_size":
			if err := func() error {
				s.LargeFilesSize.Reset()
				if err := s.LargeFilesSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"large_files_size\"")
			}
		case "large_files_count":
			if err := func() error {
				s.LargeFilesCount.Reset()
				if err := s.LargeFilesCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"large_files_count\"")
			}
		case "project_choices":
			if err := func() error {
				s.ProjectChoices = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ImportProjectChoicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ProjectChoices = append(s.ProjectChoices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_choices\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "authors_count":
			if err := func() error {
				s.AuthorsCount.Reset()
				if err := s.AuthorsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authors_count\"")
			}
		case "url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "authors_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AuthorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authors_url\"")
			}
		case "repository_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "svn_root":
			if err := func() error {
				s.SvnRoot.Reset()
				if err := s.SvnRoot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_root\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Import")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00100101,
		0b00000000,
		0b00111100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfImport) {
					name = jsonFieldsNameOfImport[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ImportProjectChoicesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Vcs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Vcs.Set {
			e.RawStr("\"vcs\"" + ":")
			s.Vcs.Encode(e)
		}
	}
	{
		if s.TfvcProject.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TfvcProject.Set {
			e.RawStr("\"tfvc_project\"" + ":")
			s.TfvcProject.Encode(e)
		}
	}
	{
		if s.HumanName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HumanName.Set {
			e.RawStr("\"human_name\"" + ":")
			s.HumanName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfImportProjectChoicesItem = [3]string{
	0: "vcs",
	1: "tfvc_project",
	2: "human_name",
}

// Decode decodes ImportProjectChoicesItem from json.
func (s *ImportProjectChoicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ImportProjectChoicesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs":
			if err := func() error {
				s.Vcs.Reset()
				if err := s.Vcs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs\"")
			}
		case "tfvc_project":
			if err := func() error {
				s.TfvcProject.Reset()
				if err := s.TfvcProject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tfvc_project\"")
			}
		case "human_name":
			if err := func() error {
				s.HumanName.Reset()
				if err := s.HumanName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"human_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ImportProjectChoicesItem")
	}

	return nil
}

// Encode encodes ImportStatus as json.
func (s ImportStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ImportStatus from json.
func (s *ImportStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ImportStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ImportStatus(v) {
	case ImportStatusAuth:
		*s = ImportStatusAuth
	case ImportStatusError:
		*s = ImportStatusError
	case ImportStatusNone:
		*s = ImportStatusNone
	case ImportStatusDetecting:
		*s = ImportStatusDetecting
	case ImportStatusChoose:
		*s = ImportStatusChoose
	case ImportStatusAuthFailed:
		*s = ImportStatusAuthFailed
	case ImportStatusImporting:
		*s = ImportStatusImporting
	case ImportStatusMapping:
		*s = ImportStatusMapping
	case ImportStatusWaitingToPush:
		*s = ImportStatusWaitingToPush
	case ImportStatusPushing:
		*s = ImportStatusPushing
	case ImportStatusComplete:
		*s = ImportStatusComplete
	case ImportStatusSetup:
		*s = ImportStatusSetup
	case ImportStatusUnknown:
		*s = ImportStatusUnknown
	case ImportStatusDetectionFoundMultiple:
		*s = ImportStatusDetectionFoundMultiple
	case ImportStatusDetectionFoundNothing:
		*s = ImportStatusDetectionFoundNothing
	case ImportStatusDetectionNeedsAuth:
		*s = ImportStatusDetectionNeedsAuth
	default:
		*s = ImportStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InstallationToken) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"token\"" + ":")
		e.Str(s.Token)
	}
	{
		e.Comma()

		e.RawStr("\"expires_at\"" + ":")
		e.Str(s.ExpiresAt)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.RepositorySelection.Set {
			e.Comma()
		}
		if s.RepositorySelection.Set {
			e.RawStr("\"repository_selection\"" + ":")
			s.RepositorySelection.Encode(e)
		}
	}
	{
		if s.Repositories != nil {
			e.Comma()
		}
		if s.Repositories != nil {
			e.RawStr("\"repositories\"" + ":")
			e.ArrStart()
			if len(s.Repositories) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Repositories[0]
					elem.Encode(e)
				}
				for _, elem := range s.Repositories[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.SingleFile.Set {
			e.Comma()
		}
		if s.SingleFile.Set {
			e.RawStr("\"single_file\"" + ":")
			s.SingleFile.Encode(e)
		}
	}
	{
		if s.HasMultipleSingleFiles.Set {
			e.Comma()
		}
		if s.HasMultipleSingleFiles.Set {
			e.RawStr("\"has_multiple_single_files\"" + ":")
			s.HasMultipleSingleFiles.Encode(e)
		}
	}
	{
		if s.SingleFilePaths != nil {
			e.Comma()
		}
		if s.SingleFilePaths != nil {
			e.RawStr("\"single_file_paths\"" + ":")
			e.ArrStart()
			if len(s.SingleFilePaths) >= 1 {
				// Encode first element without comma.
				{
					elem := s.SingleFilePaths[0]
					e.Str(elem)
				}
				for _, elem := range s.SingleFilePaths[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInstallationToken = [8]string{
	0: "token",
	1: "expires_at",
	2: "permissions",
	3: "repository_selection",
	4: "repositories",
	5: "single_file",
	6: "has_multiple_single_files",
	7: "single_file_paths",
}

// Decode decodes InstallationToken from json.
func (s *InstallationToken) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallationToken to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "expires_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ExpiresAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "repository_selection":
			if err := func() error {
				s.RepositorySelection.Reset()
				if err := s.RepositorySelection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_selection\"")
			}
		case "repositories":
			if err := func() error {
				s.Repositories = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Repository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		case "single_file":
			if err := func() error {
				s.SingleFile.Reset()
				if err := s.SingleFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"single_file\"")
			}
		case "has_multiple_single_files":
			if err := func() error {
				s.HasMultipleSingleFiles.Reset()
				if err := s.HasMultipleSingleFiles.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_multiple_single_files\"")
			}
		case "single_file_paths":
			if err := func() error {
				s.SingleFilePaths = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SingleFilePaths = append(s.SingleFilePaths, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"single_file_paths\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstallationToken")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInstallationToken) {
					name = jsonFieldsNameOfInstallationToken[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes InstallationTokenRepositorySelection as json.
func (s InstallationTokenRepositorySelection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes InstallationTokenRepositorySelection from json.
func (s *InstallationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstallationTokenRepositorySelection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InstallationTokenRepositorySelection(v) {
	case InstallationTokenRepositorySelectionAll:
		*s = InstallationTokenRepositorySelectionAll
	case InstallationTokenRepositorySelectionSelected:
		*s = InstallationTokenRepositorySelectionSelected
	default:
		*s = InstallationTokenRepositorySelection(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Integration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		if s.Slug.Set {
			e.Comma()
		}
		if s.Slug.Set {
			e.RawStr("\"slug\"" + ":")
			s.Slug.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"external_url\"" + ":")
		json.EncodeURI(e, s.ExternalURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"permissions\"" + ":")
		s.Permissions.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"events\"" + ":")
		e.ArrStart()
		if len(s.Events) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Events[0]
				e.Str(elem)
			}
			for _, elem := range s.Events[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.InstallationsCount.Set {
			e.Comma()
		}
		if s.InstallationsCount.Set {
			e.RawStr("\"installations_count\"" + ":")
			s.InstallationsCount.Encode(e)
		}
	}
	{
		if s.ClientID.Set {
			e.Comma()
		}
		if s.ClientID.Set {
			e.RawStr("\"client_id\"" + ":")
			s.ClientID.Encode(e)
		}
	}
	{
		if s.ClientSecret.Set {
			e.Comma()
		}
		if s.ClientSecret.Set {
			e.RawStr("\"client_secret\"" + ":")
			s.ClientSecret.Encode(e)
		}
	}
	{
		if s.WebhookSecret.Set {
			e.Comma()
		}
		if s.WebhookSecret.Set {
			e.RawStr("\"webhook_secret\"" + ":")
			s.WebhookSecret.Encode(e)
		}
	}
	{
		if s.Pem.Set {
			e.Comma()
		}
		if s.Pem.Set {
			e.RawStr("\"pem\"" + ":")
			s.Pem.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIntegration = [17]string{
	0:  "id",
	1:  "slug",
	2:  "node_id",
	3:  "owner",
	4:  "name",
	5:  "description",
	6:  "external_url",
	7:  "html_url",
	8:  "created_at",
	9:  "updated_at",
	10: "permissions",
	11: "events",
	12: "installations_count",
	13: "client_id",
	14: "client_secret",
	15: "webhook_secret",
	16: "pem",
}

// Decode decodes Integration from json.
func (s *Integration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Integration to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "external_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ExternalURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "events":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.Events = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "installations_count":
			if err := func() error {
				s.InstallationsCount.Reset()
				if err := s.InstallationsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"installations_count\"")
			}
		case "client_id":
			if err := func() error {
				s.ClientID.Reset()
				if err := s.ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_id\"")
			}
		case "client_secret":
			if err := func() error {
				s.ClientSecret.Reset()
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_secret\"")
			}
		case "webhook_secret":
			if err := func() error {
				s.WebhookSecret.Reset()
				if err := s.WebhookSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_secret\"")
			}
		case "pem":
			if err := func() error {
				s.Pem.Reset()
				if err := s.Pem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pem\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Integration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111101,
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIntegration) {
					name = jsonFieldsNameOfIntegration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IntegrationPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		{
			if s.Issues.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Issues.Set {
				e.RawStr("\"issues\"" + ":")
				s.Issues.Encode(e)
			}
		}
		{
			if s.Checks.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Checks.Set {
				e.RawStr("\"checks\"" + ":")
				s.Checks.Encode(e)
			}
		}
		{
			if s.Metadata.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Metadata.Set {
				e.RawStr("\"metadata\"" + ":")
				s.Metadata.Encode(e)
			}
		}
		{
			if s.Contents.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Contents.Set {
				e.RawStr("\"contents\"" + ":")
				s.Contents.Encode(e)
			}
		}
		{
			if s.Deployments.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Deployments.Set {
				e.RawStr("\"deployments\"" + ":")
				s.Deployments.Encode(e)
			}
		}
	}
	for k, elem := range s.AdditionalProps {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIntegrationPermissions = [5]string{
	0: "issues",
	1: "checks",
	2: "metadata",
	3: "contents",
	4: "deployments",
}

// Decode decodes IntegrationPermissions from json.
func (s *IntegrationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IntegrationPermissions to nil")
	}

	m := s.AdditionalProps
	if m == nil {
		m = map[string]string{}
		s.AdditionalProps = m
	}
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "issues":
			if err := func() error {
				s.Issues.Reset()
				if err := s.Issues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues\"")
			}
		case "checks":
			if err := func() error {
				s.Checks.Reset()
				if err := s.Checks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checks\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "contents":
			if err := func() error {
				s.Contents.Reset()
				if err := s.Contents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents\"")
			}
		case "deployments":
			if err := func() error {
				s.Deployments.Reset()
				if err := s.Deployments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments\"")
			}
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IntegrationPermissions")
	}

	return nil
}

// Encode encodes InteractionExpiry as json.
func (s InteractionExpiry) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes InteractionExpiry from json.
func (s *InteractionExpiry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractionExpiry to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InteractionExpiry(v) {
	case InteractionExpiryOneDay:
		*s = InteractionExpiryOneDay
	case InteractionExpiryThreeDays:
		*s = InteractionExpiryThreeDays
	case InteractionExpiryOneWeek:
		*s = InteractionExpiryOneWeek
	case InteractionExpiryOneMonth:
		*s = InteractionExpiryOneMonth
	case InteractionExpirySixMonths:
		*s = InteractionExpirySixMonths
	default:
		*s = InteractionExpiry(v)
	}

	return nil
}

// Encode encodes InteractionGroup as json.
func (s InteractionGroup) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes InteractionGroup from json.
func (s *InteractionGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractionGroup to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InteractionGroup(v) {
	case InteractionGroupExistingUsers:
		*s = InteractionGroupExistingUsers
	case InteractionGroupContributorsOnly:
		*s = InteractionGroupContributorsOnly
	case InteractionGroupCollaboratorsOnly:
		*s = InteractionGroupCollaboratorsOnly
	default:
		*s = InteractionGroup(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InteractionLimit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"limit\"" + ":")
		s.Limit.Encode(e)
	}
	{
		if s.Expiry.Set {
			e.Comma()
		}
		if s.Expiry.Set {
			e.RawStr("\"expiry\"" + ":")
			s.Expiry.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInteractionLimit = [2]string{
	0: "limit",
	1: "expiry",
}

// Decode decodes InteractionLimit from json.
func (s *InteractionLimit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractionLimit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "expiry":
			if err := func() error {
				s.Expiry.Reset()
				if err := s.Expiry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiry\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InteractionLimit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInteractionLimit) {
					name = jsonFieldsNameOfInteractionLimit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InteractionLimitResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"limit\"" + ":")
		s.Limit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"origin\"" + ":")
		e.Str(s.Origin)
	}
	{
		e.Comma()

		e.RawStr("\"expires_at\"" + ":")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInteractionLimitResponse = [3]string{
	0: "limit",
	1: "origin",
	2: "expires_at",
}

// Decode decodes InteractionLimitResponse from json.
func (s *InteractionLimitResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InteractionLimitResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "origin":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Origin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"origin\"")
			}
		case "expires_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InteractionLimitResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInteractionLimitResponse) {
					name = jsonFieldsNameOfInteractionLimitResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Issue) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"labels\"" + ":")
		e.ArrStart()
		if len(s.Labels) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Labels[0]
				elem.Encode(e)
			}
			for _, elem := range s.Labels[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"assignee\"" + ":")
		s.Assignee.Encode(e)
	}
	{
		if s.Assignees.Set {
			e.Comma()
		}
		if s.Assignees.Set {
			e.RawStr("\"assignees\"" + ":")
			s.Assignees.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"milestone\"" + ":")
		s.Milestone.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"locked\"" + ":")
		e.Bool(s.Locked)
	}
	{
		if s.ActiveLockReason.Set {
			e.Comma()
		}
		if s.ActiveLockReason.Set {
			e.RawStr("\"active_lock_reason\"" + ":")
			s.ActiveLockReason.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"comments\"" + ":")
		e.Int(s.Comments)
	}
	{
		if s.PullRequest.Set {
			e.Comma()
		}
		if s.PullRequest.Set {
			e.RawStr("\"pull_request\"" + ":")
			s.PullRequest.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"closed_at\"" + ":")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.ClosedBy.Set {
			e.Comma()
		}
		if s.ClosedBy.Set {
			e.RawStr("\"closed_by\"" + ":")
			s.ClosedBy.Encode(e)
		}
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.TimelineURL.Set {
			e.Comma()
		}
		if s.TimelineURL.Set {
			e.RawStr("\"timeline_url\"" + ":")
			s.TimelineURL.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			e.Comma()
		}
		if s.Repository.Set {
			e.RawStr("\"repository\"" + ":")
			s.Repository.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssue = [32]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "repository_url",
	4:  "labels_url",
	5:  "comments_url",
	6:  "events_url",
	7:  "html_url",
	8:  "number",
	9:  "state",
	10: "title",
	11: "body",
	12: "user",
	13: "labels",
	14: "assignee",
	15: "assignees",
	16: "milestone",
	17: "locked",
	18: "active_lock_reason",
	19: "comments",
	20: "pull_request",
	21: "closed_at",
	22: "created_at",
	23: "updated_at",
	24: "closed_by",
	25: "body_html",
	26: "body_text",
	27: "timeline_url",
	28: "repository",
	29: "performed_via_github_app",
	30: "author_association",
	31: "reactions",
}

// Decode decodes Issue from json.
func (s *Issue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Issue to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "repository_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "labels_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "title":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "labels":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				s.Labels = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IssueLabelsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "assignee":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "assignees":
			if err := func() error {
				s.Assignees.Reset()
				if err := s.Assignees.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		case "milestone":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "locked":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Locked = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locked\"")
			}
		case "active_lock_reason":
			if err := func() error {
				s.ActiveLockReason.Reset()
				if err := s.ActiveLockReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_lock_reason\"")
			}
		case "comments":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Comments = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "pull_request":
			if err := func() error {
				s.PullRequest.Reset()
				if err := s.PullRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request\"")
			}
		case "closed_at":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_at\"")
			}
		case "created_at":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "closed_by":
			if err := func() error {
				s.ClosedBy.Reset()
				if err := s.ClosedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_by\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		case "timeline_url":
			if err := func() error {
				s.TimelineURL.Reset()
				if err := s.TimelineURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeline_url\"")
			}
		case "repository":
			if err := func() error {
				s.Repository.Reset()
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		case "author_association":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Issue")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b01110111,
		0b11101011,
		0b01000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssue) {
					name = jsonFieldsNameOfIssue[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssueComment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"issue_url\"" + ":")
		json.EncodeURI(e, s.IssueURL)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssueComment = [14]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "body",
	4:  "body_text",
	5:  "body_html",
	6:  "html_url",
	7:  "user",
	8:  "created_at",
	9:  "updated_at",
	10: "issue_url",
	11: "author_association",
	12: "performed_via_github_app",
	13: "reactions",
}

// Decode decodes IssueComment from json.
func (s *IssueComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueComment to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "issue_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.IssueURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_url\"")
			}
		case "author_association":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueComment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11000111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueComment) {
					name = jsonFieldsNameOfIssueComment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssueEvent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"actor\"" + ":")
		s.Actor.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"event\"" + ":")
		e.Str(s.Event)
	}
	{
		e.Comma()

		e.RawStr("\"commit_id\"" + ":")
		s.CommitID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commit_url\"" + ":")
		s.CommitURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.Issue.Set {
			e.Comma()
		}
		if s.Issue.Set {
			e.RawStr("\"issue\"" + ":")
			s.Issue.Encode(e)
		}
	}
	{
		if s.Label.Set {
			e.Comma()
		}
		if s.Label.Set {
			e.RawStr("\"label\"" + ":")
			s.Label.Encode(e)
		}
	}
	{
		if s.Assignee.Set {
			e.Comma()
		}
		if s.Assignee.Set {
			e.RawStr("\"assignee\"" + ":")
			s.Assignee.Encode(e)
		}
	}
	{
		if s.Assigner.Set {
			e.Comma()
		}
		if s.Assigner.Set {
			e.RawStr("\"assigner\"" + ":")
			s.Assigner.Encode(e)
		}
	}
	{
		if s.ReviewRequester.Set {
			e.Comma()
		}
		if s.ReviewRequester.Set {
			e.RawStr("\"review_requester\"" + ":")
			s.ReviewRequester.Encode(e)
		}
	}
	{
		if s.RequestedReviewer.Set {
			e.Comma()
		}
		if s.RequestedReviewer.Set {
			e.RawStr("\"requested_reviewer\"" + ":")
			s.RequestedReviewer.Encode(e)
		}
	}
	{
		if s.RequestedTeam.Set {
			e.Comma()
		}
		if s.RequestedTeam.Set {
			e.RawStr("\"requested_team\"" + ":")
			s.RequestedTeam.Encode(e)
		}
	}
	{
		if s.DismissedReview.Set {
			e.Comma()
		}
		if s.DismissedReview.Set {
			e.RawStr("\"dismissed_review\"" + ":")
			s.DismissedReview.Encode(e)
		}
	}
	{
		if s.Milestone.Set {
			e.Comma()
		}
		if s.Milestone.Set {
			e.RawStr("\"milestone\"" + ":")
			s.Milestone.Encode(e)
		}
	}
	{
		if s.ProjectCard.Set {
			e.Comma()
		}
		if s.ProjectCard.Set {
			e.RawStr("\"project_card\"" + ":")
			s.ProjectCard.Encode(e)
		}
	}
	{
		if s.Rename.Set {
			e.Comma()
		}
		if s.Rename.Set {
			e.RawStr("\"rename\"" + ":")
			s.Rename.Encode(e)
		}
	}
	{
		if s.AuthorAssociation.Set {
			e.Comma()
		}
		if s.AuthorAssociation.Set {
			e.RawStr("\"author_association\"" + ":")
			s.AuthorAssociation.Encode(e)
		}
	}
	{
		if s.LockReason.Set {
			e.Comma()
		}
		if s.LockReason.Set {
			e.RawStr("\"lock_reason\"" + ":")
			s.LockReason.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssueEvent = [22]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "actor",
	4:  "event",
	5:  "commit_id",
	6:  "commit_url",
	7:  "created_at",
	8:  "issue",
	9:  "label",
	10: "assignee",
	11: "assigner",
	12: "review_requester",
	13: "requested_reviewer",
	14: "requested_team",
	15: "dismissed_review",
	16: "milestone",
	17: "project_card",
	18: "rename",
	19: "author_association",
	20: "lock_reason",
	21: "performed_via_github_app",
}

// Decode decodes IssueEvent from json.
func (s *IssueEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueEvent to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "actor":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Actor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actor\"")
			}
		case "event":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Event = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		case "commit_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.CommitID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_id\"")
			}
		case "commit_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.CommitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_url\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "issue":
			if err := func() error {
				s.Issue.Reset()
				if err := s.Issue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue\"")
			}
		case "label":
			if err := func() error {
				s.Label.Reset()
				if err := s.Label.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "assignee":
			if err := func() error {
				s.Assignee.Reset()
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "assigner":
			if err := func() error {
				s.Assigner.Reset()
				if err := s.Assigner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assigner\"")
			}
		case "review_requester":
			if err := func() error {
				s.ReviewRequester.Reset()
				if err := s.ReviewRequester.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_requester\"")
			}
		case "requested_reviewer":
			if err := func() error {
				s.RequestedReviewer.Reset()
				if err := s.RequestedReviewer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_reviewer\"")
			}
		case "requested_team":
			if err := func() error {
				s.RequestedTeam.Reset()
				if err := s.RequestedTeam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_team\"")
			}
		case "dismissed_review":
			if err := func() error {
				s.DismissedReview.Reset()
				if err := s.DismissedReview.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissed_review\"")
			}
		case "milestone":
			if err := func() error {
				s.Milestone.Reset()
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "project_card":
			if err := func() error {
				s.ProjectCard.Reset()
				if err := s.ProjectCard.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_card\"")
			}
		case "rename":
			if err := func() error {
				s.Rename.Reset()
				if err := s.Rename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rename\"")
			}
		case "author_association":
			if err := func() error {
				s.AuthorAssociation.Reset()
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "lock_reason":
			if err := func() error {
				s.LockReason.Reset()
				if err := s.LockReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lock_reason\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueEvent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueEvent) {
					name = jsonFieldsNameOfIssueEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssueEventDismissedReview) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"review_id\"" + ":")
		e.Int(s.ReviewID)
	}
	{
		e.Comma()

		e.RawStr("\"dismissal_message\"" + ":")
		s.DismissalMessage.Encode(e)
	}
	{
		if s.DismissalCommitID.Set {
			e.Comma()
		}
		if s.DismissalCommitID.Set {
			e.RawStr("\"dismissal_commit_id\"" + ":")
			s.DismissalCommitID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssueEventDismissedReview = [4]string{
	0: "state",
	1: "review_id",
	2: "dismissal_message",
	3: "dismissal_commit_id",
}

// Decode decodes IssueEventDismissedReview from json.
func (s *IssueEventDismissedReview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueEventDismissedReview to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "review_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ReviewID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_id\"")
			}
		case "dismissal_message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.DismissalMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissal_message\"")
			}
		case "dismissal_commit_id":
			if err := func() error {
				s.DismissalCommitID.Reset()
				if err := s.DismissalCommitID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissal_commit_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueEventDismissedReview")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueEventDismissedReview) {
					name = jsonFieldsNameOfIssueEventDismissedReview[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssueEventLabel) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		s.Name.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"color\"" + ":")
		s.Color.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssueEventLabel = [2]string{
	0: "name",
	1: "color",
}

// Decode decodes IssueEventLabel from json.
func (s *IssueEventLabel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueEventLabel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "color":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueEventLabel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueEventLabel) {
					name = jsonFieldsNameOfIssueEventLabel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssueEventMilestone) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssueEventMilestone = [1]string{
	0: "title",
}

// Decode decodes IssueEventMilestone from json.
func (s *IssueEventMilestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueEventMilestone to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueEventMilestone")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueEventMilestone) {
					name = jsonFieldsNameOfIssueEventMilestone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssueEventProjectCard) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"project_url\"" + ":")
		json.EncodeURI(e, s.ProjectURL)
	}
	{
		e.Comma()

		e.RawStr("\"project_id\"" + ":")
		e.Int(s.ProjectID)
	}
	{
		e.Comma()

		e.RawStr("\"column_name\"" + ":")
		e.Str(s.ColumnName)
	}
	{
		if s.PreviousColumnName.Set {
			e.Comma()
		}
		if s.PreviousColumnName.Set {
			e.RawStr("\"previous_column_name\"" + ":")
			s.PreviousColumnName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssueEventProjectCard = [6]string{
	0: "url",
	1: "id",
	2: "project_url",
	3: "project_id",
	4: "column_name",
	5: "previous_column_name",
}

// Decode decodes IssueEventProjectCard from json.
func (s *IssueEventProjectCard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueEventProjectCard to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "project_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ProjectURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_url\"")
			}
		case "project_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ProjectID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "column_name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ColumnName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"column_name\"")
			}
		case "previous_column_name":
			if err := func() error {
				s.PreviousColumnName.Reset()
				if err := s.PreviousColumnName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_column_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueEventProjectCard")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueEventProjectCard) {
					name = jsonFieldsNameOfIssueEventProjectCard[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssueEventRename) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"from\"" + ":")
		e.Str(s.From)
	}
	{
		e.Comma()

		e.RawStr("\"to\"" + ":")
		e.Str(s.To)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssueEventRename = [2]string{
	0: "from",
	1: "to",
}

// Decode decodes IssueEventRename from json.
func (s *IssueEventRename) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueEventRename to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.From = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.To = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueEventRename")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueEventRename) {
					name = jsonFieldsNameOfIssueEventRename[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes IssueLabelsItem as json.
func (s IssueLabelsItem) Encode(e *jx.Writer) {
	switch s.Type {
	case StringIssueLabelsItem:
		e.Str(s.String)
	case IssueLabelsItem1IssueLabelsItem:
		s.IssueLabelsItem1.Encode(e)
	}
}

// Decode decodes IssueLabelsItem from json.
func (s *IssueLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueLabelsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssueLabelsItem
	case jx.Object:
		if err := s.IssueLabelsItem1.Decode(d); err != nil {
			return err
		}
		s.Type = IssueLabelsItem1IssueLabelsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s IssueLabelsItem1) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Color.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	{
		if s.Default.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Default.Set {
			e.RawStr("\"default\"" + ":")
			s.Default.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssueLabelsItem1 = [7]string{
	0: "id",
	1: "node_id",
	2: "url",
	3: "name",
	4: "description",
	5: "color",
	6: "default",
}

// Decode decodes IssueLabelsItem1 from json.
func (s *IssueLabelsItem1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueLabelsItem1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueLabelsItem1")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssuePullRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MergedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MergedAt.Set {
			e.RawStr("\"merged_at\"" + ":")
			s.MergedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"diff_url\"" + ":")
		s.DiffURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"patch_url\"" + ":")
		s.PatchURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssuePullRequest = [5]string{
	0: "merged_at",
	1: "diff_url",
	2: "html_url",
	3: "patch_url",
	4: "url",
}

// Decode decodes IssuePullRequest from json.
func (s *IssuePullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuePullRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "merged_at":
			if err := func() error {
				s.MergedAt.Reset()
				if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged_at\"")
			}
		case "diff_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DiffURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "patch_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.PatchURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch_url\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuePullRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssuePullRequest) {
					name = jsonFieldsNameOfIssuePullRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssueSearchResultItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"locked\"" + ":")
		e.Bool(s.Locked)
	}
	{
		if s.ActiveLockReason.Set {
			e.Comma()
		}
		if s.ActiveLockReason.Set {
			e.RawStr("\"active_lock_reason\"" + ":")
			s.ActiveLockReason.Encode(e)
		}
	}
	{
		if s.Assignees.Set {
			e.Comma()
		}
		if s.Assignees.Set {
			e.RawStr("\"assignees\"" + ":")
			s.Assignees.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"labels\"" + ":")
		e.ArrStart()
		if len(s.Labels) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Labels[0]
				elem.Encode(e)
			}
			for _, elem := range s.Labels[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"assignee\"" + ":")
		s.Assignee.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"milestone\"" + ":")
		s.Milestone.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comments\"" + ":")
		e.Int(s.Comments)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"closed_at\"" + ":")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.TextMatches != nil {
			e.Comma()
		}
		if s.TextMatches != nil {
			e.RawStr("\"text_matches\"" + ":")
			s.TextMatches.Encode(e)
		}
	}
	{
		if s.PullRequest.Set {
			e.Comma()
		}
		if s.PullRequest.Set {
			e.RawStr("\"pull_request\"" + ":")
			s.PullRequest.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Float64(s.Score)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		if s.Draft.Set {
			e.Comma()
		}
		if s.Draft.Set {
			e.RawStr("\"draft\"" + ":")
			s.Draft.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			e.Comma()
		}
		if s.Repository.Set {
			e.RawStr("\"repository\"" + ":")
			s.Repository.Encode(e)
		}
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.TimelineURL.Set {
			e.Comma()
		}
		if s.TimelineURL.Set {
			e.RawStr("\"timeline_url\"" + ":")
			s.TimelineURL.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssueSearchResultItem = [33]string{
	0:  "url",
	1:  "repository_url",
	2:  "labels_url",
	3:  "comments_url",
	4:  "events_url",
	5:  "html_url",
	6:  "id",
	7:  "node_id",
	8:  "number",
	9:  "title",
	10: "locked",
	11: "active_lock_reason",
	12: "assignees",
	13: "user",
	14: "labels",
	15: "state",
	16: "assignee",
	17: "milestone",
	18: "comments",
	19: "created_at",
	20: "updated_at",
	21: "closed_at",
	22: "text_matches",
	23: "pull_request",
	24: "body",
	25: "score",
	26: "author_association",
	27: "draft",
	28: "repository",
	29: "body_html",
	30: "body_text",
	31: "timeline_url",
	32: "performed_via_github_app",
}

// Decode decodes IssueSearchResultItem from json.
func (s *IssueSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueSearchResultItem to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "repository_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "labels_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "title":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "locked":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Locked = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locked\"")
			}
		case "active_lock_reason":
			if err := func() error {
				s.ActiveLockReason.Reset()
				if err := s.ActiveLockReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_lock_reason\"")
			}
		case "assignees":
			if err := func() error {
				s.Assignees.Reset()
				if err := s.Assignees.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "labels":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				s.Labels = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IssueSearchResultItemLabelsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "assignee":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "milestone":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "comments":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Comments = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "created_at":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "closed_at":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_at\"")
			}
		case "text_matches":
			if err := func() error {
				s.TextMatches = nil
				var elem SearchResultTextMatches
				{
					var unwrapped []SearchResultTextMatchesItem
					unwrapped = nil
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem SearchResultTextMatchesItem
						if err := elem.Decode(d); err != nil {
							return err
						}
						unwrapped = append(unwrapped, elem)
						return nil
					}); err != nil {
						return err
					}
					elem = SearchResultTextMatches(unwrapped)
				}
				s.TextMatches = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_matches\"")
			}
		case "pull_request":
			if err := func() error {
				s.PullRequest.Reset()
				if err := s.PullRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "score":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Score = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "author_association":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "draft":
			if err := func() error {
				s.Draft.Reset()
				if err := s.Draft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		case "repository":
			if err := func() error {
				s.Repository.Reset()
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		case "timeline_url":
			if err := func() error {
				s.TimelineURL.Reset()
				if err := s.TimelineURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeline_url\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueSearchResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b11111111,
		0b11100111,
		0b00111111,
		0b00000110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueSearchResultItem) {
					name = jsonFieldsNameOfIssueSearchResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssueSearchResultItemLabelsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Color.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	{
		if s.Default.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Default.Set {
			e.RawStr("\"default\"" + ":")
			s.Default.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssueSearchResultItemLabelsItem = [7]string{
	0: "id",
	1: "node_id",
	2: "url",
	3: "name",
	4: "color",
	5: "default",
	6: "description",
}

// Decode decodes IssueSearchResultItemLabelsItem from json.
func (s *IssueSearchResultItemLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueSearchResultItemLabelsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueSearchResultItemLabelsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssueSearchResultItemPullRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MergedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MergedAt.Set {
			e.RawStr("\"merged_at\"" + ":")
			s.MergedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"diff_url\"" + ":")
		s.DiffURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"patch_url\"" + ":")
		s.PatchURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssueSearchResultItemPullRequest = [5]string{
	0: "merged_at",
	1: "diff_url",
	2: "html_url",
	3: "patch_url",
	4: "url",
}

// Decode decodes IssueSearchResultItemPullRequest from json.
func (s *IssueSearchResultItemPullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueSearchResultItemPullRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "merged_at":
			if err := func() error {
				s.MergedAt.Reset()
				if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged_at\"")
			}
		case "diff_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DiffURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "patch_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.PatchURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch_url\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueSearchResultItemPullRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueSearchResultItemPullRequest) {
					name = jsonFieldsNameOfIssueSearchResultItemPullRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssueSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"labels\"" + ":")
		e.ArrStart()
		if len(s.Labels) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Labels[0]
				elem.Encode(e)
			}
			for _, elem := range s.Labels[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"assignee\"" + ":")
		s.Assignee.Encode(e)
	}
	{
		if s.Assignees.Set {
			e.Comma()
		}
		if s.Assignees.Set {
			e.RawStr("\"assignees\"" + ":")
			s.Assignees.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"milestone\"" + ":")
		s.Milestone.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"locked\"" + ":")
		e.Bool(s.Locked)
	}
	{
		if s.ActiveLockReason.Set {
			e.Comma()
		}
		if s.ActiveLockReason.Set {
			e.RawStr("\"active_lock_reason\"" + ":")
			s.ActiveLockReason.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"comments\"" + ":")
		e.Int(s.Comments)
	}
	{
		if s.PullRequest.Set {
			e.Comma()
		}
		if s.PullRequest.Set {
			e.RawStr("\"pull_request\"" + ":")
			s.PullRequest.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"closed_at\"" + ":")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.TimelineURL.Set {
			e.Comma()
		}
		if s.TimelineURL.Set {
			e.RawStr("\"timeline_url\"" + ":")
			s.TimelineURL.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			e.Comma()
		}
		if s.Repository.Set {
			e.RawStr("\"repository\"" + ":")
			s.Repository.Encode(e)
		}
	}
	{
		if s.PerformedViaGithubApp.Set {
			e.Comma()
		}
		if s.PerformedViaGithubApp.Set {
			e.RawStr("\"performed_via_github_app\"" + ":")
			s.PerformedViaGithubApp.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssueSimple = [30]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "repository_url",
	4:  "labels_url",
	5:  "comments_url",
	6:  "events_url",
	7:  "html_url",
	8:  "number",
	9:  "state",
	10: "title",
	11: "body",
	12: "user",
	13: "labels",
	14: "assignee",
	15: "assignees",
	16: "milestone",
	17: "locked",
	18: "active_lock_reason",
	19: "comments",
	20: "pull_request",
	21: "closed_at",
	22: "created_at",
	23: "updated_at",
	24: "author_association",
	25: "body_html",
	26: "body_text",
	27: "timeline_url",
	28: "repository",
	29: "performed_via_github_app",
}

// Decode decodes IssueSimple from json.
func (s *IssueSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueSimple to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "repository_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "labels_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "title":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "labels":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				s.Labels = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Label
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "assignee":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "assignees":
			if err := func() error {
				s.Assignees.Reset()
				if err := s.Assignees.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		case "milestone":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "locked":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Locked = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locked\"")
			}
		case "active_lock_reason":
			if err := func() error {
				s.ActiveLockReason.Reset()
				if err := s.ActiveLockReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_lock_reason\"")
			}
		case "comments":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Comments = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "pull_request":
			if err := func() error {
				s.PullRequest.Reset()
				if err := s.PullRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request\"")
			}
		case "closed_at":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_at\"")
			}
		case "created_at":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "author_association":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		case "timeline_url":
			if err := func() error {
				s.TimelineURL.Reset()
				if err := s.TimelineURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeline_url\"")
			}
		case "repository":
			if err := func() error {
				s.Repository.Reset()
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "performed_via_github_app":
			if err := func() error {
				s.PerformedViaGithubApp.Reset()
				if err := s.PerformedViaGithubApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performed_via_github_app\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b01110111,
		0b11101011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueSimple) {
					name = jsonFieldsNameOfIssueSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssueSimplePullRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.MergedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MergedAt.Set {
			e.RawStr("\"merged_at\"" + ":")
			s.MergedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"diff_url\"" + ":")
		s.DiffURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"patch_url\"" + ":")
		s.PatchURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssueSimplePullRequest = [5]string{
	0: "merged_at",
	1: "diff_url",
	2: "html_url",
	3: "patch_url",
	4: "url",
}

// Decode decodes IssueSimplePullRequest from json.
func (s *IssueSimplePullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssueSimplePullRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "merged_at":
			if err := func() error {
				s.MergedAt.Reset()
				if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged_at\"")
			}
		case "diff_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DiffURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "patch_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.PatchURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch_url\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssueSimplePullRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssueSimplePullRequest) {
					name = jsonFieldsNameOfIssueSimplePullRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssuesAddAssigneesReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Assignees != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Assignees != nil {
			e.RawStr("\"assignees\"" + ":")
			e.ArrStart()
			if len(s.Assignees) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Assignees[0]
					e.Str(elem)
				}
				for _, elem := range s.Assignees[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssuesAddAssigneesReq = [1]string{
	0: "assignees",
}

// Decode decodes IssuesAddAssigneesReq from json.
func (s *IssuesAddAssigneesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesAddAssigneesReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assignees":
			if err := func() error {
				s.Assignees = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Assignees = append(s.Assignees, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesAddAssigneesReq")
	}

	return nil
}

// Encode encodes IssuesCreateApplicationJSONForbidden as json.
func (s IssuesCreateApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateApplicationJSONForbidden from json.
func (s *IssuesCreateApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes IssuesCreateApplicationJSONGone as json.
func (s IssuesCreateApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateApplicationJSONGone from json.
func (s *IssuesCreateApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesCreateApplicationJSONNotFound as json.
func (s IssuesCreateApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateApplicationJSONNotFound from json.
func (s *IssuesCreateApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesCreateCommentApplicationJSONForbidden as json.
func (s IssuesCreateCommentApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateCommentApplicationJSONForbidden from json.
func (s *IssuesCreateCommentApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateCommentApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateCommentApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes IssuesCreateCommentApplicationJSONGone as json.
func (s IssuesCreateCommentApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateCommentApplicationJSONGone from json.
func (s *IssuesCreateCommentApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateCommentApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateCommentApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesCreateCommentApplicationJSONNotFound as json.
func (s IssuesCreateCommentApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesCreateCommentApplicationJSONNotFound from json.
func (s *IssuesCreateCommentApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateCommentApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesCreateCommentApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesCreateCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssuesCreateCommentReq = [1]string{
	0: "body",
}

// Decode decodes IssuesCreateCommentReq from json.
func (s *IssuesCreateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesCreateCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssuesCreateCommentReq) {
					name = jsonFieldsNameOfIssuesCreateCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssuesCreateLabelReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Color.Set {
			e.Comma()
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssuesCreateLabelReq = [3]string{
	0: "name",
	1: "color",
	2: "description",
}

// Decode decodes IssuesCreateLabelReq from json.
func (s *IssuesCreateLabelReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateLabelReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesCreateLabelReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssuesCreateLabelReq) {
					name = jsonFieldsNameOfIssuesCreateLabelReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssuesCreateMilestoneReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		if s.State.Set {
			e.Comma()
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.DueOn.Set {
			e.Comma()
		}
		if s.DueOn.Set {
			e.RawStr("\"due_on\"" + ":")
			s.DueOn.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssuesCreateMilestoneReq = [4]string{
	0: "title",
	1: "state",
	2: "description",
	3: "due_on",
}

// Decode decodes IssuesCreateMilestoneReq from json.
func (s *IssuesCreateMilestoneReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateMilestoneReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "due_on":
			if err := func() error {
				s.DueOn.Reset()
				if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"due_on\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesCreateMilestoneReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssuesCreateMilestoneReq) {
					name = jsonFieldsNameOfIssuesCreateMilestoneReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes IssuesCreateMilestoneReqState as json.
func (s IssuesCreateMilestoneReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesCreateMilestoneReqState from json.
func (s *IssuesCreateMilestoneReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateMilestoneReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesCreateMilestoneReqState(v) {
	case IssuesCreateMilestoneReqStateOpen:
		*s = IssuesCreateMilestoneReqStateOpen
	case IssuesCreateMilestoneReqStateClosed:
		*s = IssuesCreateMilestoneReqStateClosed
	default:
		*s = IssuesCreateMilestoneReqState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssuesCreateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		s.Title.Encode(e)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.Assignee.Set {
			e.Comma()
		}
		if s.Assignee.Set {
			e.RawStr("\"assignee\"" + ":")
			s.Assignee.Encode(e)
		}
	}
	{
		if s.Milestone.Set {
			e.Comma()
		}
		if s.Milestone.Set {
			e.RawStr("\"milestone\"" + ":")
			s.Milestone.Encode(e)
		}
	}
	{
		if s.Labels != nil {
			e.Comma()
		}
		if s.Labels != nil {
			e.RawStr("\"labels\"" + ":")
			e.ArrStart()
			if len(s.Labels) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Labels[0]
					elem.Encode(e)
				}
				for _, elem := range s.Labels[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Assignees != nil {
			e.Comma()
		}
		if s.Assignees != nil {
			e.RawStr("\"assignees\"" + ":")
			e.ArrStart()
			if len(s.Assignees) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Assignees[0]
					e.Str(elem)
				}
				for _, elem := range s.Assignees[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssuesCreateReq = [6]string{
	0: "title",
	1: "body",
	2: "assignee",
	3: "milestone",
	4: "labels",
	5: "assignees",
}

// Decode decodes IssuesCreateReq from json.
func (s *IssuesCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "assignee":
			if err := func() error {
				s.Assignee.Reset()
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "milestone":
			if err := func() error {
				s.Milestone.Reset()
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "labels":
			if err := func() error {
				s.Labels = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IssuesCreateReqLabelsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "assignees":
			if err := func() error {
				s.Assignees = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Assignees = append(s.Assignees, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesCreateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssuesCreateReq) {
					name = jsonFieldsNameOfIssuesCreateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes IssuesCreateReqLabelsItem as json.
func (s IssuesCreateReqLabelsItem) Encode(e *jx.Writer) {
	switch s.Type {
	case StringIssuesCreateReqLabelsItem:
		e.Str(s.String)
	case IssuesCreateReqLabelsItem1IssuesCreateReqLabelsItem:
		s.IssuesCreateReqLabelsItem1.Encode(e)
	}
}

// Decode decodes IssuesCreateReqLabelsItem from json.
func (s *IssuesCreateReqLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateReqLabelsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesCreateReqLabelsItem
	case jx.Object:
		if err := s.IssuesCreateReqLabelsItem1.Decode(d); err != nil {
			return err
		}
		s.Type = IssuesCreateReqLabelsItem1IssuesCreateReqLabelsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesCreateReqLabelsItem1) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Color.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssuesCreateReqLabelsItem1 = [4]string{
	0: "id",
	1: "name",
	2: "description",
	3: "color",
}

// Decode decodes IssuesCreateReqLabelsItem1 from json.
func (s *IssuesCreateReqLabelsItem1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateReqLabelsItem1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesCreateReqLabelsItem1")
	}

	return nil
}

// Encode encodes IssuesCreateReqMilestone as json.
func (s IssuesCreateReqMilestone) Encode(e *jx.Writer) {
	switch s.Type {
	case StringIssuesCreateReqMilestone:
		e.Str(s.String)
	case IntIssuesCreateReqMilestone:
		e.Int(s.Int)
	}
}

// Decode decodes IssuesCreateReqMilestone from json.
func (s *IssuesCreateReqMilestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateReqMilestone to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesCreateReqMilestone
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntIssuesCreateReqMilestone
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode encodes IssuesCreateReqTitle as json.
func (s IssuesCreateReqTitle) Encode(e *jx.Writer) {
	switch s.Type {
	case StringIssuesCreateReqTitle:
		e.Str(s.String)
	case IntIssuesCreateReqTitle:
		e.Int(s.Int)
	}
}

// Decode decodes IssuesCreateReqTitle from json.
func (s *IssuesCreateReqTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesCreateReqTitle to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesCreateReqTitle
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntIssuesCreateReqTitle
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode encodes IssuesGetApplicationJSONGone as json.
func (s IssuesGetApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesGetApplicationJSONGone from json.
func (s *IssuesGetApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesGetApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesGetApplicationJSONMovedPermanently as json.
func (s IssuesGetApplicationJSONMovedPermanently) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesGetApplicationJSONMovedPermanently from json.
func (s *IssuesGetApplicationJSONMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesGetApplicationJSONMovedPermanently to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetApplicationJSONMovedPermanently(unwrapped)
	return nil
}

// Encode encodes IssuesGetApplicationJSONNotFound as json.
func (s IssuesGetApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesGetApplicationJSONNotFound from json.
func (s *IssuesGetApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesGetApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesGetEventApplicationJSONForbidden as json.
func (s IssuesGetEventApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesGetEventApplicationJSONForbidden from json.
func (s *IssuesGetEventApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesGetEventApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetEventApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes IssuesGetEventApplicationJSONGone as json.
func (s IssuesGetEventApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesGetEventApplicationJSONGone from json.
func (s *IssuesGetEventApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesGetEventApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetEventApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesGetEventApplicationJSONNotFound as json.
func (s IssuesGetEventApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesGetEventApplicationJSONNotFound from json.
func (s *IssuesGetEventApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesGetEventApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetEventApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesListAssigneesOKApplicationJSON as json.
func (s IssuesListAssigneesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListAssigneesOKApplicationJSON from json.
func (s *IssuesListAssigneesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListAssigneesOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListAssigneesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListCommentsApplicationJSONGone as json.
func (s IssuesListCommentsApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesListCommentsApplicationJSONGone from json.
func (s *IssuesListCommentsApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListCommentsApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListCommentsApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesListCommentsApplicationJSONNotFound as json.
func (s IssuesListCommentsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesListCommentsApplicationJSONNotFound from json.
func (s *IssuesListCommentsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListCommentsApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListCommentsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesListCommentsForRepoOKApplicationJSON as json.
func (s IssuesListCommentsForRepoOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []IssueComment(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListCommentsForRepoOKApplicationJSON from json.
func (s *IssuesListCommentsForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListCommentsForRepoOKApplicationJSON to nil")
	}
	var unwrapped []IssueComment
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem IssueComment
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListCommentsForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListCommentsOKApplicationJSON as json.
func (s IssuesListCommentsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []IssueComment(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListCommentsOKApplicationJSON from json.
func (s *IssuesListCommentsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListCommentsOKApplicationJSON to nil")
	}
	var unwrapped []IssueComment
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem IssueComment
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListCommentsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListEventsForRepoOKApplicationJSON as json.
func (s IssuesListEventsForRepoOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []IssueEvent(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListEventsForRepoOKApplicationJSON from json.
func (s *IssuesListEventsForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListEventsForRepoOKApplicationJSON to nil")
	}
	var unwrapped []IssueEvent
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem IssueEvent
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListEventsForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListForAuthenticatedUserOKApplicationJSON as json.
func (s IssuesListForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Issue(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListForAuthenticatedUserOKApplicationJSON from json.
func (s *IssuesListForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListForAuthenticatedUserOKApplicationJSON to nil")
	}
	var unwrapped []Issue
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Issue
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListForOrgOKApplicationJSON as json.
func (s IssuesListForOrgOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Issue(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListForOrgOKApplicationJSON from json.
func (s *IssuesListForOrgOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListForOrgOKApplicationJSON to nil")
	}
	var unwrapped []Issue
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Issue
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListForOrgOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListForRepoApplicationJSONMovedPermanently as json.
func (s IssuesListForRepoApplicationJSONMovedPermanently) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesListForRepoApplicationJSONMovedPermanently from json.
func (s *IssuesListForRepoApplicationJSONMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListForRepoApplicationJSONMovedPermanently to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListForRepoApplicationJSONMovedPermanently(unwrapped)
	return nil
}

// Encode encodes IssuesListForRepoApplicationJSONNotFound as json.
func (s IssuesListForRepoApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesListForRepoApplicationJSONNotFound from json.
func (s *IssuesListForRepoApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListForRepoApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListForRepoApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesListForRepoOKApplicationJSON as json.
func (s IssuesListForRepoOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []IssueSimple(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListForRepoOKApplicationJSON from json.
func (s *IssuesListForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListForRepoOKApplicationJSON to nil")
	}
	var unwrapped []IssueSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem IssueSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListLabelsForRepoOKApplicationJSON as json.
func (s IssuesListLabelsForRepoOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Label(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListLabelsForRepoOKApplicationJSON from json.
func (s *IssuesListLabelsForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListLabelsForRepoOKApplicationJSON to nil")
	}
	var unwrapped []Label
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Label
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListLabelsForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListLabelsOnIssueOKApplicationJSON as json.
func (s IssuesListLabelsOnIssueOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Label(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListLabelsOnIssueOKApplicationJSON from json.
func (s *IssuesListLabelsOnIssueOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListLabelsOnIssueOKApplicationJSON to nil")
	}
	var unwrapped []Label
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Label
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListLabelsOnIssueOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListMilestonesOKApplicationJSON as json.
func (s IssuesListMilestonesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Milestone(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListMilestonesOKApplicationJSON from json.
func (s *IssuesListMilestonesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListMilestonesOKApplicationJSON to nil")
	}
	var unwrapped []Milestone
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Milestone
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListMilestonesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListOKApplicationJSON as json.
func (s IssuesListOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Issue(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesListOKApplicationJSON from json.
func (s *IssuesListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesListOKApplicationJSON to nil")
	}
	var unwrapped []Issue
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Issue
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesLockApplicationJSONForbidden as json.
func (s IssuesLockApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesLockApplicationJSONForbidden from json.
func (s *IssuesLockApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesLockApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesLockApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes IssuesLockApplicationJSONGone as json.
func (s IssuesLockApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesLockApplicationJSONGone from json.
func (s *IssuesLockApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesLockApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesLockApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesLockApplicationJSONNotFound as json.
func (s IssuesLockApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesLockApplicationJSONNotFound from json.
func (s *IssuesLockApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesLockApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesLockApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesLockReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LockReason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LockReason.Set {
			e.RawStr("\"lock_reason\"" + ":")
			s.LockReason.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssuesLockReq = [1]string{
	0: "lock_reason",
}

// Decode decodes IssuesLockReq from json.
func (s *IssuesLockReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesLockReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lock_reason":
			if err := func() error {
				s.LockReason.Reset()
				if err := s.LockReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lock_reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesLockReq")
	}

	return nil
}

// Encode encodes IssuesLockReqLockReason as json.
func (s IssuesLockReqLockReason) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesLockReqLockReason from json.
func (s *IssuesLockReqLockReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesLockReqLockReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesLockReqLockReason(v) {
	case IssuesLockReqLockReasonOffMinusTopic:
		*s = IssuesLockReqLockReasonOffMinusTopic
	case IssuesLockReqLockReasonTooHeated:
		*s = IssuesLockReqLockReasonTooHeated
	case IssuesLockReqLockReasonResolved:
		*s = IssuesLockReqLockReasonResolved
	case IssuesLockReqLockReasonSpam:
		*s = IssuesLockReqLockReasonSpam
	default:
		*s = IssuesLockReqLockReason(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssuesRemoveAssigneesReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Assignees != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Assignees != nil {
			e.RawStr("\"assignees\"" + ":")
			e.ArrStart()
			if len(s.Assignees) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Assignees[0]
					e.Str(elem)
				}
				for _, elem := range s.Assignees[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssuesRemoveAssigneesReq = [1]string{
	0: "assignees",
}

// Decode decodes IssuesRemoveAssigneesReq from json.
func (s *IssuesRemoveAssigneesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesRemoveAssigneesReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assignees":
			if err := func() error {
				s.Assignees = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Assignees = append(s.Assignees, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesRemoveAssigneesReq")
	}

	return nil
}

// Encode encodes IssuesRemoveLabelApplicationJSONGone as json.
func (s IssuesRemoveLabelApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesRemoveLabelApplicationJSONGone from json.
func (s *IssuesRemoveLabelApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesRemoveLabelApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesRemoveLabelApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesRemoveLabelApplicationJSONNotFound as json.
func (s IssuesRemoveLabelApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesRemoveLabelApplicationJSONNotFound from json.
func (s *IssuesRemoveLabelApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesRemoveLabelApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesRemoveLabelApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesRemoveLabelOKApplicationJSON as json.
func (s IssuesRemoveLabelOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Label(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes IssuesRemoveLabelOKApplicationJSON from json.
func (s *IssuesRemoveLabelOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesRemoveLabelOKApplicationJSON to nil")
	}
	var unwrapped []Label
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Label
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesRemoveLabelOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesUnlockApplicationJSONForbidden as json.
func (s IssuesUnlockApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesUnlockApplicationJSONForbidden from json.
func (s *IssuesUnlockApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUnlockApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUnlockApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes IssuesUnlockApplicationJSONNotFound as json.
func (s IssuesUnlockApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesUnlockApplicationJSONNotFound from json.
func (s *IssuesUnlockApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUnlockApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUnlockApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesUpdateApplicationJSONForbidden as json.
func (s IssuesUpdateApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesUpdateApplicationJSONForbidden from json.
func (s *IssuesUpdateApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUpdateApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes IssuesUpdateApplicationJSONGone as json.
func (s IssuesUpdateApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesUpdateApplicationJSONGone from json.
func (s *IssuesUpdateApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUpdateApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesUpdateApplicationJSONMovedPermanently as json.
func (s IssuesUpdateApplicationJSONMovedPermanently) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesUpdateApplicationJSONMovedPermanently from json.
func (s *IssuesUpdateApplicationJSONMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateApplicationJSONMovedPermanently to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUpdateApplicationJSONMovedPermanently(unwrapped)
	return nil
}

// Encode encodes IssuesUpdateApplicationJSONNotFound as json.
func (s IssuesUpdateApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesUpdateApplicationJSONNotFound from json.
func (s *IssuesUpdateApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUpdateApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesUpdateCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssuesUpdateCommentReq = [1]string{
	0: "body",
}

// Decode decodes IssuesUpdateCommentReq from json.
func (s *IssuesUpdateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesUpdateCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIssuesUpdateCommentReq) {
					name = jsonFieldsNameOfIssuesUpdateCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssuesUpdateLabelReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.NewName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NewName.Set {
			e.RawStr("\"new_name\"" + ":")
			s.NewName.Encode(e)
		}
	}
	{
		if s.Color.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssuesUpdateLabelReq = [3]string{
	0: "new_name",
	1: "color",
	2: "description",
}

// Decode decodes IssuesUpdateLabelReq from json.
func (s *IssuesUpdateLabelReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateLabelReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "new_name":
			if err := func() error {
				s.NewName.Reset()
				if err := s.NewName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_name\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesUpdateLabelReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssuesUpdateMilestoneReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.DueOn.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DueOn.Set {
			e.RawStr("\"due_on\"" + ":")
			s.DueOn.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssuesUpdateMilestoneReq = [4]string{
	0: "title",
	1: "state",
	2: "description",
	3: "due_on",
}

// Decode decodes IssuesUpdateMilestoneReq from json.
func (s *IssuesUpdateMilestoneReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateMilestoneReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "due_on":
			if err := func() error {
				s.DueOn.Reset()
				if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"due_on\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesUpdateMilestoneReq")
	}

	return nil
}

// Encode encodes IssuesUpdateMilestoneReqState as json.
func (s IssuesUpdateMilestoneReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesUpdateMilestoneReqState from json.
func (s *IssuesUpdateMilestoneReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateMilestoneReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesUpdateMilestoneReqState(v) {
	case IssuesUpdateMilestoneReqStateOpen:
		*s = IssuesUpdateMilestoneReqStateOpen
	case IssuesUpdateMilestoneReqStateClosed:
		*s = IssuesUpdateMilestoneReqStateClosed
	default:
		*s = IssuesUpdateMilestoneReqState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s IssuesUpdateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.Assignee.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Assignee.Set {
			e.RawStr("\"assignee\"" + ":")
			s.Assignee.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.Milestone.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Milestone.Set {
			e.RawStr("\"milestone\"" + ":")
			s.Milestone.Encode(e)
		}
	}
	{
		if s.Labels != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Labels != nil {
			e.RawStr("\"labels\"" + ":")
			e.ArrStart()
			if len(s.Labels) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Labels[0]
					elem.Encode(e)
				}
				for _, elem := range s.Labels[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Assignees != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Assignees != nil {
			e.RawStr("\"assignees\"" + ":")
			e.ArrStart()
			if len(s.Assignees) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Assignees[0]
					e.Str(elem)
				}
				for _, elem := range s.Assignees[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssuesUpdateReq = [7]string{
	0: "title",
	1: "body",
	2: "assignee",
	3: "state",
	4: "milestone",
	5: "labels",
	6: "assignees",
}

// Decode decodes IssuesUpdateReq from json.
func (s *IssuesUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "assignee":
			if err := func() error {
				s.Assignee.Reset()
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "milestone":
			if err := func() error {
				s.Milestone.Reset()
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "labels":
			if err := func() error {
				s.Labels = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IssuesUpdateReqLabelsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "assignees":
			if err := func() error {
				s.Assignees = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Assignees = append(s.Assignees, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesUpdateReq")
	}

	return nil
}

// Encode encodes IssuesUpdateReqLabelsItem as json.
func (s IssuesUpdateReqLabelsItem) Encode(e *jx.Writer) {
	switch s.Type {
	case StringIssuesUpdateReqLabelsItem:
		e.Str(s.String)
	case IssuesUpdateReqLabelsItem1IssuesUpdateReqLabelsItem:
		s.IssuesUpdateReqLabelsItem1.Encode(e)
	}
}

// Decode decodes IssuesUpdateReqLabelsItem from json.
func (s *IssuesUpdateReqLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateReqLabelsItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesUpdateReqLabelsItem
	case jx.Object:
		if err := s.IssuesUpdateReqLabelsItem1.Decode(d); err != nil {
			return err
		}
		s.Type = IssuesUpdateReqLabelsItem1IssuesUpdateReqLabelsItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesUpdateReqLabelsItem1) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Color.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfIssuesUpdateReqLabelsItem1 = [4]string{
	0: "id",
	1: "name",
	2: "description",
	3: "color",
}

// Decode decodes IssuesUpdateReqLabelsItem1 from json.
func (s *IssuesUpdateReqLabelsItem1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateReqLabelsItem1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IssuesUpdateReqLabelsItem1")
	}

	return nil
}

// Encode encodes IssuesUpdateReqMilestone as json.
func (s IssuesUpdateReqMilestone) Encode(e *jx.Writer) {
	switch s.Type {
	case StringIssuesUpdateReqMilestone:
		e.Str(s.String)
	case IntIssuesUpdateReqMilestone:
		e.Int(s.Int)
	}
}

// Decode decodes IssuesUpdateReqMilestone from json.
func (s *IssuesUpdateReqMilestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateReqMilestone to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesUpdateReqMilestone
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntIssuesUpdateReqMilestone
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode encodes IssuesUpdateReqState as json.
func (s IssuesUpdateReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes IssuesUpdateReqState from json.
func (s *IssuesUpdateReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IssuesUpdateReqState(v) {
	case IssuesUpdateReqStateOpen:
		*s = IssuesUpdateReqStateOpen
	case IssuesUpdateReqStateClosed:
		*s = IssuesUpdateReqStateClosed
	default:
		*s = IssuesUpdateReqState(v)
	}

	return nil
}

// Encode encodes IssuesUpdateReqTitle as json.
func (s IssuesUpdateReqTitle) Encode(e *jx.Writer) {
	switch s.Type {
	case StringIssuesUpdateReqTitle:
		e.Str(s.String)
	case IntIssuesUpdateReqTitle:
		e.Int(s.Int)
	}
}

// Decode decodes IssuesUpdateReqTitle from json.
func (s *IssuesUpdateReqTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IssuesUpdateReqTitle to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringIssuesUpdateReqTitle
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntIssuesUpdateReqTitle
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s Job) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"run_id\"" + ":")
		e.Int(s.RunID)
	}
	{
		e.Comma()

		e.RawStr("\"run_url\"" + ":")
		e.Str(s.RunURL)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"head_sha\"" + ":")
		e.Str(s.HeadSha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"conclusion\"" + ":")
		s.Conclusion.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"started_at\"" + ":")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		e.Comma()

		e.RawStr("\"completed_at\"" + ":")
		s.CompletedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Steps != nil {
			e.Comma()
		}
		if s.Steps != nil {
			e.RawStr("\"steps\"" + ":")
			e.ArrStart()
			if len(s.Steps) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Steps[0]
					elem.Encode(e)
				}
				for _, elem := range s.Steps[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"check_run_url\"" + ":")
		e.Str(s.CheckRunURL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfJob = [14]string{
	0:  "id",
	1:  "run_id",
	2:  "run_url",
	3:  "node_id",
	4:  "head_sha",
	5:  "url",
	6:  "html_url",
	7:  "status",
	8:  "conclusion",
	9:  "started_at",
	10: "completed_at",
	11: "name",
	12: "steps",
	13: "check_run_url",
}

// Decode decodes Job from json.
func (s *Job) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Job to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "run_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RunID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"run_id\"")
			}
		case "run_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.RunURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"run_url\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "head_sha":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.HeadSha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "conclusion":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Conclusion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conclusion\"")
			}
		case "started_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "completed_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "steps":
			if err := func() error {
				s.Steps = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem JobStepsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Steps = append(s.Steps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"steps\"")
			}
		case "check_run_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CheckRunURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_run_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Job")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJob) {
					name = jsonFieldsNameOfJob[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes JobStatus as json.
func (s JobStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes JobStatus from json.
func (s *JobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JobStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch JobStatus(v) {
	case JobStatusQueued:
		*s = JobStatusQueued
	case JobStatusInProgress:
		*s = JobStatusInProgress
	case JobStatusCompleted:
		*s = JobStatusCompleted
	default:
		*s = JobStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s JobStepsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"conclusion\"" + ":")
		s.Conclusion.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		if s.StartedAt.Set {
			e.Comma()
		}
		if s.StartedAt.Set {
			e.RawStr("\"started_at\"" + ":")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CompletedAt.Set {
			e.Comma()
		}
		if s.CompletedAt.Set {
			e.RawStr("\"completed_at\"" + ":")
			s.CompletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfJobStepsItem = [6]string{
	0: "status",
	1: "conclusion",
	2: "name",
	3: "number",
	4: "started_at",
	5: "completed_at",
}

// Decode decodes JobStepsItem from json.
func (s *JobStepsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JobStepsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "conclusion":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Conclusion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conclusion\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "started_at":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "completed_at":
			if err := func() error {
				s.CompletedAt.Reset()
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JobStepsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJobStepsItem) {
					name = jsonFieldsNameOfJobStepsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes JobStepsItemStatus as json.
func (s JobStepsItemStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes JobStepsItemStatus from json.
func (s *JobStepsItemStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JobStepsItemStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch JobStepsItemStatus(v) {
	case JobStepsItemStatusQueued:
		*s = JobStepsItemStatusQueued
	case JobStepsItemStatusInProgress:
		*s = JobStepsItemStatusInProgress
	case JobStepsItemStatusCompleted:
		*s = JobStepsItemStatusCompleted
	default:
		*s = JobStepsItemStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Key) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"verified\"" + ":")
		e.Bool(s.Verified)
	}
	{
		e.Comma()

		e.RawStr("\"read_only\"" + ":")
		e.Bool(s.ReadOnly)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfKey = [7]string{
	0: "key",
	1: "id",
	2: "url",
	3: "title",
	4: "created_at",
	5: "verified",
	6: "read_only",
}

// Decode decodes Key from json.
func (s *Key) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Key to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "verified":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Verified = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified\"")
			}
		case "read_only":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.ReadOnly = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"read_only\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Key")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfKey) {
					name = jsonFieldsNameOfKey[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s KeySimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfKeySimple = [2]string{
	0: "id",
	1: "key",
}

// Decode decodes KeySimple from json.
func (s *KeySimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeySimple to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KeySimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfKeySimple) {
					name = jsonFieldsNameOfKeySimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Label) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int64(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"color\"" + ":")
		e.Str(s.Color)
	}
	{
		e.Comma()

		e.RawStr("\"default\"" + ":")
		e.Bool(s.Default)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLabel = [7]string{
	0: "id",
	1: "node_id",
	2: "url",
	3: "name",
	4: "description",
	5: "color",
	6: "default",
}

// Decode decodes Label from json.
func (s *Label) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Label to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "color":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Color = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "default":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Default = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Label")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLabel) {
					name = jsonFieldsNameOfLabel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s LabelSearchResultItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"color\"" + ":")
		e.Str(s.Color)
	}
	{
		e.Comma()

		e.RawStr("\"default\"" + ":")
		e.Bool(s.Default)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Float64(s.Score)
	}
	{
		if s.TextMatches != nil {
			e.Comma()
		}
		if s.TextMatches != nil {
			e.RawStr("\"text_matches\"" + ":")
			s.TextMatches.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLabelSearchResultItem = [9]string{
	0: "id",
	1: "node_id",
	2: "url",
	3: "name",
	4: "color",
	5: "default",
	6: "description",
	7: "score",
	8: "text_matches",
}

// Decode decodes LabelSearchResultItem from json.
func (s *LabelSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LabelSearchResultItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "color":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Color = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "default":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Default = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "score":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float64()
				s.Score = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "text_matches":
			if err := func() error {
				s.TextMatches = nil
				var elem SearchResultTextMatches
				{
					var unwrapped []SearchResultTextMatchesItem
					unwrapped = nil
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem SearchResultTextMatchesItem
						if err := elem.Decode(d); err != nil {
							return err
						}
						unwrapped = append(unwrapped, elem)
						return nil
					}); err != nil {
						return err
					}
					elem = SearchResultTextMatches(unwrapped)
				}
				s.TextMatches = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_matches\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LabelSearchResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLabelSearchResultItem) {
					name = jsonFieldsNameOfLabelSearchResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Language) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Int(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLanguage = [0]string{}

// Decode decodes Language from json.
func (s Language) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Language to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem int
			if err := func() error {
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Language")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s License) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"spdx_id\"" + ":")
		s.SpdxID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"implementation\"" + ":")
		e.Str(s.Implementation)
	}
	{
		e.Comma()

		e.RawStr("\"permissions\"" + ":")
		e.ArrStart()
		if len(s.Permissions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Permissions[0]
				e.Str(elem)
			}
			for _, elem := range s.Permissions[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"conditions\"" + ":")
		e.ArrStart()
		if len(s.Conditions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Conditions[0]
				e.Str(elem)
			}
			for _, elem := range s.Conditions[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"limitations\"" + ":")
		e.ArrStart()
		if len(s.Limitations) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Limitations[0]
				e.Str(elem)
			}
			for _, elem := range s.Limitations[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"featured\"" + ":")
		e.Bool(s.Featured)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLicense = [13]string{
	0:  "key",
	1:  "name",
	2:  "spdx_id",
	3:  "url",
	4:  "node_id",
	5:  "html_url",
	6:  "description",
	7:  "implementation",
	8:  "permissions",
	9:  "conditions",
	10: "limitations",
	11: "body",
	12: "featured",
}

// Decode decodes License from json.
func (s *License) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode License to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "spdx_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.SpdxID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spdx_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "implementation":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Implementation = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implementation\"")
			}
		case "permissions":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Permissions = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "conditions":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				s.Conditions = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "limitations":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.Limitations = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Limitations = append(s.Limitations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitations\"")
			}
		case "body":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "featured":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Featured = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featured\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode License")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLicense) {
					name = jsonFieldsNameOfLicense[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s LicenseContent) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		s.GitURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"download_url\"" + ":")
		s.DownloadURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"content\"" + ":")
		e.Str(s.Content)
	}
	{
		e.Comma()

		e.RawStr("\"encoding\"" + ":")
		e.Str(s.Encoding)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLicenseContent = [13]string{
	0:  "name",
	1:  "path",
	2:  "sha",
	3:  "size",
	4:  "url",
	5:  "html_url",
	6:  "git_url",
	7:  "download_url",
	8:  "type",
	9:  "content",
	10: "encoding",
	11: "_links",
	12: "license",
}

// Decode decodes LicenseContent from json.
func (s *LicenseContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicenseContent to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "git_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.GitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "download_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.DownloadURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download_url\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "content":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "encoding":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Encoding = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encoding\"")
			}
		case "_links":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "license":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicenseContent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLicenseContent) {
					name = jsonFieldsNameOfLicenseContent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s LicenseContentLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"git\"" + ":")
		s.Git.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html\"" + ":")
		s.HTML.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"self\"" + ":")
		json.EncodeURI(e, s.Self)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLicenseContentLinks = [3]string{
	0: "git",
	1: "html",
	2: "self",
}

// Decode decodes LicenseContentLinks from json.
func (s *LicenseContentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicenseContentLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "git":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Git.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git\"")
			}
		case "html":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "self":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.Self = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicenseContentLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLicenseContentLinks) {
					name = jsonFieldsNameOfLicenseContentLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s LicenseSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"spdx_id\"" + ":")
		s.SpdxID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		if s.HTMLURL.Set {
			e.Comma()
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLicenseSimple = [6]string{
	0: "key",
	1: "name",
	2: "url",
	3: "spdx_id",
	4: "node_id",
	5: "html_url",
}

// Decode decodes LicenseSimple from json.
func (s *LicenseSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicenseSimple to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "spdx_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SpdxID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spdx_id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicenseSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLicenseSimple) {
					name = jsonFieldsNameOfLicenseSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes LicensesGetAllCommonlyUsedOKApplicationJSON as json.
func (s LicensesGetAllCommonlyUsedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []LicenseSimple(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes LicensesGetAllCommonlyUsedOKApplicationJSON from json.
func (s *LicensesGetAllCommonlyUsedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicensesGetAllCommonlyUsedOKApplicationJSON to nil")
	}
	var unwrapped []LicenseSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LicenseSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LicensesGetAllCommonlyUsedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes LicensesGetApplicationJSONForbidden as json.
func (s LicensesGetApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes LicensesGetApplicationJSONForbidden from json.
func (s *LicensesGetApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicensesGetApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LicensesGetApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes LicensesGetApplicationJSONNotFound as json.
func (s LicensesGetApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes LicensesGetApplicationJSONNotFound from json.
func (s *LicensesGetApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicensesGetApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LicensesGetApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s Link) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"href\"" + ":")
		e.Str(s.Href)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLink = [1]string{
	0: "href",
}

// Decode decodes Link from json.
func (s *Link) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Link to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Href = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"href\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Link")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLink) {
					name = jsonFieldsNameOfLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s LinkWithType) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"href\"" + ":")
		e.Str(s.Href)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLinkWithType = [2]string{
	0: "href",
	1: "type",
}

// Decode decodes LinkWithType from json.
func (s *LinkWithType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LinkWithType to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Href = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"href\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LinkWithType")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLinkWithType) {
					name = jsonFieldsNameOfLinkWithType[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MarkdownRenderReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"text\"" + ":")
		e.Str(s.Text)
	}
	{
		if s.Mode.Set {
			e.Comma()
		}
		if s.Mode.Set {
			e.RawStr("\"mode\"" + ":")
			s.Mode.Encode(e)
		}
	}
	{
		if s.Context.Set {
			e.Comma()
		}
		if s.Context.Set {
			e.RawStr("\"context\"" + ":")
			s.Context.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMarkdownRenderReq = [3]string{
	0: "text",
	1: "mode",
	2: "context",
}

// Decode decodes MarkdownRenderReq from json.
func (s *MarkdownRenderReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarkdownRenderReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarkdownRenderReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMarkdownRenderReq) {
					name = jsonFieldsNameOfMarkdownRenderReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes MarkdownRenderReqMode as json.
func (s MarkdownRenderReqMode) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MarkdownRenderReqMode from json.
func (s *MarkdownRenderReqMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarkdownRenderReqMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MarkdownRenderReqMode(v) {
	case MarkdownRenderReqModeMarkdown:
		*s = MarkdownRenderReqModeMarkdown
	case MarkdownRenderReqModeGfm:
		*s = MarkdownRenderReqModeGfm
	default:
		*s = MarkdownRenderReqMode(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MarketplaceAccount) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		if s.NodeID.Set {
			e.Comma()
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		if s.Email.Set {
			e.Comma()
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.OrganizationBillingEmail.Set {
			e.Comma()
		}
		if s.OrganizationBillingEmail.Set {
			e.RawStr("\"organization_billing_email\"" + ":")
			s.OrganizationBillingEmail.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMarketplaceAccount = [7]string{
	0: "url",
	1: "id",
	2: "type",
	3: "node_id",
	4: "login",
	5: "email",
	6: "organization_billing_email",
}

// Decode decodes MarketplaceAccount from json.
func (s *MarketplaceAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarketplaceAccount to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "login":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "organization_billing_email":
			if err := func() error {
				s.OrganizationBillingEmail.Reset()
				if err := s.OrganizationBillingEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_billing_email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarketplaceAccount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMarketplaceAccount) {
					name = jsonFieldsNameOfMarketplaceAccount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MarketplaceListingPlan) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"accounts_url\"" + ":")
		json.EncodeURI(e, s.AccountsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"monthly_price_in_cents\"" + ":")
		e.Int(s.MonthlyPriceInCents)
	}
	{
		e.Comma()

		e.RawStr("\"yearly_price_in_cents\"" + ":")
		e.Int(s.YearlyPriceInCents)
	}
	{
		e.Comma()

		e.RawStr("\"price_model\"" + ":")
		e.Str(s.PriceModel)
	}
	{
		e.Comma()

		e.RawStr("\"has_free_trial\"" + ":")
		e.Bool(s.HasFreeTrial)
	}
	{
		e.Comma()

		e.RawStr("\"unit_name\"" + ":")
		s.UnitName.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"bullets\"" + ":")
		e.ArrStart()
		if len(s.Bullets) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Bullets[0]
				e.Str(elem)
			}
			for _, elem := range s.Bullets[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMarketplaceListingPlan = [13]string{
	0:  "url",
	1:  "accounts_url",
	2:  "id",
	3:  "number",
	4:  "name",
	5:  "description",
	6:  "monthly_price_in_cents",
	7:  "yearly_price_in_cents",
	8:  "price_model",
	9:  "has_free_trial",
	10: "unit_name",
	11: "state",
	12: "bullets",
}

// Decode decodes MarketplaceListingPlan from json.
func (s *MarketplaceListingPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarketplaceListingPlan to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "accounts_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AccountsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accounts_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "monthly_price_in_cents":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.MonthlyPriceInCents = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monthly_price_in_cents\"")
			}
		case "yearly_price_in_cents":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.YearlyPriceInCents = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"yearly_price_in_cents\"")
			}
		case "price_model":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PriceModel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price_model\"")
			}
		case "has_free_trial":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasFreeTrial = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_free_trial\"")
			}
		case "unit_name":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.UnitName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unit_name\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "bullets":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				s.Bullets = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Bullets = append(s.Bullets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bullets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarketplaceListingPlan")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMarketplaceListingPlan) {
					name = jsonFieldsNameOfMarketplaceListingPlan[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MarketplacePurchase) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		if s.OrganizationBillingEmail.Set {
			e.Comma()
		}
		if s.OrganizationBillingEmail.Set {
			e.RawStr("\"organization_billing_email\"" + ":")
			s.OrganizationBillingEmail.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.Comma()
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.MarketplacePendingChange.Set {
			e.Comma()
		}
		if s.MarketplacePendingChange.Set {
			e.RawStr("\"marketplace_pending_change\"" + ":")
			s.MarketplacePendingChange.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"marketplace_purchase\"" + ":")
		s.MarketplacePurchase.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMarketplacePurchase = [8]string{
	0: "url",
	1: "type",
	2: "id",
	3: "login",
	4: "organization_billing_email",
	5: "email",
	6: "marketplace_pending_change",
	7: "marketplace_purchase",
}

// Decode decodes MarketplacePurchase from json.
func (s *MarketplacePurchase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarketplacePurchase to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "login":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "organization_billing_email":
			if err := func() error {
				s.OrganizationBillingEmail.Reset()
				if err := s.OrganizationBillingEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_billing_email\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "marketplace_pending_change":
			if err := func() error {
				s.MarketplacePendingChange.Reset()
				if err := s.MarketplacePendingChange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"marketplace_pending_change\"")
			}
		case "marketplace_purchase":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.MarketplacePurchase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"marketplace_purchase\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarketplacePurchase")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMarketplacePurchase) {
					name = jsonFieldsNameOfMarketplacePurchase[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MarketplacePurchaseMarketplacePendingChange) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.IsInstalled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsInstalled.Set {
			e.RawStr("\"is_installed\"" + ":")
			s.IsInstalled.Encode(e)
		}
	}
	{
		if s.EffectiveDate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EffectiveDate.Set {
			e.RawStr("\"effective_date\"" + ":")
			s.EffectiveDate.Encode(e)
		}
	}
	{
		if s.UnitCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UnitCount.Set {
			e.RawStr("\"unit_count\"" + ":")
			s.UnitCount.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Plan.Set {
			e.RawStr("\"plan\"" + ":")
			s.Plan.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMarketplacePurchaseMarketplacePendingChange = [5]string{
	0: "is_installed",
	1: "effective_date",
	2: "unit_count",
	3: "id",
	4: "plan",
}

// Decode decodes MarketplacePurchaseMarketplacePendingChange from json.
func (s *MarketplacePurchaseMarketplacePendingChange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarketplacePurchaseMarketplacePendingChange to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_installed":
			if err := func() error {
				s.IsInstalled.Reset()
				if err := s.IsInstalled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_installed\"")
			}
		case "effective_date":
			if err := func() error {
				s.EffectiveDate.Reset()
				if err := s.EffectiveDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effective_date\"")
			}
		case "unit_count":
			if err := func() error {
				s.UnitCount.Reset()
				if err := s.UnitCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unit_count\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarketplacePurchaseMarketplacePendingChange")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MarketplacePurchaseMarketplacePurchase) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.BillingCycle.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BillingCycle.Set {
			e.RawStr("\"billing_cycle\"" + ":")
			s.BillingCycle.Encode(e)
		}
	}
	{
		if s.NextBillingDate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NextBillingDate.Set {
			e.RawStr("\"next_billing_date\"" + ":")
			s.NextBillingDate.Encode(e)
		}
	}
	{
		if s.IsInstalled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsInstalled.Set {
			e.RawStr("\"is_installed\"" + ":")
			s.IsInstalled.Encode(e)
		}
	}
	{
		if s.UnitCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UnitCount.Set {
			e.RawStr("\"unit_count\"" + ":")
			s.UnitCount.Encode(e)
		}
	}
	{
		if s.OnFreeTrial.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OnFreeTrial.Set {
			e.RawStr("\"on_free_trial\"" + ":")
			s.OnFreeTrial.Encode(e)
		}
	}
	{
		if s.FreeTrialEndsOn.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FreeTrialEndsOn.Set {
			e.RawStr("\"free_trial_ends_on\"" + ":")
			s.FreeTrialEndsOn.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Plan.Set {
			e.RawStr("\"plan\"" + ":")
			s.Plan.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMarketplacePurchaseMarketplacePurchase = [8]string{
	0: "billing_cycle",
	1: "next_billing_date",
	2: "is_installed",
	3: "unit_count",
	4: "on_free_trial",
	5: "free_trial_ends_on",
	6: "updated_at",
	7: "plan",
}

// Decode decodes MarketplacePurchaseMarketplacePurchase from json.
func (s *MarketplacePurchaseMarketplacePurchase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarketplacePurchaseMarketplacePurchase to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billing_cycle":
			if err := func() error {
				s.BillingCycle.Reset()
				if err := s.BillingCycle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billing_cycle\"")
			}
		case "next_billing_date":
			if err := func() error {
				s.NextBillingDate.Reset()
				if err := s.NextBillingDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_billing_date\"")
			}
		case "is_installed":
			if err := func() error {
				s.IsInstalled.Reset()
				if err := s.IsInstalled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_installed\"")
			}
		case "unit_count":
			if err := func() error {
				s.UnitCount.Reset()
				if err := s.UnitCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unit_count\"")
			}
		case "on_free_trial":
			if err := func() error {
				s.OnFreeTrial.Reset()
				if err := s.OnFreeTrial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"on_free_trial\"")
			}
		case "free_trial_ends_on":
			if err := func() error {
				s.FreeTrialEndsOn.Reset()
				if err := s.FreeTrialEndsOn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"free_trial_ends_on\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarketplacePurchaseMarketplacePurchase")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MergedUpstream) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.MergeType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MergeType.Set {
			e.RawStr("\"merge_type\"" + ":")
			s.MergeType.Encode(e)
		}
	}
	{
		if s.BaseBranch.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BaseBranch.Set {
			e.RawStr("\"base_branch\"" + ":")
			s.BaseBranch.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMergedUpstream = [3]string{
	0: "message",
	1: "merge_type",
	2: "base_branch",
}

// Decode decodes MergedUpstream from json.
func (s *MergedUpstream) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MergedUpstream to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "merge_type":
			if err := func() error {
				s.MergeType.Reset()
				if err := s.MergeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_type\"")
			}
		case "base_branch":
			if err := func() error {
				s.BaseBranch.Reset()
				if err := s.BaseBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_branch\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MergedUpstream")
	}

	return nil
}

// Encode encodes MergedUpstreamMergeType as json.
func (s MergedUpstreamMergeType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MergedUpstreamMergeType from json.
func (s *MergedUpstreamMergeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MergedUpstreamMergeType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MergedUpstreamMergeType(v) {
	case MergedUpstreamMergeTypeMerge:
		*s = MergedUpstreamMergeTypeMerge
	case MergedUpstreamMergeTypeFastMinusForward:
		*s = MergedUpstreamMergeTypeFastMinusForward
	case MergedUpstreamMergeTypeNone:
		*s = MergedUpstreamMergeTypeNone
	default:
		*s = MergedUpstreamMergeType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MetaRootOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"current_user_url\"" + ":")
		e.Str(s.CurrentUserURL)
	}
	{
		e.Comma()

		e.RawStr("\"current_user_authorizations_html_url\"" + ":")
		e.Str(s.CurrentUserAuthorizationsHTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"authorizations_url\"" + ":")
		e.Str(s.AuthorizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"code_search_url\"" + ":")
		e.Str(s.CodeSearchURL)
	}
	{
		e.Comma()

		e.RawStr("\"commit_search_url\"" + ":")
		e.Str(s.CommitSearchURL)
	}
	{
		e.Comma()

		e.RawStr("\"emails_url\"" + ":")
		e.Str(s.EmailsURL)
	}
	{
		e.Comma()

		e.RawStr("\"emojis_url\"" + ":")
		e.Str(s.EmojisURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"feeds_url\"" + ":")
		e.Str(s.FeedsURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		e.Str(s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"hub_url\"" + ":")
		e.Str(s.HubURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_search_url\"" + ":")
		e.Str(s.IssueSearchURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"label_search_url\"" + ":")
		e.Str(s.LabelSearchURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"organization_url\"" + ":")
		e.Str(s.OrganizationURL)
	}
	{
		e.Comma()

		e.RawStr("\"organization_repositories_url\"" + ":")
		e.Str(s.OrganizationRepositoriesURL)
	}
	{
		e.Comma()

		e.RawStr("\"organization_teams_url\"" + ":")
		e.Str(s.OrganizationTeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"public_gists_url\"" + ":")
		e.Str(s.PublicGistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"rate_limit_url\"" + ":")
		e.Str(s.RateLimitURL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		e.Str(s.RepositoryURL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_search_url\"" + ":")
		e.Str(s.RepositorySearchURL)
	}
	{
		e.Comma()

		e.RawStr("\"current_user_repositories_url\"" + ":")
		e.Str(s.CurrentUserRepositoriesURL)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"starred_gists_url\"" + ":")
		e.Str(s.StarredGistsURL)
	}
	{
		if s.TopicSearchURL.Set {
			e.Comma()
		}
		if s.TopicSearchURL.Set {
			e.RawStr("\"topic_search_url\"" + ":")
			s.TopicSearchURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"user_url\"" + ":")
		e.Str(s.UserURL)
	}
	{
		e.Comma()

		e.RawStr("\"user_organizations_url\"" + ":")
		e.Str(s.UserOrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"user_repositories_url\"" + ":")
		e.Str(s.UserRepositoriesURL)
	}
	{
		e.Comma()

		e.RawStr("\"user_search_url\"" + ":")
		e.Str(s.UserSearchURL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMetaRootOK = [33]string{
	0:  "current_user_url",
	1:  "current_user_authorizations_html_url",
	2:  "authorizations_url",
	3:  "code_search_url",
	4:  "commit_search_url",
	5:  "emails_url",
	6:  "emojis_url",
	7:  "events_url",
	8:  "feeds_url",
	9:  "followers_url",
	10: "following_url",
	11: "gists_url",
	12: "hub_url",
	13: "issue_search_url",
	14: "issues_url",
	15: "keys_url",
	16: "label_search_url",
	17: "notifications_url",
	18: "organization_url",
	19: "organization_repositories_url",
	20: "organization_teams_url",
	21: "public_gists_url",
	22: "rate_limit_url",
	23: "repository_url",
	24: "repository_search_url",
	25: "current_user_repositories_url",
	26: "starred_url",
	27: "starred_gists_url",
	28: "topic_search_url",
	29: "user_url",
	30: "user_organizations_url",
	31: "user_repositories_url",
	32: "user_search_url",
}

// Decode decodes MetaRootOK from json.
func (s *MetaRootOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MetaRootOK to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current_user_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CurrentUserURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_url\"")
			}
		case "current_user_authorizations_html_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CurrentUserAuthorizationsHTMLURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_authorizations_html_url\"")
			}
		case "authorizations_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AuthorizationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizations_url\"")
			}
		case "code_search_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CodeSearchURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_search_url\"")
			}
		case "commit_search_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CommitSearchURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_search_url\"")
			}
		case "emails_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.EmailsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails_url\"")
			}
		case "emojis_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.EmojisURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emojis_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "feeds_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FeedsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feeds_url\"")
			}
		case "followers_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FollowersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "hub_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.HubURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hub_url\"")
			}
		case "issue_search_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.IssueSearchURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_search_url\"")
			}
		case "issues_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "label_search_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LabelSearchURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label_search_url\"")
			}
		case "notifications_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "organization_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.OrganizationURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_url\"")
			}
		case "organization_repositories_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.OrganizationRepositoriesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_repositories_url\"")
			}
		case "organization_teams_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.OrganizationTeamsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_teams_url\"")
			}
		case "public_gists_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PublicGistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_gists_url\"")
			}
		case "rate_limit_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.RateLimitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limit_url\"")
			}
		case "repository_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.RepositoryURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		case "repository_search_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RepositorySearchURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_search_url\"")
			}
		case "current_user_repositories_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CurrentUserRepositoriesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_user_repositories_url\"")
			}
		case "starred_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "starred_gists_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.StarredGistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_gists_url\"")
			}
		case "topic_search_url":
			if err := func() error {
				s.TopicSearchURL.Reset()
				if err := s.TopicSearchURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topic_search_url\"")
			}
		case "user_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.UserURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_url\"")
			}
		case "user_organizations_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.UserOrganizationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_organizations_url\"")
			}
		case "user_repositories_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.UserRepositoriesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_repositories_url\"")
			}
		case "user_search_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UserSearchURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_search_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MetaRootOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11101111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMetaRootOK) {
					name = jsonFieldsNameOfMetaRootOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Migration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"guid\"" + ":")
		e.Str(s.GUID)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"lock_repositories\"" + ":")
		e.Bool(s.LockRepositories)
	}
	{
		e.Comma()

		e.RawStr("\"exclude_metadata\"" + ":")
		e.Bool(s.ExcludeMetadata)
	}
	{
		e.Comma()

		e.RawStr("\"exclude_git_data\"" + ":")
		e.Bool(s.ExcludeGitData)
	}
	{
		e.Comma()

		e.RawStr("\"exclude_attachments\"" + ":")
		e.Bool(s.ExcludeAttachments)
	}
	{
		e.Comma()

		e.RawStr("\"exclude_releases\"" + ":")
		e.Bool(s.ExcludeReleases)
	}
	{
		e.Comma()

		e.RawStr("\"exclude_owner_projects\"" + ":")
		e.Bool(s.ExcludeOwnerProjects)
	}
	{
		e.Comma()

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				elem.Encode(e)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		if s.ArchiveURL.Set {
			e.Comma()
		}
		if s.ArchiveURL.Set {
			e.RawStr("\"archive_url\"" + ":")
			s.ArchiveURL.Encode(e)
		}
	}
	{
		if s.Exclude != nil {
			e.Comma()
		}
		if s.Exclude != nil {
			e.RawStr("\"exclude\"" + ":")
			e.ArrStart()
			if len(s.Exclude) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Exclude[0]
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
				for _, elem := range s.Exclude[1:] {
					e.Comma()
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMigration = [17]string{
	0:  "id",
	1:  "owner",
	2:  "guid",
	3:  "state",
	4:  "lock_repositories",
	5:  "exclude_metadata",
	6:  "exclude_git_data",
	7:  "exclude_attachments",
	8:  "exclude_releases",
	9:  "exclude_owner_projects",
	10: "repositories",
	11: "url",
	12: "created_at",
	13: "updated_at",
	14: "node_id",
	15: "archive_url",
	16: "exclude",
}

// Decode decodes Migration from json.
func (s *Migration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Migration to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "guid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guid\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "lock_repositories":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.LockRepositories = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lock_repositories\"")
			}
		case "exclude_metadata":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.ExcludeMetadata = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_metadata\"")
			}
		case "exclude_git_data":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.ExcludeGitData = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_git_data\"")
			}
		case "exclude_attachments":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.ExcludeAttachments = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_attachments\"")
			}
		case "exclude_releases":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.ExcludeReleases = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_releases\"")
			}
		case "exclude_owner_projects":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.ExcludeOwnerProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_owner_projects\"")
			}
		case "repositories":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.Repositories = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Repository
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "archive_url":
			if err := func() error {
				s.ArchiveURL.Reset()
				if err := s.ArchiveURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "exclude":
			if err := func() error {
				s.Exclude = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.Raw()
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Exclude = append(s.Exclude, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Migration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMigration) {
					name = jsonFieldsNameOfMigration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound as json.
func (s MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound from json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes MigrationsGetCommitAuthorsOKApplicationJSON as json.
func (s MigrationsGetCommitAuthorsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PorterAuthor(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes MigrationsGetCommitAuthorsOKApplicationJSON from json.
func (s *MigrationsGetCommitAuthorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsGetCommitAuthorsOKApplicationJSON to nil")
	}
	var unwrapped []PorterAuthor
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PorterAuthor
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetCommitAuthorsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound as json.
func (s MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound from json.
func (s *MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes MigrationsListForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsListForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsListForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsListForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsListForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsListForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsListForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsListForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsListForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsListForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes MigrationsListForAuthenticatedUserOKApplicationJSON as json.
func (s MigrationsListForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Migration(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes MigrationsListForAuthenticatedUserOKApplicationJSON from json.
func (s *MigrationsListForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsListForAuthenticatedUserOKApplicationJSON to nil")
	}
	var unwrapped []Migration
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Migration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes MigrationsListReposForOrgOKApplicationJSON as json.
func (s MigrationsListReposForOrgOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes MigrationsListReposForOrgOKApplicationJSON from json.
func (s *MigrationsListReposForOrgOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsListReposForOrgOKApplicationJSON to nil")
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListReposForOrgOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes MigrationsListReposForUserOKApplicationJSON as json.
func (s MigrationsListReposForUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes MigrationsListReposForUserOKApplicationJSON from json.
func (s *MigrationsListReposForUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsListReposForUserOKApplicationJSON to nil")
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListReposForUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsMapCommitAuthorReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		{
			if s.Email.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Email.Set {
				e.RawStr("\"email\"" + ":")
				s.Email.Encode(e)
			}
		}
		{
			if s.Name.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Name.Set {
				e.RawStr("\"name\"" + ":")
				s.Name.Encode(e)
			}
		}
	}
	for k, elem := range s.AdditionalProps {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMigrationsMapCommitAuthorReq = [2]string{
	0: "email",
	1: "name",
}

// Decode decodes MigrationsMapCommitAuthorReq from json.
func (s *MigrationsMapCommitAuthorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsMapCommitAuthorReq to nil")
	}

	m := s.AdditionalProps
	if m == nil {
		m = map[string]jx.Raw{}
		s.AdditionalProps = m
	}
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MigrationsMapCommitAuthorReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsSetLfsPreferenceReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"use_lfs\"" + ":")
		s.UseLfs.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMigrationsSetLfsPreferenceReq = [1]string{
	0: "use_lfs",
}

// Decode decodes MigrationsSetLfsPreferenceReq from json.
func (s *MigrationsSetLfsPreferenceReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsSetLfsPreferenceReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "use_lfs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.UseLfs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_lfs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MigrationsSetLfsPreferenceReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMigrationsSetLfsPreferenceReq) {
					name = jsonFieldsNameOfMigrationsSetLfsPreferenceReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes MigrationsSetLfsPreferenceReqUseLfs as json.
func (s MigrationsSetLfsPreferenceReqUseLfs) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MigrationsSetLfsPreferenceReqUseLfs from json.
func (s *MigrationsSetLfsPreferenceReqUseLfs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsSetLfsPreferenceReqUseLfs to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MigrationsSetLfsPreferenceReqUseLfs(v) {
	case MigrationsSetLfsPreferenceReqUseLfsOptIn:
		*s = MigrationsSetLfsPreferenceReqUseLfsOptIn
	case MigrationsSetLfsPreferenceReqUseLfsOptOut:
		*s = MigrationsSetLfsPreferenceReqUseLfsOptOut
	default:
		*s = MigrationsSetLfsPreferenceReqUseLfs(v)
	}

	return nil
}

// Encode encodes MigrationsStartForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsStartForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsStartForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsStartForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsStartForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsStartForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsStartForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsStartForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsStartForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsStartForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsStartForAuthenticatedUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.LockRepositories.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LockRepositories.Set {
			e.RawStr("\"lock_repositories\"" + ":")
			s.LockRepositories.Encode(e)
		}
	}
	{
		if s.ExcludeAttachments.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExcludeAttachments.Set {
			e.RawStr("\"exclude_attachments\"" + ":")
			s.ExcludeAttachments.Encode(e)
		}
	}
	{
		if s.ExcludeReleases.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExcludeReleases.Set {
			e.RawStr("\"exclude_releases\"" + ":")
			s.ExcludeReleases.Encode(e)
		}
	}
	{
		if s.ExcludeOwnerProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExcludeOwnerProjects.Set {
			e.RawStr("\"exclude_owner_projects\"" + ":")
			s.ExcludeOwnerProjects.Encode(e)
		}
	}
	{
		if s.Exclude != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Exclude != nil {
			e.RawStr("\"exclude\"" + ":")
			e.ArrStart()
			if len(s.Exclude) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Exclude[0]
					elem.Encode(e)
				}
				for _, elem := range s.Exclude[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				e.Str(elem)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMigrationsStartForAuthenticatedUserReq = [6]string{
	0: "lock_repositories",
	1: "exclude_attachments",
	2: "exclude_releases",
	3: "exclude_owner_projects",
	4: "exclude",
	5: "repositories",
}

// Decode decodes MigrationsStartForAuthenticatedUserReq from json.
func (s *MigrationsStartForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartForAuthenticatedUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lock_repositories":
			if err := func() error {
				s.LockRepositories.Reset()
				if err := s.LockRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lock_repositories\"")
			}
		case "exclude_attachments":
			if err := func() error {
				s.ExcludeAttachments.Reset()
				if err := s.ExcludeAttachments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_attachments\"")
			}
		case "exclude_releases":
			if err := func() error {
				s.ExcludeReleases.Reset()
				if err := s.ExcludeReleases.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_releases\"")
			}
		case "exclude_owner_projects":
			if err := func() error {
				s.ExcludeOwnerProjects.Reset()
				if err := s.ExcludeOwnerProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_owner_projects\"")
			}
		case "exclude":
			if err := func() error {
				s.Exclude = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MigrationsStartForAuthenticatedUserReqExcludeItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Exclude = append(s.Exclude, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude\"")
			}
		case "repositories":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Repositories = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MigrationsStartForAuthenticatedUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMigrationsStartForAuthenticatedUserReq) {
					name = jsonFieldsNameOfMigrationsStartForAuthenticatedUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes MigrationsStartForAuthenticatedUserReqExcludeItem as json.
func (s MigrationsStartForAuthenticatedUserReqExcludeItem) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MigrationsStartForAuthenticatedUserReqExcludeItem from json.
func (s *MigrationsStartForAuthenticatedUserReqExcludeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartForAuthenticatedUserReqExcludeItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MigrationsStartForAuthenticatedUserReqExcludeItem(v) {
	case MigrationsStartForAuthenticatedUserReqExcludeItemRepositories:
		*s = MigrationsStartForAuthenticatedUserReqExcludeItemRepositories
	default:
		*s = MigrationsStartForAuthenticatedUserReqExcludeItem(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsStartForOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"repositories\"" + ":")
		e.ArrStart()
		if len(s.Repositories) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Repositories[0]
				e.Str(elem)
			}
			for _, elem := range s.Repositories[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.LockRepositories.Set {
			e.Comma()
		}
		if s.LockRepositories.Set {
			e.RawStr("\"lock_repositories\"" + ":")
			s.LockRepositories.Encode(e)
		}
	}
	{
		if s.ExcludeAttachments.Set {
			e.Comma()
		}
		if s.ExcludeAttachments.Set {
			e.RawStr("\"exclude_attachments\"" + ":")
			s.ExcludeAttachments.Encode(e)
		}
	}
	{
		if s.ExcludeReleases.Set {
			e.Comma()
		}
		if s.ExcludeReleases.Set {
			e.RawStr("\"exclude_releases\"" + ":")
			s.ExcludeReleases.Encode(e)
		}
	}
	{
		if s.ExcludeOwnerProjects.Set {
			e.Comma()
		}
		if s.ExcludeOwnerProjects.Set {
			e.RawStr("\"exclude_owner_projects\"" + ":")
			s.ExcludeOwnerProjects.Encode(e)
		}
	}
	{
		if s.Exclude != nil {
			e.Comma()
		}
		if s.Exclude != nil {
			e.RawStr("\"exclude\"" + ":")
			e.ArrStart()
			if len(s.Exclude) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Exclude[0]
					elem.Encode(e)
				}
				for _, elem := range s.Exclude[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMigrationsStartForOrgReq = [6]string{
	0: "repositories",
	1: "lock_repositories",
	2: "exclude_attachments",
	3: "exclude_releases",
	4: "exclude_owner_projects",
	5: "exclude",
}

// Decode decodes MigrationsStartForOrgReq from json.
func (s *MigrationsStartForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartForOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "repositories":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Repositories = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		case "lock_repositories":
			if err := func() error {
				s.LockRepositories.Reset()
				if err := s.LockRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lock_repositories\"")
			}
		case "exclude_attachments":
			if err := func() error {
				s.ExcludeAttachments.Reset()
				if err := s.ExcludeAttachments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_attachments\"")
			}
		case "exclude_releases":
			if err := func() error {
				s.ExcludeReleases.Reset()
				if err := s.ExcludeReleases.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_releases\"")
			}
		case "exclude_owner_projects":
			if err := func() error {
				s.ExcludeOwnerProjects.Reset()
				if err := s.ExcludeOwnerProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude_owner_projects\"")
			}
		case "exclude":
			if err := func() error {
				s.Exclude = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MigrationsStartForOrgReqExcludeItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Exclude = append(s.Exclude, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclude\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MigrationsStartForOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMigrationsStartForOrgReq) {
					name = jsonFieldsNameOfMigrationsStartForOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes MigrationsStartForOrgReqExcludeItem as json.
func (s MigrationsStartForOrgReqExcludeItem) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MigrationsStartForOrgReqExcludeItem from json.
func (s *MigrationsStartForOrgReqExcludeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartForOrgReqExcludeItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MigrationsStartForOrgReqExcludeItem(v) {
	case MigrationsStartForOrgReqExcludeItemRepositories:
		*s = MigrationsStartForOrgReqExcludeItemRepositories
	default:
		*s = MigrationsStartForOrgReqExcludeItem(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsStartImportReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"vcs_url\"" + ":")
		e.Str(s.VcsURL)
	}
	{
		if s.Vcs.Set {
			e.Comma()
		}
		if s.Vcs.Set {
			e.RawStr("\"vcs\"" + ":")
			s.Vcs.Encode(e)
		}
	}
	{
		if s.VcsUsername.Set {
			e.Comma()
		}
		if s.VcsUsername.Set {
			e.RawStr("\"vcs_username\"" + ":")
			s.VcsUsername.Encode(e)
		}
	}
	{
		if s.VcsPassword.Set {
			e.Comma()
		}
		if s.VcsPassword.Set {
			e.RawStr("\"vcs_password\"" + ":")
			s.VcsPassword.Encode(e)
		}
	}
	{
		if s.TfvcProject.Set {
			e.Comma()
		}
		if s.TfvcProject.Set {
			e.RawStr("\"tfvc_project\"" + ":")
			s.TfvcProject.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMigrationsStartImportReq = [5]string{
	0: "vcs_url",
	1: "vcs",
	2: "vcs_username",
	3: "vcs_password",
	4: "tfvc_project",
}

// Decode decodes MigrationsStartImportReq from json.
func (s *MigrationsStartImportReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartImportReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VcsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs_url\"")
			}
		case "vcs":
			if err := func() error {
				s.Vcs.Reset()
				if err := s.Vcs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs\"")
			}
		case "vcs_username":
			if err := func() error {
				s.VcsUsername.Reset()
				if err := s.VcsUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs_username\"")
			}
		case "vcs_password":
			if err := func() error {
				s.VcsPassword.Reset()
				if err := s.VcsPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs_password\"")
			}
		case "tfvc_project":
			if err := func() error {
				s.TfvcProject.Reset()
				if err := s.TfvcProject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tfvc_project\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MigrationsStartImportReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMigrationsStartImportReq) {
					name = jsonFieldsNameOfMigrationsStartImportReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes MigrationsStartImportReqVcs as json.
func (s MigrationsStartImportReqVcs) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MigrationsStartImportReqVcs from json.
func (s *MigrationsStartImportReqVcs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsStartImportReqVcs to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MigrationsStartImportReqVcs(v) {
	case MigrationsStartImportReqVcsSubversion:
		*s = MigrationsStartImportReqVcsSubversion
	case MigrationsStartImportReqVcsGit:
		*s = MigrationsStartImportReqVcsGit
	case MigrationsStartImportReqVcsMercurial:
		*s = MigrationsStartImportReqVcsMercurial
	case MigrationsStartImportReqVcsTfvc:
		*s = MigrationsStartImportReqVcsTfvc
	default:
		*s = MigrationsStartImportReqVcs(v)
	}

	return nil
}

// Encode encodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound as json.
func (s MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound from json.
func (s *MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsUpdateImportReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.VcsUsername.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VcsUsername.Set {
			e.RawStr("\"vcs_username\"" + ":")
			s.VcsUsername.Encode(e)
		}
	}
	{
		if s.VcsPassword.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VcsPassword.Set {
			e.RawStr("\"vcs_password\"" + ":")
			s.VcsPassword.Encode(e)
		}
	}
	{
		if s.Vcs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Vcs.Set {
			e.RawStr("\"vcs\"" + ":")
			s.Vcs.Encode(e)
		}
	}
	{
		if s.TfvcProject.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TfvcProject.Set {
			e.RawStr("\"tfvc_project\"" + ":")
			s.TfvcProject.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMigrationsUpdateImportReq = [4]string{
	0: "vcs_username",
	1: "vcs_password",
	2: "vcs",
	3: "tfvc_project",
}

// Decode decodes MigrationsUpdateImportReq from json.
func (s *MigrationsUpdateImportReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MigrationsUpdateImportReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs_username":
			if err := func() error {
				s.VcsUsername.Reset()
				if err := s.VcsUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs_username\"")
			}
		case "vcs_password":
			if err := func() error {
				s.VcsPassword.Reset()
				if err := s.VcsPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs_password\"")
			}
		case "vcs":
			if err := func() error {
				s.Vcs.Reset()
				if err := s.Vcs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcs\"")
			}
		case "tfvc_project":
			if err := func() error {
				s.TfvcProject.Reset()
				if err := s.TfvcProject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tfvc_project\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MigrationsUpdateImportReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Milestone) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		json.EncodeURI(e, s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"closed_issues\"" + ":")
		e.Int(s.ClosedIssues)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"closed_at\"" + ":")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"due_on\"" + ":")
		s.DueOn.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMilestone = [16]string{
	0:  "url",
	1:  "html_url",
	2:  "labels_url",
	3:  "id",
	4:  "node_id",
	5:  "number",
	6:  "state",
	7:  "title",
	8:  "description",
	9:  "creator",
	10: "open_issues",
	11: "closed_issues",
	12: "created_at",
	13: "updated_at",
	14: "closed_at",
	15: "due_on",
}

// Decode decodes Milestone from json.
func (s *Milestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Milestone to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "labels_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LabelsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "creator":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "open_issues":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "closed_issues":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ClosedIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_issues\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "closed_at":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_at\"")
			}
		case "due_on":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"due_on\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Milestone")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMilestone) {
					name = jsonFieldsNameOfMilestone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes MilestoneState as json.
func (s MilestoneState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes MilestoneState from json.
func (s *MilestoneState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MilestoneState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MilestoneState(v) {
	case MilestoneStateOpen:
		*s = MilestoneStateOpen
	case MilestoneStateClosed:
		*s = MilestoneStateClosed
	default:
		*s = MilestoneState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MinimalRepository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		if s.GitURL.Set {
			e.Comma()
		}
		if s.GitURL.Set {
			e.RawStr("\"git_url\"" + ":")
			s.GitURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		if s.SSHURL.Set {
			e.Comma()
		}
		if s.SSHURL.Set {
			e.RawStr("\"ssh_url\"" + ":")
			s.SSHURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		if s.CloneURL.Set {
			e.Comma()
		}
		if s.CloneURL.Set {
			e.RawStr("\"clone_url\"" + ":")
			s.CloneURL.Encode(e)
		}
	}
	{
		if s.MirrorURL.Set {
			e.Comma()
		}
		if s.MirrorURL.Set {
			e.RawStr("\"mirror_url\"" + ":")
			s.MirrorURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		if s.SvnURL.Set {
			e.Comma()
		}
		if s.SvnURL.Set {
			e.RawStr("\"svn_url\"" + ":")
			s.SvnURL.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			e.Comma()
		}
		if s.Homepage.Set {
			e.RawStr("\"homepage\"" + ":")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.Comma()
		}
		if s.Language.Set {
			e.RawStr("\"language\"" + ":")
			s.Language.Encode(e)
		}
	}
	{
		if s.ForksCount.Set {
			e.Comma()
		}
		if s.ForksCount.Set {
			e.RawStr("\"forks_count\"" + ":")
			s.ForksCount.Encode(e)
		}
	}
	{
		if s.StargazersCount.Set {
			e.Comma()
		}
		if s.StargazersCount.Set {
			e.RawStr("\"stargazers_count\"" + ":")
			s.StargazersCount.Encode(e)
		}
	}
	{
		if s.WatchersCount.Set {
			e.Comma()
		}
		if s.WatchersCount.Set {
			e.RawStr("\"watchers_count\"" + ":")
			s.WatchersCount.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.Comma()
		}
		if s.Size.Set {
			e.RawStr("\"size\"" + ":")
			s.Size.Encode(e)
		}
	}
	{
		if s.DefaultBranch.Set {
			e.Comma()
		}
		if s.DefaultBranch.Set {
			e.RawStr("\"default_branch\"" + ":")
			s.DefaultBranch.Encode(e)
		}
	}
	{
		if s.OpenIssuesCount.Set {
			e.Comma()
		}
		if s.OpenIssuesCount.Set {
			e.RawStr("\"open_issues_count\"" + ":")
			s.OpenIssuesCount.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.HasIssues.Set {
			e.Comma()
		}
		if s.HasIssues.Set {
			e.RawStr("\"has_issues\"" + ":")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			e.Comma()
		}
		if s.HasProjects.Set {
			e.RawStr("\"has_projects\"" + ":")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			e.Comma()
		}
		if s.HasWiki.Set {
			e.RawStr("\"has_wiki\"" + ":")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.HasPages.Set {
			e.Comma()
		}
		if s.HasPages.Set {
			e.RawStr("\"has_pages\"" + ":")
			s.HasPages.Encode(e)
		}
	}
	{
		if s.HasDownloads.Set {
			e.Comma()
		}
		if s.HasDownloads.Set {
			e.RawStr("\"has_downloads\"" + ":")
			s.HasDownloads.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			e.Comma()
		}
		if s.Archived.Set {
			e.RawStr("\"archived\"" + ":")
			s.Archived.Encode(e)
		}
	}
	{
		if s.Disabled.Set {
			e.Comma()
		}
		if s.Disabled.Set {
			e.RawStr("\"disabled\"" + ":")
			s.Disabled.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.PushedAt.Set {
			e.Comma()
		}
		if s.PushedAt.Set {
			e.RawStr("\"pushed_at\"" + ":")
			s.PushedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedAt.Set {
			e.Comma()
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.Comma()
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.Comma()
		}
		if s.TemplateRepository.Set {
			e.RawStr("\"template_repository\"" + ":")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.Comma()
		}
		if s.SubscribersCount.Set {
			e.RawStr("\"subscribers_count\"" + ":")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.Comma()
		}
		if s.NetworkCount.Set {
			e.RawStr("\"network_count\"" + ":")
			s.NetworkCount.Encode(e)
		}
	}
	{
		if s.CodeOfConduct.Set {
			e.Comma()
		}
		if s.CodeOfConduct.Set {
			e.RawStr("\"code_of_conduct\"" + ":")
			s.CodeOfConduct.Encode(e)
		}
	}
	{
		if s.License.Set {
			e.Comma()
		}
		if s.License.Set {
			e.RawStr("\"license\"" + ":")
			s.License.Encode(e)
		}
	}
	{
		if s.Forks.Set {
			e.Comma()
		}
		if s.Forks.Set {
			e.RawStr("\"forks\"" + ":")
			s.Forks.Encode(e)
		}
	}
	{
		if s.OpenIssues.Set {
			e.Comma()
		}
		if s.OpenIssues.Set {
			e.RawStr("\"open_issues\"" + ":")
			s.OpenIssues.Encode(e)
		}
	}
	{
		if s.Watchers.Set {
			e.Comma()
		}
		if s.Watchers.Set {
			e.RawStr("\"watchers\"" + ":")
			s.Watchers.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMinimalRepository = [84]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "owner",
	5:  "private",
	6:  "html_url",
	7:  "description",
	8:  "fork",
	9:  "url",
	10: "archive_url",
	11: "assignees_url",
	12: "blobs_url",
	13: "branches_url",
	14: "collaborators_url",
	15: "comments_url",
	16: "commits_url",
	17: "compare_url",
	18: "contents_url",
	19: "contributors_url",
	20: "deployments_url",
	21: "downloads_url",
	22: "events_url",
	23: "forks_url",
	24: "git_commits_url",
	25: "git_refs_url",
	26: "git_tags_url",
	27: "git_url",
	28: "issue_comment_url",
	29: "issue_events_url",
	30: "issues_url",
	31: "keys_url",
	32: "labels_url",
	33: "languages_url",
	34: "merges_url",
	35: "milestones_url",
	36: "notifications_url",
	37: "pulls_url",
	38: "releases_url",
	39: "ssh_url",
	40: "stargazers_url",
	41: "statuses_url",
	42: "subscribers_url",
	43: "subscription_url",
	44: "tags_url",
	45: "teams_url",
	46: "trees_url",
	47: "clone_url",
	48: "mirror_url",
	49: "hooks_url",
	50: "svn_url",
	51: "homepage",
	52: "language",
	53: "forks_count",
	54: "stargazers_count",
	55: "watchers_count",
	56: "size",
	57: "default_branch",
	58: "open_issues_count",
	59: "is_template",
	60: "topics",
	61: "has_issues",
	62: "has_projects",
	63: "has_wiki",
	64: "has_pages",
	65: "has_downloads",
	66: "archived",
	67: "disabled",
	68: "visibility",
	69: "pushed_at",
	70: "created_at",
	71: "updated_at",
	72: "permissions",
	73: "template_repository",
	74: "temp_clone_token",
	75: "delete_branch_on_merge",
	76: "subscribers_count",
	77: "network_count",
	78: "code_of_conduct",
	79: "license",
	80: "forks",
	81: "open_issues",
	82: "watchers",
	83: "allow_forking",
}

// Decode decodes MinimalRepository from json.
func (s *MinimalRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MinimalRepository to nil")
	}
	var requiredBitSet [11]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			if err := func() error {
				s.GitURL.Reset()
				if err := s.GitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			if err := func() error {
				s.SSHURL.Reset()
				if err := s.SSHURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			if err := func() error {
				s.CloneURL.Reset()
				if err := s.CloneURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			if err := func() error {
				s.MirrorURL.Reset()
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			if err := func() error {
				s.SvnURL.Reset()
				if err := s.SvnURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			if err := func() error {
				s.Homepage.Reset()
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			if err := func() error {
				s.ForksCount.Reset()
				if err := s.ForksCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			if err := func() error {
				s.StargazersCount.Reset()
				if err := s.StargazersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			if err := func() error {
				s.WatchersCount.Reset()
				if err := s.WatchersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			if err := func() error {
				s.DefaultBranch.Reset()
				if err := s.DefaultBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			if err := func() error {
				s.OpenIssuesCount.Reset()
				if err := s.OpenIssuesCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			if err := func() error {
				s.HasIssues.Reset()
				if err := s.HasIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			if err := func() error {
				s.HasProjects.Reset()
				if err := s.HasProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			if err := func() error {
				s.HasWiki.Reset()
				if err := s.HasWiki.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			if err := func() error {
				s.HasPages.Reset()
				if err := s.HasPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			if err := func() error {
				s.HasDownloads.Reset()
				if err := s.HasDownloads.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			if err := func() error {
				s.Disabled.Reset()
				if err := s.Disabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			if err := func() error {
				s.PushedAt.Reset()
				if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "template_repository":
			if err := func() error {
				s.TemplateRepository.Reset()
				if err := s.TemplateRepository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_repository\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "subscribers_count":
			if err := func() error {
				s.SubscribersCount.Reset()
				if err := s.SubscribersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			if err := func() error {
				s.NetworkCount.Reset()
				if err := s.NetworkCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		case "code_of_conduct":
			if err := func() error {
				s.CodeOfConduct.Reset()
				if err := s.CodeOfConduct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_of_conduct\"")
			}
		case "license":
			if err := func() error {
				s.License.Reset()
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "forks":
			if err := func() error {
				s.Forks.Reset()
				if err := s.Forks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "open_issues":
			if err := func() error {
				s.OpenIssues.Reset()
				if err := s.OpenIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "watchers":
			if err := func() error {
				s.Watchers.Reset()
				if err := s.Watchers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MinimalRepository")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [11]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11110111,
		0b01111111,
		0b01111111,
		0b00000010,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMinimalRepository) {
					name = jsonFieldsNameOfMinimalRepository[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MinimalRepositoryLicense) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Key.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Key.Set {
			e.RawStr("\"key\"" + ":")
			s.Key.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.SpdxID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SpdxID.Set {
			e.RawStr("\"spdx_id\"" + ":")
			s.SpdxID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMinimalRepositoryLicense = [5]string{
	0: "key",
	1: "name",
	2: "spdx_id",
	3: "url",
	4: "node_id",
}

// Decode decodes MinimalRepositoryLicense from json.
func (s *MinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MinimalRepositoryLicense to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "spdx_id":
			if err := func() error {
				s.SpdxID.Reset()
				if err := s.SpdxID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spdx_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MinimalRepositoryLicense")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MinimalRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Admin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Admin.Set {
			e.RawStr("\"admin\"" + ":")
			s.Admin.Encode(e)
		}
	}
	{
		if s.Maintain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		if s.Push.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Push.Set {
			e.RawStr("\"push\"" + ":")
			s.Push.Encode(e)
		}
	}
	{
		if s.Triage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		if s.Pull.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pull.Set {
			e.RawStr("\"pull\"" + ":")
			s.Pull.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMinimalRepositoryPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes MinimalRepositoryPermissions from json.
func (s *MinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MinimalRepositoryPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			if err := func() error {
				s.Admin.Reset()
				if err := s.Admin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			if err := func() error {
				s.Push.Reset()
				if err := s.Push.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			if err := func() error {
				s.Pull.Reset()
				if err := s.Pull.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MinimalRepositoryPermissions")
	}

	return nil
}

// Encode encodes AutoMerge as json.
func (o NilAutoMerge) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AutoMerge from json.
func (o *NilAutoMerge) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilAutoMerge to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v AutoMerge
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilAutoMerge", d.Next())
	}
}

// Encode encodes bool as json.
func (o NilBool) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *NilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilBool to nil")
	}
	switch d.Next() {
	case jx.Bool:
		o.Null = false
		v, err := d.Bool()
		if err != nil {
			return err
		}
		o.Value = bool(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v bool
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilBool", d.Next())
	}
}

// Encode encodes CheckRunCheckSuite as json.
func (o NilCheckRunCheckSuite) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CheckRunCheckSuite from json.
func (o *NilCheckRunCheckSuite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCheckRunCheckSuite to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CheckRunCheckSuite
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilCheckRunCheckSuite", d.Next())
	}
}

// Encode encodes CheckRunConclusion as json.
func (o NilCheckRunConclusion) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CheckRunConclusion from json.
func (o *NilCheckRunConclusion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCheckRunConclusion to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CheckRunConclusion
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilCheckRunConclusion", d.Next())
	}
}

// Encode encodes CheckSuiteConclusion as json.
func (o NilCheckSuiteConclusion) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CheckSuiteConclusion from json.
func (o *NilCheckSuiteConclusion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCheckSuiteConclusion to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CheckSuiteConclusion
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilCheckSuiteConclusion", d.Next())
	}
}

// Encode encodes CheckSuiteStatus as json.
func (o NilCheckSuiteStatus) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CheckSuiteStatus from json.
func (o *NilCheckSuiteStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCheckSuiteStatus to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CheckSuiteStatus
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilCheckSuiteStatus", d.Next())
	}
}

// Encode encodes CodeScanningAlertDismissedAt as json.
func (o NilCodeScanningAlertDismissedAt) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAlertDismissedAt from json.
func (o *NilCodeScanningAlertDismissedAt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCodeScanningAlertDismissedAt to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertDismissedAt
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilCodeScanningAlertDismissedAt", d.Next())
	}
}

// Encode encodes CodeScanningAlertDismissedReason as json.
func (o NilCodeScanningAlertDismissedReason) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertDismissedReason from json.
func (o *NilCodeScanningAlertDismissedReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCodeScanningAlertDismissedReason to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertDismissedReason
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilCodeScanningAlertDismissedReason", d.Next())
	}
}

// Encode encodes FileCommitContent as json.
func (o NilFileCommitContent) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileCommitContent from json.
func (o *NilFileCommitContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilFileCommitContent to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v FileCommitContent
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilFileCommitContent", d.Next())
	}
}

// Encode encodes HookDeliveryRequestHeaders as json.
func (o NilHookDeliveryRequestHeaders) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HookDeliveryRequestHeaders from json.
func (o *NilHookDeliveryRequestHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilHookDeliveryRequestHeaders to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		o.Value = make(HookDeliveryRequestHeaders)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v HookDeliveryRequestHeaders
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilHookDeliveryRequestHeaders", d.Next())
	}
}

// Encode encodes HookDeliveryRequestPayload as json.
func (o NilHookDeliveryRequestPayload) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HookDeliveryRequestPayload from json.
func (o *NilHookDeliveryRequestPayload) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilHookDeliveryRequestPayload to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		o.Value = make(HookDeliveryRequestPayload)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v HookDeliveryRequestPayload
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilHookDeliveryRequestPayload", d.Next())
	}
}

// Encode encodes HookDeliveryResponseHeaders as json.
func (o NilHookDeliveryResponseHeaders) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HookDeliveryResponseHeaders from json.
func (o *NilHookDeliveryResponseHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilHookDeliveryResponseHeaders to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		o.Value = make(HookDeliveryResponseHeaders)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v HookDeliveryResponseHeaders
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilHookDeliveryResponseHeaders", d.Next())
	}
}

// Encode encodes int as json.
func (o NilInt) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *NilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilInt to nil")
	}
	switch d.Next() {
	case jx.Number:
		o.Null = false
		v, err := d.Int()
		if err != nil {
			return err
		}
		o.Value = int(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v int
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilInt", d.Next())
	}
}

// Encode encodes NullableCodeOfConductSimple as json.
func (o NilNullableCodeOfConductSimple) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableCodeOfConductSimple from json.
func (o *NilNullableCodeOfConductSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableCodeOfConductSimple to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableCodeOfConductSimple
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilNullableCodeOfConductSimple", d.Next())
	}
}

// Encode encodes NullableCommunityHealthFile as json.
func (o NilNullableCommunityHealthFile) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableCommunityHealthFile from json.
func (o *NilNullableCommunityHealthFile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableCommunityHealthFile to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableCommunityHealthFile
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilNullableCommunityHealthFile", d.Next())
	}
}

// Encode encodes NullableGitUser as json.
func (o NilNullableGitUser) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableGitUser from json.
func (o *NilNullableGitUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableGitUser to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableGitUser
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilNullableGitUser", d.Next())
	}
}

// Encode encodes NullableIntegration as json.
func (o NilNullableIntegration) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableIntegration from json.
func (o *NilNullableIntegration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableIntegration to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableIntegration
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilNullableIntegration", d.Next())
	}
}

// Encode encodes NullableLicenseSimple as json.
func (o NilNullableLicenseSimple) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableLicenseSimple from json.
func (o *NilNullableLicenseSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableLicenseSimple to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableLicenseSimple
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilNullableLicenseSimple", d.Next())
	}
}

// Encode encodes NullableMilestone as json.
func (o NilNullableMilestone) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableMilestone from json.
func (o *NilNullableMilestone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableMilestone to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableMilestone
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilNullableMilestone", d.Next())
	}
}

// Encode encodes NullableSimpleCommit as json.
func (o NilNullableSimpleCommit) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleCommit from json.
func (o *NilNullableSimpleCommit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableSimpleCommit to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableSimpleCommit
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilNullableSimpleCommit", d.Next())
	}
}

// Encode encodes NullableSimpleCommitAuthor as json.
func (o NilNullableSimpleCommitAuthor) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleCommitAuthor from json.
func (o *NilNullableSimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableSimpleCommitAuthor to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableSimpleCommitAuthor
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilNullableSimpleCommitAuthor", d.Next())
	}
}

// Encode encodes NullableSimpleCommitCommitter as json.
func (o NilNullableSimpleCommitCommitter) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleCommitCommitter from json.
func (o *NilNullableSimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableSimpleCommitCommitter to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableSimpleCommitCommitter
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilNullableSimpleCommitCommitter", d.Next())
	}
}

// Encode encodes NullableSimpleUser as json.
func (o NilNullableSimpleUser) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleUser from json.
func (o *NilNullableSimpleUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableSimpleUser to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableSimpleUser
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilNullableSimpleUser", d.Next())
	}
}

// Encode encodes NullableTeamSimple as json.
func (o NilNullableTeamSimple) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableTeamSimple from json.
func (o *NilNullableTeamSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilNullableTeamSimple to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableTeamSimple
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilNullableTeamSimple", d.Next())
	}
}

// Encode encodes PageStatus as json.
func (o NilPageStatus) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PageStatus from json.
func (o *NilPageStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilPageStatus to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PageStatus
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilPageStatus", d.Next())
	}
}

// Encode encodes PullRequestHeadRepo as json.
func (o NilPullRequestHeadRepo) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullRequestHeadRepo from json.
func (o *NilPullRequestHeadRepo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilPullRequestHeadRepo to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PullRequestHeadRepo
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilPullRequestHeadRepo", d.Next())
	}
}

// Encode encodes PullRequestHeadRepoLicense as json.
func (o NilPullRequestHeadRepoLicense) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullRequestHeadRepoLicense from json.
func (o *NilPullRequestHeadRepoLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilPullRequestHeadRepoLicense to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PullRequestHeadRepoLicense
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilPullRequestHeadRepoLicense", d.Next())
	}
}

// Encode encodes ReposUpdateBranchProtectionReqRequiredPullRequestReviews as json.
func (o NilReposUpdateBranchProtectionReqRequiredPullRequestReviews) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviews from json.
func (o *NilReposUpdateBranchProtectionReqRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilReposUpdateBranchProtectionReqRequiredPullRequestReviews to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v ReposUpdateBranchProtectionReqRequiredPullRequestReviews
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilReposUpdateBranchProtectionReqRequiredPullRequestReviews", d.Next())
	}
}

// Encode encodes ReposUpdateBranchProtectionReqRequiredStatusChecks as json.
func (o NilReposUpdateBranchProtectionReqRequiredStatusChecks) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredStatusChecks from json.
func (o *NilReposUpdateBranchProtectionReqRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilReposUpdateBranchProtectionReqRequiredStatusChecks to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v ReposUpdateBranchProtectionReqRequiredStatusChecks
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilReposUpdateBranchProtectionReqRequiredStatusChecks", d.Next())
	}
}

// Encode encodes ReposUpdateBranchProtectionReqRestrictions as json.
func (o NilReposUpdateBranchProtectionReqRestrictions) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRestrictions from json.
func (o *NilReposUpdateBranchProtectionReqRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilReposUpdateBranchProtectionReqRestrictions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v ReposUpdateBranchProtectionReqRestrictions
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilReposUpdateBranchProtectionReqRestrictions", d.Next())
	}
}

// Encode encodes SimpleCommitAuthor as json.
func (o NilSimpleCommitAuthor) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SimpleCommitAuthor from json.
func (o *NilSimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilSimpleCommitAuthor to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v SimpleCommitAuthor
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilSimpleCommitAuthor", d.Next())
	}
}

// Encode encodes SimpleCommitCommitter as json.
func (o NilSimpleCommitCommitter) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SimpleCommitCommitter from json.
func (o *NilSimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilSimpleCommitCommitter to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v SimpleCommitCommitter
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilSimpleCommitCommitter", d.Next())
	}
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v string
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilString", d.Next())
	}
}

// Encode encodes time.Time as json.
func (o NilTime) Encode(e *jx.Writer, format func(*jx.Writer, time.Time)) {
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *NilTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilTime to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		v, err := format(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v time.Time
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilTime", d.Next())
	}
}

// Encode encodes url.URL as json.
func (o NilURL) Encode(e *jx.Writer) {
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *NilURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilURL to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		v, err := json.DecodeURI(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v url.URL
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading NilURL", d.Next())
	}
}

// Encode implements json.Marshaler.
func (s NullableCodeOfConductSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		s.HTMLURL.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableCodeOfConductSimple = [4]string{
	0: "url",
	1: "key",
	2: "name",
	3: "html_url",
}

// Decode decodes NullableCodeOfConductSimple from json.
func (s *NullableCodeOfConductSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableCodeOfConductSimple to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableCodeOfConductSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableCodeOfConductSimple) {
					name = jsonFieldsNameOfNullableCodeOfConductSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableCommunityHealthFile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableCommunityHealthFile = [2]string{
	0: "url",
	1: "html_url",
}

// Decode decodes NullableCommunityHealthFile from json.
func (s *NullableCommunityHealthFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableCommunityHealthFile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableCommunityHealthFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableCommunityHealthFile) {
					name = jsonFieldsNameOfNullableCommunityHealthFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableGitUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Date.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableGitUser = [3]string{
	0: "name",
	1: "email",
	2: "date",
}

// Decode decodes NullableGitUser from json.
func (s *NullableGitUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableGitUser to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableGitUser")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableIntegration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		if s.Slug.Set {
			e.Comma()
		}
		if s.Slug.Set {
			e.RawStr("\"slug\"" + ":")
			s.Slug.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"external_url\"" + ":")
		json.EncodeURI(e, s.ExternalURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"permissions\"" + ":")
		s.Permissions.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"events\"" + ":")
		e.ArrStart()
		if len(s.Events) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Events[0]
				e.Str(elem)
			}
			for _, elem := range s.Events[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.InstallationsCount.Set {
			e.Comma()
		}
		if s.InstallationsCount.Set {
			e.RawStr("\"installations_count\"" + ":")
			s.InstallationsCount.Encode(e)
		}
	}
	{
		if s.ClientID.Set {
			e.Comma()
		}
		if s.ClientID.Set {
			e.RawStr("\"client_id\"" + ":")
			s.ClientID.Encode(e)
		}
	}
	{
		if s.ClientSecret.Set {
			e.Comma()
		}
		if s.ClientSecret.Set {
			e.RawStr("\"client_secret\"" + ":")
			s.ClientSecret.Encode(e)
		}
	}
	{
		if s.WebhookSecret.Set {
			e.Comma()
		}
		if s.WebhookSecret.Set {
			e.RawStr("\"webhook_secret\"" + ":")
			s.WebhookSecret.Encode(e)
		}
	}
	{
		if s.Pem.Set {
			e.Comma()
		}
		if s.Pem.Set {
			e.RawStr("\"pem\"" + ":")
			s.Pem.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableIntegration = [17]string{
	0:  "id",
	1:  "slug",
	2:  "node_id",
	3:  "owner",
	4:  "name",
	5:  "description",
	6:  "external_url",
	7:  "html_url",
	8:  "created_at",
	9:  "updated_at",
	10: "permissions",
	11: "events",
	12: "installations_count",
	13: "client_id",
	14: "client_secret",
	15: "webhook_secret",
	16: "pem",
}

// Decode decodes NullableIntegration from json.
func (s *NullableIntegration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableIntegration to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "external_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ExternalURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "events":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.Events = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "installations_count":
			if err := func() error {
				s.InstallationsCount.Reset()
				if err := s.InstallationsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"installations_count\"")
			}
		case "client_id":
			if err := func() error {
				s.ClientID.Reset()
				if err := s.ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_id\"")
			}
		case "client_secret":
			if err := func() error {
				s.ClientSecret.Reset()
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_secret\"")
			}
		case "webhook_secret":
			if err := func() error {
				s.WebhookSecret.Reset()
				if err := s.WebhookSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_secret\"")
			}
		case "pem":
			if err := func() error {
				s.Pem.Reset()
				if err := s.Pem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pem\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableIntegration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111101,
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableIntegration) {
					name = jsonFieldsNameOfNullableIntegration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableIntegrationPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		{
			if s.Issues.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Issues.Set {
				e.RawStr("\"issues\"" + ":")
				s.Issues.Encode(e)
			}
		}
		{
			if s.Checks.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Checks.Set {
				e.RawStr("\"checks\"" + ":")
				s.Checks.Encode(e)
			}
		}
		{
			if s.Metadata.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Metadata.Set {
				e.RawStr("\"metadata\"" + ":")
				s.Metadata.Encode(e)
			}
		}
		{
			if s.Contents.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Contents.Set {
				e.RawStr("\"contents\"" + ":")
				s.Contents.Encode(e)
			}
		}
		{
			if s.Deployments.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Deployments.Set {
				e.RawStr("\"deployments\"" + ":")
				s.Deployments.Encode(e)
			}
		}
	}
	for k, elem := range s.AdditionalProps {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		e.Str(elem)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableIntegrationPermissions = [5]string{
	0: "issues",
	1: "checks",
	2: "metadata",
	3: "contents",
	4: "deployments",
}

// Decode decodes NullableIntegrationPermissions from json.
func (s *NullableIntegrationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableIntegrationPermissions to nil")
	}

	m := s.AdditionalProps
	if m == nil {
		m = map[string]string{}
		s.AdditionalProps = m
	}
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "issues":
			if err := func() error {
				s.Issues.Reset()
				if err := s.Issues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues\"")
			}
		case "checks":
			if err := func() error {
				s.Checks.Reset()
				if err := s.Checks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checks\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "contents":
			if err := func() error {
				s.Contents.Reset()
				if err := s.Contents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents\"")
			}
		case "deployments":
			if err := func() error {
				s.Deployments.Reset()
				if err := s.Deployments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments\"")
			}
		default:
			var elem string
			if err := func() error {
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableIntegrationPermissions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableLicenseSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"spdx_id\"" + ":")
		s.SpdxID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		if s.HTMLURL.Set {
			e.Comma()
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableLicenseSimple = [6]string{
	0: "key",
	1: "name",
	2: "url",
	3: "spdx_id",
	4: "node_id",
	5: "html_url",
}

// Decode decodes NullableLicenseSimple from json.
func (s *NullableLicenseSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableLicenseSimple to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "spdx_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SpdxID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spdx_id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableLicenseSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableLicenseSimple) {
					name = jsonFieldsNameOfNullableLicenseSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableMilestone) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		json.EncodeURI(e, s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"closed_issues\"" + ":")
		e.Int(s.ClosedIssues)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"closed_at\"" + ":")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"due_on\"" + ":")
		s.DueOn.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableMilestone = [16]string{
	0:  "url",
	1:  "html_url",
	2:  "labels_url",
	3:  "id",
	4:  "node_id",
	5:  "number",
	6:  "state",
	7:  "title",
	8:  "description",
	9:  "creator",
	10: "open_issues",
	11: "closed_issues",
	12: "created_at",
	13: "updated_at",
	14: "closed_at",
	15: "due_on",
}

// Decode decodes NullableMilestone from json.
func (s *NullableMilestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableMilestone to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "labels_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LabelsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "creator":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "open_issues":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "closed_issues":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ClosedIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_issues\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "closed_at":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_at\"")
			}
		case "due_on":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"due_on\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableMilestone")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableMilestone) {
					name = jsonFieldsNameOfNullableMilestone[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes NullableMilestoneState as json.
func (s NullableMilestoneState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes NullableMilestoneState from json.
func (s *NullableMilestoneState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableMilestoneState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NullableMilestoneState(v) {
	case NullableMilestoneStateOpen:
		*s = NullableMilestoneStateOpen
	case NullableMilestoneStateClosed:
		*s = NullableMilestoneStateClosed
	default:
		*s = NullableMilestoneState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableMinimalRepository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		if s.GitURL.Set {
			e.Comma()
		}
		if s.GitURL.Set {
			e.RawStr("\"git_url\"" + ":")
			s.GitURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		if s.SSHURL.Set {
			e.Comma()
		}
		if s.SSHURL.Set {
			e.RawStr("\"ssh_url\"" + ":")
			s.SSHURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		if s.CloneURL.Set {
			e.Comma()
		}
		if s.CloneURL.Set {
			e.RawStr("\"clone_url\"" + ":")
			s.CloneURL.Encode(e)
		}
	}
	{
		if s.MirrorURL.Set {
			e.Comma()
		}
		if s.MirrorURL.Set {
			e.RawStr("\"mirror_url\"" + ":")
			s.MirrorURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		if s.SvnURL.Set {
			e.Comma()
		}
		if s.SvnURL.Set {
			e.RawStr("\"svn_url\"" + ":")
			s.SvnURL.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			e.Comma()
		}
		if s.Homepage.Set {
			e.RawStr("\"homepage\"" + ":")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.Comma()
		}
		if s.Language.Set {
			e.RawStr("\"language\"" + ":")
			s.Language.Encode(e)
		}
	}
	{
		if s.ForksCount.Set {
			e.Comma()
		}
		if s.ForksCount.Set {
			e.RawStr("\"forks_count\"" + ":")
			s.ForksCount.Encode(e)
		}
	}
	{
		if s.StargazersCount.Set {
			e.Comma()
		}
		if s.StargazersCount.Set {
			e.RawStr("\"stargazers_count\"" + ":")
			s.StargazersCount.Encode(e)
		}
	}
	{
		if s.WatchersCount.Set {
			e.Comma()
		}
		if s.WatchersCount.Set {
			e.RawStr("\"watchers_count\"" + ":")
			s.WatchersCount.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.Comma()
		}
		if s.Size.Set {
			e.RawStr("\"size\"" + ":")
			s.Size.Encode(e)
		}
	}
	{
		if s.DefaultBranch.Set {
			e.Comma()
		}
		if s.DefaultBranch.Set {
			e.RawStr("\"default_branch\"" + ":")
			s.DefaultBranch.Encode(e)
		}
	}
	{
		if s.OpenIssuesCount.Set {
			e.Comma()
		}
		if s.OpenIssuesCount.Set {
			e.RawStr("\"open_issues_count\"" + ":")
			s.OpenIssuesCount.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.HasIssues.Set {
			e.Comma()
		}
		if s.HasIssues.Set {
			e.RawStr("\"has_issues\"" + ":")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			e.Comma()
		}
		if s.HasProjects.Set {
			e.RawStr("\"has_projects\"" + ":")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			e.Comma()
		}
		if s.HasWiki.Set {
			e.RawStr("\"has_wiki\"" + ":")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.HasPages.Set {
			e.Comma()
		}
		if s.HasPages.Set {
			e.RawStr("\"has_pages\"" + ":")
			s.HasPages.Encode(e)
		}
	}
	{
		if s.HasDownloads.Set {
			e.Comma()
		}
		if s.HasDownloads.Set {
			e.RawStr("\"has_downloads\"" + ":")
			s.HasDownloads.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			e.Comma()
		}
		if s.Archived.Set {
			e.RawStr("\"archived\"" + ":")
			s.Archived.Encode(e)
		}
	}
	{
		if s.Disabled.Set {
			e.Comma()
		}
		if s.Disabled.Set {
			e.RawStr("\"disabled\"" + ":")
			s.Disabled.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.PushedAt.Set {
			e.Comma()
		}
		if s.PushedAt.Set {
			e.RawStr("\"pushed_at\"" + ":")
			s.PushedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedAt.Set {
			e.Comma()
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.Comma()
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.Comma()
		}
		if s.TemplateRepository.Set {
			e.RawStr("\"template_repository\"" + ":")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.Comma()
		}
		if s.SubscribersCount.Set {
			e.RawStr("\"subscribers_count\"" + ":")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.Comma()
		}
		if s.NetworkCount.Set {
			e.RawStr("\"network_count\"" + ":")
			s.NetworkCount.Encode(e)
		}
	}
	{
		if s.CodeOfConduct.Set {
			e.Comma()
		}
		if s.CodeOfConduct.Set {
			e.RawStr("\"code_of_conduct\"" + ":")
			s.CodeOfConduct.Encode(e)
		}
	}
	{
		if s.License.Set {
			e.Comma()
		}
		if s.License.Set {
			e.RawStr("\"license\"" + ":")
			s.License.Encode(e)
		}
	}
	{
		if s.Forks.Set {
			e.Comma()
		}
		if s.Forks.Set {
			e.RawStr("\"forks\"" + ":")
			s.Forks.Encode(e)
		}
	}
	{
		if s.OpenIssues.Set {
			e.Comma()
		}
		if s.OpenIssues.Set {
			e.RawStr("\"open_issues\"" + ":")
			s.OpenIssues.Encode(e)
		}
	}
	{
		if s.Watchers.Set {
			e.Comma()
		}
		if s.Watchers.Set {
			e.RawStr("\"watchers\"" + ":")
			s.Watchers.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableMinimalRepository = [84]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "owner",
	5:  "private",
	6:  "html_url",
	7:  "description",
	8:  "fork",
	9:  "url",
	10: "archive_url",
	11: "assignees_url",
	12: "blobs_url",
	13: "branches_url",
	14: "collaborators_url",
	15: "comments_url",
	16: "commits_url",
	17: "compare_url",
	18: "contents_url",
	19: "contributors_url",
	20: "deployments_url",
	21: "downloads_url",
	22: "events_url",
	23: "forks_url",
	24: "git_commits_url",
	25: "git_refs_url",
	26: "git_tags_url",
	27: "git_url",
	28: "issue_comment_url",
	29: "issue_events_url",
	30: "issues_url",
	31: "keys_url",
	32: "labels_url",
	33: "languages_url",
	34: "merges_url",
	35: "milestones_url",
	36: "notifications_url",
	37: "pulls_url",
	38: "releases_url",
	39: "ssh_url",
	40: "stargazers_url",
	41: "statuses_url",
	42: "subscribers_url",
	43: "subscription_url",
	44: "tags_url",
	45: "teams_url",
	46: "trees_url",
	47: "clone_url",
	48: "mirror_url",
	49: "hooks_url",
	50: "svn_url",
	51: "homepage",
	52: "language",
	53: "forks_count",
	54: "stargazers_count",
	55: "watchers_count",
	56: "size",
	57: "default_branch",
	58: "open_issues_count",
	59: "is_template",
	60: "topics",
	61: "has_issues",
	62: "has_projects",
	63: "has_wiki",
	64: "has_pages",
	65: "has_downloads",
	66: "archived",
	67: "disabled",
	68: "visibility",
	69: "pushed_at",
	70: "created_at",
	71: "updated_at",
	72: "permissions",
	73: "template_repository",
	74: "temp_clone_token",
	75: "delete_branch_on_merge",
	76: "subscribers_count",
	77: "network_count",
	78: "code_of_conduct",
	79: "license",
	80: "forks",
	81: "open_issues",
	82: "watchers",
	83: "allow_forking",
}

// Decode decodes NullableMinimalRepository from json.
func (s *NullableMinimalRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableMinimalRepository to nil")
	}
	var requiredBitSet [11]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			if err := func() error {
				s.GitURL.Reset()
				if err := s.GitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			if err := func() error {
				s.SSHURL.Reset()
				if err := s.SSHURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			if err := func() error {
				s.CloneURL.Reset()
				if err := s.CloneURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			if err := func() error {
				s.MirrorURL.Reset()
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			if err := func() error {
				s.SvnURL.Reset()
				if err := s.SvnURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			if err := func() error {
				s.Homepage.Reset()
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			if err := func() error {
				s.ForksCount.Reset()
				if err := s.ForksCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			if err := func() error {
				s.StargazersCount.Reset()
				if err := s.StargazersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			if err := func() error {
				s.WatchersCount.Reset()
				if err := s.WatchersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			if err := func() error {
				s.DefaultBranch.Reset()
				if err := s.DefaultBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			if err := func() error {
				s.OpenIssuesCount.Reset()
				if err := s.OpenIssuesCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			if err := func() error {
				s.HasIssues.Reset()
				if err := s.HasIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			if err := func() error {
				s.HasProjects.Reset()
				if err := s.HasProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			if err := func() error {
				s.HasWiki.Reset()
				if err := s.HasWiki.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			if err := func() error {
				s.HasPages.Reset()
				if err := s.HasPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			if err := func() error {
				s.HasDownloads.Reset()
				if err := s.HasDownloads.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			if err := func() error {
				s.Disabled.Reset()
				if err := s.Disabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			if err := func() error {
				s.PushedAt.Reset()
				if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "template_repository":
			if err := func() error {
				s.TemplateRepository.Reset()
				if err := s.TemplateRepository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_repository\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "subscribers_count":
			if err := func() error {
				s.SubscribersCount.Reset()
				if err := s.SubscribersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			if err := func() error {
				s.NetworkCount.Reset()
				if err := s.NetworkCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		case "code_of_conduct":
			if err := func() error {
				s.CodeOfConduct.Reset()
				if err := s.CodeOfConduct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_of_conduct\"")
			}
		case "license":
			if err := func() error {
				s.License.Reset()
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "forks":
			if err := func() error {
				s.Forks.Reset()
				if err := s.Forks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "open_issues":
			if err := func() error {
				s.OpenIssues.Reset()
				if err := s.OpenIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "watchers":
			if err := func() error {
				s.Watchers.Reset()
				if err := s.Watchers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableMinimalRepository")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [11]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11110111,
		0b01111111,
		0b01111111,
		0b00000010,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableMinimalRepository) {
					name = jsonFieldsNameOfNullableMinimalRepository[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableMinimalRepositoryLicense) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Key.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Key.Set {
			e.RawStr("\"key\"" + ":")
			s.Key.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.SpdxID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SpdxID.Set {
			e.RawStr("\"spdx_id\"" + ":")
			s.SpdxID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableMinimalRepositoryLicense = [5]string{
	0: "key",
	1: "name",
	2: "spdx_id",
	3: "url",
	4: "node_id",
}

// Decode decodes NullableMinimalRepositoryLicense from json.
func (s *NullableMinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableMinimalRepositoryLicense to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "spdx_id":
			if err := func() error {
				s.SpdxID.Reset()
				if err := s.SpdxID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spdx_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableMinimalRepositoryLicense")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableMinimalRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Admin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Admin.Set {
			e.RawStr("\"admin\"" + ":")
			s.Admin.Encode(e)
		}
	}
	{
		if s.Maintain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		if s.Push.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Push.Set {
			e.RawStr("\"push\"" + ":")
			s.Push.Encode(e)
		}
	}
	{
		if s.Triage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		if s.Pull.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pull.Set {
			e.RawStr("\"pull\"" + ":")
			s.Pull.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableMinimalRepositoryPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes NullableMinimalRepositoryPermissions from json.
func (s *NullableMinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableMinimalRepositoryPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			if err := func() error {
				s.Admin.Reset()
				if err := s.Admin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			if err := func() error {
				s.Push.Reset()
				if err := s.Push.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			if err := func() error {
				s.Pull.Reset()
				if err := s.Pull.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableMinimalRepositoryPermissions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableRepository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		if s.Organization.Set {
			e.Comma()
		}
		if s.Organization.Set {
			e.RawStr("\"organization\"" + ":")
			s.Organization.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"forks\"" + ":")
		e.Int(s.Forks)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		e.Str(s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		e.Comma()

		e.RawStr("\"ssh_url\"" + ":")
		e.Str(s.SSHURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		e.Comma()

		e.RawStr("\"clone_url\"" + ":")
		e.Str(s.CloneURL)
	}
	{
		e.Comma()

		e.RawStr("\"mirror_url\"" + ":")
		s.MirrorURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"svn_url\"" + ":")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		e.Comma()

		e.RawStr("\"homepage\"" + ":")
		s.Homepage.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"language\"" + ":")
		s.Language.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"forks_count\"" + ":")
		e.Int(s.ForksCount)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_count\"" + ":")
		e.Int(s.StargazersCount)
	}
	{
		e.Comma()

		e.RawStr("\"watchers_count\"" + ":")
		e.Int(s.WatchersCount)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"default_branch\"" + ":")
		e.Str(s.DefaultBranch)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues_count\"" + ":")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"has_issues\"" + ":")
		e.Bool(s.HasIssues)
	}
	{
		e.Comma()

		e.RawStr("\"has_projects\"" + ":")
		e.Bool(s.HasProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_wiki\"" + ":")
		e.Bool(s.HasWiki)
	}
	{
		e.Comma()

		e.RawStr("\"has_pages\"" + ":")
		e.Bool(s.HasPages)
	}
	{
		e.Comma()

		e.RawStr("\"has_downloads\"" + ":")
		e.Bool(s.HasDownloads)
	}
	{
		e.Comma()

		e.RawStr("\"archived\"" + ":")
		e.Bool(s.Archived)
	}
	{
		e.Comma()

		e.RawStr("\"disabled\"" + ":")
		e.Bool(s.Disabled)
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pushed_at\"" + ":")
		s.PushedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.Comma()
		}
		if s.TemplateRepository.Set {
			e.RawStr("\"template_repository\"" + ":")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.Comma()
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.Comma()
		}
		if s.SubscribersCount.Set {
			e.RawStr("\"subscribers_count\"" + ":")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.Comma()
		}
		if s.NetworkCount.Set {
			e.RawStr("\"network_count\"" + ":")
			s.NetworkCount.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"watchers\"" + ":")
		e.Int(s.Watchers)
	}
	{
		if s.MasterBranch.Set {
			e.Comma()
		}
		if s.MasterBranch.Set {
			e.RawStr("\"master_branch\"" + ":")
			s.MasterBranch.Encode(e)
		}
	}
	{
		if s.StarredAt.Set {
			e.Comma()
		}
		if s.StarredAt.Set {
			e.RawStr("\"starred_at\"" + ":")
			s.StarredAt.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableRepository = [90]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "license",
	5:  "organization",
	6:  "forks",
	7:  "permissions",
	8:  "owner",
	9:  "private",
	10: "html_url",
	11: "description",
	12: "fork",
	13: "url",
	14: "archive_url",
	15: "assignees_url",
	16: "blobs_url",
	17: "branches_url",
	18: "collaborators_url",
	19: "comments_url",
	20: "commits_url",
	21: "compare_url",
	22: "contents_url",
	23: "contributors_url",
	24: "deployments_url",
	25: "downloads_url",
	26: "events_url",
	27: "forks_url",
	28: "git_commits_url",
	29: "git_refs_url",
	30: "git_tags_url",
	31: "git_url",
	32: "issue_comment_url",
	33: "issue_events_url",
	34: "issues_url",
	35: "keys_url",
	36: "labels_url",
	37: "languages_url",
	38: "merges_url",
	39: "milestones_url",
	40: "notifications_url",
	41: "pulls_url",
	42: "releases_url",
	43: "ssh_url",
	44: "stargazers_url",
	45: "statuses_url",
	46: "subscribers_url",
	47: "subscription_url",
	48: "tags_url",
	49: "teams_url",
	50: "trees_url",
	51: "clone_url",
	52: "mirror_url",
	53: "hooks_url",
	54: "svn_url",
	55: "homepage",
	56: "language",
	57: "forks_count",
	58: "stargazers_count",
	59: "watchers_count",
	60: "size",
	61: "default_branch",
	62: "open_issues_count",
	63: "is_template",
	64: "topics",
	65: "has_issues",
	66: "has_projects",
	67: "has_wiki",
	68: "has_pages",
	69: "has_downloads",
	70: "archived",
	71: "disabled",
	72: "visibility",
	73: "pushed_at",
	74: "created_at",
	75: "updated_at",
	76: "allow_rebase_merge",
	77: "template_repository",
	78: "temp_clone_token",
	79: "allow_squash_merge",
	80: "allow_auto_merge",
	81: "delete_branch_on_merge",
	82: "allow_merge_commit",
	83: "allow_forking",
	84: "subscribers_count",
	85: "network_count",
	86: "open_issues",
	87: "watchers",
	88: "master_branch",
	89: "starred_at",
}

// Decode decodes NullableRepository from json.
func (s *NullableRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableRepository to nil")
	}
	var requiredBitSet [12]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "license":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "organization":
			if err := func() error {
				s.Organization.Reset()
				if err := s.Organization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		case "forks":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Forks = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "owner":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.GitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.SSHURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CloneURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SvnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ForksCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.StargazersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WatchersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DefaultBranch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.OpenIssuesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasIssues = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.HasProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.HasWiki = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasPages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.HasDownloads = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Archived = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "template_repository":
			if err := func() error {
				s.TemplateRepository.Reset()
				if err := s.TemplateRepository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_repository\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		case "subscribers_count":
			if err := func() error {
				s.SubscribersCount.Reset()
				if err := s.SubscribersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			if err := func() error {
				s.NetworkCount.Reset()
				if err := s.NetworkCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		case "open_issues":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "watchers":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Watchers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "master_branch":
			if err := func() error {
				s.MasterBranch.Reset()
				if err := s.MasterBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master_branch\"")
			}
		case "starred_at":
			if err := func() error {
				s.StarredAt.Reset()
				if err := s.StarredAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableRepository")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [12]uint8{
		0b01011111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
		0b11111110,
		0b00001110,
		0b11000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableRepository) {
					name = jsonFieldsNameOfNullableRepository[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	{
		e.Comma()

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableRepositoryPermissions = [5]string{
	0: "admin",
	1: "pull",
	2: "triage",
	3: "push",
	4: "maintain",
}

// Decode decodes NullableRepositoryPermissions from json.
func (s *NullableRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableRepositoryPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "pull":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableRepositoryPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableRepositoryPermissions) {
					name = jsonFieldsNameOfNullableRepositoryPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableRepositoryTemplateRepository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.FullName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FullName.Set {
			e.RawStr("\"full_name\"" + ":")
			s.FullName.Encode(e)
		}
	}
	{
		if s.Owner.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Private.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Fork.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fork.Set {
			e.RawStr("\"fork\"" + ":")
			s.Fork.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ArchiveURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ArchiveURL.Set {
			e.RawStr("\"archive_url\"" + ":")
			s.ArchiveURL.Encode(e)
		}
	}
	{
		if s.AssigneesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AssigneesURL.Set {
			e.RawStr("\"assignees_url\"" + ":")
			s.AssigneesURL.Encode(e)
		}
	}
	{
		if s.BlobsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BlobsURL.Set {
			e.RawStr("\"blobs_url\"" + ":")
			s.BlobsURL.Encode(e)
		}
	}
	{
		if s.BranchesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BranchesURL.Set {
			e.RawStr("\"branches_url\"" + ":")
			s.BranchesURL.Encode(e)
		}
	}
	{
		if s.CollaboratorsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CollaboratorsURL.Set {
			e.RawStr("\"collaborators_url\"" + ":")
			s.CollaboratorsURL.Encode(e)
		}
	}
	{
		if s.CommentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommentsURL.Set {
			e.RawStr("\"comments_url\"" + ":")
			s.CommentsURL.Encode(e)
		}
	}
	{
		if s.CommitsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommitsURL.Set {
			e.RawStr("\"commits_url\"" + ":")
			s.CommitsURL.Encode(e)
		}
	}
	{
		if s.CompareURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CompareURL.Set {
			e.RawStr("\"compare_url\"" + ":")
			s.CompareURL.Encode(e)
		}
	}
	{
		if s.ContentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentsURL.Set {
			e.RawStr("\"contents_url\"" + ":")
			s.ContentsURL.Encode(e)
		}
	}
	{
		if s.ContributorsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContributorsURL.Set {
			e.RawStr("\"contributors_url\"" + ":")
			s.ContributorsURL.Encode(e)
		}
	}
	{
		if s.DeploymentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeploymentsURL.Set {
			e.RawStr("\"deployments_url\"" + ":")
			s.DeploymentsURL.Encode(e)
		}
	}
	{
		if s.DownloadsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DownloadsURL.Set {
			e.RawStr("\"downloads_url\"" + ":")
			s.DownloadsURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsURL.Set {
			e.RawStr("\"events_url\"" + ":")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ForksURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForksURL.Set {
			e.RawStr("\"forks_url\"" + ":")
			s.ForksURL.Encode(e)
		}
	}
	{
		if s.GitCommitsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitCommitsURL.Set {
			e.RawStr("\"git_commits_url\"" + ":")
			s.GitCommitsURL.Encode(e)
		}
	}
	{
		if s.GitRefsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitRefsURL.Set {
			e.RawStr("\"git_refs_url\"" + ":")
			s.GitRefsURL.Encode(e)
		}
	}
	{
		if s.GitTagsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitTagsURL.Set {
			e.RawStr("\"git_tags_url\"" + ":")
			s.GitTagsURL.Encode(e)
		}
	}
	{
		if s.GitURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitURL.Set {
			e.RawStr("\"git_url\"" + ":")
			s.GitURL.Encode(e)
		}
	}
	{
		if s.IssueCommentURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IssueCommentURL.Set {
			e.RawStr("\"issue_comment_url\"" + ":")
			s.IssueCommentURL.Encode(e)
		}
	}
	{
		if s.IssueEventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IssueEventsURL.Set {
			e.RawStr("\"issue_events_url\"" + ":")
			s.IssueEventsURL.Encode(e)
		}
	}
	{
		if s.IssuesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IssuesURL.Set {
			e.RawStr("\"issues_url\"" + ":")
			s.IssuesURL.Encode(e)
		}
	}
	{
		if s.KeysURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.KeysURL.Set {
			e.RawStr("\"keys_url\"" + ":")
			s.KeysURL.Encode(e)
		}
	}
	{
		if s.LabelsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LabelsURL.Set {
			e.RawStr("\"labels_url\"" + ":")
			s.LabelsURL.Encode(e)
		}
	}
	{
		if s.LanguagesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LanguagesURL.Set {
			e.RawStr("\"languages_url\"" + ":")
			s.LanguagesURL.Encode(e)
		}
	}
	{
		if s.MergesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MergesURL.Set {
			e.RawStr("\"merges_url\"" + ":")
			s.MergesURL.Encode(e)
		}
	}
	{
		if s.MilestonesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MilestonesURL.Set {
			e.RawStr("\"milestones_url\"" + ":")
			s.MilestonesURL.Encode(e)
		}
	}
	{
		if s.NotificationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NotificationsURL.Set {
			e.RawStr("\"notifications_url\"" + ":")
			s.NotificationsURL.Encode(e)
		}
	}
	{
		if s.PullsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PullsURL.Set {
			e.RawStr("\"pulls_url\"" + ":")
			s.PullsURL.Encode(e)
		}
	}
	{
		if s.ReleasesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReleasesURL.Set {
			e.RawStr("\"releases_url\"" + ":")
			s.ReleasesURL.Encode(e)
		}
	}
	{
		if s.SSHURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SSHURL.Set {
			e.RawStr("\"ssh_url\"" + ":")
			s.SSHURL.Encode(e)
		}
	}
	{
		if s.StargazersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StargazersURL.Set {
			e.RawStr("\"stargazers_url\"" + ":")
			s.StargazersURL.Encode(e)
		}
	}
	{
		if s.StatusesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StatusesURL.Set {
			e.RawStr("\"statuses_url\"" + ":")
			s.StatusesURL.Encode(e)
		}
	}
	{
		if s.SubscribersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscribersURL.Set {
			e.RawStr("\"subscribers_url\"" + ":")
			s.SubscribersURL.Encode(e)
		}
	}
	{
		if s.SubscriptionURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscriptionURL.Set {
			e.RawStr("\"subscription_url\"" + ":")
			s.SubscriptionURL.Encode(e)
		}
	}
	{
		if s.TagsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TagsURL.Set {
			e.RawStr("\"tags_url\"" + ":")
			s.TagsURL.Encode(e)
		}
	}
	{
		if s.TeamsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TeamsURL.Set {
			e.RawStr("\"teams_url\"" + ":")
			s.TeamsURL.Encode(e)
		}
	}
	{
		if s.TreesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TreesURL.Set {
			e.RawStr("\"trees_url\"" + ":")
			s.TreesURL.Encode(e)
		}
	}
	{
		if s.CloneURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CloneURL.Set {
			e.RawStr("\"clone_url\"" + ":")
			s.CloneURL.Encode(e)
		}
	}
	{
		if s.MirrorURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MirrorURL.Set {
			e.RawStr("\"mirror_url\"" + ":")
			s.MirrorURL.Encode(e)
		}
	}
	{
		if s.HooksURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HooksURL.Set {
			e.RawStr("\"hooks_url\"" + ":")
			s.HooksURL.Encode(e)
		}
	}
	{
		if s.SvnURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SvnURL.Set {
			e.RawStr("\"svn_url\"" + ":")
			s.SvnURL.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Homepage.Set {
			e.RawStr("\"homepage\"" + ":")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Language.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Language.Set {
			e.RawStr("\"language\"" + ":")
			s.Language.Encode(e)
		}
	}
	{
		if s.ForksCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForksCount.Set {
			e.RawStr("\"forks_count\"" + ":")
			s.ForksCount.Encode(e)
		}
	}
	{
		if s.StargazersCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StargazersCount.Set {
			e.RawStr("\"stargazers_count\"" + ":")
			s.StargazersCount.Encode(e)
		}
	}
	{
		if s.WatchersCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.WatchersCount.Set {
			e.RawStr("\"watchers_count\"" + ":")
			s.WatchersCount.Encode(e)
		}
	}
	{
		if s.Size.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Size.Set {
			e.RawStr("\"size\"" + ":")
			s.Size.Encode(e)
		}
	}
	{
		if s.DefaultBranch.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultBranch.Set {
			e.RawStr("\"default_branch\"" + ":")
			s.DefaultBranch.Encode(e)
		}
	}
	{
		if s.OpenIssuesCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OpenIssuesCount.Set {
			e.RawStr("\"open_issues_count\"" + ":")
			s.OpenIssuesCount.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.HasIssues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasIssues.Set {
			e.RawStr("\"has_issues\"" + ":")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasProjects.Set {
			e.RawStr("\"has_projects\"" + ":")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasWiki.Set {
			e.RawStr("\"has_wiki\"" + ":")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.HasPages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasPages.Set {
			e.RawStr("\"has_pages\"" + ":")
			s.HasPages.Encode(e)
		}
	}
	{
		if s.HasDownloads.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasDownloads.Set {
			e.RawStr("\"has_downloads\"" + ":")
			s.HasDownloads.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Archived.Set {
			e.RawStr("\"archived\"" + ":")
			s.Archived.Encode(e)
		}
	}
	{
		if s.Disabled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Disabled.Set {
			e.RawStr("\"disabled\"" + ":")
			s.Disabled.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.PushedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PushedAt.Set {
			e.RawStr("\"pushed_at\"" + ":")
			s.PushedAt.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.Permissions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscribersCount.Set {
			e.RawStr("\"subscribers_count\"" + ":")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NetworkCount.Set {
			e.RawStr("\"network_count\"" + ":")
			s.NetworkCount.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableRepositoryTemplateRepository = [81]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "owner",
	5:  "private",
	6:  "html_url",
	7:  "description",
	8:  "fork",
	9:  "url",
	10: "archive_url",
	11: "assignees_url",
	12: "blobs_url",
	13: "branches_url",
	14: "collaborators_url",
	15: "comments_url",
	16: "commits_url",
	17: "compare_url",
	18: "contents_url",
	19: "contributors_url",
	20: "deployments_url",
	21: "downloads_url",
	22: "events_url",
	23: "forks_url",
	24: "git_commits_url",
	25: "git_refs_url",
	26: "git_tags_url",
	27: "git_url",
	28: "issue_comment_url",
	29: "issue_events_url",
	30: "issues_url",
	31: "keys_url",
	32: "labels_url",
	33: "languages_url",
	34: "merges_url",
	35: "milestones_url",
	36: "notifications_url",
	37: "pulls_url",
	38: "releases_url",
	39: "ssh_url",
	40: "stargazers_url",
	41: "statuses_url",
	42: "subscribers_url",
	43: "subscription_url",
	44: "tags_url",
	45: "teams_url",
	46: "trees_url",
	47: "clone_url",
	48: "mirror_url",
	49: "hooks_url",
	50: "svn_url",
	51: "homepage",
	52: "language",
	53: "forks_count",
	54: "stargazers_count",
	55: "watchers_count",
	56: "size",
	57: "default_branch",
	58: "open_issues_count",
	59: "is_template",
	60: "topics",
	61: "has_issues",
	62: "has_projects",
	63: "has_wiki",
	64: "has_pages",
	65: "has_downloads",
	66: "archived",
	67: "disabled",
	68: "visibility",
	69: "pushed_at",
	70: "created_at",
	71: "updated_at",
	72: "permissions",
	73: "allow_rebase_merge",
	74: "temp_clone_token",
	75: "allow_squash_merge",
	76: "allow_auto_merge",
	77: "delete_branch_on_merge",
	78: "allow_merge_commit",
	79: "subscribers_count",
	80: "network_count",
}

// Decode decodes NullableRepositoryTemplateRepository from json.
func (s *NullableRepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableRepositoryTemplateRepository to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			if err := func() error {
				s.FullName.Reset()
				if err := s.FullName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			if err := func() error {
				s.Fork.Reset()
				if err := s.Fork.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			if err := func() error {
				s.ArchiveURL.Reset()
				if err := s.ArchiveURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			if err := func() error {
				s.AssigneesURL.Reset()
				if err := s.AssigneesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			if err := func() error {
				s.BlobsURL.Reset()
				if err := s.BlobsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			if err := func() error {
				s.BranchesURL.Reset()
				if err := s.BranchesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			if err := func() error {
				s.CollaboratorsURL.Reset()
				if err := s.CollaboratorsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			if err := func() error {
				s.CommentsURL.Reset()
				if err := s.CommentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			if err := func() error {
				s.CommitsURL.Reset()
				if err := s.CommitsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			if err := func() error {
				s.CompareURL.Reset()
				if err := s.CompareURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			if err := func() error {
				s.ContentsURL.Reset()
				if err := s.ContentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			if err := func() error {
				s.ContributorsURL.Reset()
				if err := s.ContributorsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			if err := func() error {
				s.DeploymentsURL.Reset()
				if err := s.DeploymentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			if err := func() error {
				s.DownloadsURL.Reset()
				if err := s.DownloadsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			if err := func() error {
				s.EventsURL.Reset()
				if err := s.EventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			if err := func() error {
				s.ForksURL.Reset()
				if err := s.ForksURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			if err := func() error {
				s.GitCommitsURL.Reset()
				if err := s.GitCommitsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			if err := func() error {
				s.GitRefsURL.Reset()
				if err := s.GitRefsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			if err := func() error {
				s.GitTagsURL.Reset()
				if err := s.GitTagsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			if err := func() error {
				s.GitURL.Reset()
				if err := s.GitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			if err := func() error {
				s.IssueCommentURL.Reset()
				if err := s.IssueCommentURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			if err := func() error {
				s.IssueEventsURL.Reset()
				if err := s.IssueEventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			if err := func() error {
				s.IssuesURL.Reset()
				if err := s.IssuesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			if err := func() error {
				s.KeysURL.Reset()
				if err := s.KeysURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			if err := func() error {
				s.LabelsURL.Reset()
				if err := s.LabelsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			if err := func() error {
				s.LanguagesURL.Reset()
				if err := s.LanguagesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			if err := func() error {
				s.MergesURL.Reset()
				if err := s.MergesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			if err := func() error {
				s.MilestonesURL.Reset()
				if err := s.MilestonesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			if err := func() error {
				s.NotificationsURL.Reset()
				if err := s.NotificationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			if err := func() error {
				s.PullsURL.Reset()
				if err := s.PullsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			if err := func() error {
				s.ReleasesURL.Reset()
				if err := s.ReleasesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			if err := func() error {
				s.SSHURL.Reset()
				if err := s.SSHURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			if err := func() error {
				s.StargazersURL.Reset()
				if err := s.StargazersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			if err := func() error {
				s.StatusesURL.Reset()
				if err := s.StatusesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			if err := func() error {
				s.SubscribersURL.Reset()
				if err := s.SubscribersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			if err := func() error {
				s.SubscriptionURL.Reset()
				if err := s.SubscriptionURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			if err := func() error {
				s.TagsURL.Reset()
				if err := s.TagsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			if err := func() error {
				s.TeamsURL.Reset()
				if err := s.TeamsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			if err := func() error {
				s.TreesURL.Reset()
				if err := s.TreesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			if err := func() error {
				s.CloneURL.Reset()
				if err := s.CloneURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			if err := func() error {
				s.MirrorURL.Reset()
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			if err := func() error {
				s.HooksURL.Reset()
				if err := s.HooksURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			if err := func() error {
				s.SvnURL.Reset()
				if err := s.SvnURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			if err := func() error {
				s.Homepage.Reset()
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			if err := func() error {
				s.ForksCount.Reset()
				if err := s.ForksCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			if err := func() error {
				s.StargazersCount.Reset()
				if err := s.StargazersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			if err := func() error {
				s.WatchersCount.Reset()
				if err := s.WatchersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			if err := func() error {
				s.DefaultBranch.Reset()
				if err := s.DefaultBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			if err := func() error {
				s.OpenIssuesCount.Reset()
				if err := s.OpenIssuesCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			if err := func() error {
				s.HasIssues.Reset()
				if err := s.HasIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			if err := func() error {
				s.HasProjects.Reset()
				if err := s.HasProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			if err := func() error {
				s.HasWiki.Reset()
				if err := s.HasWiki.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			if err := func() error {
				s.HasPages.Reset()
				if err := s.HasPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			if err := func() error {
				s.HasDownloads.Reset()
				if err := s.HasDownloads.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			if err := func() error {
				s.Disabled.Reset()
				if err := s.Disabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			if err := func() error {
				s.PushedAt.Reset()
				if err := s.PushedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "subscribers_count":
			if err := func() error {
				s.SubscribersCount.Reset()
				if err := s.SubscribersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			if err := func() error {
				s.NetworkCount.Reset()
				if err := s.NetworkCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableRepositoryTemplateRepository")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableRepositoryTemplateRepositoryOwner) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Login.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Login.Set {
			e.RawStr("\"login\"" + ":")
			s.Login.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvatarURL.Set {
			e.RawStr("\"avatar_url\"" + ":")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.GravatarID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GravatarID.Set {
			e.RawStr("\"gravatar_id\"" + ":")
			s.GravatarID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.FollowersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowersURL.Set {
			e.RawStr("\"followers_url\"" + ":")
			s.FollowersURL.Encode(e)
		}
	}
	{
		if s.FollowingURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowingURL.Set {
			e.RawStr("\"following_url\"" + ":")
			s.FollowingURL.Encode(e)
		}
	}
	{
		if s.GistsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GistsURL.Set {
			e.RawStr("\"gists_url\"" + ":")
			s.GistsURL.Encode(e)
		}
	}
	{
		if s.StarredURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StarredURL.Set {
			e.RawStr("\"starred_url\"" + ":")
			s.StarredURL.Encode(e)
		}
	}
	{
		if s.SubscriptionsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscriptionsURL.Set {
			e.RawStr("\"subscriptions_url\"" + ":")
			s.SubscriptionsURL.Encode(e)
		}
	}
	{
		if s.OrganizationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationsURL.Set {
			e.RawStr("\"organizations_url\"" + ":")
			s.OrganizationsURL.Encode(e)
		}
	}
	{
		if s.ReposURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReposURL.Set {
			e.RawStr("\"repos_url\"" + ":")
			s.ReposURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsURL.Set {
			e.RawStr("\"events_url\"" + ":")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ReceivedEventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReceivedEventsURL.Set {
			e.RawStr("\"received_events_url\"" + ":")
			s.ReceivedEventsURL.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.SiteAdmin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SiteAdmin.Set {
			e.RawStr("\"site_admin\"" + ":")
			s.SiteAdmin.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableRepositoryTemplateRepositoryOwner = [18]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "avatar_url",
	4:  "gravatar_id",
	5:  "url",
	6:  "html_url",
	7:  "followers_url",
	8:  "following_url",
	9:  "gists_url",
	10: "starred_url",
	11: "subscriptions_url",
	12: "organizations_url",
	13: "repos_url",
	14: "events_url",
	15: "received_events_url",
	16: "type",
	17: "site_admin",
}

// Decode decodes NullableRepositoryTemplateRepositoryOwner from json.
func (s *NullableRepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableRepositoryTemplateRepositoryOwner to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			if err := func() error {
				s.Login.Reset()
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			if err := func() error {
				s.GravatarID.Reset()
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			if err := func() error {
				s.FollowersURL.Reset()
				if err := s.FollowersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			if err := func() error {
				s.FollowingURL.Reset()
				if err := s.FollowingURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			if err := func() error {
				s.GistsURL.Reset()
				if err := s.GistsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			if err := func() error {
				s.StarredURL.Reset()
				if err := s.StarredURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			if err := func() error {
				s.SubscriptionsURL.Reset()
				if err := s.SubscriptionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			if err := func() error {
				s.OrganizationsURL.Reset()
				if err := s.OrganizationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			if err := func() error {
				s.ReposURL.Reset()
				if err := s.ReposURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			if err := func() error {
				s.EventsURL.Reset()
				if err := s.EventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			if err := func() error {
				s.ReceivedEventsURL.Reset()
				if err := s.ReceivedEventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			if err := func() error {
				s.SiteAdmin.Reset()
				if err := s.SiteAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableRepositoryTemplateRepositoryOwner")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableRepositoryTemplateRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Admin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Admin.Set {
			e.RawStr("\"admin\"" + ":")
			s.Admin.Encode(e)
		}
	}
	{
		if s.Maintain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		if s.Push.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Push.Set {
			e.RawStr("\"push\"" + ":")
			s.Push.Encode(e)
		}
	}
	{
		if s.Triage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		if s.Pull.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pull.Set {
			e.RawStr("\"pull\"" + ":")
			s.Pull.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableRepositoryTemplateRepositoryPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes NullableRepositoryTemplateRepositoryPermissions from json.
func (s *NullableRepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableRepositoryTemplateRepositoryPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			if err := func() error {
				s.Admin.Reset()
				if err := s.Admin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			if err := func() error {
				s.Push.Reset()
				if err := s.Push.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			if err := func() error {
				s.Pull.Reset()
				if err := s.Pull.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableRepositoryTemplateRepositoryPermissions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableScopedInstallation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"permissions\"" + ":")
		s.Permissions.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"repository_selection\"" + ":")
		s.RepositorySelection.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"single_file_name\"" + ":")
		s.SingleFileName.Encode(e)
	}
	{
		if s.HasMultipleSingleFiles.Set {
			e.Comma()
		}
		if s.HasMultipleSingleFiles.Set {
			e.RawStr("\"has_multiple_single_files\"" + ":")
			s.HasMultipleSingleFiles.Encode(e)
		}
	}
	{
		if s.SingleFilePaths != nil {
			e.Comma()
		}
		if s.SingleFilePaths != nil {
			e.RawStr("\"single_file_paths\"" + ":")
			e.ArrStart()
			if len(s.SingleFilePaths) >= 1 {
				// Encode first element without comma.
				{
					elem := s.SingleFilePaths[0]
					e.Str(elem)
				}
				for _, elem := range s.SingleFilePaths[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"repositories_url\"" + ":")
		json.EncodeURI(e, s.RepositoriesURL)
	}
	{
		e.Comma()

		e.RawStr("\"account\"" + ":")
		s.Account.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableScopedInstallation = [7]string{
	0: "permissions",
	1: "repository_selection",
	2: "single_file_name",
	3: "has_multiple_single_files",
	4: "single_file_paths",
	5: "repositories_url",
	6: "account",
}

// Decode decodes NullableScopedInstallation from json.
func (s *NullableScopedInstallation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableScopedInstallation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permissions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "repository_selection":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.RepositorySelection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_selection\"")
			}
		case "single_file_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.SingleFileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"single_file_name\"")
			}
		case "has_multiple_single_files":
			if err := func() error {
				s.HasMultipleSingleFiles.Reset()
				if err := s.HasMultipleSingleFiles.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_multiple_single_files\"")
			}
		case "single_file_paths":
			if err := func() error {
				s.SingleFilePaths = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SingleFilePaths = append(s.SingleFilePaths, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"single_file_paths\"")
			}
		case "repositories_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoriesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories_url\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Account.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableScopedInstallation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableScopedInstallation) {
					name = jsonFieldsNameOfNullableScopedInstallation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes NullableScopedInstallationRepositorySelection as json.
func (s NullableScopedInstallationRepositorySelection) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes NullableScopedInstallationRepositorySelection from json.
func (s *NullableScopedInstallationRepositorySelection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableScopedInstallationRepositorySelection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NullableScopedInstallationRepositorySelection(v) {
	case NullableScopedInstallationRepositorySelectionAll:
		*s = NullableScopedInstallationRepositorySelectionAll
	case NullableScopedInstallationRepositorySelectionSelected:
		*s = NullableScopedInstallationRepositorySelectionSelected
	default:
		*s = NullableScopedInstallationRepositorySelection(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableSimpleCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"tree_id\"" + ":")
		e.Str(s.TreeID)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"timestamp\"" + ":")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		e.Comma()

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committer\"" + ":")
		s.Committer.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableSimpleCommit = [6]string{
	0: "id",
	1: "tree_id",
	2: "message",
	3: "timestamp",
	4: "author",
	5: "committer",
}

// Decode decodes NullableSimpleCommit from json.
func (s *NullableSimpleCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableSimpleCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "tree_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TreeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree_id\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableSimpleCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableSimpleCommit) {
					name = jsonFieldsNameOfNullableSimpleCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableSimpleCommitAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableSimpleCommitAuthor = [2]string{
	0: "name",
	1: "email",
}

// Decode decodes NullableSimpleCommitAuthor from json.
func (s *NullableSimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableSimpleCommitAuthor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableSimpleCommitAuthor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableSimpleCommitAuthor) {
					name = jsonFieldsNameOfNullableSimpleCommitAuthor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableSimpleCommitCommitter) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableSimpleCommitCommitter = [2]string{
	0: "name",
	1: "email",
}

// Decode decodes NullableSimpleCommitCommitter from json.
func (s *NullableSimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableSimpleCommitCommitter to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableSimpleCommitCommitter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableSimpleCommitCommitter) {
					name = jsonFieldsNameOfNullableSimpleCommitCommitter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableSimpleUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		if s.StarredAt.Set {
			e.Comma()
		}
		if s.StarredAt.Set {
			e.RawStr("\"starred_at\"" + ":")
			s.StarredAt.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableSimpleUser = [21]string{
	0:  "name",
	1:  "email",
	2:  "login",
	3:  "id",
	4:  "node_id",
	5:  "avatar_url",
	6:  "gravatar_id",
	7:  "url",
	8:  "html_url",
	9:  "followers_url",
	10: "following_url",
	11: "gists_url",
	12: "starred_url",
	13: "subscriptions_url",
	14: "organizations_url",
	15: "repos_url",
	16: "events_url",
	17: "received_events_url",
	18: "type",
	19: "site_admin",
	20: "starred_at",
}

// Decode decodes NullableSimpleUser from json.
func (s *NullableSimpleUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableSimpleUser to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "login":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "starred_at":
			if err := func() error {
				s.StarredAt.Reset()
				if err := s.StarredAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableSimpleUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111100,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableSimpleUser) {
					name = jsonFieldsNameOfNullableSimpleUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NullableTeamSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"members_url\"" + ":")
		e.Str(s.MembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"permission\"" + ":")
		e.Str(s.Permission)
	}
	{
		if s.Privacy.Set {
			e.Comma()
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"repositories_url\"" + ":")
		json.EncodeURI(e, s.RepositoriesURL)
	}
	{
		e.Comma()

		e.RawStr("\"slug\"" + ":")
		e.Str(s.Slug)
	}
	{
		if s.LdapDn.Set {
			e.Comma()
		}
		if s.LdapDn.Set {
			e.RawStr("\"ldap_dn\"" + ":")
			s.LdapDn.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNullableTeamSimple = [12]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "members_url",
	4:  "name",
	5:  "description",
	6:  "permission",
	7:  "privacy",
	8:  "html_url",
	9:  "repositories_url",
	10: "slug",
	11: "ldap_dn",
}

// Decode decodes NullableTeamSimple from json.
func (s *NullableTeamSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NullableTeamSimple to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "members_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "permission":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Permission = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "repositories_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoriesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories_url\"")
			}
		case "slug":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Slug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "ldap_dn":
			if err := func() error {
				s.LdapDn.Reset()
				if err := s.LdapDn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ldap_dn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NullableTeamSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNullableTeamSimple) {
					name = jsonFieldsNameOfNullableTeamSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes OAuthAuthorizationsCreateAuthorizationApplicationJSONForbidden as json.
func (s OAuthAuthorizationsCreateAuthorizationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsCreateAuthorizationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsCreateAuthorizationApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsCreateAuthorizationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsCreateAuthorizationApplicationJSONGone as json.
func (s OAuthAuthorizationsCreateAuthorizationApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationApplicationJSONGone from json.
func (s *OAuthAuthorizationsCreateAuthorizationApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsCreateAuthorizationApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsCreateAuthorizationApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsCreateAuthorizationApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsCreateAuthorizationApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsCreateAuthorizationApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsCreateAuthorizationApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsCreateAuthorizationApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsCreateAuthorizationReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Scopes.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Scopes.Set {
			e.RawStr("\"scopes\"" + ":")
			s.Scopes.Encode(e)
		}
	}
	{
		if s.Note.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Note.Set {
			e.RawStr("\"note\"" + ":")
			s.Note.Encode(e)
		}
	}
	{
		if s.NoteURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NoteURL.Set {
			e.RawStr("\"note_url\"" + ":")
			s.NoteURL.Encode(e)
		}
	}
	{
		if s.ClientID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClientID.Set {
			e.RawStr("\"client_id\"" + ":")
			s.ClientID.Encode(e)
		}
	}
	{
		if s.ClientSecret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ClientSecret.Set {
			e.RawStr("\"client_secret\"" + ":")
			s.ClientSecret.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fingerprint.Set {
			e.RawStr("\"fingerprint\"" + ":")
			s.Fingerprint.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOAuthAuthorizationsCreateAuthorizationReq = [6]string{
	0: "scopes",
	1: "note",
	2: "note_url",
	3: "client_id",
	4: "client_secret",
	5: "fingerprint",
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationReq from json.
func (s *OAuthAuthorizationsCreateAuthorizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsCreateAuthorizationReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scopes":
			if err := func() error {
				s.Scopes.Reset()
				if err := s.Scopes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "note_url":
			if err := func() error {
				s.NoteURL.Reset()
				if err := s.NoteURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note_url\"")
			}
		case "client_id":
			if err := func() error {
				s.ClientID.Reset()
				if err := s.ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_id\"")
			}
		case "client_secret":
			if err := func() error {
				s.ClientSecret.Reset()
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_secret\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuthAuthorizationsCreateAuthorizationReq")
	}

	return nil
}

// Encode encodes OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden as json.
func (s OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsDeleteGrantApplicationJSONForbidden as json.
func (s OAuthAuthorizationsDeleteGrantApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteGrantApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsDeleteGrantApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsDeleteGrantApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteGrantApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden as json.
func (s OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetGrantApplicationJSONForbidden as json.
func (s OAuthAuthorizationsGetGrantApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetGrantApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsGetGrantApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetGrantApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetGrantApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetGrantApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsGetGrantApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetGrantApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsGetGrantApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetGrantApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetGrantApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONCreated as json.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Authorization(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONCreated from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONCreated to nil")
	}
	var unwrapped Authorization
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONOK as json.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Authorization(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONOK from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONOK to nil")
	}
	var unwrapped Authorization
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"client_secret\"" + ":")
		e.Str(s.ClientSecret)
	}
	{
		if s.Scopes.Set {
			e.Comma()
		}
		if s.Scopes.Set {
			e.RawStr("\"scopes\"" + ":")
			s.Scopes.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.Comma()
		}
		if s.Note.Set {
			e.RawStr("\"note\"" + ":")
			s.Note.Encode(e)
		}
	}
	{
		if s.NoteURL.Set {
			e.Comma()
		}
		if s.NoteURL.Set {
			e.RawStr("\"note_url\"" + ":")
			s.NoteURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq = [4]string{
	0: "client_secret",
	1: "scopes",
	2: "note",
	3: "note_url",
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_secret":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClientSecret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_secret\"")
			}
		case "scopes":
			if err := func() error {
				s.Scopes.Reset()
				if err := s.Scopes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "note_url":
			if err := func() error {
				s.NoteURL.Reset()
				if err := s.NoteURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) {
					name = jsonFieldsNameOfOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONCreated as json.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Authorization(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONCreated from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONCreated to nil")
	}
	var unwrapped Authorization
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONForbidden as json.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONOK as json.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Authorization(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONOK from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONOK to nil")
	}
	var unwrapped Authorization
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONOK(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"client_secret\"" + ":")
		e.Str(s.ClientSecret)
	}
	{
		if s.Scopes.Set {
			e.Comma()
		}
		if s.Scopes.Set {
			e.RawStr("\"scopes\"" + ":")
			s.Scopes.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.Comma()
		}
		if s.Note.Set {
			e.RawStr("\"note\"" + ":")
			s.Note.Encode(e)
		}
	}
	{
		if s.NoteURL.Set {
			e.Comma()
		}
		if s.NoteURL.Set {
			e.RawStr("\"note_url\"" + ":")
			s.NoteURL.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.Comma()
		}
		if s.Fingerprint.Set {
			e.RawStr("\"fingerprint\"" + ":")
			s.Fingerprint.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOAuthAuthorizationsGetOrCreateAuthorizationForAppReq = [5]string{
	0: "client_secret",
	1: "scopes",
	2: "note",
	3: "note_url",
	4: "fingerprint",
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppReq from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_secret":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClientSecret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_secret\"")
			}
		case "scopes":
			if err := func() error {
				s.Scopes.Reset()
				if err := s.Scopes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "note_url":
			if err := func() error {
				s.NoteURL.Reset()
				if err := s.NoteURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note_url\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuthAuthorizationsGetOrCreateAuthorizationForAppReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuthAuthorizationsGetOrCreateAuthorizationForAppReq) {
					name = jsonFieldsNameOfOAuthAuthorizationsGetOrCreateAuthorizationForAppReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden as json.
func (s OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound as json.
func (s OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound from json.
func (s *OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListAuthorizationsOKApplicationJSON as json.
func (s OAuthAuthorizationsListAuthorizationsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Authorization(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OAuthAuthorizationsListAuthorizationsOKApplicationJSON from json.
func (s *OAuthAuthorizationsListAuthorizationsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsListAuthorizationsOKApplicationJSON to nil")
	}
	var unwrapped []Authorization
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Authorization
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListAuthorizationsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListGrantsApplicationJSONForbidden as json.
func (s OAuthAuthorizationsListGrantsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListGrantsApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsListGrantsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsListGrantsApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListGrantsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListGrantsApplicationJSONNotFound as json.
func (s OAuthAuthorizationsListGrantsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListGrantsApplicationJSONNotFound from json.
func (s *OAuthAuthorizationsListGrantsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsListGrantsApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListGrantsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListGrantsApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsListGrantsApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListGrantsApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsListGrantsApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsListGrantsApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListGrantsApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListGrantsOKApplicationJSON as json.
func (s OAuthAuthorizationsListGrantsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ApplicationGrant(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OAuthAuthorizationsListGrantsOKApplicationJSON from json.
func (s *OAuthAuthorizationsListGrantsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsListGrantsOKApplicationJSON to nil")
	}
	var unwrapped []ApplicationGrant
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ApplicationGrant
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListGrantsOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsUpdateAuthorizationReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Scopes.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Scopes.Set {
			e.RawStr("\"scopes\"" + ":")
			s.Scopes.Encode(e)
		}
	}
	{
		if s.AddScopes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AddScopes != nil {
			e.RawStr("\"add_scopes\"" + ":")
			e.ArrStart()
			if len(s.AddScopes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AddScopes[0]
					e.Str(elem)
				}
				for _, elem := range s.AddScopes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RemoveScopes != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RemoveScopes != nil {
			e.RawStr("\"remove_scopes\"" + ":")
			e.ArrStart()
			if len(s.RemoveScopes) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RemoveScopes[0]
					e.Str(elem)
				}
				for _, elem := range s.RemoveScopes[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Note.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Note.Set {
			e.RawStr("\"note\"" + ":")
			s.Note.Encode(e)
		}
	}
	{
		if s.NoteURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NoteURL.Set {
			e.RawStr("\"note_url\"" + ":")
			s.NoteURL.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fingerprint.Set {
			e.RawStr("\"fingerprint\"" + ":")
			s.Fingerprint.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOAuthAuthorizationsUpdateAuthorizationReq = [6]string{
	0: "scopes",
	1: "add_scopes",
	2: "remove_scopes",
	3: "note",
	4: "note_url",
	5: "fingerprint",
}

// Decode decodes OAuthAuthorizationsUpdateAuthorizationReq from json.
func (s *OAuthAuthorizationsUpdateAuthorizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuthAuthorizationsUpdateAuthorizationReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scopes":
			if err := func() error {
				s.Scopes.Reset()
				if err := s.Scopes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "add_scopes":
			if err := func() error {
				s.AddScopes = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AddScopes = append(s.AddScopes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add_scopes\"")
			}
		case "remove_scopes":
			if err := func() error {
				s.RemoveScopes = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RemoveScopes = append(s.RemoveScopes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_scopes\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "note_url":
			if err := func() error {
				s.NoteURL.Reset()
				if err := s.NoteURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note_url\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuthAuthorizationsUpdateAuthorizationReq")
	}

	return nil
}

// Encode encodes APIOverviewSSHKeyFingerprints as json.
func (o OptAPIOverviewSSHKeyFingerprints) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes APIOverviewSSHKeyFingerprints from json.
func (o *OptAPIOverviewSSHKeyFingerprints) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIOverviewSSHKeyFingerprints to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAPIOverviewSSHKeyFingerprints", d.Next())
	}
}

// Encode encodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (o OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (o *OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility", d.Next())
	}
}

// Encode encodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (o OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (o *OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility", d.Next())
	}
}

// Encode encodes ActivityMarkNotificationsAsReadReq as json.
func (o OptActivityMarkNotificationsAsReadReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ActivityMarkNotificationsAsReadReq from json.
func (o *OptActivityMarkNotificationsAsReadReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActivityMarkNotificationsAsReadReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptActivityMarkNotificationsAsReadReq", d.Next())
	}
}

// Encode encodes ActivityMarkRepoNotificationsAsReadReq as json.
func (o OptActivityMarkRepoNotificationsAsReadReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ActivityMarkRepoNotificationsAsReadReq from json.
func (o *OptActivityMarkRepoNotificationsAsReadReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActivityMarkRepoNotificationsAsReadReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptActivityMarkRepoNotificationsAsReadReq", d.Next())
	}
}

// Encode encodes ActivitySetRepoSubscriptionReq as json.
func (o OptActivitySetRepoSubscriptionReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ActivitySetRepoSubscriptionReq from json.
func (o *OptActivitySetRepoSubscriptionReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActivitySetRepoSubscriptionReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptActivitySetRepoSubscriptionReq", d.Next())
	}
}

// Encode encodes ActivitySetThreadSubscriptionReq as json.
func (o OptActivitySetThreadSubscriptionReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ActivitySetThreadSubscriptionReq from json.
func (o *OptActivitySetThreadSubscriptionReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActivitySetThreadSubscriptionReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptActivitySetThreadSubscriptionReq", d.Next())
	}
}

// Encode encodes Actor as json.
func (o OptActor) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Actor from json.
func (o *OptActor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActor to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptActor", d.Next())
	}
}

// Encode encodes AlertCreatedAt as json.
func (o OptAlertCreatedAt) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AlertCreatedAt from json.
func (o *OptAlertCreatedAt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlertCreatedAt to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAlertCreatedAt", d.Next())
	}
}

// Encode encodes AlertHTMLURL as json.
func (o OptAlertHTMLURL) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AlertHTMLURL from json.
func (o *OptAlertHTMLURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlertHTMLURL to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAlertHTMLURL", d.Next())
	}
}

// Encode encodes AlertNumber as json.
func (o OptAlertNumber) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AlertNumber from json.
func (o *OptAlertNumber) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlertNumber to nil")
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAlertNumber", d.Next())
	}
}

// Encode encodes AlertURL as json.
func (o OptAlertURL) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AlertURL from json.
func (o *OptAlertURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlertURL to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAlertURL", d.Next())
	}
}

// Encode encodes AllowedActions as json.
func (o OptAllowedActions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AllowedActions from json.
func (o *OptAllowedActions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAllowedActions to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAllowedActions", d.Next())
	}
}

// Encode encodes AppPermissions as json.
func (o OptAppPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AppPermissions from json.
func (o *OptAppPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissions", d.Next())
	}
}

// Encode encodes AppPermissionsActions as json.
func (o OptAppPermissionsActions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsActions from json.
func (o *OptAppPermissionsActions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsActions to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsActions", d.Next())
	}
}

// Encode encodes AppPermissionsAdministration as json.
func (o OptAppPermissionsAdministration) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsAdministration from json.
func (o *OptAppPermissionsAdministration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsAdministration to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsAdministration", d.Next())
	}
}

// Encode encodes AppPermissionsChecks as json.
func (o OptAppPermissionsChecks) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsChecks from json.
func (o *OptAppPermissionsChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsChecks to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsChecks", d.Next())
	}
}

// Encode encodes AppPermissionsContentReferences as json.
func (o OptAppPermissionsContentReferences) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsContentReferences from json.
func (o *OptAppPermissionsContentReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsContentReferences to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsContentReferences", d.Next())
	}
}

// Encode encodes AppPermissionsContents as json.
func (o OptAppPermissionsContents) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsContents from json.
func (o *OptAppPermissionsContents) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsContents to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsContents", d.Next())
	}
}

// Encode encodes AppPermissionsDeployments as json.
func (o OptAppPermissionsDeployments) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsDeployments from json.
func (o *OptAppPermissionsDeployments) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsDeployments to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsDeployments", d.Next())
	}
}

// Encode encodes AppPermissionsEnvironments as json.
func (o OptAppPermissionsEnvironments) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsEnvironments from json.
func (o *OptAppPermissionsEnvironments) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsEnvironments to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsEnvironments", d.Next())
	}
}

// Encode encodes AppPermissionsIssues as json.
func (o OptAppPermissionsIssues) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsIssues from json.
func (o *OptAppPermissionsIssues) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsIssues to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsIssues", d.Next())
	}
}

// Encode encodes AppPermissionsMembers as json.
func (o OptAppPermissionsMembers) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsMembers from json.
func (o *OptAppPermissionsMembers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsMembers to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsMembers", d.Next())
	}
}

// Encode encodes AppPermissionsMetadata as json.
func (o OptAppPermissionsMetadata) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsMetadata from json.
func (o *OptAppPermissionsMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsMetadata to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsMetadata", d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationAdministration as json.
func (o OptAppPermissionsOrganizationAdministration) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationAdministration from json.
func (o *OptAppPermissionsOrganizationAdministration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationAdministration to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsOrganizationAdministration", d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationHooks as json.
func (o OptAppPermissionsOrganizationHooks) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationHooks from json.
func (o *OptAppPermissionsOrganizationHooks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationHooks to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsOrganizationHooks", d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationPackages as json.
func (o OptAppPermissionsOrganizationPackages) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationPackages from json.
func (o *OptAppPermissionsOrganizationPackages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationPackages to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsOrganizationPackages", d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationPlan as json.
func (o OptAppPermissionsOrganizationPlan) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationPlan from json.
func (o *OptAppPermissionsOrganizationPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationPlan to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsOrganizationPlan", d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationProjects as json.
func (o OptAppPermissionsOrganizationProjects) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationProjects from json.
func (o *OptAppPermissionsOrganizationProjects) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationProjects to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsOrganizationProjects", d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationSecrets as json.
func (o OptAppPermissionsOrganizationSecrets) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationSecrets from json.
func (o *OptAppPermissionsOrganizationSecrets) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationSecrets to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsOrganizationSecrets", d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationSelfHostedRunners as json.
func (o OptAppPermissionsOrganizationSelfHostedRunners) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationSelfHostedRunners from json.
func (o *OptAppPermissionsOrganizationSelfHostedRunners) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationSelfHostedRunners to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsOrganizationSelfHostedRunners", d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationUserBlocking as json.
func (o OptAppPermissionsOrganizationUserBlocking) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationUserBlocking from json.
func (o *OptAppPermissionsOrganizationUserBlocking) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsOrganizationUserBlocking to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsOrganizationUserBlocking", d.Next())
	}
}

// Encode encodes AppPermissionsPackages as json.
func (o OptAppPermissionsPackages) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsPackages from json.
func (o *OptAppPermissionsPackages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsPackages to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsPackages", d.Next())
	}
}

// Encode encodes AppPermissionsPages as json.
func (o OptAppPermissionsPages) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsPages from json.
func (o *OptAppPermissionsPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsPages to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsPages", d.Next())
	}
}

// Encode encodes AppPermissionsPullRequests as json.
func (o OptAppPermissionsPullRequests) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsPullRequests from json.
func (o *OptAppPermissionsPullRequests) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsPullRequests to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsPullRequests", d.Next())
	}
}

// Encode encodes AppPermissionsRepositoryHooks as json.
func (o OptAppPermissionsRepositoryHooks) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsRepositoryHooks from json.
func (o *OptAppPermissionsRepositoryHooks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsRepositoryHooks to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsRepositoryHooks", d.Next())
	}
}

// Encode encodes AppPermissionsRepositoryProjects as json.
func (o OptAppPermissionsRepositoryProjects) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsRepositoryProjects from json.
func (o *OptAppPermissionsRepositoryProjects) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsRepositoryProjects to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsRepositoryProjects", d.Next())
	}
}

// Encode encodes AppPermissionsSecretScanningAlerts as json.
func (o OptAppPermissionsSecretScanningAlerts) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSecretScanningAlerts from json.
func (o *OptAppPermissionsSecretScanningAlerts) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsSecretScanningAlerts to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsSecretScanningAlerts", d.Next())
	}
}

// Encode encodes AppPermissionsSecrets as json.
func (o OptAppPermissionsSecrets) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSecrets from json.
func (o *OptAppPermissionsSecrets) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsSecrets to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsSecrets", d.Next())
	}
}

// Encode encodes AppPermissionsSecurityEvents as json.
func (o OptAppPermissionsSecurityEvents) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSecurityEvents from json.
func (o *OptAppPermissionsSecurityEvents) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsSecurityEvents to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsSecurityEvents", d.Next())
	}
}

// Encode encodes AppPermissionsSingleFile as json.
func (o OptAppPermissionsSingleFile) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSingleFile from json.
func (o *OptAppPermissionsSingleFile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsSingleFile to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsSingleFile", d.Next())
	}
}

// Encode encodes AppPermissionsStatuses as json.
func (o OptAppPermissionsStatuses) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsStatuses from json.
func (o *OptAppPermissionsStatuses) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsStatuses to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsStatuses", d.Next())
	}
}

// Encode encodes AppPermissionsTeamDiscussions as json.
func (o OptAppPermissionsTeamDiscussions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsTeamDiscussions from json.
func (o *OptAppPermissionsTeamDiscussions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsTeamDiscussions to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsTeamDiscussions", d.Next())
	}
}

// Encode encodes AppPermissionsVulnerabilityAlerts as json.
func (o OptAppPermissionsVulnerabilityAlerts) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsVulnerabilityAlerts from json.
func (o *OptAppPermissionsVulnerabilityAlerts) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsVulnerabilityAlerts to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsVulnerabilityAlerts", d.Next())
	}
}

// Encode encodes AppPermissionsWorkflows as json.
func (o OptAppPermissionsWorkflows) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsWorkflows from json.
func (o *OptAppPermissionsWorkflows) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppPermissionsWorkflows to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppPermissionsWorkflows", d.Next())
	}
}

// Encode encodes AppsCreateFromManifestReq as json.
func (o OptAppsCreateFromManifestReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AppsCreateFromManifestReq from json.
func (o *OptAppsCreateFromManifestReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppsCreateFromManifestReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(AppsCreateFromManifestReq)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppsCreateFromManifestReq", d.Next())
	}
}

// Encode encodes AppsCreateInstallationAccessTokenReq as json.
func (o OptAppsCreateInstallationAccessTokenReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AppsCreateInstallationAccessTokenReq from json.
func (o *OptAppsCreateInstallationAccessTokenReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppsCreateInstallationAccessTokenReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppsCreateInstallationAccessTokenReq", d.Next())
	}
}

// Encode encodes AppsUpdateWebhookConfigForAppReq as json.
func (o OptAppsUpdateWebhookConfigForAppReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AppsUpdateWebhookConfigForAppReq from json.
func (o *OptAppsUpdateWebhookConfigForAppReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAppsUpdateWebhookConfigForAppReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAppsUpdateWebhookConfigForAppReq", d.Next())
	}
}

// Encode encodes AuditLogEventActorLocation as json.
func (o OptAuditLogEventActorLocation) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AuditLogEventActorLocation from json.
func (o *OptAuditLogEventActorLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAuditLogEventActorLocation to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAuditLogEventActorLocation", d.Next())
	}
}

// Encode encodes AuditLogEventData as json.
func (o OptAuditLogEventData) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AuditLogEventData from json.
func (o *OptAuditLogEventData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAuditLogEventData to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(AuditLogEventData)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAuditLogEventData", d.Next())
	}
}

// Encode encodes AuthenticationTokenRepositorySelection as json.
func (o OptAuthenticationTokenRepositorySelection) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AuthenticationTokenRepositorySelection from json.
func (o *OptAuthenticationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAuthenticationTokenRepositorySelection to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAuthenticationTokenRepositorySelection", d.Next())
	}
}

// Encode encodes AuthorAssociation as json.
func (o OptAuthorAssociation) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AuthorAssociation from json.
func (o *OptAuthorAssociation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAuthorAssociation to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptAuthorAssociation", d.Next())
	}
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	switch d.Next() {
	case jx.Bool:
		o.Set = true
		v, err := d.Bool()
		if err != nil {
			return err
		}
		o.Value = bool(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBool", d.Next())
	}
}

// Encode encodes BranchProtection as json.
func (o OptBranchProtection) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchProtection from json.
func (o *OptBranchProtection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchProtection to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBranchProtection", d.Next())
	}
}

// Encode encodes BranchProtectionAllowDeletions as json.
func (o OptBranchProtectionAllowDeletions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionAllowDeletions from json.
func (o *OptBranchProtectionAllowDeletions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchProtectionAllowDeletions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBranchProtectionAllowDeletions", d.Next())
	}
}

// Encode encodes BranchProtectionAllowForcePushes as json.
func (o OptBranchProtectionAllowForcePushes) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionAllowForcePushes from json.
func (o *OptBranchProtectionAllowForcePushes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchProtectionAllowForcePushes to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBranchProtectionAllowForcePushes", d.Next())
	}
}

// Encode encodes BranchProtectionRequiredConversationResolution as json.
func (o OptBranchProtectionRequiredConversationResolution) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredConversationResolution from json.
func (o *OptBranchProtectionRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchProtectionRequiredConversationResolution to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBranchProtectionRequiredConversationResolution", d.Next())
	}
}

// Encode encodes BranchProtectionRequiredLinearHistory as json.
func (o OptBranchProtectionRequiredLinearHistory) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredLinearHistory from json.
func (o *OptBranchProtectionRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchProtectionRequiredLinearHistory to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBranchProtectionRequiredLinearHistory", d.Next())
	}
}

// Encode encodes BranchProtectionRequiredSignatures as json.
func (o OptBranchProtectionRequiredSignatures) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredSignatures from json.
func (o *OptBranchProtectionRequiredSignatures) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchProtectionRequiredSignatures to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBranchProtectionRequiredSignatures", d.Next())
	}
}

// Encode encodes BranchProtectionRequiredStatusChecks as json.
func (o OptBranchProtectionRequiredStatusChecks) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredStatusChecks from json.
func (o *OptBranchProtectionRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchProtectionRequiredStatusChecks to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBranchProtectionRequiredStatusChecks", d.Next())
	}
}

// Encode encodes BranchRestrictionPolicy as json.
func (o OptBranchRestrictionPolicy) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchRestrictionPolicy from json.
func (o *OptBranchRestrictionPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchRestrictionPolicy to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBranchRestrictionPolicy", d.Next())
	}
}

// Encode encodes BranchRestrictionPolicyAppsItemOwner as json.
func (o OptBranchRestrictionPolicyAppsItemOwner) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchRestrictionPolicyAppsItemOwner from json.
func (o *OptBranchRestrictionPolicyAppsItemOwner) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchRestrictionPolicyAppsItemOwner to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBranchRestrictionPolicyAppsItemOwner", d.Next())
	}
}

// Encode encodes BranchRestrictionPolicyAppsItemPermissions as json.
func (o OptBranchRestrictionPolicyAppsItemPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BranchRestrictionPolicyAppsItemPermissions from json.
func (o *OptBranchRestrictionPolicyAppsItemPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBranchRestrictionPolicyAppsItemPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBranchRestrictionPolicyAppsItemPermissions", d.Next())
	}
}

// Encode encodes CodeOfConduct as json.
func (o OptCodeOfConduct) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeOfConduct from json.
func (o *OptCodeOfConduct) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeOfConduct to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCodeOfConduct", d.Next())
	}
}

// Encode encodes CodeOfConductSimple as json.
func (o OptCodeOfConductSimple) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeOfConductSimple from json.
func (o *OptCodeOfConductSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeOfConductSimple to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCodeOfConductSimple", d.Next())
	}
}

// Encode encodes CodeScanningAlertEnvironment as json.
func (o OptCodeScanningAlertEnvironment) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAlertEnvironment from json.
func (o *OptCodeScanningAlertEnvironment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAlertEnvironment to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCodeScanningAlertEnvironment", d.Next())
	}
}

// Encode encodes CodeScanningAlertInstanceMessage as json.
func (o OptCodeScanningAlertInstanceMessage) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAlertInstanceMessage from json.
func (o *OptCodeScanningAlertInstanceMessage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAlertInstanceMessage to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCodeScanningAlertInstanceMessage", d.Next())
	}
}

// Encode encodes CodeScanningAlertLocation as json.
func (o OptCodeScanningAlertLocation) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAlertLocation from json.
func (o *OptCodeScanningAlertLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAlertLocation to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCodeScanningAlertLocation", d.Next())
	}
}

// Encode encodes CodeScanningAlertState as json.
func (o OptCodeScanningAlertState) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertState from json.
func (o *OptCodeScanningAlertState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAlertState to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCodeScanningAlertState", d.Next())
	}
}

// Encode encodes CodeScanningAnalysisAnalysisKey as json.
func (o OptCodeScanningAnalysisAnalysisKey) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAnalysisAnalysisKey from json.
func (o *OptCodeScanningAnalysisAnalysisKey) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAnalysisAnalysisKey to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCodeScanningAnalysisAnalysisKey", d.Next())
	}
}

// Encode encodes CodeScanningAnalysisCategory as json.
func (o OptCodeScanningAnalysisCategory) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAnalysisCategory from json.
func (o *OptCodeScanningAnalysisCategory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAnalysisCategory to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCodeScanningAnalysisCategory", d.Next())
	}
}

// Encode encodes CodeScanningAnalysisSarifID as json.
func (o OptCodeScanningAnalysisSarifID) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAnalysisSarifID from json.
func (o *OptCodeScanningAnalysisSarifID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAnalysisSarifID to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCodeScanningAnalysisSarifID", d.Next())
	}
}

// Encode encodes CodeScanningAnalysisToolName as json.
func (o OptCodeScanningAnalysisToolName) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAnalysisToolName from json.
func (o *OptCodeScanningAnalysisToolName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningAnalysisToolName to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCodeScanningAnalysisToolName", d.Next())
	}
}

// Encode encodes CodeScanningRef as json.
func (o OptCodeScanningRef) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningRef from json.
func (o *OptCodeScanningRef) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningRef to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCodeScanningRef", d.Next())
	}
}

// Encode encodes CodeScanningSarifsStatusProcessingStatus as json.
func (o OptCodeScanningSarifsStatusProcessingStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningSarifsStatusProcessingStatus from json.
func (o *OptCodeScanningSarifsStatusProcessingStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCodeScanningSarifsStatusProcessingStatus to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCodeScanningSarifsStatusProcessingStatus", d.Next())
	}
}

// Encode encodes CollaboratorPermissions as json.
func (o OptCollaboratorPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CollaboratorPermissions from json.
func (o *OptCollaboratorPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCollaboratorPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCollaboratorPermissions", d.Next())
	}
}

// Encode encodes CommitStats as json.
func (o OptCommitStats) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CommitStats from json.
func (o *OptCommitStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCommitStats to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCommitStats", d.Next())
	}
}

// Encode encodes DeploymentReviewerType as json.
func (o OptDeploymentReviewerType) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DeploymentReviewerType from json.
func (o *OptDeploymentReviewerType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeploymentReviewerType to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptDeploymentReviewerType", d.Next())
	}
}

// Encode encodes DeploymentSimple as json.
func (o OptDeploymentSimple) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeploymentSimple from json.
func (o *OptDeploymentSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeploymentSimple to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptDeploymentSimple", d.Next())
	}
}

// Encode encodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (o OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (o *OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility", d.Next())
	}
}

// Encode encodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue as json.
func (o OptEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue from json.
func (o *OptEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue", d.Next())
	}
}

// Encode encodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq as json.
func (o OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq from json.
func (o *OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq", d.Next())
	}
}

// Encode encodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (o OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (o *OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility", d.Next())
	}
}

// Encode encodes FileCommitCommitAuthor as json.
func (o OptFileCommitCommitAuthor) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitAuthor from json.
func (o *OptFileCommitCommitAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFileCommitCommitAuthor to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptFileCommitCommitAuthor", d.Next())
	}
}

// Encode encodes FileCommitCommitCommitter as json.
func (o OptFileCommitCommitCommitter) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitCommitter from json.
func (o *OptFileCommitCommitCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFileCommitCommitCommitter to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptFileCommitCommitCommitter", d.Next())
	}
}

// Encode encodes FileCommitCommitTree as json.
func (o OptFileCommitCommitTree) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitTree from json.
func (o *OptFileCommitCommitTree) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFileCommitCommitTree to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptFileCommitCommitTree", d.Next())
	}
}

// Encode encodes FileCommitCommitVerification as json.
func (o OptFileCommitCommitVerification) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitVerification from json.
func (o *OptFileCommitCommitVerification) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFileCommitCommitVerification to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptFileCommitCommitVerification", d.Next())
	}
}

// Encode encodes FileCommitContentLinks as json.
func (o OptFileCommitContentLinks) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileCommitContentLinks from json.
func (o *OptFileCommitContentLinks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFileCommitContentLinks to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptFileCommitContentLinks", d.Next())
	}
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Float64()
		if err != nil {
			return err
		}
		o.Value = float64(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptFloat64", d.Next())
	}
}

// Encode encodes ForbiddenGistBlock as json.
func (o OptForbiddenGistBlock) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ForbiddenGistBlock from json.
func (o *OptForbiddenGistBlock) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptForbiddenGistBlock to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptForbiddenGistBlock", d.Next())
	}
}

// Encode encodes FullRepositoryPermissions as json.
func (o OptFullRepositoryPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FullRepositoryPermissions from json.
func (o *OptFullRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFullRepositoryPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptFullRepositoryPermissions", d.Next())
	}
}

// Encode encodes FullRepositorySecurityAndAnalysisAdvancedSecurity as json.
func (o OptFullRepositorySecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurity from json.
func (o *OptFullRepositorySecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFullRepositorySecurityAndAnalysisAdvancedSecurity to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptFullRepositorySecurityAndAnalysisAdvancedSecurity", d.Next())
	}
}

// Encode encodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus as json.
func (o OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus from json.
func (o *OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus", d.Next())
	}
}

// Encode encodes FullRepositorySecurityAndAnalysisSecretScanning as json.
func (o OptFullRepositorySecurityAndAnalysisSecretScanning) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanning from json.
func (o *OptFullRepositorySecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFullRepositorySecurityAndAnalysisSecretScanning to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptFullRepositorySecurityAndAnalysisSecretScanning", d.Next())
	}
}

// Encode encodes FullRepositorySecurityAndAnalysisSecretScanningStatus as json.
func (o OptFullRepositorySecurityAndAnalysisSecretScanningStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanningStatus from json.
func (o *OptFullRepositorySecurityAndAnalysisSecretScanningStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFullRepositorySecurityAndAnalysisSecretScanningStatus to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptFullRepositorySecurityAndAnalysisSecretScanningStatus", d.Next())
	}
}

// Encode encodes GistHistoryChangeStatus as json.
func (o OptGistHistoryChangeStatus) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GistHistoryChangeStatus from json.
func (o *OptGistHistoryChangeStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGistHistoryChangeStatus to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptGistHistoryChangeStatus", d.Next())
	}
}

// Encode encodes GistSimpleFiles as json.
func (o OptGistSimpleFiles) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GistSimpleFiles from json.
func (o *OptGistSimpleFiles) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGistSimpleFiles to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(GistSimpleFiles)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptGistSimpleFiles", d.Next())
	}
}

// Encode encodes GistsCreateReqPublic as json.
func (o OptGistsCreateReqPublic) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GistsCreateReqPublic from json.
func (o *OptGistsCreateReqPublic) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGistsCreateReqPublic to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptGistsCreateReqPublic", d.Next())
	}
}

// Encode encodes GitCreateCommitReqAuthor as json.
func (o OptGitCreateCommitReqAuthor) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GitCreateCommitReqAuthor from json.
func (o *OptGitCreateCommitReqAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGitCreateCommitReqAuthor to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptGitCreateCommitReqAuthor", d.Next())
	}
}

// Encode encodes GitCreateCommitReqCommitter as json.
func (o OptGitCreateCommitReqCommitter) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GitCreateCommitReqCommitter from json.
func (o *OptGitCreateCommitReqCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGitCreateCommitReqCommitter to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptGitCreateCommitReqCommitter", d.Next())
	}
}

// Encode encodes GitCreateTagReqTagger as json.
func (o OptGitCreateTagReqTagger) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GitCreateTagReqTagger from json.
func (o *OptGitCreateTagReqTagger) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGitCreateTagReqTagger to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptGitCreateTagReqTagger", d.Next())
	}
}

// Encode encodes GitCreateTreeReqTreeItemMode as json.
func (o OptGitCreateTreeReqTreeItemMode) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GitCreateTreeReqTreeItemMode from json.
func (o *OptGitCreateTreeReqTreeItemMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGitCreateTreeReqTreeItemMode to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptGitCreateTreeReqTreeItemMode", d.Next())
	}
}

// Encode encodes GitCreateTreeReqTreeItemType as json.
func (o OptGitCreateTreeReqTreeItemType) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GitCreateTreeReqTreeItemType from json.
func (o *OptGitCreateTreeReqTreeItemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGitCreateTreeReqTreeItemType to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptGitCreateTreeReqTreeItemType", d.Next())
	}
}

// Encode encodes InstallationTokenRepositorySelection as json.
func (o OptInstallationTokenRepositorySelection) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InstallationTokenRepositorySelection from json.
func (o *OptInstallationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInstallationTokenRepositorySelection to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptInstallationTokenRepositorySelection", d.Next())
	}
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int()
		if err != nil {
			return err
		}
		o.Value = int(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptInt", d.Next())
	}
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int64()
		if err != nil {
			return err
		}
		o.Value = int64(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptInt64", d.Next())
	}
}

// Encode encodes InteractionExpiry as json.
func (o OptInteractionExpiry) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InteractionExpiry from json.
func (o *OptInteractionExpiry) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInteractionExpiry to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptInteractionExpiry", d.Next())
	}
}

// Encode encodes IssueComment as json.
func (o OptIssueComment) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueComment from json.
func (o *OptIssueComment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueComment to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssueComment", d.Next())
	}
}

// Encode encodes IssueEventDismissedReview as json.
func (o OptIssueEventDismissedReview) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueEventDismissedReview from json.
func (o *OptIssueEventDismissedReview) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueEventDismissedReview to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssueEventDismissedReview", d.Next())
	}
}

// Encode encodes IssueEventLabel as json.
func (o OptIssueEventLabel) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueEventLabel from json.
func (o *OptIssueEventLabel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueEventLabel to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssueEventLabel", d.Next())
	}
}

// Encode encodes IssueEventMilestone as json.
func (o OptIssueEventMilestone) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueEventMilestone from json.
func (o *OptIssueEventMilestone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueEventMilestone to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssueEventMilestone", d.Next())
	}
}

// Encode encodes IssueEventProjectCard as json.
func (o OptIssueEventProjectCard) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueEventProjectCard from json.
func (o *OptIssueEventProjectCard) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueEventProjectCard to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssueEventProjectCard", d.Next())
	}
}

// Encode encodes IssueEventRename as json.
func (o OptIssueEventRename) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueEventRename from json.
func (o *OptIssueEventRename) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueEventRename to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssueEventRename", d.Next())
	}
}

// Encode encodes IssuePullRequest as json.
func (o OptIssuePullRequest) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuePullRequest from json.
func (o *OptIssuePullRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuePullRequest to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssuePullRequest", d.Next())
	}
}

// Encode encodes IssueSearchResultItemPullRequest as json.
func (o OptIssueSearchResultItemPullRequest) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueSearchResultItemPullRequest from json.
func (o *OptIssueSearchResultItemPullRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueSearchResultItemPullRequest to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssueSearchResultItemPullRequest", d.Next())
	}
}

// Encode encodes IssueSimple as json.
func (o OptIssueSimple) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueSimple from json.
func (o *OptIssueSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueSimple to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssueSimple", d.Next())
	}
}

// Encode encodes IssueSimplePullRequest as json.
func (o OptIssueSimplePullRequest) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssueSimplePullRequest from json.
func (o *OptIssueSimplePullRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssueSimplePullRequest to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssueSimplePullRequest", d.Next())
	}
}

// Encode encodes IssuesAddAssigneesReq as json.
func (o OptIssuesAddAssigneesReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesAddAssigneesReq from json.
func (o *OptIssuesAddAssigneesReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesAddAssigneesReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssuesAddAssigneesReq", d.Next())
	}
}

// Encode encodes IssuesCreateMilestoneReqState as json.
func (o OptIssuesCreateMilestoneReqState) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes IssuesCreateMilestoneReqState from json.
func (o *OptIssuesCreateMilestoneReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesCreateMilestoneReqState to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssuesCreateMilestoneReqState", d.Next())
	}
}

// Encode encodes IssuesLockReq as json.
func (o OptIssuesLockReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesLockReq from json.
func (o *OptIssuesLockReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesLockReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssuesLockReq", d.Next())
	}
}

// Encode encodes IssuesLockReqLockReason as json.
func (o OptIssuesLockReqLockReason) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes IssuesLockReqLockReason from json.
func (o *OptIssuesLockReqLockReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesLockReqLockReason to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssuesLockReqLockReason", d.Next())
	}
}

// Encode encodes IssuesRemoveAssigneesReq as json.
func (o OptIssuesRemoveAssigneesReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesRemoveAssigneesReq from json.
func (o *OptIssuesRemoveAssigneesReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesRemoveAssigneesReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssuesRemoveAssigneesReq", d.Next())
	}
}

// Encode encodes IssuesUpdateLabelReq as json.
func (o OptIssuesUpdateLabelReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesUpdateLabelReq from json.
func (o *OptIssuesUpdateLabelReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesUpdateLabelReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssuesUpdateLabelReq", d.Next())
	}
}

// Encode encodes IssuesUpdateMilestoneReq as json.
func (o OptIssuesUpdateMilestoneReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesUpdateMilestoneReq from json.
func (o *OptIssuesUpdateMilestoneReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesUpdateMilestoneReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssuesUpdateMilestoneReq", d.Next())
	}
}

// Encode encodes IssuesUpdateMilestoneReqState as json.
func (o OptIssuesUpdateMilestoneReqState) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes IssuesUpdateMilestoneReqState from json.
func (o *OptIssuesUpdateMilestoneReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesUpdateMilestoneReqState to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssuesUpdateMilestoneReqState", d.Next())
	}
}

// Encode encodes IssuesUpdateReq as json.
func (o OptIssuesUpdateReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesUpdateReq from json.
func (o *OptIssuesUpdateReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesUpdateReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssuesUpdateReq", d.Next())
	}
}

// Encode encodes IssuesUpdateReqState as json.
func (o OptIssuesUpdateReqState) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes IssuesUpdateReqState from json.
func (o *OptIssuesUpdateReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIssuesUpdateReqState to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptIssuesUpdateReqState", d.Next())
	}
}

// Encode encodes LinkWithType as json.
func (o OptLinkWithType) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LinkWithType from json.
func (o *OptLinkWithType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLinkWithType to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptLinkWithType", d.Next())
	}
}

// Encode encodes MarkdownRenderReqMode as json.
func (o OptMarkdownRenderReqMode) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes MarkdownRenderReqMode from json.
func (o *OptMarkdownRenderReqMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMarkdownRenderReqMode to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptMarkdownRenderReqMode", d.Next())
	}
}

// Encode encodes MarketplaceListingPlan as json.
func (o OptMarketplaceListingPlan) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MarketplaceListingPlan from json.
func (o *OptMarketplaceListingPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMarketplaceListingPlan to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptMarketplaceListingPlan", d.Next())
	}
}

// Encode encodes MergedUpstreamMergeType as json.
func (o OptMergedUpstreamMergeType) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes MergedUpstreamMergeType from json.
func (o *OptMergedUpstreamMergeType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMergedUpstreamMergeType to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptMergedUpstreamMergeType", d.Next())
	}
}

// Encode encodes MigrationsMapCommitAuthorReq as json.
func (o OptMigrationsMapCommitAuthorReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MigrationsMapCommitAuthorReq from json.
func (o *OptMigrationsMapCommitAuthorReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMigrationsMapCommitAuthorReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptMigrationsMapCommitAuthorReq", d.Next())
	}
}

// Encode encodes MigrationsStartImportReqVcs as json.
func (o OptMigrationsStartImportReqVcs) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes MigrationsStartImportReqVcs from json.
func (o *OptMigrationsStartImportReqVcs) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMigrationsStartImportReqVcs to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptMigrationsStartImportReqVcs", d.Next())
	}
}

// Encode encodes MigrationsUpdateImportReq as json.
func (o OptMigrationsUpdateImportReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MigrationsUpdateImportReq from json.
func (o *OptMigrationsUpdateImportReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMigrationsUpdateImportReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptMigrationsUpdateImportReq", d.Next())
	}
}

// Encode encodes MinimalRepository as json.
func (o OptMinimalRepository) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MinimalRepository from json.
func (o *OptMinimalRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMinimalRepository to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptMinimalRepository", d.Next())
	}
}

// Encode encodes MinimalRepositoryPermissions as json.
func (o OptMinimalRepositoryPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MinimalRepositoryPermissions from json.
func (o *OptMinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMinimalRepositoryPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptMinimalRepositoryPermissions", d.Next())
	}
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBool to nil")
	}
	switch d.Next() {
	case jx.Bool:
		o.Set = true
		o.Null = false
		v, err := d.Bool()
		if err != nil {
			return err
		}
		o.Value = bool(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilBool", d.Next())
	}
}

// Encode encodes CodeScanningAlertDismissedReason as json.
func (o OptNilCodeScanningAlertDismissedReason) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertDismissedReason from json.
func (o *OptNilCodeScanningAlertDismissedReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCodeScanningAlertDismissedReason to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertDismissedReason
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilCodeScanningAlertDismissedReason", d.Next())
	}
}

// Encode encodes CodeScanningAlertRuleSecuritySeverityLevel as json.
func (o OptNilCodeScanningAlertRuleSecuritySeverityLevel) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertRuleSecuritySeverityLevel from json.
func (o *OptNilCodeScanningAlertRuleSecuritySeverityLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCodeScanningAlertRuleSecuritySeverityLevel to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertRuleSecuritySeverityLevel
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilCodeScanningAlertRuleSecuritySeverityLevel", d.Next())
	}
}

// Encode encodes CodeScanningAlertRuleSeverity as json.
func (o OptNilCodeScanningAlertRuleSeverity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertRuleSeverity from json.
func (o *OptNilCodeScanningAlertRuleSeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCodeScanningAlertRuleSeverity to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertRuleSeverity
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilCodeScanningAlertRuleSeverity", d.Next())
	}
}

// Encode encodes CodeScanningAlertRuleSummarySeverity as json.
func (o OptNilCodeScanningAlertRuleSummarySeverity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertRuleSummarySeverity from json.
func (o *OptNilCodeScanningAlertRuleSummarySeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCodeScanningAlertRuleSummarySeverity to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertRuleSummarySeverity
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilCodeScanningAlertRuleSummarySeverity", d.Next())
	}
}

// Encode encodes CodeScanningAnalysisToolGUID as json.
func (o OptNilCodeScanningAnalysisToolGUID) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAnalysisToolGUID from json.
func (o *OptNilCodeScanningAnalysisToolGUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCodeScanningAnalysisToolGUID to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAnalysisToolGUID
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilCodeScanningAnalysisToolGUID", d.Next())
	}
}

// Encode encodes CodeScanningAnalysisToolVersion as json.
func (o OptNilCodeScanningAnalysisToolVersion) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAnalysisToolVersion from json.
func (o *OptNilCodeScanningAnalysisToolVersion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCodeScanningAnalysisToolVersion to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAnalysisToolVersion
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilCodeScanningAnalysisToolVersion", d.Next())
	}
}

// Encode encodes DeploymentBranchPolicy as json.
func (o OptNilDeploymentBranchPolicy) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeploymentBranchPolicy from json.
func (o *OptNilDeploymentBranchPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDeploymentBranchPolicy to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v DeploymentBranchPolicy
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilDeploymentBranchPolicy", d.Next())
	}
}

// Encode encodes FullRepositorySecurityAndAnalysis as json.
func (o OptNilFullRepositorySecurityAndAnalysis) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FullRepositorySecurityAndAnalysis from json.
func (o *OptNilFullRepositorySecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFullRepositorySecurityAndAnalysis to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v FullRepositorySecurityAndAnalysis
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilFullRepositorySecurityAndAnalysis", d.Next())
	}
}

// Encode encodes []GistHistory as json.
func (o OptNilGistHistoryArray) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	if len(o.Value) >= 1 {
		// Encode first element without comma.
		{
			elem := o.Value[0]
			elem.Encode(e)
		}
		for _, elem := range o.Value[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes []GistHistory from json.
func (o *OptNilGistHistoryArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGistHistoryArray to nil")
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GistHistory
			if err := elem.Decode(d); err != nil {
				return err
			}
			o.Value = append(o.Value, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []GistHistory
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilGistHistoryArray", d.Next())
	}
}

// Encode encodes GistSimpleForkOf as json.
func (o OptNilGistSimpleForkOf) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GistSimpleForkOf from json.
func (o *OptNilGistSimpleForkOf) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGistSimpleForkOf to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v GistSimpleForkOf
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilGistSimpleForkOf", d.Next())
	}
}

// Encode encodes []GistSimpleForksItem as json.
func (o OptNilGistSimpleForksItemArray) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	if len(o.Value) >= 1 {
		// Encode first element without comma.
		{
			elem := o.Value[0]
			elem.Encode(e)
		}
		for _, elem := range o.Value[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes []GistSimpleForksItem from json.
func (o *OptNilGistSimpleForksItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGistSimpleForksItemArray to nil")
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GistSimpleForksItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			o.Value = append(o.Value, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []GistSimpleForksItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilGistSimpleForksItemArray", d.Next())
	}
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		o.Null = false
		v, err := d.Int()
		if err != nil {
			return err
		}
		o.Value = int(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilInt", d.Next())
	}
}

// Encode encodes IssuesCreateReqMilestone as json.
func (o OptNilIssuesCreateReqMilestone) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesCreateReqMilestone from json.
func (o *OptNilIssuesCreateReqMilestone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilIssuesCreateReqMilestone to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v IssuesCreateReqMilestone
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilIssuesCreateReqMilestone", d.Next())
	}
}

// Encode encodes IssuesUpdateReqMilestone as json.
func (o OptNilIssuesUpdateReqMilestone) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesUpdateReqMilestone from json.
func (o *OptNilIssuesUpdateReqMilestone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilIssuesUpdateReqMilestone to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v IssuesUpdateReqMilestone
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilIssuesUpdateReqMilestone", d.Next())
	}
}

// Encode encodes IssuesUpdateReqTitle as json.
func (o OptNilIssuesUpdateReqTitle) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IssuesUpdateReqTitle from json.
func (o *OptNilIssuesUpdateReqTitle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilIssuesUpdateReqTitle to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v IssuesUpdateReqTitle
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilIssuesUpdateReqTitle", d.Next())
	}
}

// Encode encodes MarketplacePurchaseMarketplacePendingChange as json.
func (o OptNilMarketplacePurchaseMarketplacePendingChange) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MarketplacePurchaseMarketplacePendingChange from json.
func (o *OptNilMarketplacePurchaseMarketplacePendingChange) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilMarketplacePurchaseMarketplacePendingChange to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v MarketplacePurchaseMarketplacePendingChange
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilMarketplacePurchaseMarketplacePendingChange", d.Next())
	}
}

// Encode encodes MinimalRepositoryLicense as json.
func (o OptNilMinimalRepositoryLicense) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MinimalRepositoryLicense from json.
func (o *OptNilMinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilMinimalRepositoryLicense to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v MinimalRepositoryLicense
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilMinimalRepositoryLicense", d.Next())
	}
}

// Encode encodes NullableIntegration as json.
func (o OptNilNullableIntegration) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableIntegration from json.
func (o *OptNilNullableIntegration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableIntegration to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableIntegration
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilNullableIntegration", d.Next())
	}
}

// Encode encodes NullableMinimalRepository as json.
func (o OptNilNullableMinimalRepository) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableMinimalRepository from json.
func (o *OptNilNullableMinimalRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableMinimalRepository to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableMinimalRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilNullableMinimalRepository", d.Next())
	}
}

// Encode encodes NullableMinimalRepositoryLicense as json.
func (o OptNilNullableMinimalRepositoryLicense) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableMinimalRepositoryLicense from json.
func (o *OptNilNullableMinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableMinimalRepositoryLicense to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableMinimalRepositoryLicense
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilNullableMinimalRepositoryLicense", d.Next())
	}
}

// Encode encodes NullableRepository as json.
func (o OptNilNullableRepository) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableRepository from json.
func (o *OptNilNullableRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableRepository to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilNullableRepository", d.Next())
	}
}

// Encode encodes NullableRepositoryTemplateRepository as json.
func (o OptNilNullableRepositoryTemplateRepository) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryTemplateRepository from json.
func (o *OptNilNullableRepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableRepositoryTemplateRepository to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableRepositoryTemplateRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilNullableRepositoryTemplateRepository", d.Next())
	}
}

// Encode encodes NullableScopedInstallation as json.
func (o OptNilNullableScopedInstallation) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableScopedInstallation from json.
func (o *OptNilNullableScopedInstallation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableScopedInstallation to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableScopedInstallation
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilNullableScopedInstallation", d.Next())
	}
}

// Encode encodes NullableSimpleUser as json.
func (o OptNilNullableSimpleUser) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleUser from json.
func (o *OptNilNullableSimpleUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableSimpleUser to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableSimpleUser
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilNullableSimpleUser", d.Next())
	}
}

// Encode encodes NullableTeamSimple as json.
func (o OptNilNullableTeamSimple) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableTeamSimple from json.
func (o *OptNilNullableTeamSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNullableTeamSimple to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableTeamSimple
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilNullableTeamSimple", d.Next())
	}
}

// Encode encodes PageProtectedDomainState as json.
func (o OptNilPageProtectedDomainState) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PageProtectedDomainState from json.
func (o *OptNilPageProtectedDomainState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPageProtectedDomainState to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PageProtectedDomainState
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilPageProtectedDomainState", d.Next())
	}
}

// Encode encodes PagesHealthCheckAltDomain as json.
func (o OptNilPagesHealthCheckAltDomain) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PagesHealthCheckAltDomain from json.
func (o *OptNilPagesHealthCheckAltDomain) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPagesHealthCheckAltDomain to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PagesHealthCheckAltDomain
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilPagesHealthCheckAltDomain", d.Next())
	}
}

// Encode encodes PullRequestReviewCommentStartSide as json.
func (o OptNilPullRequestReviewCommentStartSide) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullRequestReviewCommentStartSide from json.
func (o *OptNilPullRequestReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPullRequestReviewCommentStartSide to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PullRequestReviewCommentStartSide
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilPullRequestReviewCommentStartSide", d.Next())
	}
}

// Encode encodes []ReposCreateOrUpdateEnvironmentReqReviewersItem as json.
func (o OptNilReposCreateOrUpdateEnvironmentReqReviewersItemArray) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	if len(o.Value) >= 1 {
		// Encode first element without comma.
		{
			elem := o.Value[0]
			elem.Encode(e)
		}
		for _, elem := range o.Value[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes []ReposCreateOrUpdateEnvironmentReqReviewersItem from json.
func (o *OptNilReposCreateOrUpdateEnvironmentReqReviewersItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilReposCreateOrUpdateEnvironmentReqReviewersItemArray to nil")
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ReposCreateOrUpdateEnvironmentReqReviewersItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			o.Value = append(o.Value, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []ReposCreateOrUpdateEnvironmentReqReviewersItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilReposCreateOrUpdateEnvironmentReqReviewersItemArray", d.Next())
	}
}

// Encode encodes ReposUpdateReqSecurityAndAnalysis as json.
func (o OptNilReposUpdateReqSecurityAndAnalysis) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReqSecurityAndAnalysis from json.
func (o *OptNilReposUpdateReqSecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilReposUpdateReqSecurityAndAnalysis to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v ReposUpdateReqSecurityAndAnalysis
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilReposUpdateReqSecurityAndAnalysis", d.Next())
	}
}

// Encode encodes RepositoryTemplateRepository as json.
func (o OptNilRepositoryTemplateRepository) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RepositoryTemplateRepository from json.
func (o *OptNilRepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilRepositoryTemplateRepository to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v RepositoryTemplateRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilRepositoryTemplateRepository", d.Next())
	}
}

// Encode encodes ReviewCommentStartSide as json.
func (o OptNilReviewCommentStartSide) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReviewCommentStartSide from json.
func (o *OptNilReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilReviewCommentStartSide to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v ReviewCommentStartSide
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilReviewCommentStartSide", d.Next())
	}
}

// Encode encodes SecretScanningAlertResolution as json.
func (o OptNilSecretScanningAlertResolution) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SecretScanningAlertResolution from json.
func (o *OptNilSecretScanningAlertResolution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSecretScanningAlertResolution to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v SecretScanningAlertResolution
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilSecretScanningAlertResolution", d.Next())
	}
}

// Encode encodes []SimpleUser as json.
func (o OptNilSimpleUserArray) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	if len(o.Value) >= 1 {
		// Encode first element without comma.
		{
			elem := o.Value[0]
			elem.Encode(e)
		}
		for _, elem := range o.Value[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes []SimpleUser from json.
func (o *OptNilSimpleUserArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSimpleUserArray to nil")
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			o.Value = append(o.Value, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []SimpleUser
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilSimpleUserArray", d.Next())
	}
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilString", d.Next())
	}
}

// Encode encodes []string as json.
func (o OptNilStringArray) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	if len(o.Value) >= 1 {
		// Encode first element without comma.
		{
			elem := o.Value[0]
			e.Str(elem)
		}
		for _, elem := range o.Value[1:] {
			e.Comma()
			e.Str(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes []string from json.
func (o *OptNilStringArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilStringArray to nil")
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			o.Value = append(o.Value, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilStringArray", d.Next())
	}
}

// Encode encodes []Team as json.
func (o OptNilTeamArray) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	if len(o.Value) >= 1 {
		// Encode first element without comma.
		{
			elem := o.Value[0]
			elem.Encode(e)
		}
		for _, elem := range o.Value[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes []Team from json.
func (o *OptNilTeamArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTeamArray to nil")
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			o.Value = append(o.Value, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []Team
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilTeamArray", d.Next())
	}
}

// Encode encodes []TeamSimple as json.
func (o OptNilTeamSimpleArray) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	if len(o.Value) >= 1 {
		// Encode first element without comma.
		{
			elem := o.Value[0]
			elem.Encode(e)
		}
		for _, elem := range o.Value[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes []TeamSimple from json.
func (o *OptNilTeamSimpleArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTeamSimpleArray to nil")
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TeamSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			o.Value = append(o.Value, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []TeamSimple
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilTeamSimpleArray", d.Next())
	}
}

// Encode encodes time.Time as json.
func (o OptNilTime) Encode(e *jx.Writer, format func(*jx.Writer, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTime to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := format(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilTime", d.Next())
	}
}

// Encode encodes []TopicSearchResultItemAliasesItem as json.
func (o OptNilTopicSearchResultItemAliasesItemArray) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	if len(o.Value) >= 1 {
		// Encode first element without comma.
		{
			elem := o.Value[0]
			elem.Encode(e)
		}
		for _, elem := range o.Value[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes []TopicSearchResultItemAliasesItem from json.
func (o *OptNilTopicSearchResultItemAliasesItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTopicSearchResultItemAliasesItemArray to nil")
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TopicSearchResultItemAliasesItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			o.Value = append(o.Value, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []TopicSearchResultItemAliasesItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilTopicSearchResultItemAliasesItemArray", d.Next())
	}
}

// Encode encodes []TopicSearchResultItemRelatedItem as json.
func (o OptNilTopicSearchResultItemRelatedItemArray) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	if len(o.Value) >= 1 {
		// Encode first element without comma.
		{
			elem := o.Value[0]
			elem.Encode(e)
		}
		for _, elem := range o.Value[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes []TopicSearchResultItemRelatedItem from json.
func (o *OptNilTopicSearchResultItemRelatedItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTopicSearchResultItemRelatedItemArray to nil")
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TopicSearchResultItemRelatedItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			o.Value = append(o.Value, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []TopicSearchResultItemRelatedItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilTopicSearchResultItemRelatedItemArray", d.Next())
	}
}

// Encode encodes url.URL as json.
func (o OptNilURL) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptNilURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilURL to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := json.DecodeURI(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v url.URL
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNilURL", d.Next())
	}
}

// Encode encodes NullableMinimalRepositoryPermissions as json.
func (o OptNullableMinimalRepositoryPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableMinimalRepositoryPermissions from json.
func (o *OptNullableMinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNullableMinimalRepositoryPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNullableMinimalRepositoryPermissions", d.Next())
	}
}

// Encode encodes NullableRepositoryPermissions as json.
func (o OptNullableRepositoryPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryPermissions from json.
func (o *OptNullableRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNullableRepositoryPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNullableRepositoryPermissions", d.Next())
	}
}

// Encode encodes NullableRepositoryTemplateRepositoryOwner as json.
func (o OptNullableRepositoryTemplateRepositoryOwner) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryTemplateRepositoryOwner from json.
func (o *OptNullableRepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNullableRepositoryTemplateRepositoryOwner to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNullableRepositoryTemplateRepositoryOwner", d.Next())
	}
}

// Encode encodes NullableRepositoryTemplateRepositoryPermissions as json.
func (o OptNullableRepositoryTemplateRepositoryPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryTemplateRepositoryPermissions from json.
func (o *OptNullableRepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNullableRepositoryTemplateRepositoryPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptNullableRepositoryTemplateRepositoryPermissions", d.Next())
	}
}

// Encode encodes OAuthAuthorizationsCreateAuthorizationReq as json.
func (o OptOAuthAuthorizationsCreateAuthorizationReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationReq from json.
func (o *OptOAuthAuthorizationsCreateAuthorizationReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOAuthAuthorizationsCreateAuthorizationReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptOAuthAuthorizationsCreateAuthorizationReq", d.Next())
	}
}

// Encode encodes OAuthAuthorizationsUpdateAuthorizationReq as json.
func (o OptOAuthAuthorizationsUpdateAuthorizationReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OAuthAuthorizationsUpdateAuthorizationReq from json.
func (o *OptOAuthAuthorizationsUpdateAuthorizationReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOAuthAuthorizationsUpdateAuthorizationReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptOAuthAuthorizationsUpdateAuthorizationReq", d.Next())
	}
}

// Encode encodes OrgMembershipPermissions as json.
func (o OptOrgMembershipPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrgMembershipPermissions from json.
func (o *OptOrgMembershipPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgMembershipPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptOrgMembershipPermissions", d.Next())
	}
}

// Encode encodes OrganizationFullPlan as json.
func (o OptOrganizationFullPlan) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrganizationFullPlan from json.
func (o *OptOrganizationFullPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrganizationFullPlan to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptOrganizationFullPlan", d.Next())
	}
}

// Encode encodes OrgsCreateInvitationReq as json.
func (o OptOrgsCreateInvitationReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrgsCreateInvitationReq from json.
func (o *OptOrgsCreateInvitationReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsCreateInvitationReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptOrgsCreateInvitationReq", d.Next())
	}
}

// Encode encodes OrgsCreateInvitationReqRole as json.
func (o OptOrgsCreateInvitationReqRole) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes OrgsCreateInvitationReqRole from json.
func (o *OptOrgsCreateInvitationReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsCreateInvitationReqRole to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptOrgsCreateInvitationReqRole", d.Next())
	}
}

// Encode encodes OrgsSetMembershipForUserReq as json.
func (o OptOrgsSetMembershipForUserReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrgsSetMembershipForUserReq from json.
func (o *OptOrgsSetMembershipForUserReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsSetMembershipForUserReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptOrgsSetMembershipForUserReq", d.Next())
	}
}

// Encode encodes OrgsSetMembershipForUserReqRole as json.
func (o OptOrgsSetMembershipForUserReqRole) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes OrgsSetMembershipForUserReqRole from json.
func (o *OptOrgsSetMembershipForUserReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsSetMembershipForUserReqRole to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptOrgsSetMembershipForUserReqRole", d.Next())
	}
}

// Encode encodes OrgsUpdateReq as json.
func (o OptOrgsUpdateReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrgsUpdateReq from json.
func (o *OptOrgsUpdateReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsUpdateReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptOrgsUpdateReq", d.Next())
	}
}

// Encode encodes OrgsUpdateReqDefaultRepositoryPermission as json.
func (o OptOrgsUpdateReqDefaultRepositoryPermission) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes OrgsUpdateReqDefaultRepositoryPermission from json.
func (o *OptOrgsUpdateReqDefaultRepositoryPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsUpdateReqDefaultRepositoryPermission to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptOrgsUpdateReqDefaultRepositoryPermission", d.Next())
	}
}

// Encode encodes OrgsUpdateReqMembersAllowedRepositoryCreationType as json.
func (o OptOrgsUpdateReqMembersAllowedRepositoryCreationType) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes OrgsUpdateReqMembersAllowedRepositoryCreationType from json.
func (o *OptOrgsUpdateReqMembersAllowedRepositoryCreationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsUpdateReqMembersAllowedRepositoryCreationType to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptOrgsUpdateReqMembersAllowedRepositoryCreationType", d.Next())
	}
}

// Encode encodes OrgsUpdateWebhookConfigForOrgReq as json.
func (o OptOrgsUpdateWebhookConfigForOrgReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrgsUpdateWebhookConfigForOrgReq from json.
func (o *OptOrgsUpdateWebhookConfigForOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsUpdateWebhookConfigForOrgReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptOrgsUpdateWebhookConfigForOrgReq", d.Next())
	}
}

// Encode encodes OrgsUpdateWebhookReq as json.
func (o OptOrgsUpdateWebhookReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrgsUpdateWebhookReq from json.
func (o *OptOrgsUpdateWebhookReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsUpdateWebhookReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptOrgsUpdateWebhookReq", d.Next())
	}
}

// Encode encodes OrgsUpdateWebhookReqConfig as json.
func (o OptOrgsUpdateWebhookReqConfig) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrgsUpdateWebhookReqConfig from json.
func (o *OptOrgsUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrgsUpdateWebhookReqConfig to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptOrgsUpdateWebhookReqConfig", d.Next())
	}
}

// Encode encodes PackageVersionMetadata as json.
func (o OptPackageVersionMetadata) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PackageVersionMetadata from json.
func (o *OptPackageVersionMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPackageVersionMetadata to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPackageVersionMetadata", d.Next())
	}
}

// Encode encodes PackageVersionMetadataContainer as json.
func (o OptPackageVersionMetadataContainer) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PackageVersionMetadataContainer from json.
func (o *OptPackageVersionMetadataContainer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPackageVersionMetadataContainer to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPackageVersionMetadataContainer", d.Next())
	}
}

// Encode encodes PackageVersionMetadataDocker as json.
func (o OptPackageVersionMetadataDocker) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PackageVersionMetadataDocker from json.
func (o *OptPackageVersionMetadataDocker) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPackageVersionMetadataDocker to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPackageVersionMetadataDocker", d.Next())
	}
}

// Encode encodes PagesHTTPSCertificate as json.
func (o OptPagesHTTPSCertificate) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PagesHTTPSCertificate from json.
func (o *OptPagesHTTPSCertificate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPagesHTTPSCertificate to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPagesHTTPSCertificate", d.Next())
	}
}

// Encode encodes PagesHealthCheckDomain as json.
func (o OptPagesHealthCheckDomain) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PagesHealthCheckDomain from json.
func (o *OptPagesHealthCheckDomain) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPagesHealthCheckDomain to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPagesHealthCheckDomain", d.Next())
	}
}

// Encode encodes PagesSourceHash as json.
func (o OptPagesSourceHash) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PagesSourceHash from json.
func (o *OptPagesSourceHash) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPagesSourceHash to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPagesSourceHash", d.Next())
	}
}

// Encode encodes PrivateUserPlan as json.
func (o OptPrivateUserPlan) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PrivateUserPlan from json.
func (o *OptPrivateUserPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPrivateUserPlan to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPrivateUserPlan", d.Next())
	}
}

// Encode encodes ProjectOrganizationPermission as json.
func (o OptProjectOrganizationPermission) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectOrganizationPermission from json.
func (o *OptProjectOrganizationPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectOrganizationPermission to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProjectOrganizationPermission", d.Next())
	}
}

// Encode encodes ProjectsAddCollaboratorReq as json.
func (o OptProjectsAddCollaboratorReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProjectsAddCollaboratorReq from json.
func (o *OptProjectsAddCollaboratorReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectsAddCollaboratorReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProjectsAddCollaboratorReq", d.Next())
	}
}

// Encode encodes ProjectsAddCollaboratorReqPermission as json.
func (o OptProjectsAddCollaboratorReqPermission) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectsAddCollaboratorReqPermission from json.
func (o *OptProjectsAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectsAddCollaboratorReqPermission to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProjectsAddCollaboratorReqPermission", d.Next())
	}
}

// Encode encodes ProjectsUpdateCardReq as json.
func (o OptProjectsUpdateCardReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProjectsUpdateCardReq from json.
func (o *OptProjectsUpdateCardReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectsUpdateCardReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProjectsUpdateCardReq", d.Next())
	}
}

// Encode encodes ProjectsUpdateReq as json.
func (o OptProjectsUpdateReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProjectsUpdateReq from json.
func (o *OptProjectsUpdateReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectsUpdateReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProjectsUpdateReq", d.Next())
	}
}

// Encode encodes ProjectsUpdateReqOrganizationPermission as json.
func (o OptProjectsUpdateReqOrganizationPermission) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectsUpdateReqOrganizationPermission from json.
func (o *OptProjectsUpdateReqOrganizationPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectsUpdateReqOrganizationPermission to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProjectsUpdateReqOrganizationPermission", d.Next())
	}
}

// Encode encodes ProtectedBranchAdminEnforced as json.
func (o OptProtectedBranchAdminEnforced) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchAdminEnforced from json.
func (o *OptProtectedBranchAdminEnforced) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchAdminEnforced to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProtectedBranchAdminEnforced", d.Next())
	}
}

// Encode encodes ProtectedBranchAllowDeletions as json.
func (o OptProtectedBranchAllowDeletions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchAllowDeletions from json.
func (o *OptProtectedBranchAllowDeletions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchAllowDeletions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProtectedBranchAllowDeletions", d.Next())
	}
}

// Encode encodes ProtectedBranchAllowForcePushes as json.
func (o OptProtectedBranchAllowForcePushes) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchAllowForcePushes from json.
func (o *OptProtectedBranchAllowForcePushes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchAllowForcePushes to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProtectedBranchAllowForcePushes", d.Next())
	}
}

// Encode encodes ProtectedBranchEnforceAdmins as json.
func (o OptProtectedBranchEnforceAdmins) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchEnforceAdmins from json.
func (o *OptProtectedBranchEnforceAdmins) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchEnforceAdmins to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProtectedBranchEnforceAdmins", d.Next())
	}
}

// Encode encodes ProtectedBranchPullRequestReview as json.
func (o OptProtectedBranchPullRequestReview) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchPullRequestReview from json.
func (o *OptProtectedBranchPullRequestReview) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchPullRequestReview to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProtectedBranchPullRequestReview", d.Next())
	}
}

// Encode encodes ProtectedBranchPullRequestReviewDismissalRestrictions as json.
func (o OptProtectedBranchPullRequestReviewDismissalRestrictions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchPullRequestReviewDismissalRestrictions from json.
func (o *OptProtectedBranchPullRequestReviewDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchPullRequestReviewDismissalRestrictions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProtectedBranchPullRequestReviewDismissalRestrictions", d.Next())
	}
}

// Encode encodes ProtectedBranchRequiredConversationResolution as json.
func (o OptProtectedBranchRequiredConversationResolution) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredConversationResolution from json.
func (o *OptProtectedBranchRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchRequiredConversationResolution to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProtectedBranchRequiredConversationResolution", d.Next())
	}
}

// Encode encodes ProtectedBranchRequiredLinearHistory as json.
func (o OptProtectedBranchRequiredLinearHistory) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredLinearHistory from json.
func (o *OptProtectedBranchRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchRequiredLinearHistory to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProtectedBranchRequiredLinearHistory", d.Next())
	}
}

// Encode encodes ProtectedBranchRequiredPullRequestReviews as json.
func (o OptProtectedBranchRequiredPullRequestReviews) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredPullRequestReviews from json.
func (o *OptProtectedBranchRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchRequiredPullRequestReviews to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProtectedBranchRequiredPullRequestReviews", d.Next())
	}
}

// Encode encodes ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions as json.
func (o OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions from json.
func (o *OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions", d.Next())
	}
}

// Encode encodes ProtectedBranchRequiredSignatures as json.
func (o OptProtectedBranchRequiredSignatures) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredSignatures from json.
func (o *OptProtectedBranchRequiredSignatures) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProtectedBranchRequiredSignatures to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptProtectedBranchRequiredSignatures", d.Next())
	}
}

// Encode encodes PublicUser as json.
func (o OptPublicUser) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PublicUser from json.
func (o *OptPublicUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPublicUser to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPublicUser", d.Next())
	}
}

// Encode encodes PublicUserPlan as json.
func (o OptPublicUserPlan) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PublicUserPlan from json.
func (o *OptPublicUserPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPublicUserPlan to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPublicUserPlan", d.Next())
	}
}

// Encode encodes PullRequestBaseRepoPermissions as json.
func (o OptPullRequestBaseRepoPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullRequestBaseRepoPermissions from json.
func (o *OptPullRequestBaseRepoPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullRequestBaseRepoPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPullRequestBaseRepoPermissions", d.Next())
	}
}

// Encode encodes PullRequestHeadRepoPermissions as json.
func (o OptPullRequestHeadRepoPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullRequestHeadRepoPermissions from json.
func (o *OptPullRequestHeadRepoPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullRequestHeadRepoPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPullRequestHeadRepoPermissions", d.Next())
	}
}

// Encode encodes PullRequestReviewCommentSide as json.
func (o OptPullRequestReviewCommentSide) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullRequestReviewCommentSide from json.
func (o *OptPullRequestReviewCommentSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullRequestReviewCommentSide to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPullRequestReviewCommentSide", d.Next())
	}
}

// Encode encodes PullsCreateReviewCommentReqSide as json.
func (o OptPullsCreateReviewCommentReqSide) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullsCreateReviewCommentReqSide from json.
func (o *OptPullsCreateReviewCommentReqSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsCreateReviewCommentReqSide to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPullsCreateReviewCommentReqSide", d.Next())
	}
}

// Encode encodes PullsCreateReviewCommentReqStartSide as json.
func (o OptPullsCreateReviewCommentReqStartSide) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullsCreateReviewCommentReqStartSide from json.
func (o *OptPullsCreateReviewCommentReqStartSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsCreateReviewCommentReqStartSide to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPullsCreateReviewCommentReqStartSide", d.Next())
	}
}

// Encode encodes PullsCreateReviewReq as json.
func (o OptPullsCreateReviewReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullsCreateReviewReq from json.
func (o *OptPullsCreateReviewReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsCreateReviewReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPullsCreateReviewReq", d.Next())
	}
}

// Encode encodes PullsCreateReviewReqEvent as json.
func (o OptPullsCreateReviewReqEvent) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullsCreateReviewReqEvent from json.
func (o *OptPullsCreateReviewReqEvent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsCreateReviewReqEvent to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPullsCreateReviewReqEvent", d.Next())
	}
}

// Encode encodes PullsMergeReq as json.
func (o OptPullsMergeReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullsMergeReq from json.
func (o *OptPullsMergeReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsMergeReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPullsMergeReq", d.Next())
	}
}

// Encode encodes PullsMergeReqMergeMethod as json.
func (o OptPullsMergeReqMergeMethod) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullsMergeReqMergeMethod from json.
func (o *OptPullsMergeReqMergeMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsMergeReqMergeMethod to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPullsMergeReqMergeMethod", d.Next())
	}
}

// Encode encodes PullsUpdateBranchReq as json.
func (o OptPullsUpdateBranchReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullsUpdateBranchReq from json.
func (o *OptPullsUpdateBranchReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsUpdateBranchReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPullsUpdateBranchReq", d.Next())
	}
}

// Encode encodes PullsUpdateReq as json.
func (o OptPullsUpdateReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullsUpdateReq from json.
func (o *OptPullsUpdateReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsUpdateReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPullsUpdateReq", d.Next())
	}
}

// Encode encodes PullsUpdateReqState as json.
func (o OptPullsUpdateReqState) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullsUpdateReqState from json.
func (o *OptPullsUpdateReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPullsUpdateReqState to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptPullsUpdateReqState", d.Next())
	}
}

// Encode encodes RateLimit as json.
func (o OptRateLimit) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RateLimit from json.
func (o *OptRateLimit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRateLimit to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptRateLimit", d.Next())
	}
}

// Encode encodes ReactionRollup as json.
func (o OptReactionRollup) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReactionRollup from json.
func (o *OptReactionRollup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReactionRollup to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReactionRollup", d.Next())
	}
}

// Encode encodes RepoSearchResultItemPermissions as json.
func (o OptRepoSearchResultItemPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RepoSearchResultItemPermissions from json.
func (o *OptRepoSearchResultItemPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRepoSearchResultItemPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptRepoSearchResultItemPermissions", d.Next())
	}
}

// Encode encodes ReposAddAppAccessRestrictionsReq as json.
func (o OptReposAddAppAccessRestrictionsReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposAddAppAccessRestrictionsReq from json.
func (o *OptReposAddAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposAddAppAccessRestrictionsReq to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposAddAppAccessRestrictionsReq", d.Next())
	}
}

// Encode encodes ReposAddCollaboratorReq as json.
func (o OptReposAddCollaboratorReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposAddCollaboratorReq from json.
func (o *OptReposAddCollaboratorReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposAddCollaboratorReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposAddCollaboratorReq", d.Next())
	}
}

// Encode encodes ReposAddCollaboratorReqPermission as json.
func (o OptReposAddCollaboratorReqPermission) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReposAddCollaboratorReqPermission from json.
func (o *OptReposAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposAddCollaboratorReqPermission to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposAddCollaboratorReqPermission", d.Next())
	}
}

// Encode encodes ReposAddStatusCheckContextsReq as json.
func (o OptReposAddStatusCheckContextsReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposAddStatusCheckContextsReq from json.
func (o *OptReposAddStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposAddStatusCheckContextsReq to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposAddStatusCheckContextsReq", d.Next())
	}
}

// Encode encodes ReposAddTeamAccessRestrictionsReq as json.
func (o OptReposAddTeamAccessRestrictionsReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposAddTeamAccessRestrictionsReq from json.
func (o *OptReposAddTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposAddTeamAccessRestrictionsReq to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposAddTeamAccessRestrictionsReq", d.Next())
	}
}

// Encode encodes ReposAddUserAccessRestrictionsReq as json.
func (o OptReposAddUserAccessRestrictionsReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposAddUserAccessRestrictionsReq from json.
func (o *OptReposAddUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposAddUserAccessRestrictionsReq to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposAddUserAccessRestrictionsReq", d.Next())
	}
}

// Encode encodes ReposCreateDeploymentReqPayload as json.
func (o OptReposCreateDeploymentReqPayload) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreateDeploymentReqPayload from json.
func (o *OptReposCreateDeploymentReqPayload) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateDeploymentReqPayload to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposCreateDeploymentReqPayload", d.Next())
	}
}

// Encode encodes ReposCreateDeploymentStatusReqEnvironment as json.
func (o OptReposCreateDeploymentStatusReqEnvironment) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReposCreateDeploymentStatusReqEnvironment from json.
func (o *OptReposCreateDeploymentStatusReqEnvironment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateDeploymentStatusReqEnvironment to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposCreateDeploymentStatusReqEnvironment", d.Next())
	}
}

// Encode encodes ReposCreateDispatchEventReqClientPayload as json.
func (o OptReposCreateDispatchEventReqClientPayload) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreateDispatchEventReqClientPayload from json.
func (o *OptReposCreateDispatchEventReqClientPayload) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateDispatchEventReqClientPayload to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Value = make(ReposCreateDispatchEventReqClientPayload)
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposCreateDispatchEventReqClientPayload", d.Next())
	}
}

// Encode encodes ReposCreateForkReq as json.
func (o OptReposCreateForkReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreateForkReq from json.
func (o *OptReposCreateForkReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateForkReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposCreateForkReq", d.Next())
	}
}

// Encode encodes ReposCreateInOrgReqVisibility as json.
func (o OptReposCreateInOrgReqVisibility) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReposCreateInOrgReqVisibility from json.
func (o *OptReposCreateInOrgReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateInOrgReqVisibility to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposCreateInOrgReqVisibility", d.Next())
	}
}

// Encode encodes ReposCreateOrUpdateEnvironmentReq as json.
func (o OptReposCreateOrUpdateEnvironmentReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreateOrUpdateEnvironmentReq from json.
func (o *OptReposCreateOrUpdateEnvironmentReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateOrUpdateEnvironmentReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposCreateOrUpdateEnvironmentReq", d.Next())
	}
}

// Encode encodes ReposCreateOrUpdateFileContentsReqAuthor as json.
func (o OptReposCreateOrUpdateFileContentsReqAuthor) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsReqAuthor from json.
func (o *OptReposCreateOrUpdateFileContentsReqAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateOrUpdateFileContentsReqAuthor to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposCreateOrUpdateFileContentsReqAuthor", d.Next())
	}
}

// Encode encodes ReposCreateOrUpdateFileContentsReqCommitter as json.
func (o OptReposCreateOrUpdateFileContentsReqCommitter) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsReqCommitter from json.
func (o *OptReposCreateOrUpdateFileContentsReqCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateOrUpdateFileContentsReqCommitter to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposCreateOrUpdateFileContentsReqCommitter", d.Next())
	}
}

// Encode encodes ReposCreatePagesSiteReqSourcePath as json.
func (o OptReposCreatePagesSiteReqSourcePath) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReposCreatePagesSiteReqSourcePath from json.
func (o *OptReposCreatePagesSiteReqSourcePath) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreatePagesSiteReqSourcePath to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposCreatePagesSiteReqSourcePath", d.Next())
	}
}

// Encode encodes ReposCreateWebhookReq as json.
func (o OptReposCreateWebhookReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreateWebhookReq from json.
func (o *OptReposCreateWebhookReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateWebhookReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposCreateWebhookReq", d.Next())
	}
}

// Encode encodes ReposCreateWebhookReqConfig as json.
func (o OptReposCreateWebhookReqConfig) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposCreateWebhookReqConfig from json.
func (o *OptReposCreateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposCreateWebhookReqConfig to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposCreateWebhookReqConfig", d.Next())
	}
}

// Encode encodes ReposDeleteFileReqAuthor as json.
func (o OptReposDeleteFileReqAuthor) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposDeleteFileReqAuthor from json.
func (o *OptReposDeleteFileReqAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposDeleteFileReqAuthor to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposDeleteFileReqAuthor", d.Next())
	}
}

// Encode encodes ReposDeleteFileReqCommitter as json.
func (o OptReposDeleteFileReqCommitter) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposDeleteFileReqCommitter from json.
func (o *OptReposDeleteFileReqCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposDeleteFileReqCommitter to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposDeleteFileReqCommitter", d.Next())
	}
}

// Encode encodes ReposRemoveAppAccessRestrictionsReq as json.
func (o OptReposRemoveAppAccessRestrictionsReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposRemoveAppAccessRestrictionsReq from json.
func (o *OptReposRemoveAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposRemoveAppAccessRestrictionsReq to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposRemoveAppAccessRestrictionsReq", d.Next())
	}
}

// Encode encodes ReposRemoveStatusCheckContextsReq as json.
func (o OptReposRemoveStatusCheckContextsReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposRemoveStatusCheckContextsReq from json.
func (o *OptReposRemoveStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposRemoveStatusCheckContextsReq to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposRemoveStatusCheckContextsReq", d.Next())
	}
}

// Encode encodes ReposRemoveTeamAccessRestrictionsReq as json.
func (o OptReposRemoveTeamAccessRestrictionsReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposRemoveTeamAccessRestrictionsReq from json.
func (o *OptReposRemoveTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposRemoveTeamAccessRestrictionsReq to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposRemoveTeamAccessRestrictionsReq", d.Next())
	}
}

// Encode encodes ReposRemoveUserAccessRestrictionsReq as json.
func (o OptReposRemoveUserAccessRestrictionsReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposRemoveUserAccessRestrictionsReq from json.
func (o *OptReposRemoveUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposRemoveUserAccessRestrictionsReq to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposRemoveUserAccessRestrictionsReq", d.Next())
	}
}

// Encode encodes ReposRenameBranchReq as json.
func (o OptReposRenameBranchReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposRenameBranchReq from json.
func (o *OptReposRenameBranchReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposRenameBranchReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposRenameBranchReq", d.Next())
	}
}

// Encode encodes ReposSetAppAccessRestrictionsReq as json.
func (o OptReposSetAppAccessRestrictionsReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposSetAppAccessRestrictionsReq from json.
func (o *OptReposSetAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposSetAppAccessRestrictionsReq to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposSetAppAccessRestrictionsReq", d.Next())
	}
}

// Encode encodes ReposSetStatusCheckContextsReq as json.
func (o OptReposSetStatusCheckContextsReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposSetStatusCheckContextsReq from json.
func (o *OptReposSetStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposSetStatusCheckContextsReq to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposSetStatusCheckContextsReq", d.Next())
	}
}

// Encode encodes ReposSetTeamAccessRestrictionsReq as json.
func (o OptReposSetTeamAccessRestrictionsReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposSetTeamAccessRestrictionsReq from json.
func (o *OptReposSetTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposSetTeamAccessRestrictionsReq to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposSetTeamAccessRestrictionsReq", d.Next())
	}
}

// Encode encodes ReposSetUserAccessRestrictionsReq as json.
func (o OptReposSetUserAccessRestrictionsReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposSetUserAccessRestrictionsReq from json.
func (o *OptReposSetUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposSetUserAccessRestrictionsReq to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposSetUserAccessRestrictionsReq", d.Next())
	}
}

// Encode encodes ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions as json.
func (o OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions from json.
func (o *OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions", d.Next())
	}
}

// Encode encodes ReposUpdateInvitationReq as json.
func (o OptReposUpdateInvitationReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateInvitationReq from json.
func (o *OptReposUpdateInvitationReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateInvitationReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposUpdateInvitationReq", d.Next())
	}
}

// Encode encodes ReposUpdateInvitationReqPermissions as json.
func (o OptReposUpdateInvitationReqPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReposUpdateInvitationReqPermissions from json.
func (o *OptReposUpdateInvitationReqPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateInvitationReqPermissions to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposUpdateInvitationReqPermissions", d.Next())
	}
}

// Encode encodes ReposUpdatePullRequestReviewProtectionReq as json.
func (o OptReposUpdatePullRequestReviewProtectionReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdatePullRequestReviewProtectionReq from json.
func (o *OptReposUpdatePullRequestReviewProtectionReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdatePullRequestReviewProtectionReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposUpdatePullRequestReviewProtectionReq", d.Next())
	}
}

// Encode encodes ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions as json.
func (o OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions from json.
func (o *OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions", d.Next())
	}
}

// Encode encodes ReposUpdateReleaseAssetReq as json.
func (o OptReposUpdateReleaseAssetReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReleaseAssetReq from json.
func (o *OptReposUpdateReleaseAssetReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateReleaseAssetReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposUpdateReleaseAssetReq", d.Next())
	}
}

// Encode encodes ReposUpdateReleaseReq as json.
func (o OptReposUpdateReleaseReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReleaseReq from json.
func (o *OptReposUpdateReleaseReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateReleaseReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposUpdateReleaseReq", d.Next())
	}
}

// Encode encodes ReposUpdateReq as json.
func (o OptReposUpdateReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReq from json.
func (o *OptReposUpdateReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposUpdateReq", d.Next())
	}
}

// Encode encodes ReposUpdateReqSecurityAndAnalysisAdvancedSecurity as json.
func (o OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisAdvancedSecurity from json.
func (o *OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity", d.Next())
	}
}

// Encode encodes ReposUpdateReqSecurityAndAnalysisSecretScanning as json.
func (o OptReposUpdateReqSecurityAndAnalysisSecretScanning) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisSecretScanning from json.
func (o *OptReposUpdateReqSecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateReqSecurityAndAnalysisSecretScanning to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposUpdateReqSecurityAndAnalysisSecretScanning", d.Next())
	}
}

// Encode encodes ReposUpdateReqVisibility as json.
func (o OptReposUpdateReqVisibility) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReposUpdateReqVisibility from json.
func (o *OptReposUpdateReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateReqVisibility to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposUpdateReqVisibility", d.Next())
	}
}

// Encode encodes ReposUpdateStatusCheckProtectionReq as json.
func (o OptReposUpdateStatusCheckProtectionReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateStatusCheckProtectionReq from json.
func (o *OptReposUpdateStatusCheckProtectionReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateStatusCheckProtectionReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposUpdateStatusCheckProtectionReq", d.Next())
	}
}

// Encode encodes ReposUpdateWebhookConfigForRepoReq as json.
func (o OptReposUpdateWebhookConfigForRepoReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateWebhookConfigForRepoReq from json.
func (o *OptReposUpdateWebhookConfigForRepoReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateWebhookConfigForRepoReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposUpdateWebhookConfigForRepoReq", d.Next())
	}
}

// Encode encodes ReposUpdateWebhookReq as json.
func (o OptReposUpdateWebhookReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateWebhookReq from json.
func (o *OptReposUpdateWebhookReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateWebhookReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposUpdateWebhookReq", d.Next())
	}
}

// Encode encodes ReposUpdateWebhookReqConfig as json.
func (o OptReposUpdateWebhookReqConfig) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateWebhookReqConfig from json.
func (o *OptReposUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReposUpdateWebhookReqConfig to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReposUpdateWebhookReqConfig", d.Next())
	}
}

// Encode encodes Repository as json.
func (o OptRepository) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Repository from json.
func (o *OptRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRepository to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptRepository", d.Next())
	}
}

// Encode encodes RepositoryPermissions as json.
func (o OptRepositoryPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RepositoryPermissions from json.
func (o *OptRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRepositoryPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptRepositoryPermissions", d.Next())
	}
}

// Encode encodes RepositoryTemplateRepositoryOwner as json.
func (o OptRepositoryTemplateRepositoryOwner) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RepositoryTemplateRepositoryOwner from json.
func (o *OptRepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRepositoryTemplateRepositoryOwner to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptRepositoryTemplateRepositoryOwner", d.Next())
	}
}

// Encode encodes RepositoryTemplateRepositoryPermissions as json.
func (o OptRepositoryTemplateRepositoryPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RepositoryTemplateRepositoryPermissions from json.
func (o *OptRepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRepositoryTemplateRepositoryPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptRepositoryTemplateRepositoryPermissions", d.Next())
	}
}

// Encode encodes ReviewCommentSide as json.
func (o OptReviewCommentSide) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReviewCommentSide from json.
func (o *OptReviewCommentSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReviewCommentSide to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptReviewCommentSide", d.Next())
	}
}

// Encode encodes RunnerLabelsItemType as json.
func (o OptRunnerLabelsItemType) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RunnerLabelsItemType from json.
func (o *OptRunnerLabelsItemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRunnerLabelsItemType to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptRunnerLabelsItemType", d.Next())
	}
}

// Encode encodes ScimEnterpriseGroupMeta as json.
func (o OptScimEnterpriseGroupMeta) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ScimEnterpriseGroupMeta from json.
func (o *OptScimEnterpriseGroupMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptScimEnterpriseGroupMeta to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptScimEnterpriseGroupMeta", d.Next())
	}
}

// Encode encodes ScimEnterpriseUserMeta as json.
func (o OptScimEnterpriseUserMeta) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ScimEnterpriseUserMeta from json.
func (o *OptScimEnterpriseUserMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptScimEnterpriseUserMeta to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptScimEnterpriseUserMeta", d.Next())
	}
}

// Encode encodes ScimEnterpriseUserName as json.
func (o OptScimEnterpriseUserName) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ScimEnterpriseUserName from json.
func (o *OptScimEnterpriseUserName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptScimEnterpriseUserName to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptScimEnterpriseUserName", d.Next())
	}
}

// Encode encodes ScimGroupListEnterpriseResourcesItemMeta as json.
func (o OptScimGroupListEnterpriseResourcesItemMeta) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ScimGroupListEnterpriseResourcesItemMeta from json.
func (o *OptScimGroupListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptScimGroupListEnterpriseResourcesItemMeta to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptScimGroupListEnterpriseResourcesItemMeta", d.Next())
	}
}

// Encode encodes ScimUpdateAttributeForUserReqOperationsItemValue as json.
func (o OptScimUpdateAttributeForUserReqOperationsItemValue) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ScimUpdateAttributeForUserReqOperationsItemValue from json.
func (o *OptScimUpdateAttributeForUserReqOperationsItemValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptScimUpdateAttributeForUserReqOperationsItemValue to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptScimUpdateAttributeForUserReqOperationsItemValue", d.Next())
	}
}

// Encode encodes ScimUserListEnterpriseResourcesItemMeta as json.
func (o OptScimUserListEnterpriseResourcesItemMeta) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ScimUserListEnterpriseResourcesItemMeta from json.
func (o *OptScimUserListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptScimUserListEnterpriseResourcesItemMeta to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptScimUserListEnterpriseResourcesItemMeta", d.Next())
	}
}

// Encode encodes ScimUserListEnterpriseResourcesItemName as json.
func (o OptScimUserListEnterpriseResourcesItemName) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ScimUserListEnterpriseResourcesItemName from json.
func (o *OptScimUserListEnterpriseResourcesItemName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptScimUserListEnterpriseResourcesItemName to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptScimUserListEnterpriseResourcesItemName", d.Next())
	}
}

// Encode encodes SecretScanningAlertState as json.
func (o OptSecretScanningAlertState) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SecretScanningAlertState from json.
func (o *OptSecretScanningAlertState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSecretScanningAlertState to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptSecretScanningAlertState", d.Next())
	}
}

// Encode encodes SelectedActions as json.
func (o OptSelectedActions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SelectedActions from json.
func (o *OptSelectedActions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSelectedActions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptSelectedActions", d.Next())
	}
}

// Encode encodes SelectedActionsURL as json.
func (o OptSelectedActionsURL) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SelectedActionsURL from json.
func (o *OptSelectedActionsURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSelectedActionsURL to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptSelectedActionsURL", d.Next())
	}
}

// Encode encodes SimpleUser as json.
func (o OptSimpleUser) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SimpleUser from json.
func (o *OptSimpleUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSimpleUser to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptSimpleUser", d.Next())
	}
}

// Encode encodes StatusCheckPolicy as json.
func (o OptStatusCheckPolicy) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes StatusCheckPolicy from json.
func (o *OptStatusCheckPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStatusCheckPolicy to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptStatusCheckPolicy", d.Next())
	}
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptString", d.Next())
	}
}

// Encode encodes Team as json.
func (o OptTeam) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Team from json.
func (o *OptTeam) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeam to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeam", d.Next())
	}
}

// Encode encodes TeamFullPrivacy as json.
func (o OptTeamFullPrivacy) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamFullPrivacy from json.
func (o *OptTeamFullPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamFullPrivacy to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamFullPrivacy", d.Next())
	}
}

// Encode encodes TeamPermissions as json.
func (o OptTeamPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamPermissions from json.
func (o *OptTeamPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamPermissions", d.Next())
	}
}

// Encode encodes TeamRepositoryPermissions as json.
func (o OptTeamRepositoryPermissions) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamRepositoryPermissions from json.
func (o *OptTeamRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamRepositoryPermissions to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamRepositoryPermissions", d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateMembershipForUserInOrgReq as json.
func (o OptTeamsAddOrUpdateMembershipForUserInOrgReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgReq from json.
func (o *OptTeamsAddOrUpdateMembershipForUserInOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateMembershipForUserInOrgReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsAddOrUpdateMembershipForUserInOrgReq", d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateMembershipForUserInOrgReqRole as json.
func (o OptTeamsAddOrUpdateMembershipForUserInOrgReqRole) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgReqRole from json.
func (o *OptTeamsAddOrUpdateMembershipForUserInOrgReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateMembershipForUserInOrgReqRole to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsAddOrUpdateMembershipForUserInOrgReqRole", d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateMembershipForUserLegacyReq as json.
func (o OptTeamsAddOrUpdateMembershipForUserLegacyReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyReq from json.
func (o *OptTeamsAddOrUpdateMembershipForUserLegacyReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateMembershipForUserLegacyReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsAddOrUpdateMembershipForUserLegacyReq", d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateMembershipForUserLegacyReqRole as json.
func (o OptTeamsAddOrUpdateMembershipForUserLegacyReqRole) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyReqRole from json.
func (o *OptTeamsAddOrUpdateMembershipForUserLegacyReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateMembershipForUserLegacyReqRole to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsAddOrUpdateMembershipForUserLegacyReqRole", d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsInOrgReq as json.
func (o OptTeamsAddOrUpdateProjectPermissionsInOrgReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgReq from json.
func (o *OptTeamsAddOrUpdateProjectPermissionsInOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateProjectPermissionsInOrgReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsAddOrUpdateProjectPermissionsInOrgReq", d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission as json.
func (o OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission from json.
func (o *OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission", d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsLegacyReq as json.
func (o OptTeamsAddOrUpdateProjectPermissionsLegacyReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyReq from json.
func (o *OptTeamsAddOrUpdateProjectPermissionsLegacyReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateProjectPermissionsLegacyReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsAddOrUpdateProjectPermissionsLegacyReq", d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission as json.
func (o OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission from json.
func (o *OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission", d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsInOrgReq as json.
func (o OptTeamsAddOrUpdateRepoPermissionsInOrgReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgReq from json.
func (o *OptTeamsAddOrUpdateRepoPermissionsInOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateRepoPermissionsInOrgReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsAddOrUpdateRepoPermissionsInOrgReq", d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission as json.
func (o OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission from json.
func (o *OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission", d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsLegacyReq as json.
func (o OptTeamsAddOrUpdateRepoPermissionsLegacyReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyReq from json.
func (o *OptTeamsAddOrUpdateRepoPermissionsLegacyReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateRepoPermissionsLegacyReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsAddOrUpdateRepoPermissionsLegacyReq", d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission as json.
func (o OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission from json.
func (o *OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission", d.Next())
	}
}

// Encode encodes TeamsCreateReqPermission as json.
func (o OptTeamsCreateReqPermission) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsCreateReqPermission from json.
func (o *OptTeamsCreateReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsCreateReqPermission to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsCreateReqPermission", d.Next())
	}
}

// Encode encodes TeamsCreateReqPrivacy as json.
func (o OptTeamsCreateReqPrivacy) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsCreateReqPrivacy from json.
func (o *OptTeamsCreateReqPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsCreateReqPrivacy to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsCreateReqPrivacy", d.Next())
	}
}

// Encode encodes TeamsUpdateDiscussionInOrgReq as json.
func (o OptTeamsUpdateDiscussionInOrgReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsUpdateDiscussionInOrgReq from json.
func (o *OptTeamsUpdateDiscussionInOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsUpdateDiscussionInOrgReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsUpdateDiscussionInOrgReq", d.Next())
	}
}

// Encode encodes TeamsUpdateDiscussionLegacyReq as json.
func (o OptTeamsUpdateDiscussionLegacyReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsUpdateDiscussionLegacyReq from json.
func (o *OptTeamsUpdateDiscussionLegacyReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsUpdateDiscussionLegacyReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsUpdateDiscussionLegacyReq", d.Next())
	}
}

// Encode encodes TeamsUpdateInOrgReq as json.
func (o OptTeamsUpdateInOrgReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamsUpdateInOrgReq from json.
func (o *OptTeamsUpdateInOrgReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsUpdateInOrgReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsUpdateInOrgReq", d.Next())
	}
}

// Encode encodes TeamsUpdateInOrgReqPermission as json.
func (o OptTeamsUpdateInOrgReqPermission) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateInOrgReqPermission from json.
func (o *OptTeamsUpdateInOrgReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsUpdateInOrgReqPermission to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsUpdateInOrgReqPermission", d.Next())
	}
}

// Encode encodes TeamsUpdateInOrgReqPrivacy as json.
func (o OptTeamsUpdateInOrgReqPrivacy) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateInOrgReqPrivacy from json.
func (o *OptTeamsUpdateInOrgReqPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsUpdateInOrgReqPrivacy to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsUpdateInOrgReqPrivacy", d.Next())
	}
}

// Encode encodes TeamsUpdateLegacyReqPermission as json.
func (o OptTeamsUpdateLegacyReqPermission) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateLegacyReqPermission from json.
func (o *OptTeamsUpdateLegacyReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsUpdateLegacyReqPermission to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsUpdateLegacyReqPermission", d.Next())
	}
}

// Encode encodes TeamsUpdateLegacyReqPrivacy as json.
func (o OptTeamsUpdateLegacyReqPrivacy) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateLegacyReqPrivacy from json.
func (o *OptTeamsUpdateLegacyReqPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamsUpdateLegacyReqPrivacy to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTeamsUpdateLegacyReqPrivacy", d.Next())
	}
}

// Encode encodes time.Time as json.
func (o OptTime) Encode(e *jx.Writer, format func(*jx.Writer, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTime to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := format(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTime", d.Next())
	}
}

// Encode encodes TopicSearchResultItemAliasesItemTopicRelation as json.
func (o OptTopicSearchResultItemAliasesItemTopicRelation) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TopicSearchResultItemAliasesItemTopicRelation from json.
func (o *OptTopicSearchResultItemAliasesItemTopicRelation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTopicSearchResultItemAliasesItemTopicRelation to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTopicSearchResultItemAliasesItemTopicRelation", d.Next())
	}
}

// Encode encodes TopicSearchResultItemRelatedItemTopicRelation as json.
func (o OptTopicSearchResultItemRelatedItemTopicRelation) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TopicSearchResultItemRelatedItemTopicRelation from json.
func (o *OptTopicSearchResultItemRelatedItemTopicRelation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTopicSearchResultItemRelatedItemTopicRelation to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTopicSearchResultItemRelatedItemTopicRelation", d.Next())
	}
}

// Encode encodes url.URL as json.
func (o OptURL) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURL to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := json.DecodeURI(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptURL", d.Next())
	}
}

// Encode encodes UsersAddEmailForAuthenticatedReq as json.
func (o OptUsersAddEmailForAuthenticatedReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UsersAddEmailForAuthenticatedReq from json.
func (o *OptUsersAddEmailForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUsersAddEmailForAuthenticatedReq to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptUsersAddEmailForAuthenticatedReq", d.Next())
	}
}

// Encode encodes UsersDeleteEmailForAuthenticatedReq as json.
func (o OptUsersDeleteEmailForAuthenticatedReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UsersDeleteEmailForAuthenticatedReq from json.
func (o *OptUsersDeleteEmailForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUsersDeleteEmailForAuthenticatedReq to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptUsersDeleteEmailForAuthenticatedReq", d.Next())
	}
}

// Encode encodes UsersUpdateAuthenticatedReq as json.
func (o OptUsersUpdateAuthenticatedReq) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UsersUpdateAuthenticatedReq from json.
func (o *OptUsersUpdateAuthenticatedReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUsersUpdateAuthenticatedReq to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptUsersUpdateAuthenticatedReq", d.Next())
	}
}

// Encode encodes ValidationErrorErrorsItemValue as json.
func (o OptValidationErrorErrorsItemValue) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValidationErrorErrorsItemValue from json.
func (o *OptValidationErrorErrorsItemValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValidationErrorErrorsItemValue to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptValidationErrorErrorsItemValue", d.Next())
	}
}

// Encode encodes Verification as json.
func (o OptVerification) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Verification from json.
func (o *OptVerification) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVerification to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptVerification", d.Next())
	}
}

// Encode encodes WaitTimer as json.
func (o OptWaitTimer) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WaitTimer from json.
func (o *OptWaitTimer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWaitTimer to nil")
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptWaitTimer", d.Next())
	}
}

// Encode encodes WebhookConfigContentType as json.
func (o OptWebhookConfigContentType) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookConfigContentType from json.
func (o *OptWebhookConfigContentType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookConfigContentType to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptWebhookConfigContentType", d.Next())
	}
}

// Encode encodes WebhookConfigInsecureSsl as json.
func (o OptWebhookConfigInsecureSsl) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookConfigInsecureSsl from json.
func (o *OptWebhookConfigInsecureSsl) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookConfigInsecureSsl to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptWebhookConfigInsecureSsl", d.Next())
	}
}

// Encode encodes WebhookConfigSecret as json.
func (o OptWebhookConfigSecret) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookConfigSecret from json.
func (o *OptWebhookConfigSecret) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookConfigSecret to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptWebhookConfigSecret", d.Next())
	}
}

// Encode encodes WebhookConfigURL as json.
func (o OptWebhookConfigURL) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookConfigURL from json.
func (o *OptWebhookConfigURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookConfigURL to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptWebhookConfigURL", d.Next())
	}
}

// Encode encodes WorkflowRunUsageBillableMACOS as json.
func (o OptWorkflowRunUsageBillableMACOS) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorkflowRunUsageBillableMACOS from json.
func (o *OptWorkflowRunUsageBillableMACOS) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowRunUsageBillableMACOS to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptWorkflowRunUsageBillableMACOS", d.Next())
	}
}

// Encode encodes WorkflowRunUsageBillableUBUNTU as json.
func (o OptWorkflowRunUsageBillableUBUNTU) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorkflowRunUsageBillableUBUNTU from json.
func (o *OptWorkflowRunUsageBillableUBUNTU) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowRunUsageBillableUBUNTU to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptWorkflowRunUsageBillableUBUNTU", d.Next())
	}
}

// Encode encodes WorkflowRunUsageBillableWINDOWS as json.
func (o OptWorkflowRunUsageBillableWINDOWS) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorkflowRunUsageBillableWINDOWS from json.
func (o *OptWorkflowRunUsageBillableWINDOWS) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowRunUsageBillableWINDOWS to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptWorkflowRunUsageBillableWINDOWS", d.Next())
	}
}

// Encode implements json.Marshaler.
func (s OrgHook) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"ping_url\"" + ":")
		json.EncodeURI(e, s.PingURL)
	}
	{
		if s.DeliveriesURL.Set {
			e.Comma()
		}
		if s.DeliveriesURL.Set {
			e.RawStr("\"deliveries_url\"" + ":")
			s.DeliveriesURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"events\"" + ":")
		e.ArrStart()
		if len(s.Events) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Events[0]
				e.Str(elem)
			}
			for _, elem := range s.Events[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"active\"" + ":")
		e.Bool(s.Active)
	}
	{
		e.Comma()

		e.RawStr("\"config\"" + ":")
		s.Config.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrgHook = [11]string{
	0:  "id",
	1:  "url",
	2:  "ping_url",
	3:  "deliveries_url",
	4:  "name",
	5:  "events",
	6:  "active",
	7:  "config",
	8:  "updated_at",
	9:  "created_at",
	10: "type",
}

// Decode decodes OrgHook from json.
func (s *OrgHook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgHook to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "ping_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PingURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ping_url\"")
			}
		case "deliveries_url":
			if err := func() error {
				s.DeliveriesURL.Reset()
				if err := s.DeliveriesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deliveries_url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "events":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Events = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "active":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Active = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgHook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrgHook) {
					name = jsonFieldsNameOfOrgHook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgHookConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrgHookConfig = [4]string{
	0: "url",
	1: "insecure_ssl",
	2: "content_type",
	3: "secret",
}

// Decode decodes OrgHookConfig from json.
func (s *OrgHookConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgHookConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgHookConfig")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgMembership) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"role\"" + ":")
		s.Role.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"organization_url\"" + ":")
		json.EncodeURI(e, s.OrganizationURL)
	}
	{
		e.Comma()

		e.RawStr("\"organization\"" + ":")
		s.Organization.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrgMembership = [7]string{
	0: "url",
	1: "state",
	2: "role",
	3: "organization_url",
	4: "organization",
	5: "user",
	6: "permissions",
}

// Decode decodes OrgMembership from json.
func (s *OrgMembership) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgMembership to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "organization_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_url\"")
			}
		case "organization":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Organization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgMembership")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrgMembership) {
					name = jsonFieldsNameOfOrgMembership[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgMembershipPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"can_create_repository\"" + ":")
		e.Bool(s.CanCreateRepository)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrgMembershipPermissions = [1]string{
	0: "can_create_repository",
}

// Decode decodes OrgMembershipPermissions from json.
func (s *OrgMembershipPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgMembershipPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "can_create_repository":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CanCreateRepository = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_create_repository\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgMembershipPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrgMembershipPermissions) {
					name = jsonFieldsNameOfOrgMembershipPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes OrgMembershipRole as json.
func (s OrgMembershipRole) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgMembershipRole from json.
func (s *OrgMembershipRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgMembershipRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgMembershipRole(v) {
	case OrgMembershipRoleAdmin:
		*s = OrgMembershipRoleAdmin
	case OrgMembershipRoleMember:
		*s = OrgMembershipRoleMember
	case OrgMembershipRoleBillingManager:
		*s = OrgMembershipRoleBillingManager
	default:
		*s = OrgMembershipRole(v)
	}

	return nil
}

// Encode encodes OrgMembershipState as json.
func (s OrgMembershipState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgMembershipState from json.
func (s *OrgMembershipState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgMembershipState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgMembershipState(v) {
	case OrgMembershipStateActive:
		*s = OrgMembershipStateActive
	case OrgMembershipStatePending:
		*s = OrgMembershipStatePending
	default:
		*s = OrgMembershipState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrganizationActionsSecret) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"visibility\"" + ":")
		s.Visibility.Encode(e)
	}
	{
		if s.SelectedRepositoriesURL.Set {
			e.Comma()
		}
		if s.SelectedRepositoriesURL.Set {
			e.RawStr("\"selected_repositories_url\"" + ":")
			s.SelectedRepositoriesURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrganizationActionsSecret = [5]string{
	0: "name",
	1: "created_at",
	2: "updated_at",
	3: "visibility",
	4: "selected_repositories_url",
}

// Decode decodes OrganizationActionsSecret from json.
func (s *OrganizationActionsSecret) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationActionsSecret to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "visibility":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "selected_repositories_url":
			if err := func() error {
				s.SelectedRepositoriesURL.Reset()
				if err := s.SelectedRepositoriesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repositories_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganizationActionsSecret")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrganizationActionsSecret) {
					name = jsonFieldsNameOfOrganizationActionsSecret[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes OrganizationActionsSecretVisibility as json.
func (s OrganizationActionsSecretVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrganizationActionsSecretVisibility from json.
func (s *OrganizationActionsSecretVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationActionsSecretVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrganizationActionsSecretVisibility(v) {
	case OrganizationActionsSecretVisibilityAll:
		*s = OrganizationActionsSecretVisibilityAll
	case OrganizationActionsSecretVisibilityPrivate:
		*s = OrganizationActionsSecretVisibilityPrivate
	case OrganizationActionsSecretVisibilitySelected:
		*s = OrganizationActionsSecretVisibilitySelected
	default:
		*s = OrganizationActionsSecretVisibility(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrganizationFull) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		e.Str(s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"members_url\"" + ":")
		e.Str(s.MembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"public_members_url\"" + ":")
		e.Str(s.PublicMembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		e.Str(s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Company.Set {
			e.Comma()
		}
		if s.Company.Set {
			e.RawStr("\"company\"" + ":")
			s.Company.Encode(e)
		}
	}
	{
		if s.Blog.Set {
			e.Comma()
		}
		if s.Blog.Set {
			e.RawStr("\"blog\"" + ":")
			s.Blog.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.Comma()
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.Comma()
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.TwitterUsername.Set {
			e.Comma()
		}
		if s.TwitterUsername.Set {
			e.RawStr("\"twitter_username\"" + ":")
			s.TwitterUsername.Encode(e)
		}
	}
	{
		if s.IsVerified.Set {
			e.Comma()
		}
		if s.IsVerified.Set {
			e.RawStr("\"is_verified\"" + ":")
			s.IsVerified.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"has_organization_projects\"" + ":")
		e.Bool(s.HasOrganizationProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_repository_projects\"" + ":")
		e.Bool(s.HasRepositoryProjects)
	}
	{
		e.Comma()

		e.RawStr("\"public_repos\"" + ":")
		e.Int(s.PublicRepos)
	}
	{
		e.Comma()

		e.RawStr("\"public_gists\"" + ":")
		e.Int(s.PublicGists)
	}
	{
		e.Comma()

		e.RawStr("\"followers\"" + ":")
		e.Int(s.Followers)
	}
	{
		e.Comma()

		e.RawStr("\"following\"" + ":")
		e.Int(s.Following)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		if s.TotalPrivateRepos.Set {
			e.Comma()
		}
		if s.TotalPrivateRepos.Set {
			e.RawStr("\"total_private_repos\"" + ":")
			s.TotalPrivateRepos.Encode(e)
		}
	}
	{
		if s.OwnedPrivateRepos.Set {
			e.Comma()
		}
		if s.OwnedPrivateRepos.Set {
			e.RawStr("\"owned_private_repos\"" + ":")
			s.OwnedPrivateRepos.Encode(e)
		}
	}
	{
		if s.PrivateGists.Set {
			e.Comma()
		}
		if s.PrivateGists.Set {
			e.RawStr("\"private_gists\"" + ":")
			s.PrivateGists.Encode(e)
		}
	}
	{
		if s.DiskUsage.Set {
			e.Comma()
		}
		if s.DiskUsage.Set {
			e.RawStr("\"disk_usage\"" + ":")
			s.DiskUsage.Encode(e)
		}
	}
	{
		if s.Collaborators.Set {
			e.Comma()
		}
		if s.Collaborators.Set {
			e.RawStr("\"collaborators\"" + ":")
			s.Collaborators.Encode(e)
		}
	}
	{
		if s.BillingEmail.Set {
			e.Comma()
		}
		if s.BillingEmail.Set {
			e.RawStr("\"billing_email\"" + ":")
			s.BillingEmail.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.Comma()
		}
		if s.Plan.Set {
			e.RawStr("\"plan\"" + ":")
			s.Plan.Encode(e)
		}
	}
	{
		if s.DefaultRepositoryPermission.Set {
			e.Comma()
		}
		if s.DefaultRepositoryPermission.Set {
			e.RawStr("\"default_repository_permission\"" + ":")
			s.DefaultRepositoryPermission.Encode(e)
		}
	}
	{
		if s.MembersCanCreateRepositories.Set {
			e.Comma()
		}
		if s.MembersCanCreateRepositories.Set {
			e.RawStr("\"members_can_create_repositories\"" + ":")
			s.MembersCanCreateRepositories.Encode(e)
		}
	}
	{
		if s.TwoFactorRequirementEnabled.Set {
			e.Comma()
		}
		if s.TwoFactorRequirementEnabled.Set {
			e.RawStr("\"two_factor_requirement_enabled\"" + ":")
			s.TwoFactorRequirementEnabled.Encode(e)
		}
	}
	{
		if s.MembersAllowedRepositoryCreationType.Set {
			e.Comma()
		}
		if s.MembersAllowedRepositoryCreationType.Set {
			e.RawStr("\"members_allowed_repository_creation_type\"" + ":")
			s.MembersAllowedRepositoryCreationType.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePublicRepositories.Set {
			e.Comma()
		}
		if s.MembersCanCreatePublicRepositories.Set {
			e.RawStr("\"members_can_create_public_repositories\"" + ":")
			s.MembersCanCreatePublicRepositories.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePrivateRepositories.Set {
			e.Comma()
		}
		if s.MembersCanCreatePrivateRepositories.Set {
			e.RawStr("\"members_can_create_private_repositories\"" + ":")
			s.MembersCanCreatePrivateRepositories.Encode(e)
		}
	}
	{
		if s.MembersCanCreateInternalRepositories.Set {
			e.Comma()
		}
		if s.MembersCanCreateInternalRepositories.Set {
			e.RawStr("\"members_can_create_internal_repositories\"" + ":")
			s.MembersCanCreateInternalRepositories.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePages.Set {
			e.Comma()
		}
		if s.MembersCanCreatePages.Set {
			e.RawStr("\"members_can_create_pages\"" + ":")
			s.MembersCanCreatePages.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePublicPages.Set {
			e.Comma()
		}
		if s.MembersCanCreatePublicPages.Set {
			e.RawStr("\"members_can_create_public_pages\"" + ":")
			s.MembersCanCreatePublicPages.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePrivatePages.Set {
			e.Comma()
		}
		if s.MembersCanCreatePrivatePages.Set {
			e.RawStr("\"members_can_create_private_pages\"" + ":")
			s.MembersCanCreatePrivatePages.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrganizationFull = [46]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "url",
	4:  "repos_url",
	5:  "events_url",
	6:  "hooks_url",
	7:  "issues_url",
	8:  "members_url",
	9:  "public_members_url",
	10: "avatar_url",
	11: "description",
	12: "name",
	13: "company",
	14: "blog",
	15: "location",
	16: "email",
	17: "twitter_username",
	18: "is_verified",
	19: "has_organization_projects",
	20: "has_repository_projects",
	21: "public_repos",
	22: "public_gists",
	23: "followers",
	24: "following",
	25: "html_url",
	26: "created_at",
	27: "type",
	28: "total_private_repos",
	29: "owned_private_repos",
	30: "private_gists",
	31: "disk_usage",
	32: "collaborators",
	33: "billing_email",
	34: "plan",
	35: "default_repository_permission",
	36: "members_can_create_repositories",
	37: "two_factor_requirement_enabled",
	38: "members_allowed_repository_creation_type",
	39: "members_can_create_public_repositories",
	40: "members_can_create_private_repositories",
	41: "members_can_create_internal_repositories",
	42: "members_can_create_pages",
	43: "members_can_create_public_pages",
	44: "members_can_create_private_pages",
	45: "updated_at",
}

// Decode decodes OrganizationFull from json.
func (s *OrganizationFull) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationFull to nil")
	}
	var requiredBitSet [6]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "repos_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "hooks_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HooksURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "issues_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "members_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "public_members_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PublicMembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_members_url\"")
			}
		case "avatar_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AvatarURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "company":
			if err := func() error {
				s.Company.Reset()
				if err := s.Company.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"company\"")
			}
		case "blog":
			if err := func() error {
				s.Blog.Reset()
				if err := s.Blog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blog\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "twitter_username":
			if err := func() error {
				s.TwitterUsername.Reset()
				if err := s.TwitterUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"twitter_username\"")
			}
		case "is_verified":
			if err := func() error {
				s.IsVerified.Reset()
				if err := s.IsVerified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_verified\"")
			}
		case "has_organization_projects":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.HasOrganizationProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_organization_projects\"")
			}
		case "has_repository_projects":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasRepositoryProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_repository_projects\"")
			}
		case "public_repos":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.PublicRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_repos\"")
			}
		case "public_gists":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.PublicGists = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_gists\"")
			}
		case "followers":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Followers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers\"")
			}
		case "following":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Following = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following\"")
			}
		case "html_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "created_at":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "type":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "total_private_repos":
			if err := func() error {
				s.TotalPrivateRepos.Reset()
				if err := s.TotalPrivateRepos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_private_repos\"")
			}
		case "owned_private_repos":
			if err := func() error {
				s.OwnedPrivateRepos.Reset()
				if err := s.OwnedPrivateRepos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owned_private_repos\"")
			}
		case "private_gists":
			if err := func() error {
				s.PrivateGists.Reset()
				if err := s.PrivateGists.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private_gists\"")
			}
		case "disk_usage":
			if err := func() error {
				s.DiskUsage.Reset()
				if err := s.DiskUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk_usage\"")
			}
		case "collaborators":
			if err := func() error {
				s.Collaborators.Reset()
				if err := s.Collaborators.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators\"")
			}
		case "billing_email":
			if err := func() error {
				s.BillingEmail.Reset()
				if err := s.BillingEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billing_email\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "default_repository_permission":
			if err := func() error {
				s.DefaultRepositoryPermission.Reset()
				if err := s.DefaultRepositoryPermission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_repository_permission\"")
			}
		case "members_can_create_repositories":
			if err := func() error {
				s.MembersCanCreateRepositories.Reset()
				if err := s.MembersCanCreateRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_repositories\"")
			}
		case "two_factor_requirement_enabled":
			if err := func() error {
				s.TwoFactorRequirementEnabled.Reset()
				if err := s.TwoFactorRequirementEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"two_factor_requirement_enabled\"")
			}
		case "members_allowed_repository_creation_type":
			if err := func() error {
				s.MembersAllowedRepositoryCreationType.Reset()
				if err := s.MembersAllowedRepositoryCreationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_allowed_repository_creation_type\"")
			}
		case "members_can_create_public_repositories":
			if err := func() error {
				s.MembersCanCreatePublicRepositories.Reset()
				if err := s.MembersCanCreatePublicRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_public_repositories\"")
			}
		case "members_can_create_private_repositories":
			if err := func() error {
				s.MembersCanCreatePrivateRepositories.Reset()
				if err := s.MembersCanCreatePrivateRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_private_repositories\"")
			}
		case "members_can_create_internal_repositories":
			if err := func() error {
				s.MembersCanCreateInternalRepositories.Reset()
				if err := s.MembersCanCreateInternalRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_internal_repositories\"")
			}
		case "members_can_create_pages":
			if err := func() error {
				s.MembersCanCreatePages.Reset()
				if err := s.MembersCanCreatePages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_pages\"")
			}
		case "members_can_create_public_pages":
			if err := func() error {
				s.MembersCanCreatePublicPages.Reset()
				if err := s.MembersCanCreatePublicPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_public_pages\"")
			}
		case "members_can_create_private_pages":
			if err := func() error {
				s.MembersCanCreatePrivatePages.Reset()
				if err := s.MembersCanCreatePrivatePages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_private_pages\"")
			}
		case "updated_at":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganizationFull")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [6]uint8{
		0b11111111,
		0b00001111,
		0b11111000,
		0b00001111,
		0b00000000,
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrganizationFull) {
					name = jsonFieldsNameOfOrganizationFull[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrganizationFullPlan) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"space\"" + ":")
		e.Int(s.Space)
	}
	{
		e.Comma()

		e.RawStr("\"private_repos\"" + ":")
		e.Int(s.PrivateRepos)
	}
	{
		if s.FilledSeats.Set {
			e.Comma()
		}
		if s.FilledSeats.Set {
			e.RawStr("\"filled_seats\"" + ":")
			s.FilledSeats.Encode(e)
		}
	}
	{
		if s.Seats.Set {
			e.Comma()
		}
		if s.Seats.Set {
			e.RawStr("\"seats\"" + ":")
			s.Seats.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrganizationFullPlan = [5]string{
	0: "name",
	1: "space",
	2: "private_repos",
	3: "filled_seats",
	4: "seats",
}

// Decode decodes OrganizationFullPlan from json.
func (s *OrganizationFullPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationFullPlan to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "space":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Space = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"space\"")
			}
		case "private_repos":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.PrivateRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private_repos\"")
			}
		case "filled_seats":
			if err := func() error {
				s.FilledSeats.Reset()
				if err := s.FilledSeats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filled_seats\"")
			}
		case "seats":
			if err := func() error {
				s.Seats.Reset()
				if err := s.Seats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganizationFullPlan")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrganizationFullPlan) {
					name = jsonFieldsNameOfOrganizationFullPlan[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrganizationInvitation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		s.Login.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		s.Email.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"role\"" + ":")
		e.Str(s.Role)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		e.Str(s.CreatedAt)
	}
	{
		if s.FailedAt.Set {
			e.Comma()
		}
		if s.FailedAt.Set {
			e.RawStr("\"failed_at\"" + ":")
			s.FailedAt.Encode(e)
		}
	}
	{
		if s.FailedReason.Set {
			e.Comma()
		}
		if s.FailedReason.Set {
			e.RawStr("\"failed_reason\"" + ":")
			s.FailedReason.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"inviter\"" + ":")
		s.Inviter.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"team_count\"" + ":")
		e.Int(s.TeamCount)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"invitation_teams_url\"" + ":")
		e.Str(s.InvitationTeamsURL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrganizationInvitation = [11]string{
	0:  "id",
	1:  "login",
	2:  "email",
	3:  "role",
	4:  "created_at",
	5:  "failed_at",
	6:  "failed_reason",
	7:  "inviter",
	8:  "team_count",
	9:  "node_id",
	10: "invitation_teams_url",
}

// Decode decodes OrganizationInvitation from json.
func (s *OrganizationInvitation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationInvitation to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "login":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Role = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "failed_at":
			if err := func() error {
				s.FailedAt.Reset()
				if err := s.FailedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_at\"")
			}
		case "failed_reason":
			if err := func() error {
				s.FailedReason.Reset()
				if err := s.FailedReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_reason\"")
			}
		case "inviter":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Inviter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inviter\"")
			}
		case "team_count":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TeamCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_count\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "invitation_teams_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.InvitationTeamsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invitation_teams_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganizationInvitation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10011111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrganizationInvitation) {
					name = jsonFieldsNameOfOrganizationInvitation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrganizationSecretScanningAlert) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Number.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Number.Set {
			e.RawStr("\"number\"" + ":")
			s.Number.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.LocationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LocationsURL.Set {
			e.RawStr("\"locations_url\"" + ":")
			s.LocationsURL.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.Resolution.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resolution.Set {
			e.RawStr("\"resolution\"" + ":")
			s.Resolution.Encode(e)
		}
	}
	{
		if s.ResolvedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResolvedAt.Set {
			e.RawStr("\"resolved_at\"" + ":")
			s.ResolvedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ResolvedBy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResolvedBy.Set {
			e.RawStr("\"resolved_by\"" + ":")
			s.ResolvedBy.Encode(e)
		}
	}
	{
		if s.SecretType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretType.Set {
			e.RawStr("\"secret_type\"" + ":")
			s.SecretType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Repository.Set {
			e.RawStr("\"repository\"" + ":")
			s.Repository.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrganizationSecretScanningAlert = [12]string{
	0:  "number",
	1:  "created_at",
	2:  "url",
	3:  "html_url",
	4:  "locations_url",
	5:  "state",
	6:  "resolution",
	7:  "resolved_at",
	8:  "resolved_by",
	9:  "secret_type",
	10: "secret",
	11: "repository",
}

// Decode decodes OrganizationSecretScanningAlert from json.
func (s *OrganizationSecretScanningAlert) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationSecretScanningAlert to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			if err := func() error {
				s.Number.Reset()
				if err := s.Number.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "locations_url":
			if err := func() error {
				s.LocationsURL.Reset()
				if err := s.LocationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locations_url\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "resolution":
			if err := func() error {
				s.Resolution.Reset()
				if err := s.Resolution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolution\"")
			}
		case "resolved_at":
			if err := func() error {
				s.ResolvedAt.Reset()
				if err := s.ResolvedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolved_at\"")
			}
		case "resolved_by":
			if err := func() error {
				s.ResolvedBy.Reset()
				if err := s.ResolvedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolved_by\"")
			}
		case "secret_type":
			if err := func() error {
				s.SecretType.Reset()
				if err := s.SecretType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "repository":
			if err := func() error {
				s.Repository.Reset()
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganizationSecretScanningAlert")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrganizationSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		e.Str(s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"members_url\"" + ":")
		e.Str(s.MembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"public_members_url\"" + ":")
		e.Str(s.PublicMembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		e.Str(s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrganizationSimple = [12]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "url",
	4:  "repos_url",
	5:  "events_url",
	6:  "hooks_url",
	7:  "issues_url",
	8:  "members_url",
	9:  "public_members_url",
	10: "avatar_url",
	11: "description",
}

// Decode decodes OrganizationSimple from json.
func (s *OrganizationSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganizationSimple to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "repos_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "hooks_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HooksURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "issues_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "members_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "public_members_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PublicMembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_members_url\"")
			}
		case "avatar_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AvatarURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganizationSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrganizationSimple) {
					name = jsonFieldsNameOfOrganizationSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgsConvertMemberToOutsideCollaboratorAccepted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrgsConvertMemberToOutsideCollaboratorAccepted = [0]string{}

// Decode decodes OrgsConvertMemberToOutsideCollaboratorAccepted from json.
func (s OrgsConvertMemberToOutsideCollaboratorAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsConvertMemberToOutsideCollaboratorAccepted to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsConvertMemberToOutsideCollaboratorAccepted")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgsCreateInvitationReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.InviteeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InviteeID.Set {
			e.RawStr("\"invitee_id\"" + ":")
			s.InviteeID.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Role.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Role.Set {
			e.RawStr("\"role\"" + ":")
			s.Role.Encode(e)
		}
	}
	{
		if s.TeamIds != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TeamIds != nil {
			e.RawStr("\"team_ids\"" + ":")
			e.ArrStart()
			if len(s.TeamIds) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TeamIds[0]
					e.Int(elem)
				}
				for _, elem := range s.TeamIds[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrgsCreateInvitationReq = [4]string{
	0: "invitee_id",
	1: "email",
	2: "role",
	3: "team_ids",
}

// Decode decodes OrgsCreateInvitationReq from json.
func (s *OrgsCreateInvitationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsCreateInvitationReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "invitee_id":
			if err := func() error {
				s.InviteeID.Reset()
				if err := s.InviteeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invitee_id\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "team_ids":
			if err := func() error {
				s.TeamIds = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.TeamIds = append(s.TeamIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsCreateInvitationReq")
	}

	return nil
}

// Encode encodes OrgsCreateInvitationReqRole as json.
func (s OrgsCreateInvitationReqRole) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsCreateInvitationReqRole from json.
func (s *OrgsCreateInvitationReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsCreateInvitationReqRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsCreateInvitationReqRole(v) {
	case OrgsCreateInvitationReqRoleAdmin:
		*s = OrgsCreateInvitationReqRoleAdmin
	case OrgsCreateInvitationReqRoleDirectMember:
		*s = OrgsCreateInvitationReqRoleDirectMember
	case OrgsCreateInvitationReqRoleBillingManager:
		*s = OrgsCreateInvitationReqRoleBillingManager
	default:
		*s = OrgsCreateInvitationReqRole(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgsCreateWebhookReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"config\"" + ":")
		s.Config.Encode(e)
	}
	{
		if s.Events != nil {
			e.Comma()
		}
		if s.Events != nil {
			e.RawStr("\"events\"" + ":")
			e.ArrStart()
			if len(s.Events) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Events[0]
					e.Str(elem)
				}
				for _, elem := range s.Events[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.Comma()
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrgsCreateWebhookReq = [4]string{
	0: "name",
	1: "config",
	2: "events",
	3: "active",
}

// Decode decodes OrgsCreateWebhookReq from json.
func (s *OrgsCreateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsCreateWebhookReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "events":
			if err := func() error {
				s.Events = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsCreateWebhookReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrgsCreateWebhookReq) {
					name = jsonFieldsNameOfOrgsCreateWebhookReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgsCreateWebhookReqConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		if s.ContentType.Set {
			e.Comma()
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.Comma()
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.Comma()
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.Comma()
		}
		if s.Username.Set {
			e.RawStr("\"username\"" + ":")
			s.Username.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.Comma()
		}
		if s.Password.Set {
			e.RawStr("\"password\"" + ":")
			s.Password.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrgsCreateWebhookReqConfig = [6]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
	4: "username",
	5: "password",
}

// Decode decodes OrgsCreateWebhookReqConfig from json.
func (s *OrgsCreateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsCreateWebhookReqConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				{
					var unwrapped url.URL
					v, err := json.DecodeURI(d)
					unwrapped = v
					if err != nil {
						return err
					}
					s.URL = WebhookConfigURL(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsCreateWebhookReqConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrgsCreateWebhookReqConfig) {
					name = jsonFieldsNameOfOrgsCreateWebhookReqConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden as json.
func (s OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden from json.
func (s *OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound as json.
func (s OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound from json.
func (s *OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes OrgsGetMembershipForUserApplicationJSONForbidden as json.
func (s OrgsGetMembershipForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForUserApplicationJSONForbidden from json.
func (s *OrgsGetMembershipForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsGetMembershipForUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsGetMembershipForUserApplicationJSONNotFound as json.
func (s OrgsGetMembershipForUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForUserApplicationJSONNotFound from json.
func (s *OrgsGetMembershipForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsGetMembershipForUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes OrgsListBlockedUsersOKApplicationJSON as json.
func (s OrgsListBlockedUsersOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListBlockedUsersOKApplicationJSON from json.
func (s *OrgsListBlockedUsersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListBlockedUsersOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListBlockedUsersOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListFailedInvitationsOKApplicationJSON as json.
func (s OrgsListFailedInvitationsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []OrganizationInvitation(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListFailedInvitationsOKApplicationJSON from json.
func (s *OrgsListFailedInvitationsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListFailedInvitationsOKApplicationJSON to nil")
	}
	var unwrapped []OrganizationInvitation
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationInvitation
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListFailedInvitationsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListForAuthenticatedUserApplicationJSONForbidden as json.
func (s OrgsListForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsListForAuthenticatedUserApplicationJSONForbidden from json.
func (s *OrgsListForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsListForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s OrgsListForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsListForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *OrgsListForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OrgsListForAuthenticatedUserOKApplicationJSON as json.
func (s OrgsListForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []OrganizationSimple(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListForAuthenticatedUserOKApplicationJSON from json.
func (s *OrgsListForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListForAuthenticatedUserOKApplicationJSON to nil")
	}
	var unwrapped []OrganizationSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListInvitationTeamsOKApplicationJSON as json.
func (s OrgsListInvitationTeamsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Team(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListInvitationTeamsOKApplicationJSON from json.
func (s *OrgsListInvitationTeamsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListInvitationTeamsOKApplicationJSON to nil")
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListInvitationTeamsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListMembersOKApplicationJSON as json.
func (s OrgsListMembersOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListMembersOKApplicationJSON from json.
func (s *OrgsListMembersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListMembersOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListMembersOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListMembershipsForAuthenticatedUserApplicationJSONForbidden as json.
func (s OrgsListMembershipsForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsListMembershipsForAuthenticatedUserApplicationJSONForbidden from json.
func (s *OrgsListMembershipsForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListMembershipsForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListMembershipsForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsListMembershipsForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s OrgsListMembershipsForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsListMembershipsForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *OrgsListMembershipsForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListMembershipsForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListMembershipsForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OrgsListMembershipsForAuthenticatedUserOKApplicationJSON as json.
func (s OrgsListMembershipsForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []OrgMembership(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListMembershipsForAuthenticatedUserOKApplicationJSON from json.
func (s *OrgsListMembershipsForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListMembershipsForAuthenticatedUserOKApplicationJSON to nil")
	}
	var unwrapped []OrgMembership
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrgMembership
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListMembershipsForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListOKApplicationJSON as json.
func (s OrgsListOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []OrganizationSimple(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListOKApplicationJSON from json.
func (s *OrgsListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListOKApplicationJSON to nil")
	}
	var unwrapped []OrganizationSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListPendingInvitationsOKApplicationJSON as json.
func (s OrgsListPendingInvitationsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []OrganizationInvitation(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListPendingInvitationsOKApplicationJSON from json.
func (s *OrgsListPendingInvitationsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListPendingInvitationsOKApplicationJSON to nil")
	}
	var unwrapped []OrganizationInvitation
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationInvitation
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListPendingInvitationsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListWebhookDeliveriesOKApplicationJSON as json.
func (s OrgsListWebhookDeliveriesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []HookDeliveryItem(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListWebhookDeliveriesOKApplicationJSON from json.
func (s *OrgsListWebhookDeliveriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListWebhookDeliveriesOKApplicationJSON to nil")
	}
	var unwrapped []HookDeliveryItem
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HookDeliveryItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListWebhookDeliveriesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListWebhooksOKApplicationJSON as json.
func (s OrgsListWebhooksOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []OrgHook(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes OrgsListWebhooksOKApplicationJSON from json.
func (s *OrgsListWebhooksOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsListWebhooksOKApplicationJSON to nil")
	}
	var unwrapped []OrgHook
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrgHook
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListWebhooksOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsRemoveMembershipForUserApplicationJSONForbidden as json.
func (s OrgsRemoveMembershipForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsRemoveMembershipForUserApplicationJSONForbidden from json.
func (s *OrgsRemoveMembershipForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsRemoveMembershipForUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsRemoveMembershipForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsRemoveMembershipForUserApplicationJSONNotFound as json.
func (s OrgsRemoveMembershipForUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsRemoveMembershipForUserApplicationJSONNotFound from json.
func (s *OrgsRemoveMembershipForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsRemoveMembershipForUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsRemoveMembershipForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OrgsRemoveOutsideCollaboratorUnprocessableEntity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrgsRemoveOutsideCollaboratorUnprocessableEntity = [2]string{
	0: "message",
	1: "documentation_url",
}

// Decode decodes OrgsRemoveOutsideCollaboratorUnprocessableEntity from json.
func (s *OrgsRemoveOutsideCollaboratorUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsRemoveOutsideCollaboratorUnprocessableEntity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsRemoveOutsideCollaboratorUnprocessableEntity")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgsSetMembershipForUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Role.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Role.Set {
			e.RawStr("\"role\"" + ":")
			s.Role.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrgsSetMembershipForUserReq = [1]string{
	0: "role",
}

// Decode decodes OrgsSetMembershipForUserReq from json.
func (s *OrgsSetMembershipForUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsSetMembershipForUserReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsSetMembershipForUserReq")
	}

	return nil
}

// Encode encodes OrgsSetMembershipForUserReqRole as json.
func (s OrgsSetMembershipForUserReqRole) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsSetMembershipForUserReqRole from json.
func (s *OrgsSetMembershipForUserReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsSetMembershipForUserReqRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsSetMembershipForUserReqRole(v) {
	case OrgsSetMembershipForUserReqRoleAdmin:
		*s = OrgsSetMembershipForUserReqRoleAdmin
	case OrgsSetMembershipForUserReqRoleMember:
		*s = OrgsSetMembershipForUserReqRoleMember
	default:
		*s = OrgsSetMembershipForUserReqRole(v)
	}

	return nil
}

// Encode encodes OrgsUpdateMembershipForAuthenticatedUserApplicationJSONForbidden as json.
func (s OrgsUpdateMembershipForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsUpdateMembershipForAuthenticatedUserApplicationJSONForbidden from json.
func (s *OrgsUpdateMembershipForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateMembershipForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsUpdateMembershipForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsUpdateMembershipForAuthenticatedUserApplicationJSONNotFound as json.
func (s OrgsUpdateMembershipForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsUpdateMembershipForAuthenticatedUserApplicationJSONNotFound from json.
func (s *OrgsUpdateMembershipForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateMembershipForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsUpdateMembershipForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OrgsUpdateMembershipForAuthenticatedUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrgsUpdateMembershipForAuthenticatedUserReq = [1]string{
	0: "state",
}

// Decode decodes OrgsUpdateMembershipForAuthenticatedUserReq from json.
func (s *OrgsUpdateMembershipForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateMembershipForAuthenticatedUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsUpdateMembershipForAuthenticatedUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrgsUpdateMembershipForAuthenticatedUserReq) {
					name = jsonFieldsNameOfOrgsUpdateMembershipForAuthenticatedUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes OrgsUpdateMembershipForAuthenticatedUserReqState as json.
func (s OrgsUpdateMembershipForAuthenticatedUserReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsUpdateMembershipForAuthenticatedUserReqState from json.
func (s *OrgsUpdateMembershipForAuthenticatedUserReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateMembershipForAuthenticatedUserReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsUpdateMembershipForAuthenticatedUserReqState(v) {
	case OrgsUpdateMembershipForAuthenticatedUserReqStateActive:
		*s = OrgsUpdateMembershipForAuthenticatedUserReqStateActive
	default:
		*s = OrgsUpdateMembershipForAuthenticatedUserReqState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgsUpdateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.BillingEmail.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BillingEmail.Set {
			e.RawStr("\"billing_email\"" + ":")
			s.BillingEmail.Encode(e)
		}
	}
	{
		if s.Company.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Company.Set {
			e.RawStr("\"company\"" + ":")
			s.Company.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.TwitterUsername.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TwitterUsername.Set {
			e.RawStr("\"twitter_username\"" + ":")
			s.TwitterUsername.Encode(e)
		}
	}
	{
		if s.Location.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.HasOrganizationProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasOrganizationProjects.Set {
			e.RawStr("\"has_organization_projects\"" + ":")
			s.HasOrganizationProjects.Encode(e)
		}
	}
	{
		if s.HasRepositoryProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasRepositoryProjects.Set {
			e.RawStr("\"has_repository_projects\"" + ":")
			s.HasRepositoryProjects.Encode(e)
		}
	}
	{
		if s.DefaultRepositoryPermission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultRepositoryPermission.Set {
			e.RawStr("\"default_repository_permission\"" + ":")
			s.DefaultRepositoryPermission.Encode(e)
		}
	}
	{
		if s.MembersCanCreateRepositories.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersCanCreateRepositories.Set {
			e.RawStr("\"members_can_create_repositories\"" + ":")
			s.MembersCanCreateRepositories.Encode(e)
		}
	}
	{
		if s.MembersCanCreateInternalRepositories.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersCanCreateInternalRepositories.Set {
			e.RawStr("\"members_can_create_internal_repositories\"" + ":")
			s.MembersCanCreateInternalRepositories.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePrivateRepositories.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersCanCreatePrivateRepositories.Set {
			e.RawStr("\"members_can_create_private_repositories\"" + ":")
			s.MembersCanCreatePrivateRepositories.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePublicRepositories.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersCanCreatePublicRepositories.Set {
			e.RawStr("\"members_can_create_public_repositories\"" + ":")
			s.MembersCanCreatePublicRepositories.Encode(e)
		}
	}
	{
		if s.MembersAllowedRepositoryCreationType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersAllowedRepositoryCreationType.Set {
			e.RawStr("\"members_allowed_repository_creation_type\"" + ":")
			s.MembersAllowedRepositoryCreationType.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersCanCreatePages.Set {
			e.RawStr("\"members_can_create_pages\"" + ":")
			s.MembersCanCreatePages.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePublicPages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersCanCreatePublicPages.Set {
			e.RawStr("\"members_can_create_public_pages\"" + ":")
			s.MembersCanCreatePublicPages.Encode(e)
		}
	}
	{
		if s.MembersCanCreatePrivatePages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MembersCanCreatePrivatePages.Set {
			e.RawStr("\"members_can_create_private_pages\"" + ":")
			s.MembersCanCreatePrivatePages.Encode(e)
		}
	}
	{
		if s.Blog.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Blog.Set {
			e.RawStr("\"blog\"" + ":")
			s.Blog.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrgsUpdateReq = [19]string{
	0:  "billing_email",
	1:  "company",
	2:  "email",
	3:  "twitter_username",
	4:  "location",
	5:  "name",
	6:  "description",
	7:  "has_organization_projects",
	8:  "has_repository_projects",
	9:  "default_repository_permission",
	10: "members_can_create_repositories",
	11: "members_can_create_internal_repositories",
	12: "members_can_create_private_repositories",
	13: "members_can_create_public_repositories",
	14: "members_allowed_repository_creation_type",
	15: "members_can_create_pages",
	16: "members_can_create_public_pages",
	17: "members_can_create_private_pages",
	18: "blog",
}

// Decode decodes OrgsUpdateReq from json.
func (s *OrgsUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billing_email":
			if err := func() error {
				s.BillingEmail.Reset()
				if err := s.BillingEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billing_email\"")
			}
		case "company":
			if err := func() error {
				s.Company.Reset()
				if err := s.Company.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"company\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "twitter_username":
			if err := func() error {
				s.TwitterUsername.Reset()
				if err := s.TwitterUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"twitter_username\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "has_organization_projects":
			if err := func() error {
				s.HasOrganizationProjects.Reset()
				if err := s.HasOrganizationProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_organization_projects\"")
			}
		case "has_repository_projects":
			if err := func() error {
				s.HasRepositoryProjects.Reset()
				if err := s.HasRepositoryProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_repository_projects\"")
			}
		case "default_repository_permission":
			if err := func() error {
				s.DefaultRepositoryPermission.Reset()
				if err := s.DefaultRepositoryPermission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_repository_permission\"")
			}
		case "members_can_create_repositories":
			if err := func() error {
				s.MembersCanCreateRepositories.Reset()
				if err := s.MembersCanCreateRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_repositories\"")
			}
		case "members_can_create_internal_repositories":
			if err := func() error {
				s.MembersCanCreateInternalRepositories.Reset()
				if err := s.MembersCanCreateInternalRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_internal_repositories\"")
			}
		case "members_can_create_private_repositories":
			if err := func() error {
				s.MembersCanCreatePrivateRepositories.Reset()
				if err := s.MembersCanCreatePrivateRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_private_repositories\"")
			}
		case "members_can_create_public_repositories":
			if err := func() error {
				s.MembersCanCreatePublicRepositories.Reset()
				if err := s.MembersCanCreatePublicRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_public_repositories\"")
			}
		case "members_allowed_repository_creation_type":
			if err := func() error {
				s.MembersAllowedRepositoryCreationType.Reset()
				if err := s.MembersAllowedRepositoryCreationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_allowed_repository_creation_type\"")
			}
		case "members_can_create_pages":
			if err := func() error {
				s.MembersCanCreatePages.Reset()
				if err := s.MembersCanCreatePages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_pages\"")
			}
		case "members_can_create_public_pages":
			if err := func() error {
				s.MembersCanCreatePublicPages.Reset()
				if err := s.MembersCanCreatePublicPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_public_pages\"")
			}
		case "members_can_create_private_pages":
			if err := func() error {
				s.MembersCanCreatePrivatePages.Reset()
				if err := s.MembersCanCreatePrivatePages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_can_create_private_pages\"")
			}
		case "blog":
			if err := func() error {
				s.Blog.Reset()
				if err := s.Blog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blog\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsUpdateReq")
	}

	return nil
}

// Encode encodes OrgsUpdateReqDefaultRepositoryPermission as json.
func (s OrgsUpdateReqDefaultRepositoryPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsUpdateReqDefaultRepositoryPermission from json.
func (s *OrgsUpdateReqDefaultRepositoryPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateReqDefaultRepositoryPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsUpdateReqDefaultRepositoryPermission(v) {
	case OrgsUpdateReqDefaultRepositoryPermissionRead:
		*s = OrgsUpdateReqDefaultRepositoryPermissionRead
	case OrgsUpdateReqDefaultRepositoryPermissionWrite:
		*s = OrgsUpdateReqDefaultRepositoryPermissionWrite
	case OrgsUpdateReqDefaultRepositoryPermissionAdmin:
		*s = OrgsUpdateReqDefaultRepositoryPermissionAdmin
	case OrgsUpdateReqDefaultRepositoryPermissionNone:
		*s = OrgsUpdateReqDefaultRepositoryPermissionNone
	default:
		*s = OrgsUpdateReqDefaultRepositoryPermission(v)
	}

	return nil
}

// Encode encodes OrgsUpdateReqMembersAllowedRepositoryCreationType as json.
func (s OrgsUpdateReqMembersAllowedRepositoryCreationType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrgsUpdateReqMembersAllowedRepositoryCreationType from json.
func (s *OrgsUpdateReqMembersAllowedRepositoryCreationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateReqMembersAllowedRepositoryCreationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrgsUpdateReqMembersAllowedRepositoryCreationType(v) {
	case OrgsUpdateReqMembersAllowedRepositoryCreationTypeAll:
		*s = OrgsUpdateReqMembersAllowedRepositoryCreationTypeAll
	case OrgsUpdateReqMembersAllowedRepositoryCreationTypePrivate:
		*s = OrgsUpdateReqMembersAllowedRepositoryCreationTypePrivate
	case OrgsUpdateReqMembersAllowedRepositoryCreationTypeNone:
		*s = OrgsUpdateReqMembersAllowedRepositoryCreationTypeNone
	default:
		*s = OrgsUpdateReqMembersAllowedRepositoryCreationType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgsUpdateWebhookConfigForOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		{
			if s.URL.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.URL.Set {
				e.RawStr("\"url\"" + ":")
				s.URL.Encode(e)
			}
		}
		{
			if s.ContentType.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.ContentType.Set {
				e.RawStr("\"content_type\"" + ":")
				s.ContentType.Encode(e)
			}
		}
		{
			if s.Secret.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Secret.Set {
				e.RawStr("\"secret\"" + ":")
				s.Secret.Encode(e)
			}
		}
		{
			if s.InsecureSsl.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.InsecureSsl.Set {
				e.RawStr("\"insecure_ssl\"" + ":")
				s.InsecureSsl.Encode(e)
			}
		}
	}
	for k, elem := range s.AdditionalProps {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrgsUpdateWebhookConfigForOrgReq = [4]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
}

// Decode decodes OrgsUpdateWebhookConfigForOrgReq from json.
func (s *OrgsUpdateWebhookConfigForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateWebhookConfigForOrgReq to nil")
	}

	m := s.AdditionalProps
	if m == nil {
		m = map[string]jx.Raw{}
		s.AdditionalProps = m
	}
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsUpdateWebhookConfigForOrgReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgsUpdateWebhookReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Config.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Config.Set {
			e.RawStr("\"config\"" + ":")
			s.Config.Encode(e)
		}
	}
	{
		if s.Events != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Events != nil {
			e.RawStr("\"events\"" + ":")
			e.ArrStart()
			if len(s.Events) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Events[0]
					e.Str(elem)
				}
				for _, elem := range s.Events[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrgsUpdateWebhookReq = [4]string{
	0: "config",
	1: "events",
	2: "active",
	3: "name",
}

// Decode decodes OrgsUpdateWebhookReq from json.
func (s *OrgsUpdateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateWebhookReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			if err := func() error {
				s.Config.Reset()
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "events":
			if err := func() error {
				s.Events = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsUpdateWebhookReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrgsUpdateWebhookReqConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		if s.ContentType.Set {
			e.Comma()
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.Comma()
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.Comma()
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrgsUpdateWebhookReqConfig = [4]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
}

// Decode decodes OrgsUpdateWebhookReqConfig from json.
func (s *OrgsUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrgsUpdateWebhookReqConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				{
					var unwrapped url.URL
					v, err := json.DecodeURI(d)
					unwrapped = v
					if err != nil {
						return err
					}
					s.URL = WebhookConfigURL(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrgsUpdateWebhookReqConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrgsUpdateWebhookReqConfig) {
					name = jsonFieldsNameOfOrgsUpdateWebhookReqConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Package) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"package_type\"" + ":")
		s.PackageType.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		e.Str(s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"version_count\"" + ":")
		e.Int(s.VersionCount)
	}
	{
		e.Comma()

		e.RawStr("\"visibility\"" + ":")
		s.Visibility.Encode(e)
	}
	{
		if s.Owner.Set {
			e.Comma()
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Repository.Set {
			e.Comma()
		}
		if s.Repository.Set {
			e.RawStr("\"repository\"" + ":")
			s.Repository.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPackage = [11]string{
	0:  "id",
	1:  "name",
	2:  "package_type",
	3:  "url",
	4:  "html_url",
	5:  "version_count",
	6:  "visibility",
	7:  "owner",
	8:  "repository",
	9:  "created_at",
	10: "updated_at",
}

// Decode decodes Package from json.
func (s *Package) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Package to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "package_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PackageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"package_type\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.HTMLURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "version_count":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.VersionCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_count\"")
			}
		case "visibility":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "repository":
			if err := func() error {
				s.Repository.Reset()
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Package")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPackage) {
					name = jsonFieldsNameOfPackage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PackagePackageType as json.
func (s PackagePackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackagePackageType from json.
func (s *PackagePackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagePackageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackagePackageType(v) {
	case PackagePackageTypeNpm:
		*s = PackagePackageTypeNpm
	case PackagePackageTypeMaven:
		*s = PackagePackageTypeMaven
	case PackagePackageTypeRubygems:
		*s = PackagePackageTypeRubygems
	case PackagePackageTypeDocker:
		*s = PackagePackageTypeDocker
	case PackagePackageTypeNuget:
		*s = PackagePackageTypeNuget
	case PackagePackageTypeContainer:
		*s = PackagePackageTypeContainer
	default:
		*s = PackagePackageType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PackageVersion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"package_html_url\"" + ":")
		e.Str(s.PackageHTMLURL)
	}
	{
		if s.HTMLURL.Set {
			e.Comma()
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.License.Set {
			e.Comma()
		}
		if s.License.Set {
			e.RawStr("\"license\"" + ":")
			s.License.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.DeletedAt.Set {
			e.Comma()
		}
		if s.DeletedAt.Set {
			e.RawStr("\"deleted_at\"" + ":")
			s.DeletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Metadata.Set {
			e.Comma()
		}
		if s.Metadata.Set {
			e.RawStr("\"metadata\"" + ":")
			s.Metadata.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPackageVersion = [11]string{
	0:  "id",
	1:  "name",
	2:  "url",
	3:  "package_html_url",
	4:  "html_url",
	5:  "license",
	6:  "description",
	7:  "created_at",
	8:  "updated_at",
	9:  "deleted_at",
	10: "metadata",
}

// Decode decodes PackageVersion from json.
func (s *PackageVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackageVersion to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "package_html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.PackageHTMLURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"package_html_url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "license":
			if err := func() error {
				s.License.Reset()
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "deleted_at":
			if err := func() error {
				s.DeletedAt.Reset()
				if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleted_at\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PackageVersion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10001111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPackageVersion) {
					name = jsonFieldsNameOfPackageVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PackageVersionMetadata) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"package_type\"" + ":")
		s.PackageType.Encode(e)
	}
	{
		if s.Container.Set {
			e.Comma()
		}
		if s.Container.Set {
			e.RawStr("\"container\"" + ":")
			s.Container.Encode(e)
		}
	}
	{
		if s.Docker.Set {
			e.Comma()
		}
		if s.Docker.Set {
			e.RawStr("\"docker\"" + ":")
			s.Docker.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPackageVersionMetadata = [3]string{
	0: "package_type",
	1: "container",
	2: "docker",
}

// Decode decodes PackageVersionMetadata from json.
func (s *PackageVersionMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackageVersionMetadata to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "package_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.PackageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"package_type\"")
			}
		case "container":
			if err := func() error {
				s.Container.Reset()
				if err := s.Container.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container\"")
			}
		case "docker":
			if err := func() error {
				s.Docker.Reset()
				if err := s.Docker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"docker\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PackageVersionMetadata")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPackageVersionMetadata) {
					name = jsonFieldsNameOfPackageVersionMetadata[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PackageVersionMetadataContainer) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"tags\"" + ":")
		e.ArrStart()
		if len(s.Tags) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Tags[0]
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			for _, elem := range s.Tags[1:] {
				e.Comma()
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPackageVersionMetadataContainer = [1]string{
	0: "tags",
}

// Decode decodes PackageVersionMetadataContainer from json.
func (s *PackageVersionMetadataContainer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackageVersionMetadataContainer to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Tags = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.Raw()
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PackageVersionMetadataContainer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPackageVersionMetadataContainer) {
					name = jsonFieldsNameOfPackageVersionMetadataContainer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PackageVersionMetadataDocker) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Tag != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Tag != nil {
			e.RawStr("\"tag\"" + ":")
			e.ArrStart()
			if len(s.Tag) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Tag[0]
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
				for _, elem := range s.Tag[1:] {
					e.Comma()
					if len(elem) != 0 {
						e.Raw(elem)
					}
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPackageVersionMetadataDocker = [1]string{
	0: "tag",
}

// Decode decodes PackageVersionMetadataDocker from json.
func (s *PackageVersionMetadataDocker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackageVersionMetadataDocker to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			if err := func() error {
				s.Tag = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.Raw()
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Tag = append(s.Tag, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PackageVersionMetadataDocker")
	}

	return nil
}

// Encode encodes PackageVersionMetadataPackageType as json.
func (s PackageVersionMetadataPackageType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackageVersionMetadataPackageType from json.
func (s *PackageVersionMetadataPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackageVersionMetadataPackageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackageVersionMetadataPackageType(v) {
	case PackageVersionMetadataPackageTypeNpm:
		*s = PackageVersionMetadataPackageTypeNpm
	case PackageVersionMetadataPackageTypeMaven:
		*s = PackageVersionMetadataPackageTypeMaven
	case PackageVersionMetadataPackageTypeRubygems:
		*s = PackageVersionMetadataPackageTypeRubygems
	case PackageVersionMetadataPackageTypeDocker:
		*s = PackageVersionMetadataPackageTypeDocker
	case PackageVersionMetadataPackageTypeNuget:
		*s = PackageVersionMetadataPackageTypeNuget
	case PackageVersionMetadataPackageTypeContainer:
		*s = PackageVersionMetadataPackageTypeContainer
	default:
		*s = PackageVersionMetadataPackageType(v)
	}

	return nil
}

// Encode encodes PackageVisibility as json.
func (s PackageVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PackageVisibility from json.
func (s *PackageVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackageVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PackageVisibility(v) {
	case PackageVisibilityPrivate:
		*s = PackageVisibilityPrivate
	case PackageVisibilityPublic:
		*s = PackageVisibilityPublic
	default:
		*s = PackageVisibility(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PackagesBillingUsage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_gigabytes_bandwidth_used\"" + ":")
		e.Int(s.TotalGigabytesBandwidthUsed)
	}
	{
		e.Comma()

		e.RawStr("\"total_paid_gigabytes_bandwidth_used\"" + ":")
		e.Int(s.TotalPaidGigabytesBandwidthUsed)
	}
	{
		e.Comma()

		e.RawStr("\"included_gigabytes_bandwidth\"" + ":")
		e.Int(s.IncludedGigabytesBandwidth)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPackagesBillingUsage = [3]string{
	0: "total_gigabytes_bandwidth_used",
	1: "total_paid_gigabytes_bandwidth_used",
	2: "included_gigabytes_bandwidth",
}

// Decode decodes PackagesBillingUsage from json.
func (s *PackagesBillingUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesBillingUsage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_gigabytes_bandwidth_used":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalGigabytesBandwidthUsed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_gigabytes_bandwidth_used\"")
			}
		case "total_paid_gigabytes_bandwidth_used":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalPaidGigabytesBandwidthUsed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_paid_gigabytes_bandwidth_used\"")
			}
		case "included_gigabytes_bandwidth":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.IncludedGigabytesBandwidth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"included_gigabytes_bandwidth\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PackagesBillingUsage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPackagesBillingUsage) {
					name = jsonFieldsNameOfPackagesBillingUsage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden as json.
func (s PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden from json.
func (s *PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound as json.
func (s PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound from json.
func (s *PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForOrgApplicationJSONForbidden as json.
func (s PackagesDeletePackageForOrgApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForOrgApplicationJSONForbidden from json.
func (s *PackagesDeletePackageForOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForOrgApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForOrgApplicationJSONNotFound as json.
func (s PackagesDeletePackageForOrgApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForOrgApplicationJSONNotFound from json.
func (s *PackagesDeletePackageForOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForOrgApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForOrgApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageForOrgApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForOrgApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageForOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForOrgApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForUserApplicationJSONForbidden as json.
func (s PackagesDeletePackageForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForUserApplicationJSONForbidden from json.
func (s *PackagesDeletePackageForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForUserApplicationJSONNotFound as json.
func (s PackagesDeletePackageForUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForUserApplicationJSONNotFound from json.
func (s *PackagesDeletePackageForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForUserApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageForUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForUserApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageForUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden as json.
func (s PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound as json.
func (s PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForOrgApplicationJSONForbidden as json.
func (s PackagesDeletePackageVersionForOrgApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForOrgApplicationJSONForbidden from json.
func (s *PackagesDeletePackageVersionForOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForOrgApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForOrgApplicationJSONNotFound as json.
func (s PackagesDeletePackageVersionForOrgApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForOrgApplicationJSONNotFound from json.
func (s *PackagesDeletePackageVersionForOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForOrgApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForUserApplicationJSONForbidden as json.
func (s PackagesDeletePackageVersionForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForUserApplicationJSONForbidden from json.
func (s *PackagesDeletePackageVersionForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForUserApplicationJSONNotFound as json.
func (s PackagesDeletePackageVersionForUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForUserApplicationJSONNotFound from json.
func (s *PackagesDeletePackageVersionForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForUserApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageVersionForUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForUserApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageVersionForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesDeletePackageVersionForUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PackageVersion(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON to nil")
	}
	var unwrapped []PackageVersion
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PackageVersion
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PackageVersion(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON to nil")
	}
	var unwrapped []PackageVersion
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PackageVersion
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PackageVersion(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON to nil")
	}
	var unwrapped []PackageVersion
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PackageVersion
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForOrganizationApplicationJSONForbidden as json.
func (s PackagesListPackagesForOrganizationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForOrganizationApplicationJSONForbidden from json.
func (s *PackagesListPackagesForOrganizationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesListPackagesForOrganizationApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForOrganizationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForOrganizationApplicationJSONUnauthorized as json.
func (s PackagesListPackagesForOrganizationApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForOrganizationApplicationJSONUnauthorized from json.
func (s *PackagesListPackagesForOrganizationApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesListPackagesForOrganizationApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForOrganizationApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForOrganizationOKApplicationJSON as json.
func (s PackagesListPackagesForOrganizationOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Package(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PackagesListPackagesForOrganizationOKApplicationJSON from json.
func (s *PackagesListPackagesForOrganizationOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesListPackagesForOrganizationOKApplicationJSON to nil")
	}
	var unwrapped []Package
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Package
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForOrganizationOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForUserApplicationJSONForbidden as json.
func (s PackagesListPackagesForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForUserApplicationJSONForbidden from json.
func (s *PackagesListPackagesForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesListPackagesForUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForUserApplicationJSONUnauthorized as json.
func (s PackagesListPackagesForUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForUserApplicationJSONUnauthorized from json.
func (s *PackagesListPackagesForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesListPackagesForUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForUserOKApplicationJSON as json.
func (s PackagesListPackagesForUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Package(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PackagesListPackagesForUserOKApplicationJSON from json.
func (s *PackagesListPackagesForUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesListPackagesForUserOKApplicationJSON to nil")
	}
	var unwrapped []Package
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Package
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden as json.
func (s PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden from json.
func (s *PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound as json.
func (s PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound from json.
func (s *PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForOrgApplicationJSONForbidden as json.
func (s PackagesRestorePackageForOrgApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForOrgApplicationJSONForbidden from json.
func (s *PackagesRestorePackageForOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForOrgApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForOrgApplicationJSONNotFound as json.
func (s PackagesRestorePackageForOrgApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForOrgApplicationJSONNotFound from json.
func (s *PackagesRestorePackageForOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForOrgApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForOrgApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageForOrgApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForOrgApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageForOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForOrgApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForUserApplicationJSONForbidden as json.
func (s PackagesRestorePackageForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForUserApplicationJSONForbidden from json.
func (s *PackagesRestorePackageForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForUserApplicationJSONNotFound as json.
func (s PackagesRestorePackageForUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForUserApplicationJSONNotFound from json.
func (s *PackagesRestorePackageForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForUserApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageForUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForUserApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageForUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden as json.
func (s PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound as json.
func (s PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForOrgApplicationJSONForbidden as json.
func (s PackagesRestorePackageVersionForOrgApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForOrgApplicationJSONForbidden from json.
func (s *PackagesRestorePackageVersionForOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForOrgApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForOrgApplicationJSONNotFound as json.
func (s PackagesRestorePackageVersionForOrgApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForOrgApplicationJSONNotFound from json.
func (s *PackagesRestorePackageVersionForOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForOrgApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForUserApplicationJSONForbidden as json.
func (s PackagesRestorePackageVersionForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForUserApplicationJSONForbidden from json.
func (s *PackagesRestorePackageVersionForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForUserApplicationJSONNotFound as json.
func (s PackagesRestorePackageVersionForUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForUserApplicationJSONNotFound from json.
func (s *PackagesRestorePackageVersionForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForUserApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageVersionForUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForUserApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageVersionForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PackagesRestorePackageVersionForUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s Page) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"cname\"" + ":")
		s.Cname.Encode(e)
	}
	{
		if s.ProtectedDomainState.Set {
			e.Comma()
		}
		if s.ProtectedDomainState.Set {
			e.RawStr("\"protected_domain_state\"" + ":")
			s.ProtectedDomainState.Encode(e)
		}
	}
	{
		if s.PendingDomainUnverifiedAt.Set {
			e.Comma()
		}
		if s.PendingDomainUnverifiedAt.Set {
			e.RawStr("\"pending_domain_unverified_at\"" + ":")
			s.PendingDomainUnverifiedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.Comma()

		e.RawStr("\"custom_404\"" + ":")
		e.Bool(s.Custom404)
	}
	{
		if s.HTMLURL.Set {
			e.Comma()
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.Comma()
		}
		if s.Source.Set {
			e.RawStr("\"source\"" + ":")
			s.Source.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"public\"" + ":")
		e.Bool(s.Public)
	}
	{
		if s.HTTPSCertificate.Set {
			e.Comma()
		}
		if s.HTTPSCertificate.Set {
			e.RawStr("\"https_certificate\"" + ":")
			s.HTTPSCertificate.Encode(e)
		}
	}
	{
		if s.HTTPSEnforced.Set {
			e.Comma()
		}
		if s.HTTPSEnforced.Set {
			e.RawStr("\"https_enforced\"" + ":")
			s.HTTPSEnforced.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPage = [11]string{
	0:  "url",
	1:  "status",
	2:  "cname",
	3:  "protected_domain_state",
	4:  "pending_domain_unverified_at",
	5:  "custom_404",
	6:  "html_url",
	7:  "source",
	8:  "public",
	9:  "https_certificate",
	10: "https_enforced",
}

// Decode decodes Page from json.
func (s *Page) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Page to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "cname":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Cname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cname\"")
			}
		case "protected_domain_state":
			if err := func() error {
				s.ProtectedDomainState.Reset()
				if err := s.ProtectedDomainState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protected_domain_state\"")
			}
		case "pending_domain_unverified_at":
			if err := func() error {
				s.PendingDomainUnverifiedAt.Reset()
				if err := s.PendingDomainUnverifiedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pending_domain_unverified_at\"")
			}
		case "custom_404":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Custom404 = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_404\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "public":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Public = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		case "https_certificate":
			if err := func() error {
				s.HTTPSCertificate.Reset()
				if err := s.HTTPSCertificate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"https_certificate\"")
			}
		case "https_enforced":
			if err := func() error {
				s.HTTPSEnforced.Reset()
				if err := s.HTTPSEnforced.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"https_enforced\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Page")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00100111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPage) {
					name = jsonFieldsNameOfPage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PageBuild) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"error\"" + ":")
		s.Error.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pusher\"" + ":")
		s.Pusher.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		e.Str(s.Commit)
	}
	{
		e.Comma()

		e.RawStr("\"duration\"" + ":")
		e.Int(s.Duration)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPageBuild = [8]string{
	0: "url",
	1: "status",
	2: "error",
	3: "pusher",
	4: "commit",
	5: "duration",
	6: "created_at",
	7: "updated_at",
}

// Decode decodes PageBuild from json.
func (s *PageBuild) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageBuild to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "pusher":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Pusher.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pusher\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Commit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Duration = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageBuild")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPageBuild) {
					name = jsonFieldsNameOfPageBuild[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PageBuildError) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		s.Message.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPageBuildError = [1]string{
	0: "message",
}

// Decode decodes PageBuildError from json.
func (s *PageBuildError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageBuildError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageBuildError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPageBuildError) {
					name = jsonFieldsNameOfPageBuildError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PageBuildStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPageBuildStatus = [2]string{
	0: "url",
	1: "status",
}

// Decode decodes PageBuildStatus from json.
func (s *PageBuildStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageBuildStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageBuildStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPageBuildStatus) {
					name = jsonFieldsNameOfPageBuildStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PageProtectedDomainState as json.
func (s PageProtectedDomainState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PageProtectedDomainState from json.
func (s *PageProtectedDomainState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageProtectedDomainState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PageProtectedDomainState(v) {
	case PageProtectedDomainStatePending:
		*s = PageProtectedDomainStatePending
	case PageProtectedDomainStateVerified:
		*s = PageProtectedDomainStateVerified
	case PageProtectedDomainStateUnverified:
		*s = PageProtectedDomainStateUnverified
	default:
		*s = PageProtectedDomainState(v)
	}

	return nil
}

// Encode encodes PageStatus as json.
func (s PageStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PageStatus from json.
func (s *PageStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PageStatus(v) {
	case PageStatusBuilt:
		*s = PageStatusBuilt
	case PageStatusBuilding:
		*s = PageStatusBuilding
	case PageStatusErrored:
		*s = PageStatusErrored
	default:
		*s = PageStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PagesHTTPSCertificate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"domains\"" + ":")
		e.ArrStart()
		if len(s.Domains) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Domains[0]
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			for _, elem := range s.Domains[1:] {
				e.Comma()
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
		}
		e.ArrEnd()
	}
	{
		if s.ExpiresAt.Set {
			e.Comma()
		}
		if s.ExpiresAt.Set {
			e.RawStr("\"expires_at\"" + ":")
			s.ExpiresAt.Encode(e, json.EncodeDate)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPagesHTTPSCertificate = [4]string{
	0: "state",
	1: "description",
	2: "domains",
	3: "expires_at",
}

// Decode decodes PagesHTTPSCertificate from json.
func (s *PagesHTTPSCertificate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PagesHTTPSCertificate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "domains":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Domains = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.Raw()
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PagesHTTPSCertificate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPagesHTTPSCertificate) {
					name = jsonFieldsNameOfPagesHTTPSCertificate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PagesHTTPSCertificateState as json.
func (s PagesHTTPSCertificateState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PagesHTTPSCertificateState from json.
func (s *PagesHTTPSCertificateState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PagesHTTPSCertificateState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PagesHTTPSCertificateState(v) {
	case PagesHTTPSCertificateStateNew:
		*s = PagesHTTPSCertificateStateNew
	case PagesHTTPSCertificateStateAuthorizationCreated:
		*s = PagesHTTPSCertificateStateAuthorizationCreated
	case PagesHTTPSCertificateStateAuthorizationPending:
		*s = PagesHTTPSCertificateStateAuthorizationPending
	case PagesHTTPSCertificateStateAuthorized:
		*s = PagesHTTPSCertificateStateAuthorized
	case PagesHTTPSCertificateStateAuthorizationRevoked:
		*s = PagesHTTPSCertificateStateAuthorizationRevoked
	case PagesHTTPSCertificateStateIssued:
		*s = PagesHTTPSCertificateStateIssued
	case PagesHTTPSCertificateStateUploaded:
		*s = PagesHTTPSCertificateStateUploaded
	case PagesHTTPSCertificateStateApproved:
		*s = PagesHTTPSCertificateStateApproved
	case PagesHTTPSCertificateStateErrored:
		*s = PagesHTTPSCertificateStateErrored
	case PagesHTTPSCertificateStateBadAuthz:
		*s = PagesHTTPSCertificateStateBadAuthz
	case PagesHTTPSCertificateStateDestroyPending:
		*s = PagesHTTPSCertificateStateDestroyPending
	case PagesHTTPSCertificateStateDNSChanged:
		*s = PagesHTTPSCertificateStateDNSChanged
	default:
		*s = PagesHTTPSCertificateState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PagesHealthCheck) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Domain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Domain.Set {
			e.RawStr("\"domain\"" + ":")
			s.Domain.Encode(e)
		}
	}
	{
		if s.AltDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AltDomain.Set {
			e.RawStr("\"alt_domain\"" + ":")
			s.AltDomain.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPagesHealthCheck = [2]string{
	0: "domain",
	1: "alt_domain",
}

// Decode decodes PagesHealthCheck from json.
func (s *PagesHealthCheck) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PagesHealthCheck to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "alt_domain":
			if err := func() error {
				s.AltDomain.Reset()
				if err := s.AltDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alt_domain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PagesHealthCheck")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PagesHealthCheckAltDomain) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Host.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Host.Set {
			e.RawStr("\"host\"" + ":")
			s.Host.Encode(e)
		}
	}
	{
		if s.URI.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URI.Set {
			e.RawStr("\"uri\"" + ":")
			s.URI.Encode(e)
		}
	}
	{
		if s.Nameservers.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Nameservers.Set {
			e.RawStr("\"nameservers\"" + ":")
			s.Nameservers.Encode(e)
		}
	}
	{
		if s.DNSResolves.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DNSResolves.Set {
			e.RawStr("\"dns_resolves\"" + ":")
			s.DNSResolves.Encode(e)
		}
	}
	{
		if s.IsProxied.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsProxied.Set {
			e.RawStr("\"is_proxied\"" + ":")
			s.IsProxied.Encode(e)
		}
	}
	{
		if s.IsCloudflareIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCloudflareIP.Set {
			e.RawStr("\"is_cloudflare_ip\"" + ":")
			s.IsCloudflareIP.Encode(e)
		}
	}
	{
		if s.IsFastlyIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsFastlyIP.Set {
			e.RawStr("\"is_fastly_ip\"" + ":")
			s.IsFastlyIP.Encode(e)
		}
	}
	{
		if s.IsOldIPAddress.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsOldIPAddress.Set {
			e.RawStr("\"is_old_ip_address\"" + ":")
			s.IsOldIPAddress.Encode(e)
		}
	}
	{
		if s.IsARecord.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsARecord.Set {
			e.RawStr("\"is_a_record\"" + ":")
			s.IsARecord.Encode(e)
		}
	}
	{
		if s.HasCnameRecord.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasCnameRecord.Set {
			e.RawStr("\"has_cname_record\"" + ":")
			s.HasCnameRecord.Encode(e)
		}
	}
	{
		if s.HasMxRecordsPresent.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasMxRecordsPresent.Set {
			e.RawStr("\"has_mx_records_present\"" + ":")
			s.HasMxRecordsPresent.Encode(e)
		}
	}
	{
		if s.IsValidDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsValidDomain.Set {
			e.RawStr("\"is_valid_domain\"" + ":")
			s.IsValidDomain.Encode(e)
		}
	}
	{
		if s.IsApexDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsApexDomain.Set {
			e.RawStr("\"is_apex_domain\"" + ":")
			s.IsApexDomain.Encode(e)
		}
	}
	{
		if s.ShouldBeARecord.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ShouldBeARecord.Set {
			e.RawStr("\"should_be_a_record\"" + ":")
			s.ShouldBeARecord.Encode(e)
		}
	}
	{
		if s.IsCnameToGithubUserDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCnameToGithubUserDomain.Set {
			e.RawStr("\"is_cname_to_github_user_domain\"" + ":")
			s.IsCnameToGithubUserDomain.Encode(e)
		}
	}
	{
		if s.IsCnameToPagesDotGithubDotCom.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCnameToPagesDotGithubDotCom.Set {
			e.RawStr("\"is_cname_to_pages_dot_github_dot_com\"" + ":")
			s.IsCnameToPagesDotGithubDotCom.Encode(e)
		}
	}
	{
		if s.IsCnameToFastly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCnameToFastly.Set {
			e.RawStr("\"is_cname_to_fastly\"" + ":")
			s.IsCnameToFastly.Encode(e)
		}
	}
	{
		if s.IsPointedToGithubPagesIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsPointedToGithubPagesIP.Set {
			e.RawStr("\"is_pointed_to_github_pages_ip\"" + ":")
			s.IsPointedToGithubPagesIP.Encode(e)
		}
	}
	{
		if s.IsNonGithubPagesIPPresent.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsNonGithubPagesIPPresent.Set {
			e.RawStr("\"is_non_github_pages_ip_present\"" + ":")
			s.IsNonGithubPagesIPPresent.Encode(e)
		}
	}
	{
		if s.IsPagesDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsPagesDomain.Set {
			e.RawStr("\"is_pages_domain\"" + ":")
			s.IsPagesDomain.Encode(e)
		}
	}
	{
		if s.IsServedByPages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsServedByPages.Set {
			e.RawStr("\"is_served_by_pages\"" + ":")
			s.IsServedByPages.Encode(e)
		}
	}
	{
		if s.IsValid.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsValid.Set {
			e.RawStr("\"is_valid\"" + ":")
			s.IsValid.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.RespondsToHTTPS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RespondsToHTTPS.Set {
			e.RawStr("\"responds_to_https\"" + ":")
			s.RespondsToHTTPS.Encode(e)
		}
	}
	{
		if s.EnforcesHTTPS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EnforcesHTTPS.Set {
			e.RawStr("\"enforces_https\"" + ":")
			s.EnforcesHTTPS.Encode(e)
		}
	}
	{
		if s.HTTPSError.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTTPSError.Set {
			e.RawStr("\"https_error\"" + ":")
			s.HTTPSError.Encode(e)
		}
	}
	{
		if s.IsHTTPSEligible.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsHTTPSEligible.Set {
			e.RawStr("\"is_https_eligible\"" + ":")
			s.IsHTTPSEligible.Encode(e)
		}
	}
	{
		if s.CaaError.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CaaError.Set {
			e.RawStr("\"caa_error\"" + ":")
			s.CaaError.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPagesHealthCheckAltDomain = [28]string{
	0:  "host",
	1:  "uri",
	2:  "nameservers",
	3:  "dns_resolves",
	4:  "is_proxied",
	5:  "is_cloudflare_ip",
	6:  "is_fastly_ip",
	7:  "is_old_ip_address",
	8:  "is_a_record",
	9:  "has_cname_record",
	10: "has_mx_records_present",
	11: "is_valid_domain",
	12: "is_apex_domain",
	13: "should_be_a_record",
	14: "is_cname_to_github_user_domain",
	15: "is_cname_to_pages_dot_github_dot_com",
	16: "is_cname_to_fastly",
	17: "is_pointed_to_github_pages_ip",
	18: "is_non_github_pages_ip_present",
	19: "is_pages_domain",
	20: "is_served_by_pages",
	21: "is_valid",
	22: "reason",
	23: "responds_to_https",
	24: "enforces_https",
	25: "https_error",
	26: "is_https_eligible",
	27: "caa_error",
}

// Decode decodes PagesHealthCheckAltDomain from json.
func (s *PagesHealthCheckAltDomain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PagesHealthCheckAltDomain to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "nameservers":
			if err := func() error {
				s.Nameservers.Reset()
				if err := s.Nameservers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameservers\"")
			}
		case "dns_resolves":
			if err := func() error {
				s.DNSResolves.Reset()
				if err := s.DNSResolves.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dns_resolves\"")
			}
		case "is_proxied":
			if err := func() error {
				s.IsProxied.Reset()
				if err := s.IsProxied.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_proxied\"")
			}
		case "is_cloudflare_ip":
			if err := func() error {
				s.IsCloudflareIP.Reset()
				if err := s.IsCloudflareIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cloudflare_ip\"")
			}
		case "is_fastly_ip":
			if err := func() error {
				s.IsFastlyIP.Reset()
				if err := s.IsFastlyIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_fastly_ip\"")
			}
		case "is_old_ip_address":
			if err := func() error {
				s.IsOldIPAddress.Reset()
				if err := s.IsOldIPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_old_ip_address\"")
			}
		case "is_a_record":
			if err := func() error {
				s.IsARecord.Reset()
				if err := s.IsARecord.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_a_record\"")
			}
		case "has_cname_record":
			if err := func() error {
				s.HasCnameRecord.Reset()
				if err := s.HasCnameRecord.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_cname_record\"")
			}
		case "has_mx_records_present":
			if err := func() error {
				s.HasMxRecordsPresent.Reset()
				if err := s.HasMxRecordsPresent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_mx_records_present\"")
			}
		case "is_valid_domain":
			if err := func() error {
				s.IsValidDomain.Reset()
				if err := s.IsValidDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_valid_domain\"")
			}
		case "is_apex_domain":
			if err := func() error {
				s.IsApexDomain.Reset()
				if err := s.IsApexDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_apex_domain\"")
			}
		case "should_be_a_record":
			if err := func() error {
				s.ShouldBeARecord.Reset()
				if err := s.ShouldBeARecord.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"should_be_a_record\"")
			}
		case "is_cname_to_github_user_domain":
			if err := func() error {
				s.IsCnameToGithubUserDomain.Reset()
				if err := s.IsCnameToGithubUserDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cname_to_github_user_domain\"")
			}
		case "is_cname_to_pages_dot_github_dot_com":
			if err := func() error {
				s.IsCnameToPagesDotGithubDotCom.Reset()
				if err := s.IsCnameToPagesDotGithubDotCom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cname_to_pages_dot_github_dot_com\"")
			}
		case "is_cname_to_fastly":
			if err := func() error {
				s.IsCnameToFastly.Reset()
				if err := s.IsCnameToFastly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cname_to_fastly\"")
			}
		case "is_pointed_to_github_pages_ip":
			if err := func() error {
				s.IsPointedToGithubPagesIP.Reset()
				if err := s.IsPointedToGithubPagesIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_pointed_to_github_pages_ip\"")
			}
		case "is_non_github_pages_ip_present":
			if err := func() error {
				s.IsNonGithubPagesIPPresent.Reset()
				if err := s.IsNonGithubPagesIPPresent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_non_github_pages_ip_present\"")
			}
		case "is_pages_domain":
			if err := func() error {
				s.IsPagesDomain.Reset()
				if err := s.IsPagesDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_pages_domain\"")
			}
		case "is_served_by_pages":
			if err := func() error {
				s.IsServedByPages.Reset()
				if err := s.IsServedByPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_served_by_pages\"")
			}
		case "is_valid":
			if err := func() error {
				s.IsValid.Reset()
				if err := s.IsValid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_valid\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "responds_to_https":
			if err := func() error {
				s.RespondsToHTTPS.Reset()
				if err := s.RespondsToHTTPS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responds_to_https\"")
			}
		case "enforces_https":
			if err := func() error {
				s.EnforcesHTTPS.Reset()
				if err := s.EnforcesHTTPS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforces_https\"")
			}
		case "https_error":
			if err := func() error {
				s.HTTPSError.Reset()
				if err := s.HTTPSError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"https_error\"")
			}
		case "is_https_eligible":
			if err := func() error {
				s.IsHTTPSEligible.Reset()
				if err := s.IsHTTPSEligible.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_https_eligible\"")
			}
		case "caa_error":
			if err := func() error {
				s.CaaError.Reset()
				if err := s.CaaError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caa_error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PagesHealthCheckAltDomain")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PagesHealthCheckDomain) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Host.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Host.Set {
			e.RawStr("\"host\"" + ":")
			s.Host.Encode(e)
		}
	}
	{
		if s.URI.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URI.Set {
			e.RawStr("\"uri\"" + ":")
			s.URI.Encode(e)
		}
	}
	{
		if s.Nameservers.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Nameservers.Set {
			e.RawStr("\"nameservers\"" + ":")
			s.Nameservers.Encode(e)
		}
	}
	{
		if s.DNSResolves.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DNSResolves.Set {
			e.RawStr("\"dns_resolves\"" + ":")
			s.DNSResolves.Encode(e)
		}
	}
	{
		if s.IsProxied.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsProxied.Set {
			e.RawStr("\"is_proxied\"" + ":")
			s.IsProxied.Encode(e)
		}
	}
	{
		if s.IsCloudflareIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCloudflareIP.Set {
			e.RawStr("\"is_cloudflare_ip\"" + ":")
			s.IsCloudflareIP.Encode(e)
		}
	}
	{
		if s.IsFastlyIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsFastlyIP.Set {
			e.RawStr("\"is_fastly_ip\"" + ":")
			s.IsFastlyIP.Encode(e)
		}
	}
	{
		if s.IsOldIPAddress.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsOldIPAddress.Set {
			e.RawStr("\"is_old_ip_address\"" + ":")
			s.IsOldIPAddress.Encode(e)
		}
	}
	{
		if s.IsARecord.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsARecord.Set {
			e.RawStr("\"is_a_record\"" + ":")
			s.IsARecord.Encode(e)
		}
	}
	{
		if s.HasCnameRecord.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasCnameRecord.Set {
			e.RawStr("\"has_cname_record\"" + ":")
			s.HasCnameRecord.Encode(e)
		}
	}
	{
		if s.HasMxRecordsPresent.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasMxRecordsPresent.Set {
			e.RawStr("\"has_mx_records_present\"" + ":")
			s.HasMxRecordsPresent.Encode(e)
		}
	}
	{
		if s.IsValidDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsValidDomain.Set {
			e.RawStr("\"is_valid_domain\"" + ":")
			s.IsValidDomain.Encode(e)
		}
	}
	{
		if s.IsApexDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsApexDomain.Set {
			e.RawStr("\"is_apex_domain\"" + ":")
			s.IsApexDomain.Encode(e)
		}
	}
	{
		if s.ShouldBeARecord.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ShouldBeARecord.Set {
			e.RawStr("\"should_be_a_record\"" + ":")
			s.ShouldBeARecord.Encode(e)
		}
	}
	{
		if s.IsCnameToGithubUserDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCnameToGithubUserDomain.Set {
			e.RawStr("\"is_cname_to_github_user_domain\"" + ":")
			s.IsCnameToGithubUserDomain.Encode(e)
		}
	}
	{
		if s.IsCnameToPagesDotGithubDotCom.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCnameToPagesDotGithubDotCom.Set {
			e.RawStr("\"is_cname_to_pages_dot_github_dot_com\"" + ":")
			s.IsCnameToPagesDotGithubDotCom.Encode(e)
		}
	}
	{
		if s.IsCnameToFastly.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsCnameToFastly.Set {
			e.RawStr("\"is_cname_to_fastly\"" + ":")
			s.IsCnameToFastly.Encode(e)
		}
	}
	{
		if s.IsPointedToGithubPagesIP.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsPointedToGithubPagesIP.Set {
			e.RawStr("\"is_pointed_to_github_pages_ip\"" + ":")
			s.IsPointedToGithubPagesIP.Encode(e)
		}
	}
	{
		if s.IsNonGithubPagesIPPresent.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsNonGithubPagesIPPresent.Set {
			e.RawStr("\"is_non_github_pages_ip_present\"" + ":")
			s.IsNonGithubPagesIPPresent.Encode(e)
		}
	}
	{
		if s.IsPagesDomain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsPagesDomain.Set {
			e.RawStr("\"is_pages_domain\"" + ":")
			s.IsPagesDomain.Encode(e)
		}
	}
	{
		if s.IsServedByPages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsServedByPages.Set {
			e.RawStr("\"is_served_by_pages\"" + ":")
			s.IsServedByPages.Encode(e)
		}
	}
	{
		if s.IsValid.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsValid.Set {
			e.RawStr("\"is_valid\"" + ":")
			s.IsValid.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Reason.Set {
			e.RawStr("\"reason\"" + ":")
			s.Reason.Encode(e)
		}
	}
	{
		if s.RespondsToHTTPS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RespondsToHTTPS.Set {
			e.RawStr("\"responds_to_https\"" + ":")
			s.RespondsToHTTPS.Encode(e)
		}
	}
	{
		if s.EnforcesHTTPS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EnforcesHTTPS.Set {
			e.RawStr("\"enforces_https\"" + ":")
			s.EnforcesHTTPS.Encode(e)
		}
	}
	{
		if s.HTTPSError.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTTPSError.Set {
			e.RawStr("\"https_error\"" + ":")
			s.HTTPSError.Encode(e)
		}
	}
	{
		if s.IsHTTPSEligible.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsHTTPSEligible.Set {
			e.RawStr("\"is_https_eligible\"" + ":")
			s.IsHTTPSEligible.Encode(e)
		}
	}
	{
		if s.CaaError.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CaaError.Set {
			e.RawStr("\"caa_error\"" + ":")
			s.CaaError.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPagesHealthCheckDomain = [28]string{
	0:  "host",
	1:  "uri",
	2:  "nameservers",
	3:  "dns_resolves",
	4:  "is_proxied",
	5:  "is_cloudflare_ip",
	6:  "is_fastly_ip",
	7:  "is_old_ip_address",
	8:  "is_a_record",
	9:  "has_cname_record",
	10: "has_mx_records_present",
	11: "is_valid_domain",
	12: "is_apex_domain",
	13: "should_be_a_record",
	14: "is_cname_to_github_user_domain",
	15: "is_cname_to_pages_dot_github_dot_com",
	16: "is_cname_to_fastly",
	17: "is_pointed_to_github_pages_ip",
	18: "is_non_github_pages_ip_present",
	19: "is_pages_domain",
	20: "is_served_by_pages",
	21: "is_valid",
	22: "reason",
	23: "responds_to_https",
	24: "enforces_https",
	25: "https_error",
	26: "is_https_eligible",
	27: "caa_error",
}

// Decode decodes PagesHealthCheckDomain from json.
func (s *PagesHealthCheckDomain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PagesHealthCheckDomain to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "nameservers":
			if err := func() error {
				s.Nameservers.Reset()
				if err := s.Nameservers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameservers\"")
			}
		case "dns_resolves":
			if err := func() error {
				s.DNSResolves.Reset()
				if err := s.DNSResolves.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dns_resolves\"")
			}
		case "is_proxied":
			if err := func() error {
				s.IsProxied.Reset()
				if err := s.IsProxied.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_proxied\"")
			}
		case "is_cloudflare_ip":
			if err := func() error {
				s.IsCloudflareIP.Reset()
				if err := s.IsCloudflareIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cloudflare_ip\"")
			}
		case "is_fastly_ip":
			if err := func() error {
				s.IsFastlyIP.Reset()
				if err := s.IsFastlyIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_fastly_ip\"")
			}
		case "is_old_ip_address":
			if err := func() error {
				s.IsOldIPAddress.Reset()
				if err := s.IsOldIPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_old_ip_address\"")
			}
		case "is_a_record":
			if err := func() error {
				s.IsARecord.Reset()
				if err := s.IsARecord.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_a_record\"")
			}
		case "has_cname_record":
			if err := func() error {
				s.HasCnameRecord.Reset()
				if err := s.HasCnameRecord.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_cname_record\"")
			}
		case "has_mx_records_present":
			if err := func() error {
				s.HasMxRecordsPresent.Reset()
				if err := s.HasMxRecordsPresent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_mx_records_present\"")
			}
		case "is_valid_domain":
			if err := func() error {
				s.IsValidDomain.Reset()
				if err := s.IsValidDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_valid_domain\"")
			}
		case "is_apex_domain":
			if err := func() error {
				s.IsApexDomain.Reset()
				if err := s.IsApexDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_apex_domain\"")
			}
		case "should_be_a_record":
			if err := func() error {
				s.ShouldBeARecord.Reset()
				if err := s.ShouldBeARecord.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"should_be_a_record\"")
			}
		case "is_cname_to_github_user_domain":
			if err := func() error {
				s.IsCnameToGithubUserDomain.Reset()
				if err := s.IsCnameToGithubUserDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cname_to_github_user_domain\"")
			}
		case "is_cname_to_pages_dot_github_dot_com":
			if err := func() error {
				s.IsCnameToPagesDotGithubDotCom.Reset()
				if err := s.IsCnameToPagesDotGithubDotCom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cname_to_pages_dot_github_dot_com\"")
			}
		case "is_cname_to_fastly":
			if err := func() error {
				s.IsCnameToFastly.Reset()
				if err := s.IsCnameToFastly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_cname_to_fastly\"")
			}
		case "is_pointed_to_github_pages_ip":
			if err := func() error {
				s.IsPointedToGithubPagesIP.Reset()
				if err := s.IsPointedToGithubPagesIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_pointed_to_github_pages_ip\"")
			}
		case "is_non_github_pages_ip_present":
			if err := func() error {
				s.IsNonGithubPagesIPPresent.Reset()
				if err := s.IsNonGithubPagesIPPresent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_non_github_pages_ip_present\"")
			}
		case "is_pages_domain":
			if err := func() error {
				s.IsPagesDomain.Reset()
				if err := s.IsPagesDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_pages_domain\"")
			}
		case "is_served_by_pages":
			if err := func() error {
				s.IsServedByPages.Reset()
				if err := s.IsServedByPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_served_by_pages\"")
			}
		case "is_valid":
			if err := func() error {
				s.IsValid.Reset()
				if err := s.IsValid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_valid\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "responds_to_https":
			if err := func() error {
				s.RespondsToHTTPS.Reset()
				if err := s.RespondsToHTTPS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responds_to_https\"")
			}
		case "enforces_https":
			if err := func() error {
				s.EnforcesHTTPS.Reset()
				if err := s.EnforcesHTTPS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforces_https\"")
			}
		case "https_error":
			if err := func() error {
				s.HTTPSError.Reset()
				if err := s.HTTPSError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"https_error\"")
			}
		case "is_https_eligible":
			if err := func() error {
				s.IsHTTPSEligible.Reset()
				if err := s.IsHTTPSEligible.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_https_eligible\"")
			}
		case "caa_error":
			if err := func() error {
				s.CaaError.Reset()
				if err := s.CaaError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caa_error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PagesHealthCheckDomain")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PagesSourceHash) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"branch\"" + ":")
		e.Str(s.Branch)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPagesSourceHash = [2]string{
	0: "branch",
	1: "path",
}

// Decode decodes PagesSourceHash from json.
func (s *PagesSourceHash) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PagesSourceHash to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "branch":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Branch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PagesSourceHash")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPagesSourceHash) {
					name = jsonFieldsNameOfPagesSourceHash[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ParticipationStats) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"all\"" + ":")
		e.ArrStart()
		if len(s.All) >= 1 {
			// Encode first element without comma.
			{
				elem := s.All[0]
				e.Int(elem)
			}
			for _, elem := range s.All[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		e.ArrStart()
		if len(s.Owner) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Owner[0]
				e.Int(elem)
			}
			for _, elem := range s.Owner[1:] {
				e.Comma()
				e.Int(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfParticipationStats = [2]string{
	0: "all",
	1: "owner",
}

// Decode decodes ParticipationStats from json.
func (s *ParticipationStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ParticipationStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "all":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.All = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.All = append(s.All, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"all\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Owner = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Owner = append(s.Owner, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ParticipationStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfParticipationStats) {
					name = jsonFieldsNameOfParticipationStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PorterAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"remote_id\"" + ":")
		e.Str(s.RemoteID)
	}
	{
		e.Comma()

		e.RawStr("\"remote_name\"" + ":")
		e.Str(s.RemoteName)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"import_url\"" + ":")
		json.EncodeURI(e, s.ImportURL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPorterAuthor = [7]string{
	0: "id",
	1: "remote_id",
	2: "remote_name",
	3: "email",
	4: "name",
	5: "url",
	6: "import_url",
}

// Decode decodes PorterAuthor from json.
func (s *PorterAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PorterAuthor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "remote_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RemoteID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remote_id\"")
			}
		case "remote_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.RemoteName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remote_name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "import_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ImportURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"import_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PorterAuthor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPorterAuthor) {
					name = jsonFieldsNameOfPorterAuthor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PorterLargeFile) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ref_name\"" + ":")
		e.Str(s.RefName)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"oid\"" + ":")
		e.Str(s.Oid)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPorterLargeFile = [4]string{
	0: "ref_name",
	1: "path",
	2: "oid",
	3: "size",
}

// Decode decodes PorterLargeFile from json.
func (s *PorterLargeFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PorterLargeFile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RefName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref_name\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "oid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Oid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oid\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PorterLargeFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPorterLargeFile) {
					name = jsonFieldsNameOfPorterLargeFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PreviewHeaderMissing) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"documentation_url\"" + ":")
		e.Str(s.DocumentationURL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPreviewHeaderMissing = [2]string{
	0: "message",
	1: "documentation_url",
}

// Decode decodes PreviewHeaderMissing from json.
func (s *PreviewHeaderMissing) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PreviewHeaderMissing to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DocumentationURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PreviewHeaderMissing")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPreviewHeaderMissing) {
					name = jsonFieldsNameOfPreviewHeaderMissing[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PrivateUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		s.Name.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"company\"" + ":")
		s.Company.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"blog\"" + ":")
		s.Blog.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"location\"" + ":")
		s.Location.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		s.Email.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"hireable\"" + ":")
		s.Hireable.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"bio\"" + ":")
		s.Bio.Encode(e)
	}
	{
		if s.TwitterUsername.Set {
			e.Comma()
		}
		if s.TwitterUsername.Set {
			e.RawStr("\"twitter_username\"" + ":")
			s.TwitterUsername.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"public_repos\"" + ":")
		e.Int(s.PublicRepos)
	}
	{
		e.Comma()

		e.RawStr("\"public_gists\"" + ":")
		e.Int(s.PublicGists)
	}
	{
		e.Comma()

		e.RawStr("\"followers\"" + ":")
		e.Int(s.Followers)
	}
	{
		e.Comma()

		e.RawStr("\"following\"" + ":")
		e.Int(s.Following)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"private_gists\"" + ":")
		e.Int(s.PrivateGists)
	}
	{
		e.Comma()

		e.RawStr("\"total_private_repos\"" + ":")
		e.Int(s.TotalPrivateRepos)
	}
	{
		e.Comma()

		e.RawStr("\"owned_private_repos\"" + ":")
		e.Int(s.OwnedPrivateRepos)
	}
	{
		e.Comma()

		e.RawStr("\"disk_usage\"" + ":")
		e.Int(s.DiskUsage)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators\"" + ":")
		e.Int(s.Collaborators)
	}
	{
		e.Comma()

		e.RawStr("\"two_factor_authentication\"" + ":")
		e.Bool(s.TwoFactorAuthentication)
	}
	{
		if s.Plan.Set {
			e.Comma()
		}
		if s.Plan.Set {
			e.RawStr("\"plan\"" + ":")
			s.Plan.Encode(e)
		}
	}
	{
		if s.SuspendedAt.Set {
			e.Comma()
		}
		if s.SuspendedAt.Set {
			e.RawStr("\"suspended_at\"" + ":")
			s.SuspendedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.BusinessPlus.Set {
			e.Comma()
		}
		if s.BusinessPlus.Set {
			e.RawStr("\"business_plus\"" + ":")
			s.BusinessPlus.Encode(e)
		}
	}
	{
		if s.LdapDn.Set {
			e.Comma()
		}
		if s.LdapDn.Set {
			e.RawStr("\"ldap_dn\"" + ":")
			s.LdapDn.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPrivateUser = [42]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "avatar_url",
	4:  "gravatar_id",
	5:  "url",
	6:  "html_url",
	7:  "followers_url",
	8:  "following_url",
	9:  "gists_url",
	10: "starred_url",
	11: "subscriptions_url",
	12: "organizations_url",
	13: "repos_url",
	14: "events_url",
	15: "received_events_url",
	16: "type",
	17: "site_admin",
	18: "name",
	19: "company",
	20: "blog",
	21: "location",
	22: "email",
	23: "hireable",
	24: "bio",
	25: "twitter_username",
	26: "public_repos",
	27: "public_gists",
	28: "followers",
	29: "following",
	30: "created_at",
	31: "updated_at",
	32: "private_gists",
	33: "total_private_repos",
	34: "owned_private_repos",
	35: "disk_usage",
	36: "collaborators",
	37: "two_factor_authentication",
	38: "plan",
	39: "suspended_at",
	40: "business_plus",
	41: "ldap_dn",
}

// Decode decodes PrivateUser from json.
func (s *PrivateUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PrivateUser to nil")
	}
	var requiredBitSet [6]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "name":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "company":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Company.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"company\"")
			}
		case "blog":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Blog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blog\"")
			}
		case "location":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hireable":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.Hireable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hireable\"")
			}
		case "bio":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "twitter_username":
			if err := func() error {
				s.TwitterUsername.Reset()
				if err := s.TwitterUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"twitter_username\"")
			}
		case "public_repos":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.PublicRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_repos\"")
			}
		case "public_gists":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.PublicGists = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_gists\"")
			}
		case "followers":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Followers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers\"")
			}
		case "following":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Following = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following\"")
			}
		case "created_at":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "private_gists":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.PrivateGists = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private_gists\"")
			}
		case "total_private_repos":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalPrivateRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_private_repos\"")
			}
		case "owned_private_repos":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.OwnedPrivateRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owned_private_repos\"")
			}
		case "disk_usage":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DiskUsage = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk_usage\"")
			}
		case "collaborators":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Collaborators = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators\"")
			}
		case "two_factor_authentication":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.TwoFactorAuthentication = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"two_factor_authentication\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "suspended_at":
			if err := func() error {
				s.SuspendedAt.Reset()
				if err := s.SuspendedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspended_at\"")
			}
		case "business_plus":
			if err := func() error {
				s.BusinessPlus.Reset()
				if err := s.BusinessPlus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_plus\"")
			}
		case "ldap_dn":
			if err := func() error {
				s.LdapDn.Reset()
				if err := s.LdapDn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ldap_dn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PrivateUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [6]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111101,
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPrivateUser) {
					name = jsonFieldsNameOfPrivateUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PrivateUserPlan) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"collaborators\"" + ":")
		e.Int(s.Collaborators)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"space\"" + ":")
		e.Int(s.Space)
	}
	{
		e.Comma()

		e.RawStr("\"private_repos\"" + ":")
		e.Int(s.PrivateRepos)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPrivateUserPlan = [4]string{
	0: "collaborators",
	1: "name",
	2: "space",
	3: "private_repos",
}

// Decode decodes PrivateUserPlan from json.
func (s *PrivateUserPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PrivateUserPlan to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collaborators":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Collaborators = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "space":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Space = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"space\"")
			}
		case "private_repos":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.PrivateRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private_repos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PrivateUserPlan")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPrivateUserPlan) {
					name = jsonFieldsNameOfPrivateUserPlan[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Project) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"owner_url\"" + ":")
		json.EncodeURI(e, s.OwnerURL)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"columns_url\"" + ":")
		json.EncodeURI(e, s.ColumnsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		s.Body.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.OrganizationPermission.Set {
			e.Comma()
		}
		if s.OrganizationPermission.Set {
			e.RawStr("\"organization_permission\"" + ":")
			s.OrganizationPermission.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.Comma()
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProject = [15]string{
	0:  "owner_url",
	1:  "url",
	2:  "html_url",
	3:  "columns_url",
	4:  "id",
	5:  "node_id",
	6:  "name",
	7:  "body",
	8:  "number",
	9:  "state",
	10: "creator",
	11: "created_at",
	12: "updated_at",
	13: "organization_permission",
	14: "private",
}

// Decode decodes Project from json.
func (s *Project) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Project to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "owner_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OwnerURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner_url\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "columns_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ColumnsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"columns_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "creator":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "organization_permission":
			if err := func() error {
				s.OrganizationPermission.Reset()
				if err := s.OrganizationPermission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_permission\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Project")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProject) {
					name = jsonFieldsNameOfProject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProjectCard) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"note\"" + ":")
		s.Note.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.Archived.Set {
			e.Comma()
		}
		if s.Archived.Set {
			e.RawStr("\"archived\"" + ":")
			s.Archived.Encode(e)
		}
	}
	{
		if s.ColumnName.Set {
			e.Comma()
		}
		if s.ColumnName.Set {
			e.RawStr("\"column_name\"" + ":")
			s.ColumnName.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.Comma()
		}
		if s.ProjectID.Set {
			e.RawStr("\"project_id\"" + ":")
			s.ProjectID.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"column_url\"" + ":")
		json.EncodeURI(e, s.ColumnURL)
	}
	{
		if s.ContentURL.Set {
			e.Comma()
		}
		if s.ContentURL.Set {
			e.RawStr("\"content_url\"" + ":")
			s.ContentURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"project_url\"" + ":")
		json.EncodeURI(e, s.ProjectURL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectCard = [13]string{
	0:  "url",
	1:  "id",
	2:  "node_id",
	3:  "note",
	4:  "creator",
	5:  "created_at",
	6:  "updated_at",
	7:  "archived",
	8:  "column_name",
	9:  "project_id",
	10: "column_url",
	11: "content_url",
	12: "project_url",
}

// Decode decodes ProjectCard from json.
func (s *ProjectCard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectCard to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "note":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "creator":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "column_name":
			if err := func() error {
				s.ColumnName.Reset()
				if err := s.ColumnName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"column_name\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "column_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ColumnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"column_url\"")
			}
		case "content_url":
			if err := func() error {
				s.ContentURL.Reset()
				if err := s.ContentURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_url\"")
			}
		case "project_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ProjectURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectCard")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00010100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectCard) {
					name = jsonFieldsNameOfProjectCard[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProjectColumn) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"project_url\"" + ":")
		json.EncodeURI(e, s.ProjectURL)
	}
	{
		e.Comma()

		e.RawStr("\"cards_url\"" + ":")
		json.EncodeURI(e, s.CardsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectColumn = [8]string{
	0: "url",
	1: "project_url",
	2: "cards_url",
	3: "id",
	4: "node_id",
	5: "name",
	6: "created_at",
	7: "updated_at",
}

// Decode decodes ProjectColumn from json.
func (s *ProjectColumn) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectColumn to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "project_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ProjectURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_url\"")
			}
		case "cards_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CardsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cards_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectColumn")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectColumn) {
					name = jsonFieldsNameOfProjectColumn[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ProjectOrganizationPermission as json.
func (s ProjectOrganizationPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ProjectOrganizationPermission from json.
func (s *ProjectOrganizationPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectOrganizationPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectOrganizationPermission(v) {
	case ProjectOrganizationPermissionRead:
		*s = ProjectOrganizationPermissionRead
	case ProjectOrganizationPermissionWrite:
		*s = ProjectOrganizationPermissionWrite
	case ProjectOrganizationPermissionAdmin:
		*s = ProjectOrganizationPermissionAdmin
	case ProjectOrganizationPermissionNone:
		*s = ProjectOrganizationPermissionNone
	default:
		*s = ProjectOrganizationPermission(v)
	}

	return nil
}

// Encode encodes ProjectsAddCollaboratorApplicationJSONForbidden as json.
func (s ProjectsAddCollaboratorApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsAddCollaboratorApplicationJSONForbidden from json.
func (s *ProjectsAddCollaboratorApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsAddCollaboratorApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsAddCollaboratorApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsAddCollaboratorApplicationJSONNotFound as json.
func (s ProjectsAddCollaboratorApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsAddCollaboratorApplicationJSONNotFound from json.
func (s *ProjectsAddCollaboratorApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsAddCollaboratorApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsAddCollaboratorApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsAddCollaboratorApplicationJSONUnauthorized as json.
func (s ProjectsAddCollaboratorApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsAddCollaboratorApplicationJSONUnauthorized from json.
func (s *ProjectsAddCollaboratorApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsAddCollaboratorApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsAddCollaboratorApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsAddCollaboratorReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsAddCollaboratorReq = [1]string{
	0: "permission",
}

// Decode decodes ProjectsAddCollaboratorReq from json.
func (s *ProjectsAddCollaboratorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsAddCollaboratorReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsAddCollaboratorReq")
	}

	return nil
}

// Encode encodes ProjectsAddCollaboratorReqPermission as json.
func (s ProjectsAddCollaboratorReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ProjectsAddCollaboratorReqPermission from json.
func (s *ProjectsAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsAddCollaboratorReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectsAddCollaboratorReqPermission(v) {
	case ProjectsAddCollaboratorReqPermissionRead:
		*s = ProjectsAddCollaboratorReqPermissionRead
	case ProjectsAddCollaboratorReqPermissionWrite:
		*s = ProjectsAddCollaboratorReqPermissionWrite
	case ProjectsAddCollaboratorReqPermissionAdmin:
		*s = ProjectsAddCollaboratorReqPermissionAdmin
	default:
		*s = ProjectsAddCollaboratorReqPermission(v)
	}

	return nil
}

// Encode encodes ProjectsCreateCardReq as json.
func (s ProjectsCreateCardReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ProjectsCreateCardReq0ProjectsCreateCardReq:
		s.ProjectsCreateCardReq0.Encode(e)
	case ProjectsCreateCardReq1ProjectsCreateCardReq:
		s.ProjectsCreateCardReq1.Encode(e)
	}
}

// Decode decodes ProjectsCreateCardReq from json.
func (s *ProjectsCreateCardReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateCardReq to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "note":
				found = true
				s.Type = ProjectsCreateCardReq0ProjectsCreateCardReq
			case "content_id":
				found = true
				s.Type = ProjectsCreateCardReq1ProjectsCreateCardReq
			case "content_type":
				found = true
				s.Type = ProjectsCreateCardReq1ProjectsCreateCardReq
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ProjectsCreateCardReq0ProjectsCreateCardReq:
		if err := s.ProjectsCreateCardReq0.Decode(d); err != nil {
			return err
		}
	case ProjectsCreateCardReq1ProjectsCreateCardReq:
		if err := s.ProjectsCreateCardReq1.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateCardReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"note\"" + ":")
		s.Note.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsCreateCardReq0 = [1]string{
	0: "note",
}

// Decode decodes ProjectsCreateCardReq0 from json.
func (s *ProjectsCreateCardReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateCardReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "note":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsCreateCardReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsCreateCardReq0) {
					name = jsonFieldsNameOfProjectsCreateCardReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateCardReq1) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content_id\"" + ":")
		e.Int(s.ContentID)
	}
	{
		e.Comma()

		e.RawStr("\"content_type\"" + ":")
		e.Str(s.ContentType)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsCreateCardReq1 = [2]string{
	0: "content_id",
	1: "content_type",
}

// Decode decodes ProjectsCreateCardReq1 from json.
func (s *ProjectsCreateCardReq1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateCardReq1 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ContentID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_id\"")
			}
		case "content_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ContentType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsCreateCardReq1")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsCreateCardReq1) {
					name = jsonFieldsNameOfProjectsCreateCardReq1[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ProjectsCreateColumnApplicationJSONForbidden as json.
func (s ProjectsCreateColumnApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateColumnApplicationJSONForbidden from json.
func (s *ProjectsCreateColumnApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateColumnApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateColumnApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateColumnApplicationJSONUnauthorized as json.
func (s ProjectsCreateColumnApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateColumnApplicationJSONUnauthorized from json.
func (s *ProjectsCreateColumnApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateColumnApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateColumnApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateColumnReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsCreateColumnReq = [1]string{
	0: "name",
}

// Decode decodes ProjectsCreateColumnReq from json.
func (s *ProjectsCreateColumnReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateColumnReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsCreateColumnReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsCreateColumnReq) {
					name = jsonFieldsNameOfProjectsCreateColumnReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ProjectsCreateForAuthenticatedUserApplicationJSONForbidden as json.
func (s ProjectsCreateForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ProjectsCreateForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateForAuthenticatedUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsCreateForAuthenticatedUserReq = [2]string{
	0: "name",
	1: "body",
}

// Decode decodes ProjectsCreateForAuthenticatedUserReq from json.
func (s *ProjectsCreateForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForAuthenticatedUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsCreateForAuthenticatedUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsCreateForAuthenticatedUserReq) {
					name = jsonFieldsNameOfProjectsCreateForAuthenticatedUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ProjectsCreateForOrgApplicationJSONForbidden as json.
func (s ProjectsCreateForOrgApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgApplicationJSONForbidden from json.
func (s *ProjectsCreateForOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForOrgApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForOrgApplicationJSONGone as json.
func (s ProjectsCreateForOrgApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgApplicationJSONGone from json.
func (s *ProjectsCreateForOrgApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForOrgApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForOrgApplicationJSONNotFound as json.
func (s ProjectsCreateForOrgApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgApplicationJSONNotFound from json.
func (s *ProjectsCreateForOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForOrgApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForOrgApplicationJSONUnauthorized as json.
func (s ProjectsCreateForOrgApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgApplicationJSONUnauthorized from json.
func (s *ProjectsCreateForOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForOrgApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateForOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsCreateForOrgReq = [2]string{
	0: "name",
	1: "body",
}

// Decode decodes ProjectsCreateForOrgReq from json.
func (s *ProjectsCreateForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsCreateForOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsCreateForOrgReq) {
					name = jsonFieldsNameOfProjectsCreateForOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ProjectsCreateForRepoApplicationJSONForbidden as json.
func (s ProjectsCreateForRepoApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoApplicationJSONForbidden from json.
func (s *ProjectsCreateForRepoApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForRepoApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForRepoApplicationJSONGone as json.
func (s ProjectsCreateForRepoApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoApplicationJSONGone from json.
func (s *ProjectsCreateForRepoApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForRepoApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForRepoApplicationJSONNotFound as json.
func (s ProjectsCreateForRepoApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoApplicationJSONNotFound from json.
func (s *ProjectsCreateForRepoApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForRepoApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForRepoApplicationJSONUnauthorized as json.
func (s ProjectsCreateForRepoApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoApplicationJSONUnauthorized from json.
func (s *ProjectsCreateForRepoApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForRepoApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateForRepoReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsCreateForRepoReq = [2]string{
	0: "name",
	1: "body",
}

// Decode decodes ProjectsCreateForRepoReq from json.
func (s *ProjectsCreateForRepoReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsCreateForRepoReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsCreateForRepoReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsCreateForRepoReq) {
					name = jsonFieldsNameOfProjectsCreateForRepoReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ProjectsDeleteApplicationJSONGone as json.
func (s ProjectsDeleteApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteApplicationJSONGone from json.
func (s *ProjectsDeleteApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ProjectsDeleteApplicationJSONNotFound as json.
func (s ProjectsDeleteApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteApplicationJSONNotFound from json.
func (s *ProjectsDeleteApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsDeleteApplicationJSONUnauthorized as json.
func (s ProjectsDeleteApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteApplicationJSONUnauthorized from json.
func (s *ProjectsDeleteApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsDeleteCardApplicationJSONNotFound as json.
func (s ProjectsDeleteCardApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteCardApplicationJSONNotFound from json.
func (s *ProjectsDeleteCardApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteCardApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteCardApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsDeleteCardApplicationJSONUnauthorized as json.
func (s ProjectsDeleteCardApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteCardApplicationJSONUnauthorized from json.
func (s *ProjectsDeleteCardApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteCardApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteCardApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsDeleteCardForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Errors != nil {
			e.RawStr("\"errors\"" + ":")
			e.ArrStart()
			if len(s.Errors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Errors[0]
					e.Str(elem)
				}
				for _, elem := range s.Errors[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsDeleteCardForbidden = [3]string{
	0: "message",
	1: "documentation_url",
	2: "errors",
}

// Decode decodes ProjectsDeleteCardForbidden from json.
func (s *ProjectsDeleteCardForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteCardForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsDeleteCardForbidden")
	}

	return nil
}

// Encode encodes ProjectsDeleteColumnApplicationJSONForbidden as json.
func (s ProjectsDeleteColumnApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteColumnApplicationJSONForbidden from json.
func (s *ProjectsDeleteColumnApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteColumnApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteColumnApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsDeleteColumnApplicationJSONUnauthorized as json.
func (s ProjectsDeleteColumnApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteColumnApplicationJSONUnauthorized from json.
func (s *ProjectsDeleteColumnApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteColumnApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteColumnApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsDeleteForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Errors != nil {
			e.RawStr("\"errors\"" + ":")
			e.ArrStart()
			if len(s.Errors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Errors[0]
					e.Str(elem)
				}
				for _, elem := range s.Errors[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsDeleteForbidden = [3]string{
	0: "message",
	1: "documentation_url",
	2: "errors",
}

// Decode decodes ProjectsDeleteForbidden from json.
func (s *ProjectsDeleteForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsDeleteForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsDeleteForbidden")
	}

	return nil
}

// Encode encodes ProjectsGetApplicationJSONForbidden as json.
func (s ProjectsGetApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetApplicationJSONForbidden from json.
func (s *ProjectsGetApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsGetApplicationJSONUnauthorized as json.
func (s ProjectsGetApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetApplicationJSONUnauthorized from json.
func (s *ProjectsGetApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsGetCardApplicationJSONForbidden as json.
func (s ProjectsGetCardApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetCardApplicationJSONForbidden from json.
func (s *ProjectsGetCardApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetCardApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetCardApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsGetCardApplicationJSONNotFound as json.
func (s ProjectsGetCardApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetCardApplicationJSONNotFound from json.
func (s *ProjectsGetCardApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetCardApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetCardApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsGetCardApplicationJSONUnauthorized as json.
func (s ProjectsGetCardApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetCardApplicationJSONUnauthorized from json.
func (s *ProjectsGetCardApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetCardApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetCardApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsGetColumnApplicationJSONForbidden as json.
func (s ProjectsGetColumnApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetColumnApplicationJSONForbidden from json.
func (s *ProjectsGetColumnApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetColumnApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetColumnApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsGetColumnApplicationJSONNotFound as json.
func (s ProjectsGetColumnApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetColumnApplicationJSONNotFound from json.
func (s *ProjectsGetColumnApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetColumnApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetColumnApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsGetColumnApplicationJSONUnauthorized as json.
func (s ProjectsGetColumnApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetColumnApplicationJSONUnauthorized from json.
func (s *ProjectsGetColumnApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetColumnApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetColumnApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsGetPermissionForUserApplicationJSONForbidden as json.
func (s ProjectsGetPermissionForUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetPermissionForUserApplicationJSONForbidden from json.
func (s *ProjectsGetPermissionForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetPermissionForUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetPermissionForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsGetPermissionForUserApplicationJSONNotFound as json.
func (s ProjectsGetPermissionForUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetPermissionForUserApplicationJSONNotFound from json.
func (s *ProjectsGetPermissionForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetPermissionForUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetPermissionForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsGetPermissionForUserApplicationJSONUnauthorized as json.
func (s ProjectsGetPermissionForUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetPermissionForUserApplicationJSONUnauthorized from json.
func (s *ProjectsGetPermissionForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsGetPermissionForUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetPermissionForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsListCardsApplicationJSONForbidden as json.
func (s ProjectsListCardsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCardsApplicationJSONForbidden from json.
func (s *ProjectsListCardsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListCardsApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCardsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsListCardsApplicationJSONUnauthorized as json.
func (s ProjectsListCardsApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCardsApplicationJSONUnauthorized from json.
func (s *ProjectsListCardsApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListCardsApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCardsApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsListCardsOKApplicationJSON as json.
func (s ProjectsListCardsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ProjectCard(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListCardsOKApplicationJSON from json.
func (s *ProjectsListCardsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListCardsOKApplicationJSON to nil")
	}
	var unwrapped []ProjectCard
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ProjectCard
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCardsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ProjectsListCollaboratorsApplicationJSONForbidden as json.
func (s ProjectsListCollaboratorsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCollaboratorsApplicationJSONForbidden from json.
func (s *ProjectsListCollaboratorsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListCollaboratorsApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCollaboratorsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsListCollaboratorsApplicationJSONNotFound as json.
func (s ProjectsListCollaboratorsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCollaboratorsApplicationJSONNotFound from json.
func (s *ProjectsListCollaboratorsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListCollaboratorsApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCollaboratorsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsListCollaboratorsApplicationJSONUnauthorized as json.
func (s ProjectsListCollaboratorsApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCollaboratorsApplicationJSONUnauthorized from json.
func (s *ProjectsListCollaboratorsApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListCollaboratorsApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCollaboratorsApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsListCollaboratorsOKApplicationJSON as json.
func (s ProjectsListCollaboratorsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListCollaboratorsOKApplicationJSON from json.
func (s *ProjectsListCollaboratorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListCollaboratorsOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCollaboratorsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ProjectsListColumnsApplicationJSONForbidden as json.
func (s ProjectsListColumnsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListColumnsApplicationJSONForbidden from json.
func (s *ProjectsListColumnsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListColumnsApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListColumnsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsListColumnsApplicationJSONUnauthorized as json.
func (s ProjectsListColumnsApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListColumnsApplicationJSONUnauthorized from json.
func (s *ProjectsListColumnsApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListColumnsApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListColumnsApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsListColumnsOKApplicationJSON as json.
func (s ProjectsListColumnsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ProjectColumn(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListColumnsOKApplicationJSON from json.
func (s *ProjectsListColumnsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListColumnsOKApplicationJSON to nil")
	}
	var unwrapped []ProjectColumn
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ProjectColumn
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListColumnsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ProjectsListForOrgOKApplicationJSON as json.
func (s ProjectsListForOrgOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Project(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListForOrgOKApplicationJSON from json.
func (s *ProjectsListForOrgOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListForOrgOKApplicationJSON to nil")
	}
	var unwrapped []Project
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Project
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForOrgOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ProjectsListForRepoApplicationJSONForbidden as json.
func (s ProjectsListForRepoApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoApplicationJSONForbidden from json.
func (s *ProjectsListForRepoApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListForRepoApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsListForRepoApplicationJSONGone as json.
func (s ProjectsListForRepoApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoApplicationJSONGone from json.
func (s *ProjectsListForRepoApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListForRepoApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ProjectsListForRepoApplicationJSONNotFound as json.
func (s ProjectsListForRepoApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoApplicationJSONNotFound from json.
func (s *ProjectsListForRepoApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListForRepoApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsListForRepoApplicationJSONUnauthorized as json.
func (s ProjectsListForRepoApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoApplicationJSONUnauthorized from json.
func (s *ProjectsListForRepoApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListForRepoApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsListForRepoOKApplicationJSON as json.
func (s ProjectsListForRepoOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Project(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListForRepoOKApplicationJSON from json.
func (s *ProjectsListForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListForRepoOKApplicationJSON to nil")
	}
	var unwrapped []Project
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Project
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ProjectsListForUserOKApplicationJSON as json.
func (s ProjectsListForUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Project(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListForUserOKApplicationJSON from json.
func (s *ProjectsListForUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsListForUserOKApplicationJSON to nil")
	}
	var unwrapped []Project
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Project
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardCreated) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsMoveCardCreated = [0]string{}

// Decode decodes ProjectsMoveCardCreated from json.
func (s ProjectsMoveCardCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveCardCreated to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveCardCreated")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Errors != nil {
			e.RawStr("\"errors\"" + ":")
			e.ArrStart()
			if len(s.Errors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Errors[0]
					elem.Encode(e)
				}
				for _, elem := range s.Errors[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsMoveCardForbidden = [3]string{
	0: "message",
	1: "documentation_url",
	2: "errors",
}

// Decode decodes ProjectsMoveCardForbidden from json.
func (s *ProjectsMoveCardForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveCardForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectsMoveCardForbiddenErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveCardForbidden")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardForbiddenErrorsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Code.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Code.Set {
			e.RawStr("\"code\"" + ":")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Resource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resource.Set {
			e.RawStr("\"resource\"" + ":")
			s.Resource.Encode(e)
		}
	}
	{
		if s.Field.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Field.Set {
			e.RawStr("\"field\"" + ":")
			s.Field.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsMoveCardForbiddenErrorsItem = [4]string{
	0: "code",
	1: "message",
	2: "resource",
	3: "field",
}

// Decode decodes ProjectsMoveCardForbiddenErrorsItem from json.
func (s *ProjectsMoveCardForbiddenErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveCardForbiddenErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "field":
			if err := func() error {
				s.Field.Reset()
				if err := s.Field.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"field\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveCardForbiddenErrorsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"position\"" + ":")
		e.Str(s.Position)
	}
	{
		if s.ColumnID.Set {
			e.Comma()
		}
		if s.ColumnID.Set {
			e.RawStr("\"column_id\"" + ":")
			s.ColumnID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsMoveCardReq = [2]string{
	0: "position",
	1: "column_id",
}

// Decode decodes ProjectsMoveCardReq from json.
func (s *ProjectsMoveCardReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveCardReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "position":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Position = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "column_id":
			if err := func() error {
				s.ColumnID.Reset()
				if err := s.ColumnID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"column_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveCardReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsMoveCardReq) {
					name = jsonFieldsNameOfProjectsMoveCardReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardServiceUnavailable) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Code.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Code.Set {
			e.RawStr("\"code\"" + ":")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Errors != nil {
			e.RawStr("\"errors\"" + ":")
			e.ArrStart()
			if len(s.Errors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Errors[0]
					elem.Encode(e)
				}
				for _, elem := range s.Errors[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsMoveCardServiceUnavailable = [4]string{
	0: "code",
	1: "message",
	2: "documentation_url",
	3: "errors",
}

// Decode decodes ProjectsMoveCardServiceUnavailable from json.
func (s *ProjectsMoveCardServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveCardServiceUnavailable to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectsMoveCardServiceUnavailableErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveCardServiceUnavailable")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardServiceUnavailableErrorsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Code.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Code.Set {
			e.RawStr("\"code\"" + ":")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsMoveCardServiceUnavailableErrorsItem = [2]string{
	0: "code",
	1: "message",
}

// Decode decodes ProjectsMoveCardServiceUnavailableErrorsItem from json.
func (s *ProjectsMoveCardServiceUnavailableErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveCardServiceUnavailableErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveCardServiceUnavailableErrorsItem")
	}

	return nil
}

// Encode encodes ProjectsMoveColumnApplicationJSONForbidden as json.
func (s ProjectsMoveColumnApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsMoveColumnApplicationJSONForbidden from json.
func (s *ProjectsMoveColumnApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveColumnApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsMoveColumnApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsMoveColumnApplicationJSONUnauthorized as json.
func (s ProjectsMoveColumnApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsMoveColumnApplicationJSONUnauthorized from json.
func (s *ProjectsMoveColumnApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveColumnApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsMoveColumnApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsMoveColumnCreated) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsMoveColumnCreated = [0]string{}

// Decode decodes ProjectsMoveColumnCreated from json.
func (s ProjectsMoveColumnCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveColumnCreated to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveColumnCreated")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsMoveColumnReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"position\"" + ":")
		e.Str(s.Position)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsMoveColumnReq = [1]string{
	0: "position",
}

// Decode decodes ProjectsMoveColumnReq from json.
func (s *ProjectsMoveColumnReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsMoveColumnReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "position":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Position = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsMoveColumnReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsMoveColumnReq) {
					name = jsonFieldsNameOfProjectsMoveColumnReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ProjectsRemoveCollaboratorApplicationJSONForbidden as json.
func (s ProjectsRemoveCollaboratorApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsRemoveCollaboratorApplicationJSONForbidden from json.
func (s *ProjectsRemoveCollaboratorApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsRemoveCollaboratorApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsRemoveCollaboratorApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsRemoveCollaboratorApplicationJSONNotFound as json.
func (s ProjectsRemoveCollaboratorApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsRemoveCollaboratorApplicationJSONNotFound from json.
func (s *ProjectsRemoveCollaboratorApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsRemoveCollaboratorApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsRemoveCollaboratorApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsRemoveCollaboratorApplicationJSONUnauthorized as json.
func (s ProjectsRemoveCollaboratorApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsRemoveCollaboratorApplicationJSONUnauthorized from json.
func (s *ProjectsRemoveCollaboratorApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsRemoveCollaboratorApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsRemoveCollaboratorApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateApplicationJSONGone as json.
func (s ProjectsUpdateApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateApplicationJSONGone from json.
func (s *ProjectsUpdateApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateApplicationJSONUnauthorized as json.
func (s ProjectsUpdateApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateApplicationJSONUnauthorized from json.
func (s *ProjectsUpdateApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateCardApplicationJSONForbidden as json.
func (s ProjectsUpdateCardApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateCardApplicationJSONForbidden from json.
func (s *ProjectsUpdateCardApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateCardApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateCardApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateCardApplicationJSONNotFound as json.
func (s ProjectsUpdateCardApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateCardApplicationJSONNotFound from json.
func (s *ProjectsUpdateCardApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateCardApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateCardApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateCardApplicationJSONUnauthorized as json.
func (s ProjectsUpdateCardApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateCardApplicationJSONUnauthorized from json.
func (s *ProjectsUpdateCardApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateCardApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateCardApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsUpdateCardReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Note.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Note.Set {
			e.RawStr("\"note\"" + ":")
			s.Note.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Archived.Set {
			e.RawStr("\"archived\"" + ":")
			s.Archived.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsUpdateCardReq = [2]string{
	0: "note",
	1: "archived",
}

// Decode decodes ProjectsUpdateCardReq from json.
func (s *ProjectsUpdateCardReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateCardReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsUpdateCardReq")
	}

	return nil
}

// Encode encodes ProjectsUpdateColumnApplicationJSONForbidden as json.
func (s ProjectsUpdateColumnApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateColumnApplicationJSONForbidden from json.
func (s *ProjectsUpdateColumnApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateColumnApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateColumnApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateColumnApplicationJSONUnauthorized as json.
func (s ProjectsUpdateColumnApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateColumnApplicationJSONUnauthorized from json.
func (s *ProjectsUpdateColumnApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateColumnApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateColumnApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsUpdateColumnReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsUpdateColumnReq = [1]string{
	0: "name",
}

// Decode decodes ProjectsUpdateColumnReq from json.
func (s *ProjectsUpdateColumnReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateColumnReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsUpdateColumnReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectsUpdateColumnReq) {
					name = jsonFieldsNameOfProjectsUpdateColumnReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsUpdateForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Errors != nil {
			e.RawStr("\"errors\"" + ":")
			e.ArrStart()
			if len(s.Errors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Errors[0]
					e.Str(elem)
				}
				for _, elem := range s.Errors[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsUpdateForbidden = [3]string{
	0: "message",
	1: "documentation_url",
	2: "errors",
}

// Decode decodes ProjectsUpdateForbidden from json.
func (s *ProjectsUpdateForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsUpdateForbidden")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsUpdateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.OrganizationPermission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationPermission.Set {
			e.RawStr("\"organization_permission\"" + ":")
			s.OrganizationPermission.Encode(e)
		}
	}
	{
		if s.Private.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProjectsUpdateReq = [5]string{
	0: "name",
	1: "body",
	2: "state",
	3: "organization_permission",
	4: "private",
}

// Decode decodes ProjectsUpdateReq from json.
func (s *ProjectsUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "organization_permission":
			if err := func() error {
				s.OrganizationPermission.Reset()
				if err := s.OrganizationPermission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_permission\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectsUpdateReq")
	}

	return nil
}

// Encode encodes ProjectsUpdateReqOrganizationPermission as json.
func (s ProjectsUpdateReqOrganizationPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ProjectsUpdateReqOrganizationPermission from json.
func (s *ProjectsUpdateReqOrganizationPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectsUpdateReqOrganizationPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectsUpdateReqOrganizationPermission(v) {
	case ProjectsUpdateReqOrganizationPermissionRead:
		*s = ProjectsUpdateReqOrganizationPermissionRead
	case ProjectsUpdateReqOrganizationPermissionWrite:
		*s = ProjectsUpdateReqOrganizationPermissionWrite
	case ProjectsUpdateReqOrganizationPermissionAdmin:
		*s = ProjectsUpdateReqOrganizationPermissionAdmin
	case ProjectsUpdateReqOrganizationPermissionNone:
		*s = ProjectsUpdateReqOrganizationPermissionNone
	default:
		*s = ProjectsUpdateReqOrganizationPermission(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProtectedBranch) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.RequiredStatusChecks.Set {
			e.Comma()
		}
		if s.RequiredStatusChecks.Set {
			e.RawStr("\"required_status_checks\"" + ":")
			s.RequiredStatusChecks.Encode(e)
		}
	}
	{
		if s.RequiredPullRequestReviews.Set {
			e.Comma()
		}
		if s.RequiredPullRequestReviews.Set {
			e.RawStr("\"required_pull_request_reviews\"" + ":")
			s.RequiredPullRequestReviews.Encode(e)
		}
	}
	{
		if s.RequiredSignatures.Set {
			e.Comma()
		}
		if s.RequiredSignatures.Set {
			e.RawStr("\"required_signatures\"" + ":")
			s.RequiredSignatures.Encode(e)
		}
	}
	{
		if s.EnforceAdmins.Set {
			e.Comma()
		}
		if s.EnforceAdmins.Set {
			e.RawStr("\"enforce_admins\"" + ":")
			s.EnforceAdmins.Encode(e)
		}
	}
	{
		if s.RequiredLinearHistory.Set {
			e.Comma()
		}
		if s.RequiredLinearHistory.Set {
			e.RawStr("\"required_linear_history\"" + ":")
			s.RequiredLinearHistory.Encode(e)
		}
	}
	{
		if s.AllowForcePushes.Set {
			e.Comma()
		}
		if s.AllowForcePushes.Set {
			e.RawStr("\"allow_force_pushes\"" + ":")
			s.AllowForcePushes.Encode(e)
		}
	}
	{
		if s.AllowDeletions.Set {
			e.Comma()
		}
		if s.AllowDeletions.Set {
			e.RawStr("\"allow_deletions\"" + ":")
			s.AllowDeletions.Encode(e)
		}
	}
	{
		if s.Restrictions.Set {
			e.Comma()
		}
		if s.Restrictions.Set {
			e.RawStr("\"restrictions\"" + ":")
			s.Restrictions.Encode(e)
		}
	}
	{
		if s.RequiredConversationResolution.Set {
			e.Comma()
		}
		if s.RequiredConversationResolution.Set {
			e.RawStr("\"required_conversation_resolution\"" + ":")
			s.RequiredConversationResolution.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProtectedBranch = [10]string{
	0: "url",
	1: "required_status_checks",
	2: "required_pull_request_reviews",
	3: "required_signatures",
	4: "enforce_admins",
	5: "required_linear_history",
	6: "allow_force_pushes",
	7: "allow_deletions",
	8: "restrictions",
	9: "required_conversation_resolution",
}

// Decode decodes ProtectedBranch from json.
func (s *ProtectedBranch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranch to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "required_status_checks":
			if err := func() error {
				s.RequiredStatusChecks.Reset()
				if err := s.RequiredStatusChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_status_checks\"")
			}
		case "required_pull_request_reviews":
			if err := func() error {
				s.RequiredPullRequestReviews.Reset()
				if err := s.RequiredPullRequestReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_pull_request_reviews\"")
			}
		case "required_signatures":
			if err := func() error {
				s.RequiredSignatures.Reset()
				if err := s.RequiredSignatures.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_signatures\"")
			}
		case "enforce_admins":
			if err := func() error {
				s.EnforceAdmins.Reset()
				if err := s.EnforceAdmins.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforce_admins\"")
			}
		case "required_linear_history":
			if err := func() error {
				s.RequiredLinearHistory.Reset()
				if err := s.RequiredLinearHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_linear_history\"")
			}
		case "allow_force_pushes":
			if err := func() error {
				s.AllowForcePushes.Reset()
				if err := s.AllowForcePushes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_force_pushes\"")
			}
		case "allow_deletions":
			if err := func() error {
				s.AllowDeletions.Reset()
				if err := s.AllowDeletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_deletions\"")
			}
		case "restrictions":
			if err := func() error {
				s.Restrictions.Reset()
				if err := s.Restrictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restrictions\"")
			}
		case "required_conversation_resolution":
			if err := func() error {
				s.RequiredConversationResolution.Reset()
				if err := s.RequiredConversationResolution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_conversation_resolution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranch) {
					name = jsonFieldsNameOfProtectedBranch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProtectedBranchAdminEnforced) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"enabled\"" + ":")
		e.Bool(s.Enabled)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProtectedBranchAdminEnforced = [2]string{
	0: "url",
	1: "enabled",
}

// Decode decodes ProtectedBranchAdminEnforced from json.
func (s *ProtectedBranchAdminEnforced) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchAdminEnforced to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchAdminEnforced")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchAdminEnforced) {
					name = jsonFieldsNameOfProtectedBranchAdminEnforced[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProtectedBranchAllowDeletions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		{
			if !first {
				e.Comma()
			}
			first = false

			e.RawStr("\"enabled\"" + ":")
			e.Bool(s.Enabled)
		}
	}
	for k, elem := range s.AdditionalProps {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProtectedBranchAllowDeletions = [1]string{
	0: "enabled",
}

// Decode decodes ProtectedBranchAllowDeletions from json.
func (s *ProtectedBranchAllowDeletions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchAllowDeletions to nil")
	}
	var requiredBitSet [1]uint8

	m := s.AdditionalProps
	if m == nil {
		m = map[string]jx.Raw{}
		s.AdditionalProps = m
	}
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchAllowDeletions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchAllowDeletions) {
					name = jsonFieldsNameOfProtectedBranchAllowDeletions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProtectedBranchAllowForcePushes) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		{
			if !first {
				e.Comma()
			}
			first = false

			e.RawStr("\"enabled\"" + ":")
			e.Bool(s.Enabled)
		}
	}
	for k, elem := range s.AdditionalProps {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProtectedBranchAllowForcePushes = [1]string{
	0: "enabled",
}

// Decode decodes ProtectedBranchAllowForcePushes from json.
func (s *ProtectedBranchAllowForcePushes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchAllowForcePushes to nil")
	}
	var requiredBitSet [1]uint8

	m := s.AdditionalProps
	if m == nil {
		m = map[string]jx.Raw{}
		s.AdditionalProps = m
	}
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchAllowForcePushes")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchAllowForcePushes) {
					name = jsonFieldsNameOfProtectedBranchAllowForcePushes[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProtectedBranchEnforceAdmins) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		{
			if !first {
				e.Comma()
			}
			first = false

			e.RawStr("\"url\"" + ":")
			json.EncodeURI(e, s.URL)
		}
		{
			e.Comma()

			e.RawStr("\"enabled\"" + ":")
			e.Bool(s.Enabled)
		}
	}
	for k, elem := range s.AdditionalProps {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProtectedBranchEnforceAdmins = [2]string{
	0: "url",
	1: "enabled",
}

// Decode decodes ProtectedBranchEnforceAdmins from json.
func (s *ProtectedBranchEnforceAdmins) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchEnforceAdmins to nil")
	}
	var requiredBitSet [1]uint8

	m := s.AdditionalProps
	if m == nil {
		m = map[string]jx.Raw{}
		s.AdditionalProps = m
	}
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchEnforceAdmins")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchEnforceAdmins) {
					name = jsonFieldsNameOfProtectedBranchEnforceAdmins[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProtectedBranchPullRequestReview) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.DismissalRestrictions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DismissalRestrictions.Set {
			e.RawStr("\"dismissal_restrictions\"" + ":")
			s.DismissalRestrictions.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"dismiss_stale_reviews\"" + ":")
		e.Bool(s.DismissStaleReviews)
	}
	{
		e.Comma()

		e.RawStr("\"require_code_owner_reviews\"" + ":")
		e.Bool(s.RequireCodeOwnerReviews)
	}
	{
		if s.RequiredApprovingReviewCount.Set {
			e.Comma()
		}
		if s.RequiredApprovingReviewCount.Set {
			e.RawStr("\"required_approving_review_count\"" + ":")
			s.RequiredApprovingReviewCount.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProtectedBranchPullRequestReview = [5]string{
	0: "url",
	1: "dismissal_restrictions",
	2: "dismiss_stale_reviews",
	3: "require_code_owner_reviews",
	4: "required_approving_review_count",
}

// Decode decodes ProtectedBranchPullRequestReview from json.
func (s *ProtectedBranchPullRequestReview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchPullRequestReview to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "dismissal_restrictions":
			if err := func() error {
				s.DismissalRestrictions.Reset()
				if err := s.DismissalRestrictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissal_restrictions\"")
			}
		case "dismiss_stale_reviews":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.DismissStaleReviews = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismiss_stale_reviews\"")
			}
		case "require_code_owner_reviews":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.RequireCodeOwnerReviews = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"require_code_owner_reviews\"")
			}
		case "required_approving_review_count":
			if err := func() error {
				s.RequiredApprovingReviewCount.Reset()
				if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_approving_review_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchPullRequestReview")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchPullRequestReview) {
					name = jsonFieldsNameOfProtectedBranchPullRequestReview[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProtectedBranchPullRequestReviewDismissalRestrictions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Users != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Users != nil {
			e.RawStr("\"users\"" + ":")
			e.ArrStart()
			if len(s.Users) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Users[0]
					elem.Encode(e)
				}
				for _, elem := range s.Users[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Teams != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Teams != nil {
			e.RawStr("\"teams\"" + ":")
			e.ArrStart()
			if len(s.Teams) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Teams[0]
					elem.Encode(e)
				}
				for _, elem := range s.Teams[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.UsersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UsersURL.Set {
			e.RawStr("\"users_url\"" + ":")
			s.UsersURL.Encode(e)
		}
	}
	{
		if s.TeamsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TeamsURL.Set {
			e.RawStr("\"teams_url\"" + ":")
			s.TeamsURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProtectedBranchPullRequestReviewDismissalRestrictions = [5]string{
	0: "users",
	1: "teams",
	2: "url",
	3: "users_url",
	4: "teams_url",
}

// Decode decodes ProtectedBranchPullRequestReviewDismissalRestrictions from json.
func (s *ProtectedBranchPullRequestReviewDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchPullRequestReviewDismissalRestrictions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			if err := func() error {
				s.Users = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleUser
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "teams":
			if err := func() error {
				s.Teams = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Team
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "users_url":
			if err := func() error {
				s.UsersURL.Reset()
				if err := s.UsersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users_url\"")
			}
		case "teams_url":
			if err := func() error {
				s.TeamsURL.Reset()
				if err := s.TeamsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchPullRequestReviewDismissalRestrictions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProtectedBranchRequiredConversationResolution) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		{
			if s.Enabled.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Enabled.Set {
				e.RawStr("\"enabled\"" + ":")
				s.Enabled.Encode(e)
			}
		}
	}
	for k, elem := range s.AdditionalProps {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProtectedBranchRequiredConversationResolution = [1]string{
	0: "enabled",
}

// Decode decodes ProtectedBranchRequiredConversationResolution from json.
func (s *ProtectedBranchRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchRequiredConversationResolution to nil")
	}

	m := s.AdditionalProps
	if m == nil {
		m = map[string]jx.Raw{}
		s.AdditionalProps = m
	}
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchRequiredConversationResolution")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProtectedBranchRequiredLinearHistory) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		{
			if !first {
				e.Comma()
			}
			first = false

			e.RawStr("\"enabled\"" + ":")
			e.Bool(s.Enabled)
		}
	}
	for k, elem := range s.AdditionalProps {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProtectedBranchRequiredLinearHistory = [1]string{
	0: "enabled",
}

// Decode decodes ProtectedBranchRequiredLinearHistory from json.
func (s *ProtectedBranchRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchRequiredLinearHistory to nil")
	}
	var requiredBitSet [1]uint8

	m := s.AdditionalProps
	if m == nil {
		m = map[string]jx.Raw{}
		s.AdditionalProps = m
	}
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchRequiredLinearHistory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchRequiredLinearHistory) {
					name = jsonFieldsNameOfProtectedBranchRequiredLinearHistory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProtectedBranchRequiredPullRequestReviews) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.DismissStaleReviews.Set {
			e.Comma()
		}
		if s.DismissStaleReviews.Set {
			e.RawStr("\"dismiss_stale_reviews\"" + ":")
			s.DismissStaleReviews.Encode(e)
		}
	}
	{
		if s.RequireCodeOwnerReviews.Set {
			e.Comma()
		}
		if s.RequireCodeOwnerReviews.Set {
			e.RawStr("\"require_code_owner_reviews\"" + ":")
			s.RequireCodeOwnerReviews.Encode(e)
		}
	}
	{
		if s.RequiredApprovingReviewCount.Set {
			e.Comma()
		}
		if s.RequiredApprovingReviewCount.Set {
			e.RawStr("\"required_approving_review_count\"" + ":")
			s.RequiredApprovingReviewCount.Encode(e)
		}
	}
	{
		if s.DismissalRestrictions.Set {
			e.Comma()
		}
		if s.DismissalRestrictions.Set {
			e.RawStr("\"dismissal_restrictions\"" + ":")
			s.DismissalRestrictions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProtectedBranchRequiredPullRequestReviews = [5]string{
	0: "url",
	1: "dismiss_stale_reviews",
	2: "require_code_owner_reviews",
	3: "required_approving_review_count",
	4: "dismissal_restrictions",
}

// Decode decodes ProtectedBranchRequiredPullRequestReviews from json.
func (s *ProtectedBranchRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchRequiredPullRequestReviews to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "dismiss_stale_reviews":
			if err := func() error {
				s.DismissStaleReviews.Reset()
				if err := s.DismissStaleReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismiss_stale_reviews\"")
			}
		case "require_code_owner_reviews":
			if err := func() error {
				s.RequireCodeOwnerReviews.Reset()
				if err := s.RequireCodeOwnerReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"require_code_owner_reviews\"")
			}
		case "required_approving_review_count":
			if err := func() error {
				s.RequiredApprovingReviewCount.Reset()
				if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_approving_review_count\"")
			}
		case "dismissal_restrictions":
			if err := func() error {
				s.DismissalRestrictions.Reset()
				if err := s.DismissalRestrictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissal_restrictions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchRequiredPullRequestReviews")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchRequiredPullRequestReviews) {
					name = jsonFieldsNameOfProtectedBranchRequiredPullRequestReviews[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"users_url\"" + ":")
		json.EncodeURI(e, s.UsersURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"users\"" + ":")
		e.ArrStart()
		if len(s.Users) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Users[0]
				elem.Encode(e)
			}
			for _, elem := range s.Users[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"teams\"" + ":")
		e.ArrStart()
		if len(s.Teams) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Teams[0]
				elem.Encode(e)
			}
			for _, elem := range s.Teams[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProtectedBranchRequiredPullRequestReviewsDismissalRestrictions = [5]string{
	0: "url",
	1: "users_url",
	2: "teams_url",
	3: "users",
	4: "teams",
}

// Decode decodes ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions from json.
func (s *ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "users_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.UsersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users_url\"")
			}
		case "teams_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "users":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Users = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleUser
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "teams":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Teams = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Team
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) {
					name = jsonFieldsNameOfProtectedBranchRequiredPullRequestReviewsDismissalRestrictions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ProtectedBranchRequiredSignatures) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"enabled\"" + ":")
		e.Bool(s.Enabled)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfProtectedBranchRequiredSignatures = [2]string{
	0: "url",
	1: "enabled",
}

// Decode decodes ProtectedBranchRequiredSignatures from json.
func (s *ProtectedBranchRequiredSignatures) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtectedBranchRequiredSignatures to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtectedBranchRequiredSignatures")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProtectedBranchRequiredSignatures) {
					name = jsonFieldsNameOfProtectedBranchRequiredSignatures[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PublicUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		{
			if !first {
				e.Comma()
			}
			first = false

			e.RawStr("\"login\"" + ":")
			e.Str(s.Login)
		}
		{
			e.Comma()

			e.RawStr("\"id\"" + ":")
			e.Int(s.ID)
		}
		{
			e.Comma()

			e.RawStr("\"node_id\"" + ":")
			e.Str(s.NodeID)
		}
		{
			e.Comma()

			e.RawStr("\"avatar_url\"" + ":")
			json.EncodeURI(e, s.AvatarURL)
		}
		{
			e.Comma()

			e.RawStr("\"gravatar_id\"" + ":")
			s.GravatarID.Encode(e)
		}
		{
			e.Comma()

			e.RawStr("\"url\"" + ":")
			json.EncodeURI(e, s.URL)
		}
		{
			e.Comma()

			e.RawStr("\"html_url\"" + ":")
			json.EncodeURI(e, s.HTMLURL)
		}
		{
			e.Comma()

			e.RawStr("\"followers_url\"" + ":")
			json.EncodeURI(e, s.FollowersURL)
		}
		{
			e.Comma()

			e.RawStr("\"following_url\"" + ":")
			e.Str(s.FollowingURL)
		}
		{
			e.Comma()

			e.RawStr("\"gists_url\"" + ":")
			e.Str(s.GistsURL)
		}
		{
			e.Comma()

			e.RawStr("\"starred_url\"" + ":")
			e.Str(s.StarredURL)
		}
		{
			e.Comma()

			e.RawStr("\"subscriptions_url\"" + ":")
			json.EncodeURI(e, s.SubscriptionsURL)
		}
		{
			e.Comma()

			e.RawStr("\"organizations_url\"" + ":")
			json.EncodeURI(e, s.OrganizationsURL)
		}
		{
			e.Comma()

			e.RawStr("\"repos_url\"" + ":")
			json.EncodeURI(e, s.ReposURL)
		}
		{
			e.Comma()

			e.RawStr("\"events_url\"" + ":")
			e.Str(s.EventsURL)
		}
		{
			e.Comma()

			e.RawStr("\"received_events_url\"" + ":")
			json.EncodeURI(e, s.ReceivedEventsURL)
		}
		{
			e.Comma()

			e.RawStr("\"type\"" + ":")
			e.Str(s.Type)
		}
		{
			e.Comma()

			e.RawStr("\"site_admin\"" + ":")
			e.Bool(s.SiteAdmin)
		}
		{
			e.Comma()

			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
		{
			e.Comma()

			e.RawStr("\"company\"" + ":")
			s.Company.Encode(e)
		}
		{
			e.Comma()

			e.RawStr("\"blog\"" + ":")
			s.Blog.Encode(e)
		}
		{
			e.Comma()

			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
		{
			e.Comma()

			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
		{
			e.Comma()

			e.RawStr("\"hireable\"" + ":")
			s.Hireable.Encode(e)
		}
		{
			e.Comma()

			e.RawStr("\"bio\"" + ":")
			s.Bio.Encode(e)
		}
		{
			if s.TwitterUsername.Set {
				e.Comma()
			}
			if s.TwitterUsername.Set {
				e.RawStr("\"twitter_username\"" + ":")
				s.TwitterUsername.Encode(e)
			}
		}
		{
			e.Comma()

			e.RawStr("\"public_repos\"" + ":")
			e.Int(s.PublicRepos)
		}
		{
			e.Comma()

			e.RawStr("\"public_gists\"" + ":")
			e.Int(s.PublicGists)
		}
		{
			e.Comma()

			e.RawStr("\"followers\"" + ":")
			e.Int(s.Followers)
		}
		{
			e.Comma()

			e.RawStr("\"following\"" + ":")
			e.Int(s.Following)
		}
		{
			e.Comma()

			e.RawStr("\"created_at\"" + ":")
			json.EncodeDateTime(e, s.CreatedAt)
		}
		{
			e.Comma()

			e.RawStr("\"updated_at\"" + ":")
			json.EncodeDateTime(e, s.UpdatedAt)
		}
		{
			if s.Plan.Set {
				e.Comma()
			}
			if s.Plan.Set {
				e.RawStr("\"plan\"" + ":")
				s.Plan.Encode(e)
			}
		}
		{
			if s.SuspendedAt.Set {
				e.Comma()
			}
			if s.SuspendedAt.Set {
				e.RawStr("\"suspended_at\"" + ":")
				s.SuspendedAt.Encode(e, json.EncodeDateTime)
			}
		}
		{
			if s.PrivateGists.Set {
				e.Comma()
			}
			if s.PrivateGists.Set {
				e.RawStr("\"private_gists\"" + ":")
				s.PrivateGists.Encode(e)
			}
		}
		{
			if s.TotalPrivateRepos.Set {
				e.Comma()
			}
			if s.TotalPrivateRepos.Set {
				e.RawStr("\"total_private_repos\"" + ":")
				s.TotalPrivateRepos.Encode(e)
			}
		}
		{
			if s.OwnedPrivateRepos.Set {
				e.Comma()
			}
			if s.OwnedPrivateRepos.Set {
				e.RawStr("\"owned_private_repos\"" + ":")
				s.OwnedPrivateRepos.Encode(e)
			}
		}
		{
			if s.DiskUsage.Set {
				e.Comma()
			}
			if s.DiskUsage.Set {
				e.RawStr("\"disk_usage\"" + ":")
				s.DiskUsage.Encode(e)
			}
		}
		{
			if s.Collaborators.Set {
				e.Comma()
			}
			if s.Collaborators.Set {
				e.RawStr("\"collaborators\"" + ":")
				s.Collaborators.Encode(e)
			}
		}
	}
	for k, elem := range s.AdditionalProps {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPublicUser = [39]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "avatar_url",
	4:  "gravatar_id",
	5:  "url",
	6:  "html_url",
	7:  "followers_url",
	8:  "following_url",
	9:  "gists_url",
	10: "starred_url",
	11: "subscriptions_url",
	12: "organizations_url",
	13: "repos_url",
	14: "events_url",
	15: "received_events_url",
	16: "type",
	17: "site_admin",
	18: "name",
	19: "company",
	20: "blog",
	21: "location",
	22: "email",
	23: "hireable",
	24: "bio",
	25: "twitter_username",
	26: "public_repos",
	27: "public_gists",
	28: "followers",
	29: "following",
	30: "created_at",
	31: "updated_at",
	32: "plan",
	33: "suspended_at",
	34: "private_gists",
	35: "total_private_repos",
	36: "owned_private_repos",
	37: "disk_usage",
	38: "collaborators",
}

// Decode decodes PublicUser from json.
func (s *PublicUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublicUser to nil")
	}
	var requiredBitSet [5]uint8

	m := s.AdditionalProps
	if m == nil {
		m = map[string]jx.Raw{}
		s.AdditionalProps = m
	}
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "name":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "company":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Company.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"company\"")
			}
		case "blog":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Blog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blog\"")
			}
		case "location":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hireable":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.Hireable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hireable\"")
			}
		case "bio":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "twitter_username":
			if err := func() error {
				s.TwitterUsername.Reset()
				if err := s.TwitterUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"twitter_username\"")
			}
		case "public_repos":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.PublicRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_repos\"")
			}
		case "public_gists":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.PublicGists = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_gists\"")
			}
		case "followers":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Followers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers\"")
			}
		case "following":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Following = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following\"")
			}
		case "created_at":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "suspended_at":
			if err := func() error {
				s.SuspendedAt.Reset()
				if err := s.SuspendedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspended_at\"")
			}
		case "private_gists":
			if err := func() error {
				s.PrivateGists.Reset()
				if err := s.PrivateGists.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private_gists\"")
			}
		case "total_private_repos":
			if err := func() error {
				s.TotalPrivateRepos.Reset()
				if err := s.TotalPrivateRepos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_private_repos\"")
			}
		case "owned_private_repos":
			if err := func() error {
				s.OwnedPrivateRepos.Reset()
				if err := s.OwnedPrivateRepos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owned_private_repos\"")
			}
		case "disk_usage":
			if err := func() error {
				s.DiskUsage.Reset()
				if err := s.DiskUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk_usage\"")
			}
		case "collaborators":
			if err := func() error {
				s.Collaborators.Reset()
				if err := s.Collaborators.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PublicUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPublicUser) {
					name = jsonFieldsNameOfPublicUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PublicUserPlan) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"collaborators\"" + ":")
		e.Int(s.Collaborators)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"space\"" + ":")
		e.Int(s.Space)
	}
	{
		e.Comma()

		e.RawStr("\"private_repos\"" + ":")
		e.Int(s.PrivateRepos)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPublicUserPlan = [4]string{
	0: "collaborators",
	1: "name",
	2: "space",
	3: "private_repos",
}

// Decode decodes PublicUserPlan from json.
func (s *PublicUserPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublicUserPlan to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collaborators":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Collaborators = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "space":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Space = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"space\"")
			}
		case "private_repos":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.PrivateRepos = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private_repos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PublicUserPlan")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPublicUserPlan) {
					name = jsonFieldsNameOfPublicUserPlan[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"diff_url\"" + ":")
		json.EncodeURI(e, s.DiffURL)
	}
	{
		e.Comma()

		e.RawStr("\"patch_url\"" + ":")
		json.EncodeURI(e, s.PatchURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_url\"" + ":")
		json.EncodeURI(e, s.IssueURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		json.EncodeURI(e, s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"review_comments_url\"" + ":")
		json.EncodeURI(e, s.ReviewCommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"review_comment_url\"" + ":")
		e.Str(s.ReviewCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		json.EncodeURI(e, s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"locked\"" + ":")
		e.Bool(s.Locked)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		s.Body.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"labels\"" + ":")
		e.ArrStart()
		if len(s.Labels) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Labels[0]
				elem.Encode(e)
			}
			for _, elem := range s.Labels[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"milestone\"" + ":")
		s.Milestone.Encode(e)
	}
	{
		if s.ActiveLockReason.Set {
			e.Comma()
		}
		if s.ActiveLockReason.Set {
			e.RawStr("\"active_lock_reason\"" + ":")
			s.ActiveLockReason.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"closed_at\"" + ":")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"merged_at\"" + ":")
		s.MergedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"merge_commit_sha\"" + ":")
		s.MergeCommitSha.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"assignee\"" + ":")
		s.Assignee.Encode(e)
	}
	{
		if s.Assignees.Set {
			e.Comma()
		}
		if s.Assignees.Set {
			e.RawStr("\"assignees\"" + ":")
			s.Assignees.Encode(e)
		}
	}
	{
		if s.RequestedReviewers.Set {
			e.Comma()
		}
		if s.RequestedReviewers.Set {
			e.RawStr("\"requested_reviewers\"" + ":")
			s.RequestedReviewers.Encode(e)
		}
	}
	{
		if s.RequestedTeams.Set {
			e.Comma()
		}
		if s.RequestedTeams.Set {
			e.RawStr("\"requested_teams\"" + ":")
			s.RequestedTeams.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"head\"" + ":")
		s.Head.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"base\"" + ":")
		s.Base.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"auto_merge\"" + ":")
		s.AutoMerge.Encode(e)
	}
	{
		if s.Draft.Set {
			e.Comma()
		}
		if s.Draft.Set {
			e.RawStr("\"draft\"" + ":")
			s.Draft.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"merged\"" + ":")
		e.Bool(s.Merged)
	}
	{
		e.Comma()

		e.RawStr("\"mergeable\"" + ":")
		s.Mergeable.Encode(e)
	}
	{
		if s.Rebaseable.Set {
			e.Comma()
		}
		if s.Rebaseable.Set {
			e.RawStr("\"rebaseable\"" + ":")
			s.Rebaseable.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"mergeable_state\"" + ":")
		e.Str(s.MergeableState)
	}
	{
		e.Comma()

		e.RawStr("\"merged_by\"" + ":")
		s.MergedBy.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"comments\"" + ":")
		e.Int(s.Comments)
	}
	{
		e.Comma()

		e.RawStr("\"review_comments\"" + ":")
		e.Int(s.ReviewComments)
	}
	{
		e.Comma()

		e.RawStr("\"maintainer_can_modify\"" + ":")
		e.Bool(s.MaintainerCanModify)
	}
	{
		e.Comma()

		e.RawStr("\"commits\"" + ":")
		e.Int(s.Commits)
	}
	{
		e.Comma()

		e.RawStr("\"additions\"" + ":")
		e.Int(s.Additions)
	}
	{
		e.Comma()

		e.RawStr("\"deletions\"" + ":")
		e.Int(s.Deletions)
	}
	{
		e.Comma()

		e.RawStr("\"changed_files\"" + ":")
		e.Int(s.ChangedFiles)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequest = [48]string{
	0:  "url",
	1:  "id",
	2:  "node_id",
	3:  "html_url",
	4:  "diff_url",
	5:  "patch_url",
	6:  "issue_url",
	7:  "commits_url",
	8:  "review_comments_url",
	9:  "review_comment_url",
	10: "comments_url",
	11: "statuses_url",
	12: "number",
	13: "state",
	14: "locked",
	15: "title",
	16: "user",
	17: "body",
	18: "labels",
	19: "milestone",
	20: "active_lock_reason",
	21: "created_at",
	22: "updated_at",
	23: "closed_at",
	24: "merged_at",
	25: "merge_commit_sha",
	26: "assignee",
	27: "assignees",
	28: "requested_reviewers",
	29: "requested_teams",
	30: "head",
	31: "base",
	32: "_links",
	33: "author_association",
	34: "auto_merge",
	35: "draft",
	36: "merged",
	37: "mergeable",
	38: "rebaseable",
	39: "mergeable_state",
	40: "merged_by",
	41: "comments",
	42: "review_comments",
	43: "maintainer_can_modify",
	44: "commits",
	45: "additions",
	46: "deletions",
	47: "changed_files",
}

// Decode decodes PullRequest from json.
func (s *PullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequest to nil")
	}
	var requiredBitSet [6]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "diff_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DiffURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_url\"")
			}
		case "patch_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PatchURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch_url\"")
			}
		case "issue_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.IssueURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_url\"")
			}
		case "commits_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommitsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "review_comments_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReviewCommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comments_url\"")
			}
		case "review_comment_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ReviewCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comment_url\"")
			}
		case "comments_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "statuses_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StatusesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "locked":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Locked = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locked\"")
			}
		case "title":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "user":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "body":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "labels":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				s.Labels = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PullRequestLabelsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "milestone":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "active_lock_reason":
			if err := func() error {
				s.ActiveLockReason.Reset()
				if err := s.ActiveLockReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_lock_reason\"")
			}
		case "created_at":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "closed_at":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_at\"")
			}
		case "merged_at":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged_at\"")
			}
		case "merge_commit_sha":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.MergeCommitSha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_commit_sha\"")
			}
		case "assignee":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "assignees":
			if err := func() error {
				s.Assignees.Reset()
				if err := s.Assignees.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		case "requested_reviewers":
			if err := func() error {
				s.RequestedReviewers.Reset()
				if err := s.RequestedReviewers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_reviewers\"")
			}
		case "requested_teams":
			if err := func() error {
				s.RequestedTeams.Reset()
				if err := s.RequestedTeams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_teams\"")
			}
		case "head":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Head.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head\"")
			}
		case "base":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				if err := s.Base.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base\"")
			}
		case "_links":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "author_association":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "auto_merge":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				if err := s.AutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_merge\"")
			}
		case "draft":
			if err := func() error {
				s.Draft.Reset()
				if err := s.Draft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		case "merged":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Merged = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged\"")
			}
		case "mergeable":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				if err := s.Mergeable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mergeable\"")
			}
		case "rebaseable":
			if err := func() error {
				s.Rebaseable.Reset()
				if err := s.Rebaseable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rebaseable\"")
			}
		case "mergeable_state":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.MergeableState = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mergeable_state\"")
			}
		case "merged_by":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				if err := s.MergedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged_by\"")
			}
		case "comments":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Comments = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "review_comments":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ReviewComments = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comments\"")
			}
		case "maintainer_can_modify":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.MaintainerCanModify = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintainer_can_modify\"")
			}
		case "commits":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Commits = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits\"")
			}
		case "additions":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Additions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additions\"")
			}
		case "deletions":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Deletions = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletions\"")
			}
		case "changed_files":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ChangedFiles = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changed_files\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [6]uint8{
		0b11111111,
		0b11111111,
		0b11101111,
		0b11000111,
		0b10110111,
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequest) {
					name = jsonFieldsNameOfPullRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestBase) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"label\"" + ":")
		e.Str(s.Label)
	}
	{
		e.Comma()

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"repo\"" + ":")
		s.Repo.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestBase = [5]string{
	0: "label",
	1: "ref",
	2: "repo",
	3: "sha",
	4: "user",
}

// Decode decodes PullRequestBase from json.
func (s *PullRequestBase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestBase to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "ref":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "repo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestBase")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestBase) {
					name = jsonFieldsNameOfPullRequestBase[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestBaseRepo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"clone_url\"" + ":")
		e.Str(s.CloneURL)
	}
	{
		e.Comma()

		e.RawStr("\"default_branch\"" + ":")
		e.Str(s.DefaultBranch)
	}
	{
		e.Comma()

		e.RawStr("\"forks\"" + ":")
		e.Int(s.Forks)
	}
	{
		e.Comma()

		e.RawStr("\"forks_count\"" + ":")
		e.Int(s.ForksCount)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		e.Str(s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"has_downloads\"" + ":")
		e.Bool(s.HasDownloads)
	}
	{
		e.Comma()

		e.RawStr("\"has_issues\"" + ":")
		e.Bool(s.HasIssues)
	}
	{
		e.Comma()

		e.RawStr("\"has_projects\"" + ":")
		e.Bool(s.HasProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_wiki\"" + ":")
		e.Bool(s.HasWiki)
	}
	{
		e.Comma()

		e.RawStr("\"has_pages\"" + ":")
		e.Bool(s.HasPages)
	}
	{
		e.Comma()

		e.RawStr("\"homepage\"" + ":")
		s.Homepage.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"language\"" + ":")
		s.Language.Encode(e)
	}
	{
		if s.MasterBranch.Set {
			e.Comma()
		}
		if s.MasterBranch.Set {
			e.RawStr("\"master_branch\"" + ":")
			s.MasterBranch.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"archived\"" + ":")
		e.Bool(s.Archived)
	}
	{
		e.Comma()

		e.RawStr("\"disabled\"" + ":")
		e.Bool(s.Disabled)
	}
	{
		e.Comma()

		e.RawStr("\"mirror_url\"" + ":")
		s.MirrorURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues_count\"" + ":")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pushed_at\"" + ":")
		json.EncodeDateTime(e, s.PushedAt)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"ssh_url\"" + ":")
		e.Str(s.SSHURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_count\"" + ":")
		e.Int(s.StargazersCount)
	}
	{
		e.Comma()

		e.RawStr("\"svn_url\"" + ":")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"watchers\"" + ":")
		e.Int(s.Watchers)
	}
	{
		e.Comma()

		e.RawStr("\"watchers_count\"" + ":")
		e.Int(s.WatchersCount)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestBaseRepo = [81]string{
	0:  "archive_url",
	1:  "assignees_url",
	2:  "blobs_url",
	3:  "branches_url",
	4:  "collaborators_url",
	5:  "comments_url",
	6:  "commits_url",
	7:  "compare_url",
	8:  "contents_url",
	9:  "contributors_url",
	10: "deployments_url",
	11: "description",
	12: "downloads_url",
	13: "events_url",
	14: "fork",
	15: "forks_url",
	16: "full_name",
	17: "git_commits_url",
	18: "git_refs_url",
	19: "git_tags_url",
	20: "hooks_url",
	21: "html_url",
	22: "id",
	23: "node_id",
	24: "issue_comment_url",
	25: "issue_events_url",
	26: "issues_url",
	27: "keys_url",
	28: "labels_url",
	29: "languages_url",
	30: "merges_url",
	31: "milestones_url",
	32: "name",
	33: "notifications_url",
	34: "owner",
	35: "private",
	36: "pulls_url",
	37: "releases_url",
	38: "stargazers_url",
	39: "statuses_url",
	40: "subscribers_url",
	41: "subscription_url",
	42: "tags_url",
	43: "teams_url",
	44: "trees_url",
	45: "url",
	46: "clone_url",
	47: "default_branch",
	48: "forks",
	49: "forks_count",
	50: "git_url",
	51: "has_downloads",
	52: "has_issues",
	53: "has_projects",
	54: "has_wiki",
	55: "has_pages",
	56: "homepage",
	57: "language",
	58: "master_branch",
	59: "archived",
	60: "disabled",
	61: "mirror_url",
	62: "open_issues",
	63: "open_issues_count",
	64: "permissions",
	65: "temp_clone_token",
	66: "allow_merge_commit",
	67: "allow_squash_merge",
	68: "allow_rebase_merge",
	69: "license",
	70: "pushed_at",
	71: "size",
	72: "ssh_url",
	73: "stargazers_count",
	74: "svn_url",
	75: "topics",
	76: "watchers",
	77: "watchers_count",
	78: "created_at",
	79: "updated_at",
	80: "allow_forking",
}

// Decode decodes PullRequestBaseRepo from json.
func (s *PullRequestBaseRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestBaseRepo to nil")
	}
	var requiredBitSet [11]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archive_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "downloads_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "forks_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "full_name":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "git_commits_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "hooks_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "html_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "id":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "issue_comment_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "name":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "notifications_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "owner":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "pulls_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "stargazers_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "clone_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CloneURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "default_branch":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.DefaultBranch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "forks":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Forks = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "forks_count":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ForksCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "git_url":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "has_downloads":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.HasDownloads = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "has_issues":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasIssues = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.HasProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.HasWiki = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.HasPages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "homepage":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "master_branch":
			if err := func() error {
				s.MasterBranch.Reset()
				if err := s.MasterBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master_branch\"")
			}
		case "archived":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Archived = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "mirror_url":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "open_issues":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "open_issues_count":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.OpenIssuesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "license":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "pushed_at":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.PushedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "size":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "ssh_url":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SSHURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_count":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.StargazersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "svn_url":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SvnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "watchers":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Watchers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "watchers_count":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WatchersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "created_at":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestBaseRepo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [11]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111011,
		0b11100000,
		0b11110111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestBaseRepo) {
					name = jsonFieldsNameOfPullRequestBaseRepo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestBaseRepoOwner) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestBaseRepoOwner = [18]string{
	0:  "avatar_url",
	1:  "events_url",
	2:  "followers_url",
	3:  "following_url",
	4:  "gists_url",
	5:  "gravatar_id",
	6:  "html_url",
	7:  "id",
	8:  "node_id",
	9:  "login",
	10: "organizations_url",
	11: "received_events_url",
	12: "repos_url",
	13: "site_admin",
	14: "starred_url",
	15: "subscriptions_url",
	16: "type",
	17: "url",
}

// Decode decodes PullRequestBaseRepoOwner from json.
func (s *PullRequestBaseRepoOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestBaseRepoOwner to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "followers_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "login":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "received_events_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "site_admin":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestBaseRepoOwner")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestBaseRepoOwner) {
					name = jsonFieldsNameOfPullRequestBaseRepoOwner[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestBaseRepoPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestBaseRepoPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes PullRequestBaseRepoPermissions from json.
func (s *PullRequestBaseRepoPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestBaseRepoPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestBaseRepoPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestBaseRepoPermissions) {
					name = jsonFieldsNameOfPullRequestBaseRepoPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestBaseUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestBaseUser = [18]string{
	0:  "avatar_url",
	1:  "events_url",
	2:  "followers_url",
	3:  "following_url",
	4:  "gists_url",
	5:  "gravatar_id",
	6:  "html_url",
	7:  "id",
	8:  "node_id",
	9:  "login",
	10: "organizations_url",
	11: "received_events_url",
	12: "repos_url",
	13: "site_admin",
	14: "starred_url",
	15: "subscriptions_url",
	16: "type",
	17: "url",
}

// Decode decodes PullRequestBaseUser from json.
func (s *PullRequestBaseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestBaseUser to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "followers_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "login":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "received_events_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "site_admin":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestBaseUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestBaseUser) {
					name = jsonFieldsNameOfPullRequestBaseUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestHead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"label\"" + ":")
		e.Str(s.Label)
	}
	{
		e.Comma()

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"repo\"" + ":")
		s.Repo.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestHead = [5]string{
	0: "label",
	1: "ref",
	2: "repo",
	3: "sha",
	4: "user",
}

// Decode decodes PullRequestHead from json.
func (s *PullRequestHead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestHead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "ref":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "repo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestHead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestHead) {
					name = jsonFieldsNameOfPullRequestHead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestHeadRepo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"clone_url\"" + ":")
		e.Str(s.CloneURL)
	}
	{
		e.Comma()

		e.RawStr("\"default_branch\"" + ":")
		e.Str(s.DefaultBranch)
	}
	{
		e.Comma()

		e.RawStr("\"forks\"" + ":")
		e.Int(s.Forks)
	}
	{
		e.Comma()

		e.RawStr("\"forks_count\"" + ":")
		e.Int(s.ForksCount)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		e.Str(s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"has_downloads\"" + ":")
		e.Bool(s.HasDownloads)
	}
	{
		e.Comma()

		e.RawStr("\"has_issues\"" + ":")
		e.Bool(s.HasIssues)
	}
	{
		e.Comma()

		e.RawStr("\"has_projects\"" + ":")
		e.Bool(s.HasProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_wiki\"" + ":")
		e.Bool(s.HasWiki)
	}
	{
		e.Comma()

		e.RawStr("\"has_pages\"" + ":")
		e.Bool(s.HasPages)
	}
	{
		e.Comma()

		e.RawStr("\"homepage\"" + ":")
		s.Homepage.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"language\"" + ":")
		s.Language.Encode(e)
	}
	{
		if s.MasterBranch.Set {
			e.Comma()
		}
		if s.MasterBranch.Set {
			e.RawStr("\"master_branch\"" + ":")
			s.MasterBranch.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"archived\"" + ":")
		e.Bool(s.Archived)
	}
	{
		e.Comma()

		e.RawStr("\"disabled\"" + ":")
		e.Bool(s.Disabled)
	}
	{
		e.Comma()

		e.RawStr("\"mirror_url\"" + ":")
		s.MirrorURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues_count\"" + ":")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pushed_at\"" + ":")
		json.EncodeDateTime(e, s.PushedAt)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"ssh_url\"" + ":")
		e.Str(s.SSHURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_count\"" + ":")
		e.Int(s.StargazersCount)
	}
	{
		e.Comma()

		e.RawStr("\"svn_url\"" + ":")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"watchers\"" + ":")
		e.Int(s.Watchers)
	}
	{
		e.Comma()

		e.RawStr("\"watchers_count\"" + ":")
		e.Int(s.WatchersCount)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestHeadRepo = [81]string{
	0:  "archive_url",
	1:  "assignees_url",
	2:  "blobs_url",
	3:  "branches_url",
	4:  "collaborators_url",
	5:  "comments_url",
	6:  "commits_url",
	7:  "compare_url",
	8:  "contents_url",
	9:  "contributors_url",
	10: "deployments_url",
	11: "description",
	12: "downloads_url",
	13: "events_url",
	14: "fork",
	15: "forks_url",
	16: "full_name",
	17: "git_commits_url",
	18: "git_refs_url",
	19: "git_tags_url",
	20: "hooks_url",
	21: "html_url",
	22: "id",
	23: "node_id",
	24: "issue_comment_url",
	25: "issue_events_url",
	26: "issues_url",
	27: "keys_url",
	28: "labels_url",
	29: "languages_url",
	30: "merges_url",
	31: "milestones_url",
	32: "name",
	33: "notifications_url",
	34: "owner",
	35: "private",
	36: "pulls_url",
	37: "releases_url",
	38: "stargazers_url",
	39: "statuses_url",
	40: "subscribers_url",
	41: "subscription_url",
	42: "tags_url",
	43: "teams_url",
	44: "trees_url",
	45: "url",
	46: "clone_url",
	47: "default_branch",
	48: "forks",
	49: "forks_count",
	50: "git_url",
	51: "has_downloads",
	52: "has_issues",
	53: "has_projects",
	54: "has_wiki",
	55: "has_pages",
	56: "homepage",
	57: "language",
	58: "master_branch",
	59: "archived",
	60: "disabled",
	61: "mirror_url",
	62: "open_issues",
	63: "open_issues_count",
	64: "permissions",
	65: "temp_clone_token",
	66: "allow_merge_commit",
	67: "allow_squash_merge",
	68: "allow_rebase_merge",
	69: "license",
	70: "pushed_at",
	71: "size",
	72: "ssh_url",
	73: "stargazers_count",
	74: "svn_url",
	75: "topics",
	76: "watchers",
	77: "watchers_count",
	78: "created_at",
	79: "updated_at",
	80: "allow_forking",
}

// Decode decodes PullRequestHeadRepo from json.
func (s *PullRequestHeadRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestHeadRepo to nil")
	}
	var requiredBitSet [11]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archive_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "downloads_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "forks_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "full_name":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "git_commits_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "hooks_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "html_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "id":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "issue_comment_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "name":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "notifications_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "owner":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "pulls_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "stargazers_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "clone_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CloneURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "default_branch":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.DefaultBranch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "forks":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Forks = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "forks_count":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ForksCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "git_url":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "has_downloads":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.HasDownloads = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "has_issues":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasIssues = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.HasProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.HasWiki = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.HasPages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "homepage":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "master_branch":
			if err := func() error {
				s.MasterBranch.Reset()
				if err := s.MasterBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master_branch\"")
			}
		case "archived":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Archived = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "mirror_url":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "open_issues":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "open_issues_count":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.OpenIssuesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "license":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "pushed_at":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.PushedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "size":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "ssh_url":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SSHURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_count":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.StargazersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "svn_url":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SvnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "watchers":
			requiredBitSet[9] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Watchers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "watchers_count":
			requiredBitSet[9] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.WatchersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "created_at":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestHeadRepo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [11]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111011,
		0b11100000,
		0b11110111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestHeadRepo) {
					name = jsonFieldsNameOfPullRequestHeadRepo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestHeadRepoLicense) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"spdx_id\"" + ":")
		s.SpdxID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestHeadRepoLicense = [5]string{
	0: "key",
	1: "name",
	2: "url",
	3: "spdx_id",
	4: "node_id",
}

// Decode decodes PullRequestHeadRepoLicense from json.
func (s *PullRequestHeadRepoLicense) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestHeadRepoLicense to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "spdx_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SpdxID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spdx_id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestHeadRepoLicense")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestHeadRepoLicense) {
					name = jsonFieldsNameOfPullRequestHeadRepoLicense[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestHeadRepoOwner) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestHeadRepoOwner = [18]string{
	0:  "avatar_url",
	1:  "events_url",
	2:  "followers_url",
	3:  "following_url",
	4:  "gists_url",
	5:  "gravatar_id",
	6:  "html_url",
	7:  "id",
	8:  "node_id",
	9:  "login",
	10: "organizations_url",
	11: "received_events_url",
	12: "repos_url",
	13: "site_admin",
	14: "starred_url",
	15: "subscriptions_url",
	16: "type",
	17: "url",
}

// Decode decodes PullRequestHeadRepoOwner from json.
func (s *PullRequestHeadRepoOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestHeadRepoOwner to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "followers_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "login":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "received_events_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "site_admin":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestHeadRepoOwner")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestHeadRepoOwner) {
					name = jsonFieldsNameOfPullRequestHeadRepoOwner[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestHeadRepoPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestHeadRepoPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes PullRequestHeadRepoPermissions from json.
func (s *PullRequestHeadRepoPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestHeadRepoPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestHeadRepoPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestHeadRepoPermissions) {
					name = jsonFieldsNameOfPullRequestHeadRepoPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestHeadUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestHeadUser = [18]string{
	0:  "avatar_url",
	1:  "events_url",
	2:  "followers_url",
	3:  "following_url",
	4:  "gists_url",
	5:  "gravatar_id",
	6:  "html_url",
	7:  "id",
	8:  "node_id",
	9:  "login",
	10: "organizations_url",
	11: "received_events_url",
	12: "repos_url",
	13: "site_admin",
	14: "starred_url",
	15: "subscriptions_url",
	16: "type",
	17: "url",
}

// Decode decodes PullRequestHeadUser from json.
func (s *PullRequestHeadUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestHeadUser to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "events_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "followers_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "login":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "received_events_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "site_admin":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestHeadUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestHeadUser) {
					name = jsonFieldsNameOfPullRequestHeadUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestLabelsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Color.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	{
		if s.Default.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Default.Set {
			e.RawStr("\"default\"" + ":")
			s.Default.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestLabelsItem = [7]string{
	0: "id",
	1: "node_id",
	2: "url",
	3: "name",
	4: "description",
	5: "color",
	6: "default",
}

// Decode decodes PullRequestLabelsItem from json.
func (s *PullRequestLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestLabelsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestLabelsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"comments\"" + ":")
		s.Comments.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commits\"" + ":")
		s.Commits.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"statuses\"" + ":")
		s.Statuses.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html\"" + ":")
		s.HTML.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"issue\"" + ":")
		s.Issue.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"review_comments\"" + ":")
		s.ReviewComments.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"review_comment\"" + ":")
		s.ReviewComment.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"self\"" + ":")
		s.Self.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestLinks = [8]string{
	0: "comments",
	1: "commits",
	2: "statuses",
	3: "html",
	4: "issue",
	5: "review_comments",
	6: "review_comment",
	7: "self",
}

// Decode decodes PullRequestLinks from json.
func (s *PullRequestLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "comments":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Comments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "commits":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Commits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits\"")
			}
		case "statuses":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Statuses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses\"")
			}
		case "html":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "issue":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Issue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue\"")
			}
		case "review_comments":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.ReviewComments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comments\"")
			}
		case "review_comment":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.ReviewComment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comment\"")
			}
		case "self":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestLinks) {
					name = jsonFieldsNameOfPullRequestLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestMergeResult) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"merged\"" + ":")
		e.Bool(s.Merged)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestMergeResult = [3]string{
	0: "sha",
	1: "merged",
	2: "message",
}

// Decode decodes PullRequestMergeResult from json.
func (s *PullRequestMergeResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestMergeResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "merged":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Merged = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestMergeResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestMergeResult) {
					name = jsonFieldsNameOfPullRequestMergeResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestMinimal) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"head\"" + ":")
		s.Head.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"base\"" + ":")
		s.Base.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestMinimal = [5]string{
	0: "id",
	1: "number",
	2: "url",
	3: "head",
	4: "base",
}

// Decode decodes PullRequestMinimal from json.
func (s *PullRequestMinimal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestMinimal to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "head":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Head.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head\"")
			}
		case "base":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Base.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestMinimal")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestMinimal) {
					name = jsonFieldsNameOfPullRequestMinimal[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestMinimalBase) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"repo\"" + ":")
		s.Repo.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestMinimalBase = [3]string{
	0: "ref",
	1: "sha",
	2: "repo",
}

// Decode decodes PullRequestMinimalBase from json.
func (s *PullRequestMinimalBase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestMinimalBase to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "repo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestMinimalBase")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestMinimalBase) {
					name = jsonFieldsNameOfPullRequestMinimalBase[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestMinimalBaseRepo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestMinimalBaseRepo = [3]string{
	0: "id",
	1: "url",
	2: "name",
}

// Decode decodes PullRequestMinimalBaseRepo from json.
func (s *PullRequestMinimalBaseRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestMinimalBaseRepo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestMinimalBaseRepo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestMinimalBaseRepo) {
					name = jsonFieldsNameOfPullRequestMinimalBaseRepo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestMinimalHead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"repo\"" + ":")
		s.Repo.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestMinimalHead = [3]string{
	0: "ref",
	1: "sha",
	2: "repo",
}

// Decode decodes PullRequestMinimalHead from json.
func (s *PullRequestMinimalHead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestMinimalHead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "repo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestMinimalHead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestMinimalHead) {
					name = jsonFieldsNameOfPullRequestMinimalHead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestMinimalHeadRepo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestMinimalHeadRepo = [3]string{
	0: "id",
	1: "url",
	2: "name",
}

// Decode decodes PullRequestMinimalHeadRepo from json.
func (s *PullRequestMinimalHeadRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestMinimalHeadRepo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestMinimalHeadRepo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestMinimalHeadRepo) {
					name = jsonFieldsNameOfPullRequestMinimalHeadRepo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestReview) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request_url\"" + ":")
		json.EncodeURI(e, s.PullRequestURL)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		if s.SubmittedAt.Set {
			e.Comma()
		}
		if s.SubmittedAt.Set {
			e.RawStr("\"submitted_at\"" + ":")
			s.SubmittedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.Comma()

		e.RawStr("\"commit_id\"" + ":")
		e.Str(s.CommitID)
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestReview = [13]string{
	0:  "id",
	1:  "node_id",
	2:  "user",
	3:  "body",
	4:  "state",
	5:  "html_url",
	6:  "pull_request_url",
	7:  "_links",
	8:  "submitted_at",
	9:  "commit_id",
	10: "body_html",
	11: "body_text",
	12: "author_association",
}

// Decode decodes PullRequestReview from json.
func (s *PullRequestReview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReview to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "pull_request_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PullRequestURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request_url\"")
			}
		case "_links":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "submitted_at":
			if err := func() error {
				s.SubmittedAt.Reset()
				if err := s.SubmittedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"submitted_at\"")
			}
		case "commit_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CommitID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_id\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		case "author_association":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReview")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00010010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReview) {
					name = jsonFieldsNameOfPullRequestReview[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestReviewComment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request_review_id\"" + ":")
		s.PullRequestReviewID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"diff_hunk\"" + ":")
		e.Str(s.DiffHunk)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"position\"" + ":")
		e.Int(s.Position)
	}
	{
		e.Comma()

		e.RawStr("\"original_position\"" + ":")
		e.Int(s.OriginalPosition)
	}
	{
		e.Comma()

		e.RawStr("\"commit_id\"" + ":")
		e.Str(s.CommitID)
	}
	{
		e.Comma()

		e.RawStr("\"original_commit_id\"" + ":")
		e.Str(s.OriginalCommitID)
	}
	{
		if s.InReplyToID.Set {
			e.Comma()
		}
		if s.InReplyToID.Set {
			e.RawStr("\"in_reply_to_id\"" + ":")
			s.InReplyToID.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request_url\"" + ":")
		json.EncodeURI(e, s.PullRequestURL)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		if s.StartLine.Set {
			e.Comma()
		}
		if s.StartLine.Set {
			e.RawStr("\"start_line\"" + ":")
			s.StartLine.Encode(e)
		}
	}
	{
		if s.OriginalStartLine.Set {
			e.Comma()
		}
		if s.OriginalStartLine.Set {
			e.RawStr("\"original_start_line\"" + ":")
			s.OriginalStartLine.Encode(e)
		}
	}
	{
		if s.StartSide.Set {
			e.Comma()
		}
		if s.StartSide.Set {
			e.RawStr("\"start_side\"" + ":")
			s.StartSide.Encode(e)
		}
	}
	{
		if s.Line.Set {
			e.Comma()
		}
		if s.Line.Set {
			e.RawStr("\"line\"" + ":")
			s.Line.Encode(e)
		}
	}
	{
		if s.OriginalLine.Set {
			e.Comma()
		}
		if s.OriginalLine.Set {
			e.RawStr("\"original_line\"" + ":")
			s.OriginalLine.Encode(e)
		}
	}
	{
		if s.Side.Set {
			e.Comma()
		}
		if s.Side.Set {
			e.RawStr("\"side\"" + ":")
			s.Side.Encode(e)
		}
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestReviewComment = [28]string{
	0:  "url",
	1:  "pull_request_review_id",
	2:  "id",
	3:  "node_id",
	4:  "diff_hunk",
	5:  "path",
	6:  "position",
	7:  "original_position",
	8:  "commit_id",
	9:  "original_commit_id",
	10: "in_reply_to_id",
	11: "user",
	12: "body",
	13: "created_at",
	14: "updated_at",
	15: "html_url",
	16: "pull_request_url",
	17: "author_association",
	18: "_links",
	19: "start_line",
	20: "original_start_line",
	21: "start_side",
	22: "line",
	23: "original_line",
	24: "side",
	25: "reactions",
	26: "body_html",
	27: "body_text",
}

// Decode decodes PullRequestReviewComment from json.
func (s *PullRequestReviewComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewComment to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "pull_request_review_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PullRequestReviewID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request_review_id\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "diff_hunk":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.DiffHunk = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_hunk\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "position":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Position = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "original_position":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.OriginalPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_position\"")
			}
		case "commit_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CommitID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_id\"")
			}
		case "original_commit_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.OriginalCommitID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_commit_id\"")
			}
		case "in_reply_to_id":
			if err := func() error {
				s.InReplyToID.Reset()
				if err := s.InReplyToID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"in_reply_to_id\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "body":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "pull_request_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PullRequestURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request_url\"")
			}
		case "author_association":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "_links":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "start_line":
			if err := func() error {
				s.StartLine.Reset()
				if err := s.StartLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_line\"")
			}
		case "original_start_line":
			if err := func() error {
				s.OriginalStartLine.Reset()
				if err := s.OriginalStartLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_start_line\"")
			}
		case "start_side":
			if err := func() error {
				s.StartSide.Reset()
				if err := s.StartSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_side\"")
			}
		case "line":
			if err := func() error {
				s.Line.Reset()
				if err := s.Line.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"line\"")
			}
		case "original_line":
			if err := func() error {
				s.OriginalLine.Reset()
				if err := s.OriginalLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_line\"")
			}
		case "side":
			if err := func() error {
				s.Side.Reset()
				if err := s.Side.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"side\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewComment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111011,
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewComment) {
					name = jsonFieldsNameOfPullRequestReviewComment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestReviewCommentLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"self\"" + ":")
		s.Self.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html\"" + ":")
		s.HTML.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request\"" + ":")
		s.PullRequest.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestReviewCommentLinks = [3]string{
	0: "self",
	1: "html",
	2: "pull_request",
}

// Decode decodes PullRequestReviewCommentLinks from json.
func (s *PullRequestReviewCommentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewCommentLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		case "html":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "pull_request":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PullRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewCommentLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewCommentLinks) {
					name = jsonFieldsNameOfPullRequestReviewCommentLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestReviewCommentLinksHTML) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"href\"" + ":")
		json.EncodeURI(e, s.Href)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestReviewCommentLinksHTML = [1]string{
	0: "href",
}

// Decode decodes PullRequestReviewCommentLinksHTML from json.
func (s *PullRequestReviewCommentLinksHTML) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewCommentLinksHTML to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.Href = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"href\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewCommentLinksHTML")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewCommentLinksHTML) {
					name = jsonFieldsNameOfPullRequestReviewCommentLinksHTML[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestReviewCommentLinksPullRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"href\"" + ":")
		json.EncodeURI(e, s.Href)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestReviewCommentLinksPullRequest = [1]string{
	0: "href",
}

// Decode decodes PullRequestReviewCommentLinksPullRequest from json.
func (s *PullRequestReviewCommentLinksPullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewCommentLinksPullRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.Href = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"href\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewCommentLinksPullRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewCommentLinksPullRequest) {
					name = jsonFieldsNameOfPullRequestReviewCommentLinksPullRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestReviewCommentLinksSelf) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"href\"" + ":")
		json.EncodeURI(e, s.Href)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestReviewCommentLinksSelf = [1]string{
	0: "href",
}

// Decode decodes PullRequestReviewCommentLinksSelf from json.
func (s *PullRequestReviewCommentLinksSelf) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewCommentLinksSelf to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.Href = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"href\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewCommentLinksSelf")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewCommentLinksSelf) {
					name = jsonFieldsNameOfPullRequestReviewCommentLinksSelf[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PullRequestReviewCommentSide as json.
func (s PullRequestReviewCommentSide) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullRequestReviewCommentSide from json.
func (s *PullRequestReviewCommentSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewCommentSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullRequestReviewCommentSide(v) {
	case PullRequestReviewCommentSideLEFT:
		*s = PullRequestReviewCommentSideLEFT
	case PullRequestReviewCommentSideRIGHT:
		*s = PullRequestReviewCommentSideRIGHT
	default:
		*s = PullRequestReviewCommentSide(v)
	}

	return nil
}

// Encode encodes PullRequestReviewCommentStartSide as json.
func (s PullRequestReviewCommentStartSide) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullRequestReviewCommentStartSide from json.
func (s *PullRequestReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewCommentStartSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullRequestReviewCommentStartSide(v) {
	case PullRequestReviewCommentStartSideLEFT:
		*s = PullRequestReviewCommentStartSideLEFT
	case PullRequestReviewCommentStartSideRIGHT:
		*s = PullRequestReviewCommentStartSideRIGHT
	default:
		*s = PullRequestReviewCommentStartSide(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestReviewLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"html\"" + ":")
		s.HTML.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request\"" + ":")
		s.PullRequest.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestReviewLinks = [2]string{
	0: "html",
	1: "pull_request",
}

// Decode decodes PullRequestReviewLinks from json.
func (s *PullRequestReviewLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "html":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "pull_request":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PullRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewLinks) {
					name = jsonFieldsNameOfPullRequestReviewLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestReviewLinksHTML) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"href\"" + ":")
		e.Str(s.Href)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestReviewLinksHTML = [1]string{
	0: "href",
}

// Decode decodes PullRequestReviewLinksHTML from json.
func (s *PullRequestReviewLinksHTML) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewLinksHTML to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Href = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"href\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewLinksHTML")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewLinksHTML) {
					name = jsonFieldsNameOfPullRequestReviewLinksHTML[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestReviewLinksPullRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"href\"" + ":")
		e.Str(s.Href)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestReviewLinksPullRequest = [1]string{
	0: "href",
}

// Decode decodes PullRequestReviewLinksPullRequest from json.
func (s *PullRequestReviewLinksPullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewLinksPullRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Href = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"href\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewLinksPullRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewLinksPullRequest) {
					name = jsonFieldsNameOfPullRequestReviewLinksPullRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestReviewRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"users\"" + ":")
		e.ArrStart()
		if len(s.Users) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Users[0]
				elem.Encode(e)
			}
			for _, elem := range s.Users[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"teams\"" + ":")
		e.ArrStart()
		if len(s.Teams) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Teams[0]
				elem.Encode(e)
			}
			for _, elem := range s.Teams[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestReviewRequest = [2]string{
	0: "users",
	1: "teams",
}

// Decode decodes PullRequestReviewRequest from json.
func (s *PullRequestReviewRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestReviewRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Users = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimpleUser
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "teams":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Teams = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Team
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestReviewRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestReviewRequest) {
					name = jsonFieldsNameOfPullRequestReviewRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"diff_url\"" + ":")
		json.EncodeURI(e, s.DiffURL)
	}
	{
		e.Comma()

		e.RawStr("\"patch_url\"" + ":")
		json.EncodeURI(e, s.PatchURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_url\"" + ":")
		json.EncodeURI(e, s.IssueURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		json.EncodeURI(e, s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"review_comments_url\"" + ":")
		json.EncodeURI(e, s.ReviewCommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"review_comment_url\"" + ":")
		e.Str(s.ReviewCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		json.EncodeURI(e, s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"locked\"" + ":")
		e.Bool(s.Locked)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		s.Body.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"labels\"" + ":")
		e.ArrStart()
		if len(s.Labels) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Labels[0]
				elem.Encode(e)
			}
			for _, elem := range s.Labels[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"milestone\"" + ":")
		s.Milestone.Encode(e)
	}
	{
		if s.ActiveLockReason.Set {
			e.Comma()
		}
		if s.ActiveLockReason.Set {
			e.RawStr("\"active_lock_reason\"" + ":")
			s.ActiveLockReason.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"closed_at\"" + ":")
		s.ClosedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"merged_at\"" + ":")
		s.MergedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"merge_commit_sha\"" + ":")
		s.MergeCommitSha.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"assignee\"" + ":")
		s.Assignee.Encode(e)
	}
	{
		if s.Assignees.Set {
			e.Comma()
		}
		if s.Assignees.Set {
			e.RawStr("\"assignees\"" + ":")
			s.Assignees.Encode(e)
		}
	}
	{
		if s.RequestedReviewers.Set {
			e.Comma()
		}
		if s.RequestedReviewers.Set {
			e.RawStr("\"requested_reviewers\"" + ":")
			s.RequestedReviewers.Encode(e)
		}
	}
	{
		if s.RequestedTeams.Set {
			e.Comma()
		}
		if s.RequestedTeams.Set {
			e.RawStr("\"requested_teams\"" + ":")
			s.RequestedTeams.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"head\"" + ":")
		s.Head.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"base\"" + ":")
		s.Base.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"auto_merge\"" + ":")
		s.AutoMerge.Encode(e)
	}
	{
		if s.Draft.Set {
			e.Comma()
		}
		if s.Draft.Set {
			e.RawStr("\"draft\"" + ":")
			s.Draft.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestSimple = [36]string{
	0:  "url",
	1:  "id",
	2:  "node_id",
	3:  "html_url",
	4:  "diff_url",
	5:  "patch_url",
	6:  "issue_url",
	7:  "commits_url",
	8:  "review_comments_url",
	9:  "review_comment_url",
	10: "comments_url",
	11: "statuses_url",
	12: "number",
	13: "state",
	14: "locked",
	15: "title",
	16: "user",
	17: "body",
	18: "labels",
	19: "milestone",
	20: "active_lock_reason",
	21: "created_at",
	22: "updated_at",
	23: "closed_at",
	24: "merged_at",
	25: "merge_commit_sha",
	26: "assignee",
	27: "assignees",
	28: "requested_reviewers",
	29: "requested_teams",
	30: "head",
	31: "base",
	32: "_links",
	33: "author_association",
	34: "auto_merge",
	35: "draft",
}

// Decode decodes PullRequestSimple from json.
func (s *PullRequestSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestSimple to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "diff_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DiffURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_url\"")
			}
		case "patch_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PatchURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch_url\"")
			}
		case "issue_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.IssueURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_url\"")
			}
		case "commits_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommitsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "review_comments_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReviewCommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comments_url\"")
			}
		case "review_comment_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ReviewCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comment_url\"")
			}
		case "comments_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "statuses_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StatusesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "locked":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Locked = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locked\"")
			}
		case "title":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "user":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "body":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "labels":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				s.Labels = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PullRequestSimpleLabelsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "milestone":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Milestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestone\"")
			}
		case "active_lock_reason":
			if err := func() error {
				s.ActiveLockReason.Reset()
				if err := s.ActiveLockReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_lock_reason\"")
			}
		case "created_at":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "closed_at":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed_at\"")
			}
		case "merged_at":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merged_at\"")
			}
		case "merge_commit_sha":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.MergeCommitSha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_commit_sha\"")
			}
		case "assignee":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				if err := s.Assignee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignee\"")
			}
		case "assignees":
			if err := func() error {
				s.Assignees.Reset()
				if err := s.Assignees.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees\"")
			}
		case "requested_reviewers":
			if err := func() error {
				s.RequestedReviewers.Reset()
				if err := s.RequestedReviewers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_reviewers\"")
			}
		case "requested_teams":
			if err := func() error {
				s.RequestedTeams.Reset()
				if err := s.RequestedTeams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_teams\"")
			}
		case "head":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Head.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head\"")
			}
		case "base":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				if err := s.Base.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base\"")
			}
		case "_links":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "author_association":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "auto_merge":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				if err := s.AutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_merge\"")
			}
		case "draft":
			if err := func() error {
				s.Draft.Reset()
				if err := s.Draft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b11111111,
		0b11111111,
		0b11101111,
		0b11000111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestSimple) {
					name = jsonFieldsNameOfPullRequestSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestSimpleBase) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"label\"" + ":")
		e.Str(s.Label)
	}
	{
		e.Comma()

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"repo\"" + ":")
		s.Repo.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestSimpleBase = [5]string{
	0: "label",
	1: "ref",
	2: "repo",
	3: "sha",
	4: "user",
}

// Decode decodes PullRequestSimpleBase from json.
func (s *PullRequestSimpleBase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestSimpleBase to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "ref":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "repo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestSimpleBase")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestSimpleBase) {
					name = jsonFieldsNameOfPullRequestSimpleBase[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestSimpleHead) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"label\"" + ":")
		e.Str(s.Label)
	}
	{
		e.Comma()

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		e.Comma()

		e.RawStr("\"repo\"" + ":")
		s.Repo.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestSimpleHead = [5]string{
	0: "label",
	1: "ref",
	2: "repo",
	3: "sha",
	4: "user",
}

// Decode decodes PullRequestSimpleHead from json.
func (s *PullRequestSimpleHead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestSimpleHead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "ref":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "repo":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Repo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestSimpleHead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestSimpleHead) {
					name = jsonFieldsNameOfPullRequestSimpleHead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestSimpleLabelsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Color.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Color.Set {
			e.RawStr("\"color\"" + ":")
			s.Color.Encode(e)
		}
	}
	{
		if s.Default.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Default.Set {
			e.RawStr("\"default\"" + ":")
			s.Default.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestSimpleLabelsItem = [7]string{
	0: "id",
	1: "node_id",
	2: "url",
	3: "name",
	4: "description",
	5: "color",
	6: "default",
}

// Decode decodes PullRequestSimpleLabelsItem from json.
func (s *PullRequestSimpleLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestSimpleLabelsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestSimpleLabelsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestSimpleLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"comments\"" + ":")
		s.Comments.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"commits\"" + ":")
		s.Commits.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"statuses\"" + ":")
		s.Statuses.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html\"" + ":")
		s.HTML.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"issue\"" + ":")
		s.Issue.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"review_comments\"" + ":")
		s.ReviewComments.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"review_comment\"" + ":")
		s.ReviewComment.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"self\"" + ":")
		s.Self.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullRequestSimpleLinks = [8]string{
	0: "comments",
	1: "commits",
	2: "statuses",
	3: "html",
	4: "issue",
	5: "review_comments",
	6: "review_comment",
	7: "self",
}

// Decode decodes PullRequestSimpleLinks from json.
func (s *PullRequestSimpleLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestSimpleLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "comments":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Comments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "commits":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Commits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits\"")
			}
		case "statuses":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Statuses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses\"")
			}
		case "html":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "issue":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Issue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue\"")
			}
		case "review_comments":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.ReviewComments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comments\"")
			}
		case "review_comment":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.ReviewComment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_comment\"")
			}
		case "self":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullRequestSimpleLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullRequestSimpleLinks) {
					name = jsonFieldsNameOfPullRequestSimpleLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PullRequestState as json.
func (s PullRequestState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullRequestState from json.
func (s *PullRequestState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullRequestState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullRequestState(v) {
	case PullRequestStateOpen:
		*s = PullRequestStateOpen
	case PullRequestStateClosed:
		*s = PullRequestStateClosed
	default:
		*s = PullRequestState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsCreateReplyForReviewCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsCreateReplyForReviewCommentReq = [1]string{
	0: "body",
}

// Decode decodes PullsCreateReplyForReviewCommentReq from json.
func (s *PullsCreateReplyForReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReplyForReviewCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsCreateReplyForReviewCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsCreateReplyForReviewCommentReq) {
					name = jsonFieldsNameOfPullsCreateReplyForReviewCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsCreateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"head\"" + ":")
		e.Str(s.Head)
	}
	{
		e.Comma()

		e.RawStr("\"base\"" + ":")
		e.Str(s.Base)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.MaintainerCanModify.Set {
			e.Comma()
		}
		if s.MaintainerCanModify.Set {
			e.RawStr("\"maintainer_can_modify\"" + ":")
			s.MaintainerCanModify.Encode(e)
		}
	}
	{
		if s.Draft.Set {
			e.Comma()
		}
		if s.Draft.Set {
			e.RawStr("\"draft\"" + ":")
			s.Draft.Encode(e)
		}
	}
	{
		if s.Issue.Set {
			e.Comma()
		}
		if s.Issue.Set {
			e.RawStr("\"issue\"" + ":")
			s.Issue.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsCreateReq = [7]string{
	0: "title",
	1: "head",
	2: "base",
	3: "body",
	4: "maintainer_can_modify",
	5: "draft",
	6: "issue",
}

// Decode decodes PullsCreateReq from json.
func (s *PullsCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "head":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Head = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head\"")
			}
		case "base":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Base = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "maintainer_can_modify":
			if err := func() error {
				s.MaintainerCanModify.Reset()
				if err := s.MaintainerCanModify.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintainer_can_modify\"")
			}
		case "draft":
			if err := func() error {
				s.Draft.Reset()
				if err := s.Draft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		case "issue":
			if err := func() error {
				s.Issue.Reset()
				if err := s.Issue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsCreateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsCreateReq) {
					name = jsonFieldsNameOfPullsCreateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsCreateReviewCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		if s.CommitID.Set {
			e.Comma()
		}
		if s.CommitID.Set {
			e.RawStr("\"commit_id\"" + ":")
			s.CommitID.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Position.Set {
			e.Comma()
		}
		if s.Position.Set {
			e.RawStr("\"position\"" + ":")
			s.Position.Encode(e)
		}
	}
	{
		if s.Side.Set {
			e.Comma()
		}
		if s.Side.Set {
			e.RawStr("\"side\"" + ":")
			s.Side.Encode(e)
		}
	}
	{
		if s.Line.Set {
			e.Comma()
		}
		if s.Line.Set {
			e.RawStr("\"line\"" + ":")
			s.Line.Encode(e)
		}
	}
	{
		if s.StartLine.Set {
			e.Comma()
		}
		if s.StartLine.Set {
			e.RawStr("\"start_line\"" + ":")
			s.StartLine.Encode(e)
		}
	}
	{
		if s.StartSide.Set {
			e.Comma()
		}
		if s.StartSide.Set {
			e.RawStr("\"start_side\"" + ":")
			s.StartSide.Encode(e)
		}
	}
	{
		if s.InReplyTo.Set {
			e.Comma()
		}
		if s.InReplyTo.Set {
			e.RawStr("\"in_reply_to\"" + ":")
			s.InReplyTo.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsCreateReviewCommentReq = [9]string{
	0: "body",
	1: "commit_id",
	2: "path",
	3: "position",
	4: "side",
	5: "line",
	6: "start_line",
	7: "start_side",
	8: "in_reply_to",
}

// Decode decodes PullsCreateReviewCommentReq from json.
func (s *PullsCreateReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReviewCommentReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "commit_id":
			if err := func() error {
				s.CommitID.Reset()
				if err := s.CommitID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_id\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "position":
			if err := func() error {
				s.Position.Reset()
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "side":
			if err := func() error {
				s.Side.Reset()
				if err := s.Side.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"side\"")
			}
		case "line":
			if err := func() error {
				s.Line.Reset()
				if err := s.Line.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"line\"")
			}
		case "start_line":
			if err := func() error {
				s.StartLine.Reset()
				if err := s.StartLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_line\"")
			}
		case "start_side":
			if err := func() error {
				s.StartSide.Reset()
				if err := s.StartSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_side\"")
			}
		case "in_reply_to":
			if err := func() error {
				s.InReplyTo.Reset()
				if err := s.InReplyTo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"in_reply_to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsCreateReviewCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsCreateReviewCommentReq) {
					name = jsonFieldsNameOfPullsCreateReviewCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PullsCreateReviewCommentReqSide as json.
func (s PullsCreateReviewCommentReqSide) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsCreateReviewCommentReqSide from json.
func (s *PullsCreateReviewCommentReqSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReviewCommentReqSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsCreateReviewCommentReqSide(v) {
	case PullsCreateReviewCommentReqSideLEFT:
		*s = PullsCreateReviewCommentReqSideLEFT
	case PullsCreateReviewCommentReqSideRIGHT:
		*s = PullsCreateReviewCommentReqSideRIGHT
	default:
		*s = PullsCreateReviewCommentReqSide(v)
	}

	return nil
}

// Encode encodes PullsCreateReviewCommentReqStartSide as json.
func (s PullsCreateReviewCommentReqStartSide) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsCreateReviewCommentReqStartSide from json.
func (s *PullsCreateReviewCommentReqStartSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReviewCommentReqStartSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsCreateReviewCommentReqStartSide(v) {
	case PullsCreateReviewCommentReqStartSideLEFT:
		*s = PullsCreateReviewCommentReqStartSideLEFT
	case PullsCreateReviewCommentReqStartSideRIGHT:
		*s = PullsCreateReviewCommentReqStartSideRIGHT
	case PullsCreateReviewCommentReqStartSideSide:
		*s = PullsCreateReviewCommentReqStartSideSide
	default:
		*s = PullsCreateReviewCommentReqStartSide(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsCreateReviewReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CommitID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommitID.Set {
			e.RawStr("\"commit_id\"" + ":")
			s.CommitID.Encode(e)
		}
	}
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.Event.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Event.Set {
			e.RawStr("\"event\"" + ":")
			s.Event.Encode(e)
		}
	}
	{
		if s.Comments != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Comments != nil {
			e.RawStr("\"comments\"" + ":")
			e.ArrStart()
			if len(s.Comments) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Comments[0]
					elem.Encode(e)
				}
				for _, elem := range s.Comments[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsCreateReviewReq = [4]string{
	0: "commit_id",
	1: "body",
	2: "event",
	3: "comments",
}

// Decode decodes PullsCreateReviewReq from json.
func (s *PullsCreateReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReviewReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commit_id":
			if err := func() error {
				s.CommitID.Reset()
				if err := s.CommitID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_id\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "event":
			if err := func() error {
				s.Event.Reset()
				if err := s.Event.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		case "comments":
			if err := func() error {
				s.Comments = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PullsCreateReviewReqCommentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Comments = append(s.Comments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsCreateReviewReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsCreateReviewReqCommentsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		if s.Position.Set {
			e.Comma()
		}
		if s.Position.Set {
			e.RawStr("\"position\"" + ":")
			s.Position.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		if s.Line.Set {
			e.Comma()
		}
		if s.Line.Set {
			e.RawStr("\"line\"" + ":")
			s.Line.Encode(e)
		}
	}
	{
		if s.Side.Set {
			e.Comma()
		}
		if s.Side.Set {
			e.RawStr("\"side\"" + ":")
			s.Side.Encode(e)
		}
	}
	{
		if s.StartLine.Set {
			e.Comma()
		}
		if s.StartLine.Set {
			e.RawStr("\"start_line\"" + ":")
			s.StartLine.Encode(e)
		}
	}
	{
		if s.StartSide.Set {
			e.Comma()
		}
		if s.StartSide.Set {
			e.RawStr("\"start_side\"" + ":")
			s.StartSide.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsCreateReviewReqCommentsItem = [7]string{
	0: "path",
	1: "position",
	2: "body",
	3: "line",
	4: "side",
	5: "start_line",
	6: "start_side",
}

// Decode decodes PullsCreateReviewReqCommentsItem from json.
func (s *PullsCreateReviewReqCommentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReviewReqCommentsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "position":
			if err := func() error {
				s.Position.Reset()
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "line":
			if err := func() error {
				s.Line.Reset()
				if err := s.Line.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"line\"")
			}
		case "side":
			if err := func() error {
				s.Side.Reset()
				if err := s.Side.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"side\"")
			}
		case "start_line":
			if err := func() error {
				s.StartLine.Reset()
				if err := s.StartLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_line\"")
			}
		case "start_side":
			if err := func() error {
				s.StartSide.Reset()
				if err := s.StartSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_side\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsCreateReviewReqCommentsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsCreateReviewReqCommentsItem) {
					name = jsonFieldsNameOfPullsCreateReviewReqCommentsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PullsCreateReviewReqEvent as json.
func (s PullsCreateReviewReqEvent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsCreateReviewReqEvent from json.
func (s *PullsCreateReviewReqEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsCreateReviewReqEvent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsCreateReviewReqEvent(v) {
	case PullsCreateReviewReqEventAPPROVE:
		*s = PullsCreateReviewReqEventAPPROVE
	case PullsCreateReviewReqEventREQUESTCHANGES:
		*s = PullsCreateReviewReqEventREQUESTCHANGES
	case PullsCreateReviewReqEventCOMMENT:
		*s = PullsCreateReviewReqEventCOMMENT
	default:
		*s = PullsCreateReviewReqEvent(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsDismissReviewReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		if s.Event.Set {
			e.Comma()
		}
		if s.Event.Set {
			e.RawStr("\"event\"" + ":")
			s.Event.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsDismissReviewReq = [2]string{
	0: "message",
	1: "event",
}

// Decode decodes PullsDismissReviewReq from json.
func (s *PullsDismissReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsDismissReviewReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "event":
			if err := func() error {
				s.Event.Reset()
				if err := s.Event.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsDismissReviewReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsDismissReviewReq) {
					name = jsonFieldsNameOfPullsDismissReviewReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PullsGetApplicationJSONInternalServerError as json.
func (s PullsGetApplicationJSONInternalServerError) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsGetApplicationJSONInternalServerError from json.
func (s *PullsGetApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsGetApplicationJSONInternalServerError to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsGetApplicationJSONInternalServerError(unwrapped)
	return nil
}

// Encode encodes PullsGetApplicationJSONNotFound as json.
func (s PullsGetApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsGetApplicationJSONNotFound from json.
func (s *PullsGetApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsGetApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsGetApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PullsListCommentsForReviewOKApplicationJSON as json.
func (s PullsListCommentsForReviewOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ReviewComment(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PullsListCommentsForReviewOKApplicationJSON from json.
func (s *PullsListCommentsForReviewOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsListCommentsForReviewOKApplicationJSON to nil")
	}
	var unwrapped []ReviewComment
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ReviewComment
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsListCommentsForReviewOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PullsListFilesOKApplicationJSON as json.
func (s PullsListFilesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []DiffEntry(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PullsListFilesOKApplicationJSON from json.
func (s *PullsListFilesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsListFilesOKApplicationJSON to nil")
	}
	var unwrapped []DiffEntry
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem DiffEntry
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsListFilesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PullsListOKApplicationJSON as json.
func (s PullsListOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []PullRequestSimple(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes PullsListOKApplicationJSON from json.
func (s *PullsListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsListOKApplicationJSON to nil")
	}
	var unwrapped []PullRequestSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PullRequestSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PullsMergeApplicationJSONForbidden as json.
func (s PullsMergeApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsMergeApplicationJSONForbidden from json.
func (s *PullsMergeApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsMergeApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsMergeApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PullsMergeApplicationJSONNotFound as json.
func (s PullsMergeApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsMergeApplicationJSONNotFound from json.
func (s *PullsMergeApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsMergeApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsMergeApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PullsMergeConflict) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsMergeConflict = [2]string{
	0: "message",
	1: "documentation_url",
}

// Decode decodes PullsMergeConflict from json.
func (s *PullsMergeConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsMergeConflict to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsMergeConflict")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsMergeMethodNotAllowed) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsMergeMethodNotAllowed = [2]string{
	0: "message",
	1: "documentation_url",
}

// Decode decodes PullsMergeMethodNotAllowed from json.
func (s *PullsMergeMethodNotAllowed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsMergeMethodNotAllowed to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsMergeMethodNotAllowed")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsMergeReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CommitTitle.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommitTitle.Set {
			e.RawStr("\"commit_title\"" + ":")
			s.CommitTitle.Encode(e)
		}
	}
	{
		if s.CommitMessage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommitMessage.Set {
			e.RawStr("\"commit_message\"" + ":")
			s.CommitMessage.Encode(e)
		}
	}
	{
		if s.Sha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.MergeMethod.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MergeMethod.Set {
			e.RawStr("\"merge_method\"" + ":")
			s.MergeMethod.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsMergeReq = [4]string{
	0: "commit_title",
	1: "commit_message",
	2: "sha",
	3: "merge_method",
}

// Decode decodes PullsMergeReq from json.
func (s *PullsMergeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsMergeReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commit_title":
			if err := func() error {
				s.CommitTitle.Reset()
				if err := s.CommitTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_title\"")
			}
		case "commit_message":
			if err := func() error {
				s.CommitMessage.Reset()
				if err := s.CommitMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_message\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "merge_method":
			if err := func() error {
				s.MergeMethod.Reset()
				if err := s.MergeMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsMergeReq")
	}

	return nil
}

// Encode encodes PullsMergeReqMergeMethod as json.
func (s PullsMergeReqMergeMethod) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsMergeReqMergeMethod from json.
func (s *PullsMergeReqMergeMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsMergeReqMergeMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsMergeReqMergeMethod(v) {
	case PullsMergeReqMergeMethodMerge:
		*s = PullsMergeReqMergeMethodMerge
	case PullsMergeReqMergeMethodSquash:
		*s = PullsMergeReqMergeMethodSquash
	case PullsMergeReqMergeMethodRebase:
		*s = PullsMergeReqMergeMethodRebase
	default:
		*s = PullsMergeReqMergeMethod(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsRemoveRequestedReviewersReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"reviewers\"" + ":")
		e.ArrStart()
		if len(s.Reviewers) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Reviewers[0]
				e.Str(elem)
			}
			for _, elem := range s.Reviewers[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.TeamReviewers != nil {
			e.Comma()
		}
		if s.TeamReviewers != nil {
			e.RawStr("\"team_reviewers\"" + ":")
			e.ArrStart()
			if len(s.TeamReviewers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TeamReviewers[0]
					e.Str(elem)
				}
				for _, elem := range s.TeamReviewers[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsRemoveRequestedReviewersReq = [2]string{
	0: "reviewers",
	1: "team_reviewers",
}

// Decode decodes PullsRemoveRequestedReviewersReq from json.
func (s *PullsRemoveRequestedReviewersReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsRemoveRequestedReviewersReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reviewers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Reviewers = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Reviewers = append(s.Reviewers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reviewers\"")
			}
		case "team_reviewers":
			if err := func() error {
				s.TeamReviewers = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TeamReviewers = append(s.TeamReviewers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_reviewers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsRemoveRequestedReviewersReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsRemoveRequestedReviewersReq) {
					name = jsonFieldsNameOfPullsRemoveRequestedReviewersReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PullsSubmitReviewApplicationJSONForbidden as json.
func (s PullsSubmitReviewApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsSubmitReviewApplicationJSONForbidden from json.
func (s *PullsSubmitReviewApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsSubmitReviewApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsSubmitReviewApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PullsSubmitReviewApplicationJSONNotFound as json.
func (s PullsSubmitReviewApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsSubmitReviewApplicationJSONNotFound from json.
func (s *PullsSubmitReviewApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsSubmitReviewApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsSubmitReviewApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PullsSubmitReviewReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"event\"" + ":")
		s.Event.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsSubmitReviewReq = [2]string{
	0: "body",
	1: "event",
}

// Decode decodes PullsSubmitReviewReq from json.
func (s *PullsSubmitReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsSubmitReviewReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "event":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Event.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsSubmitReviewReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsSubmitReviewReq) {
					name = jsonFieldsNameOfPullsSubmitReviewReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes PullsSubmitReviewReqEvent as json.
func (s PullsSubmitReviewReqEvent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsSubmitReviewReqEvent from json.
func (s *PullsSubmitReviewReqEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsSubmitReviewReqEvent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsSubmitReviewReqEvent(v) {
	case PullsSubmitReviewReqEventAPPROVE:
		*s = PullsSubmitReviewReqEventAPPROVE
	case PullsSubmitReviewReqEventREQUESTCHANGES:
		*s = PullsSubmitReviewReqEventREQUESTCHANGES
	case PullsSubmitReviewReqEventCOMMENT:
		*s = PullsSubmitReviewReqEventCOMMENT
	default:
		*s = PullsSubmitReviewReqEvent(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsUpdateBranchAccepted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsUpdateBranchAccepted = [2]string{
	0: "message",
	1: "url",
}

// Decode decodes PullsUpdateBranchAccepted from json.
func (s *PullsUpdateBranchAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsUpdateBranchAccepted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsUpdateBranchAccepted")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsUpdateBranchReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ExpectedHeadSha.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExpectedHeadSha.Set {
			e.RawStr("\"expected_head_sha\"" + ":")
			s.ExpectedHeadSha.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsUpdateBranchReq = [1]string{
	0: "expected_head_sha",
}

// Decode decodes PullsUpdateBranchReq from json.
func (s *PullsUpdateBranchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsUpdateBranchReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "expected_head_sha":
			if err := func() error {
				s.ExpectedHeadSha.Reset()
				if err := s.ExpectedHeadSha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expected_head_sha\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsUpdateBranchReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsUpdateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.Base.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Base.Set {
			e.RawStr("\"base\"" + ":")
			s.Base.Encode(e)
		}
	}
	{
		if s.MaintainerCanModify.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MaintainerCanModify.Set {
			e.RawStr("\"maintainer_can_modify\"" + ":")
			s.MaintainerCanModify.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsUpdateReq = [5]string{
	0: "title",
	1: "body",
	2: "state",
	3: "base",
	4: "maintainer_can_modify",
}

// Decode decodes PullsUpdateReq from json.
func (s *PullsUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsUpdateReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "base":
			if err := func() error {
				s.Base.Reset()
				if err := s.Base.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base\"")
			}
		case "maintainer_can_modify":
			if err := func() error {
				s.MaintainerCanModify.Reset()
				if err := s.MaintainerCanModify.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintainer_can_modify\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsUpdateReq")
	}

	return nil
}

// Encode encodes PullsUpdateReqState as json.
func (s PullsUpdateReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes PullsUpdateReqState from json.
func (s *PullsUpdateReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsUpdateReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PullsUpdateReqState(v) {
	case PullsUpdateReqStateOpen:
		*s = PullsUpdateReqStateOpen
	case PullsUpdateReqStateClosed:
		*s = PullsUpdateReqStateClosed
	default:
		*s = PullsUpdateReqState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsUpdateReviewCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsUpdateReviewCommentReq = [1]string{
	0: "body",
}

// Decode decodes PullsUpdateReviewCommentReq from json.
func (s *PullsUpdateReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsUpdateReviewCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsUpdateReviewCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsUpdateReviewCommentReq) {
					name = jsonFieldsNameOfPullsUpdateReviewCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PullsUpdateReviewReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPullsUpdateReviewReq = [1]string{
	0: "body",
}

// Decode decodes PullsUpdateReviewReq from json.
func (s *PullsUpdateReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PullsUpdateReviewReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PullsUpdateReviewReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPullsUpdateReviewReq) {
					name = jsonFieldsNameOfPullsUpdateReviewReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RateLimit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"limit\"" + ":")
		e.Int(s.Limit)
	}
	{
		e.Comma()

		e.RawStr("\"remaining\"" + ":")
		e.Int(s.Remaining)
	}
	{
		e.Comma()

		e.RawStr("\"reset\"" + ":")
		e.Int(s.Reset)
	}
	{
		e.Comma()

		e.RawStr("\"used\"" + ":")
		e.Int(s.Used)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRateLimit = [4]string{
	0: "limit",
	1: "remaining",
	2: "reset",
	3: "used",
}

// Decode decodes RateLimit from json.
func (s *RateLimit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "remaining":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Remaining = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining\"")
			}
		case "reset":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Reset = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reset\"")
			}
		case "used":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Used = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRateLimit) {
					name = jsonFieldsNameOfRateLimit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RateLimitOverview) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"resources\"" + ":")
		s.Resources.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"rate\"" + ":")
		s.Rate.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRateLimitOverview = [2]string{
	0: "resources",
	1: "rate",
}

// Decode decodes RateLimitOverview from json.
func (s *RateLimitOverview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitOverview to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resources":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Resources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "rate":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Rate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitOverview")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRateLimitOverview) {
					name = jsonFieldsNameOfRateLimitOverview[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RateLimitOverviewResources) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"core\"" + ":")
		s.Core.Encode(e)
	}
	{
		if s.Graphql.Set {
			e.Comma()
		}
		if s.Graphql.Set {
			e.RawStr("\"graphql\"" + ":")
			s.Graphql.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"search\"" + ":")
		s.Search.Encode(e)
	}
	{
		if s.SourceImport.Set {
			e.Comma()
		}
		if s.SourceImport.Set {
			e.RawStr("\"source_import\"" + ":")
			s.SourceImport.Encode(e)
		}
	}
	{
		if s.IntegrationManifest.Set {
			e.Comma()
		}
		if s.IntegrationManifest.Set {
			e.RawStr("\"integration_manifest\"" + ":")
			s.IntegrationManifest.Encode(e)
		}
	}
	{
		if s.CodeScanningUpload.Set {
			e.Comma()
		}
		if s.CodeScanningUpload.Set {
			e.RawStr("\"code_scanning_upload\"" + ":")
			s.CodeScanningUpload.Encode(e)
		}
	}
	{
		if s.ActionsRunnerRegistration.Set {
			e.Comma()
		}
		if s.ActionsRunnerRegistration.Set {
			e.RawStr("\"actions_runner_registration\"" + ":")
			s.ActionsRunnerRegistration.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRateLimitOverviewResources = [7]string{
	0: "core",
	1: "graphql",
	2: "search",
	3: "source_import",
	4: "integration_manifest",
	5: "code_scanning_upload",
	6: "actions_runner_registration",
}

// Decode decodes RateLimitOverviewResources from json.
func (s *RateLimitOverviewResources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimitOverviewResources to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "core":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Core.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"core\"")
			}
		case "graphql":
			if err := func() error {
				s.Graphql.Reset()
				if err := s.Graphql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"graphql\"")
			}
		case "search":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Search.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search\"")
			}
		case "source_import":
			if err := func() error {
				s.SourceImport.Reset()
				if err := s.SourceImport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_import\"")
			}
		case "integration_manifest":
			if err := func() error {
				s.IntegrationManifest.Reset()
				if err := s.IntegrationManifest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integration_manifest\"")
			}
		case "code_scanning_upload":
			if err := func() error {
				s.CodeScanningUpload.Reset()
				if err := s.CodeScanningUpload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_scanning_upload\"")
			}
		case "actions_runner_registration":
			if err := func() error {
				s.ActionsRunnerRegistration.Reset()
				if err := s.ActionsRunnerRegistration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actions_runner_registration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimitOverviewResources")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRateLimitOverviewResources) {
					name = jsonFieldsNameOfRateLimitOverviewResources[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Reaction) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReaction = [5]string{
	0: "id",
	1: "node_id",
	2: "user",
	3: "content",
	4: "created_at",
}

// Decode decodes Reaction from json.
func (s *Reaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Reaction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Reaction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReaction) {
					name = jsonFieldsNameOfReaction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReactionContent as json.
func (s ReactionContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionContent from json.
func (s *ReactionContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionContent(v) {
	case ReactionContentPlus1:
		*s = ReactionContentPlus1
	case ReactionContentMinus1:
		*s = ReactionContentMinus1
	case ReactionContentLaugh:
		*s = ReactionContentLaugh
	case ReactionContentConfused:
		*s = ReactionContentConfused
	case ReactionContentHeart:
		*s = ReactionContentHeart
	case ReactionContentHooray:
		*s = ReactionContentHooray
	case ReactionContentRocket:
		*s = ReactionContentRocket
	case ReactionContentEyes:
		*s = ReactionContentEyes
	default:
		*s = ReactionContent(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReactionRollup) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"+1\"" + ":")
		e.Int(s.Plus1)
	}
	{
		e.Comma()

		e.RawStr("\"-1\"" + ":")
		e.Int(s.Minus1)
	}
	{
		e.Comma()

		e.RawStr("\"laugh\"" + ":")
		e.Int(s.Laugh)
	}
	{
		e.Comma()

		e.RawStr("\"confused\"" + ":")
		e.Int(s.Confused)
	}
	{
		e.Comma()

		e.RawStr("\"heart\"" + ":")
		e.Int(s.Heart)
	}
	{
		e.Comma()

		e.RawStr("\"hooray\"" + ":")
		e.Int(s.Hooray)
	}
	{
		e.Comma()

		e.RawStr("\"eyes\"" + ":")
		e.Int(s.Eyes)
	}
	{
		e.Comma()

		e.RawStr("\"rocket\"" + ":")
		e.Int(s.Rocket)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReactionRollup = [10]string{
	0: "url",
	1: "total_count",
	2: "+1",
	3: "-1",
	4: "laugh",
	5: "confused",
	6: "heart",
	7: "hooray",
	8: "eyes",
	9: "rocket",
}

// Decode decodes ReactionRollup from json.
func (s *ReactionRollup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionRollup to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "total_count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "+1":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Plus1 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"+1\"")
			}
		case "-1":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Minus1 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"-1\"")
			}
		case "laugh":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Laugh = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"laugh\"")
			}
		case "confused":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Confused = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confused\"")
			}
		case "heart":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Heart = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heart\"")
			}
		case "hooray":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Hooray = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooray\"")
			}
		case "eyes":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Eyes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eyes\"")
			}
		case "rocket":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Rocket = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rocket\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionRollup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionRollup) {
					name = jsonFieldsNameOfReactionRollup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReactionsCreateForCommitCommentApplicationJSONCreated as json.
func (s ReactionsCreateForCommitCommentApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForCommitCommentApplicationJSONCreated from json.
func (s *ReactionsCreateForCommitCommentApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForCommitCommentApplicationJSONCreated to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForCommitCommentApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForCommitCommentApplicationJSONOK as json.
func (s ReactionsCreateForCommitCommentApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForCommitCommentApplicationJSONOK from json.
func (s *ReactionsCreateForCommitCommentApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForCommitCommentApplicationJSONOK to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForCommitCommentApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForCommitCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReactionsCreateForCommitCommentReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForCommitCommentReq from json.
func (s *ReactionsCreateForCommitCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForCommitCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForCommitCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForCommitCommentReq) {
					name = jsonFieldsNameOfReactionsCreateForCommitCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReactionsCreateForCommitCommentReqContent as json.
func (s ReactionsCreateForCommitCommentReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForCommitCommentReqContent from json.
func (s *ReactionsCreateForCommitCommentReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForCommitCommentReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForCommitCommentReqContent(v) {
	case ReactionsCreateForCommitCommentReqContentPlus1:
		*s = ReactionsCreateForCommitCommentReqContentPlus1
	case ReactionsCreateForCommitCommentReqContentMinus1:
		*s = ReactionsCreateForCommitCommentReqContentMinus1
	case ReactionsCreateForCommitCommentReqContentLaugh:
		*s = ReactionsCreateForCommitCommentReqContentLaugh
	case ReactionsCreateForCommitCommentReqContentConfused:
		*s = ReactionsCreateForCommitCommentReqContentConfused
	case ReactionsCreateForCommitCommentReqContentHeart:
		*s = ReactionsCreateForCommitCommentReqContentHeart
	case ReactionsCreateForCommitCommentReqContentHooray:
		*s = ReactionsCreateForCommitCommentReqContentHooray
	case ReactionsCreateForCommitCommentReqContentRocket:
		*s = ReactionsCreateForCommitCommentReqContentRocket
	case ReactionsCreateForCommitCommentReqContentEyes:
		*s = ReactionsCreateForCommitCommentReqContentEyes
	default:
		*s = ReactionsCreateForCommitCommentReqContent(v)
	}

	return nil
}

// Encode encodes ReactionsCreateForIssueApplicationJSONCreated as json.
func (s ReactionsCreateForIssueApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForIssueApplicationJSONCreated from json.
func (s *ReactionsCreateForIssueApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueApplicationJSONCreated to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForIssueApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForIssueApplicationJSONOK as json.
func (s ReactionsCreateForIssueApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForIssueApplicationJSONOK from json.
func (s *ReactionsCreateForIssueApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueApplicationJSONOK to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForIssueApplicationJSONOK(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForIssueCommentApplicationJSONCreated as json.
func (s ReactionsCreateForIssueCommentApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForIssueCommentApplicationJSONCreated from json.
func (s *ReactionsCreateForIssueCommentApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueCommentApplicationJSONCreated to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForIssueCommentApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForIssueCommentApplicationJSONOK as json.
func (s ReactionsCreateForIssueCommentApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForIssueCommentApplicationJSONOK from json.
func (s *ReactionsCreateForIssueCommentApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueCommentApplicationJSONOK to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForIssueCommentApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForIssueCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReactionsCreateForIssueCommentReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForIssueCommentReq from json.
func (s *ReactionsCreateForIssueCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForIssueCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForIssueCommentReq) {
					name = jsonFieldsNameOfReactionsCreateForIssueCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReactionsCreateForIssueCommentReqContent as json.
func (s ReactionsCreateForIssueCommentReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForIssueCommentReqContent from json.
func (s *ReactionsCreateForIssueCommentReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueCommentReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForIssueCommentReqContent(v) {
	case ReactionsCreateForIssueCommentReqContentPlus1:
		*s = ReactionsCreateForIssueCommentReqContentPlus1
	case ReactionsCreateForIssueCommentReqContentMinus1:
		*s = ReactionsCreateForIssueCommentReqContentMinus1
	case ReactionsCreateForIssueCommentReqContentLaugh:
		*s = ReactionsCreateForIssueCommentReqContentLaugh
	case ReactionsCreateForIssueCommentReqContentConfused:
		*s = ReactionsCreateForIssueCommentReqContentConfused
	case ReactionsCreateForIssueCommentReqContentHeart:
		*s = ReactionsCreateForIssueCommentReqContentHeart
	case ReactionsCreateForIssueCommentReqContentHooray:
		*s = ReactionsCreateForIssueCommentReqContentHooray
	case ReactionsCreateForIssueCommentReqContentRocket:
		*s = ReactionsCreateForIssueCommentReqContentRocket
	case ReactionsCreateForIssueCommentReqContentEyes:
		*s = ReactionsCreateForIssueCommentReqContentEyes
	default:
		*s = ReactionsCreateForIssueCommentReqContent(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForIssueReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReactionsCreateForIssueReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForIssueReq from json.
func (s *ReactionsCreateForIssueReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForIssueReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForIssueReq) {
					name = jsonFieldsNameOfReactionsCreateForIssueReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReactionsCreateForIssueReqContent as json.
func (s ReactionsCreateForIssueReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForIssueReqContent from json.
func (s *ReactionsCreateForIssueReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForIssueReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForIssueReqContent(v) {
	case ReactionsCreateForIssueReqContentPlus1:
		*s = ReactionsCreateForIssueReqContentPlus1
	case ReactionsCreateForIssueReqContentMinus1:
		*s = ReactionsCreateForIssueReqContentMinus1
	case ReactionsCreateForIssueReqContentLaugh:
		*s = ReactionsCreateForIssueReqContentLaugh
	case ReactionsCreateForIssueReqContentConfused:
		*s = ReactionsCreateForIssueReqContentConfused
	case ReactionsCreateForIssueReqContentHeart:
		*s = ReactionsCreateForIssueReqContentHeart
	case ReactionsCreateForIssueReqContentHooray:
		*s = ReactionsCreateForIssueReqContentHooray
	case ReactionsCreateForIssueReqContentRocket:
		*s = ReactionsCreateForIssueReqContentRocket
	case ReactionsCreateForIssueReqContentEyes:
		*s = ReactionsCreateForIssueReqContentEyes
	default:
		*s = ReactionsCreateForIssueReqContent(v)
	}

	return nil
}

// Encode encodes ReactionsCreateForPullRequestReviewCommentApplicationJSONCreated as json.
func (s ReactionsCreateForPullRequestReviewCommentApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForPullRequestReviewCommentApplicationJSONCreated from json.
func (s *ReactionsCreateForPullRequestReviewCommentApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForPullRequestReviewCommentApplicationJSONCreated to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForPullRequestReviewCommentApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForPullRequestReviewCommentApplicationJSONOK as json.
func (s ReactionsCreateForPullRequestReviewCommentApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForPullRequestReviewCommentApplicationJSONOK from json.
func (s *ReactionsCreateForPullRequestReviewCommentApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForPullRequestReviewCommentApplicationJSONOK to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForPullRequestReviewCommentApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForPullRequestReviewCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReactionsCreateForPullRequestReviewCommentReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForPullRequestReviewCommentReq from json.
func (s *ReactionsCreateForPullRequestReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForPullRequestReviewCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForPullRequestReviewCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForPullRequestReviewCommentReq) {
					name = jsonFieldsNameOfReactionsCreateForPullRequestReviewCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReactionsCreateForPullRequestReviewCommentReqContent as json.
func (s ReactionsCreateForPullRequestReviewCommentReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForPullRequestReviewCommentReqContent from json.
func (s *ReactionsCreateForPullRequestReviewCommentReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForPullRequestReviewCommentReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForPullRequestReviewCommentReqContent(v) {
	case ReactionsCreateForPullRequestReviewCommentReqContentPlus1:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentPlus1
	case ReactionsCreateForPullRequestReviewCommentReqContentMinus1:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentMinus1
	case ReactionsCreateForPullRequestReviewCommentReqContentLaugh:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentLaugh
	case ReactionsCreateForPullRequestReviewCommentReqContentConfused:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentConfused
	case ReactionsCreateForPullRequestReviewCommentReqContentHeart:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentHeart
	case ReactionsCreateForPullRequestReviewCommentReqContentHooray:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentHooray
	case ReactionsCreateForPullRequestReviewCommentReqContentRocket:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentRocket
	case ReactionsCreateForPullRequestReviewCommentReqContentEyes:
		*s = ReactionsCreateForPullRequestReviewCommentReqContentEyes
	default:
		*s = ReactionsCreateForPullRequestReviewCommentReqContent(v)
	}

	return nil
}

// Encode encodes ReactionsCreateForReleaseApplicationJSONCreated as json.
func (s ReactionsCreateForReleaseApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForReleaseApplicationJSONCreated from json.
func (s *ReactionsCreateForReleaseApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForReleaseApplicationJSONCreated to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForReleaseApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForReleaseApplicationJSONOK as json.
func (s ReactionsCreateForReleaseApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForReleaseApplicationJSONOK from json.
func (s *ReactionsCreateForReleaseApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForReleaseApplicationJSONOK to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForReleaseApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForReleaseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReactionsCreateForReleaseReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForReleaseReq from json.
func (s *ReactionsCreateForReleaseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForReleaseReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForReleaseReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForReleaseReq) {
					name = jsonFieldsNameOfReactionsCreateForReleaseReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReactionsCreateForReleaseReqContent as json.
func (s ReactionsCreateForReleaseReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForReleaseReqContent from json.
func (s *ReactionsCreateForReleaseReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForReleaseReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForReleaseReqContent(v) {
	case ReactionsCreateForReleaseReqContentPlus1:
		*s = ReactionsCreateForReleaseReqContentPlus1
	case ReactionsCreateForReleaseReqContentLaugh:
		*s = ReactionsCreateForReleaseReqContentLaugh
	case ReactionsCreateForReleaseReqContentHeart:
		*s = ReactionsCreateForReleaseReqContentHeart
	case ReactionsCreateForReleaseReqContentHooray:
		*s = ReactionsCreateForReleaseReqContentHooray
	case ReactionsCreateForReleaseReqContentRocket:
		*s = ReactionsCreateForReleaseReqContentRocket
	case ReactionsCreateForReleaseReqContentEyes:
		*s = ReactionsCreateForReleaseReqContentEyes
	default:
		*s = ReactionsCreateForReleaseReqContent(v)
	}

	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated as json.
func (s ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK as json.
func (s ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForTeamDiscussionCommentInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReactionsCreateForTeamDiscussionCommentInOrgReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgReq from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForTeamDiscussionCommentInOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForTeamDiscussionCommentInOrgReq) {
					name = jsonFieldsNameOfReactionsCreateForTeamDiscussionCommentInOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentInOrgReqContent as json.
func (s ReactionsCreateForTeamDiscussionCommentInOrgReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgReqContent from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForTeamDiscussionCommentInOrgReqContent(v) {
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentPlus1:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentPlus1
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentMinus1:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentMinus1
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentLaugh:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentLaugh
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentConfused:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentConfused
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentHeart:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentHeart
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentHooray:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentHooray
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentRocket:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentRocket
	case ReactionsCreateForTeamDiscussionCommentInOrgReqContentEyes:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContentEyes
	default:
		*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContent(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForTeamDiscussionCommentLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReactionsCreateForTeamDiscussionCommentLegacyReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentLegacyReq from json.
func (s *ReactionsCreateForTeamDiscussionCommentLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionCommentLegacyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForTeamDiscussionCommentLegacyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForTeamDiscussionCommentLegacyReq) {
					name = jsonFieldsNameOfReactionsCreateForTeamDiscussionCommentLegacyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentLegacyReqContent as json.
func (s ReactionsCreateForTeamDiscussionCommentLegacyReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentLegacyReqContent from json.
func (s *ReactionsCreateForTeamDiscussionCommentLegacyReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionCommentLegacyReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForTeamDiscussionCommentLegacyReqContent(v) {
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentPlus1:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentPlus1
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentMinus1:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentMinus1
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentLaugh:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentLaugh
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentConfused:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentConfused
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentHeart:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentHeart
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentHooray:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentHooray
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentRocket:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentRocket
	case ReactionsCreateForTeamDiscussionCommentLegacyReqContentEyes:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContentEyes
	default:
		*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContent(v)
	}

	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated as json.
func (s ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated from json.
func (s *ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK as json.
func (s ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK from json.
func (s *ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK to nil")
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForTeamDiscussionInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReactionsCreateForTeamDiscussionInOrgReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgReq from json.
func (s *ReactionsCreateForTeamDiscussionInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForTeamDiscussionInOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForTeamDiscussionInOrgReq) {
					name = jsonFieldsNameOfReactionsCreateForTeamDiscussionInOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionInOrgReqContent as json.
func (s ReactionsCreateForTeamDiscussionInOrgReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgReqContent from json.
func (s *ReactionsCreateForTeamDiscussionInOrgReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForTeamDiscussionInOrgReqContent(v) {
	case ReactionsCreateForTeamDiscussionInOrgReqContentPlus1:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentPlus1
	case ReactionsCreateForTeamDiscussionInOrgReqContentMinus1:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentMinus1
	case ReactionsCreateForTeamDiscussionInOrgReqContentLaugh:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentLaugh
	case ReactionsCreateForTeamDiscussionInOrgReqContentConfused:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentConfused
	case ReactionsCreateForTeamDiscussionInOrgReqContentHeart:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentHeart
	case ReactionsCreateForTeamDiscussionInOrgReqContentHooray:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentHooray
	case ReactionsCreateForTeamDiscussionInOrgReqContentRocket:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentRocket
	case ReactionsCreateForTeamDiscussionInOrgReqContentEyes:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContentEyes
	default:
		*s = ReactionsCreateForTeamDiscussionInOrgReqContent(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForTeamDiscussionLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"content\"" + ":")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReactionsCreateForTeamDiscussionLegacyReq = [1]string{
	0: "content",
}

// Decode decodes ReactionsCreateForTeamDiscussionLegacyReq from json.
func (s *ReactionsCreateForTeamDiscussionLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionLegacyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReactionsCreateForTeamDiscussionLegacyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReactionsCreateForTeamDiscussionLegacyReq) {
					name = jsonFieldsNameOfReactionsCreateForTeamDiscussionLegacyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionLegacyReqContent as json.
func (s ReactionsCreateForTeamDiscussionLegacyReqContent) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionLegacyReqContent from json.
func (s *ReactionsCreateForTeamDiscussionLegacyReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsCreateForTeamDiscussionLegacyReqContent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReactionsCreateForTeamDiscussionLegacyReqContent(v) {
	case ReactionsCreateForTeamDiscussionLegacyReqContentPlus1:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentPlus1
	case ReactionsCreateForTeamDiscussionLegacyReqContentMinus1:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentMinus1
	case ReactionsCreateForTeamDiscussionLegacyReqContentLaugh:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentLaugh
	case ReactionsCreateForTeamDiscussionLegacyReqContentConfused:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentConfused
	case ReactionsCreateForTeamDiscussionLegacyReqContentHeart:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentHeart
	case ReactionsCreateForTeamDiscussionLegacyReqContentHooray:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentHooray
	case ReactionsCreateForTeamDiscussionLegacyReqContentRocket:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentRocket
	case ReactionsCreateForTeamDiscussionLegacyReqContentEyes:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContentEyes
	default:
		*s = ReactionsCreateForTeamDiscussionLegacyReqContent(v)
	}

	return nil
}

// Encode encodes ReactionsDeleteLegacyApplicationJSONForbidden as json.
func (s ReactionsDeleteLegacyApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsDeleteLegacyApplicationJSONForbidden from json.
func (s *ReactionsDeleteLegacyApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsDeleteLegacyApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsDeleteLegacyApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReactionsDeleteLegacyApplicationJSONGone as json.
func (s ReactionsDeleteLegacyApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsDeleteLegacyApplicationJSONGone from json.
func (s *ReactionsDeleteLegacyApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsDeleteLegacyApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsDeleteLegacyApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ReactionsDeleteLegacyApplicationJSONUnauthorized as json.
func (s ReactionsDeleteLegacyApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsDeleteLegacyApplicationJSONUnauthorized from json.
func (s *ReactionsDeleteLegacyApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsDeleteLegacyApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsDeleteLegacyApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ReactionsListForCommitCommentOKApplicationJSON as json.
func (s ReactionsListForCommitCommentOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Reaction(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReactionsListForCommitCommentOKApplicationJSON from json.
func (s *ReactionsListForCommitCommentOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsListForCommitCommentOKApplicationJSON to nil")
	}
	var unwrapped []Reaction
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Reaction
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForCommitCommentOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReactionsListForIssueApplicationJSONGone as json.
func (s ReactionsListForIssueApplicationJSONGone) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsListForIssueApplicationJSONGone from json.
func (s *ReactionsListForIssueApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsListForIssueApplicationJSONGone to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForIssueApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ReactionsListForIssueApplicationJSONNotFound as json.
func (s ReactionsListForIssueApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsListForIssueApplicationJSONNotFound from json.
func (s *ReactionsListForIssueApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsListForIssueApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForIssueApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReactionsListForIssueCommentOKApplicationJSON as json.
func (s ReactionsListForIssueCommentOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Reaction(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReactionsListForIssueCommentOKApplicationJSON from json.
func (s *ReactionsListForIssueCommentOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsListForIssueCommentOKApplicationJSON to nil")
	}
	var unwrapped []Reaction
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Reaction
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForIssueCommentOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReactionsListForIssueOKApplicationJSON as json.
func (s ReactionsListForIssueOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Reaction(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReactionsListForIssueOKApplicationJSON from json.
func (s *ReactionsListForIssueOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsListForIssueOKApplicationJSON to nil")
	}
	var unwrapped []Reaction
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Reaction
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForIssueOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReactionsListForPullRequestReviewCommentOKApplicationJSON as json.
func (s ReactionsListForPullRequestReviewCommentOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Reaction(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReactionsListForPullRequestReviewCommentOKApplicationJSON from json.
func (s *ReactionsListForPullRequestReviewCommentOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReactionsListForPullRequestReviewCommentOKApplicationJSON to nil")
	}
	var unwrapped []Reaction
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Reaction
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForPullRequestReviewCommentOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReferrerTraffic) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"referrer\"" + ":")
		e.Str(s.Referrer)
	}
	{
		e.Comma()

		e.RawStr("\"count\"" + ":")
		e.Int(s.Count)
	}
	{
		e.Comma()

		e.RawStr("\"uniques\"" + ":")
		e.Int(s.Uniques)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReferrerTraffic = [3]string{
	0: "referrer",
	1: "count",
	2: "uniques",
}

// Decode decodes ReferrerTraffic from json.
func (s *ReferrerTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReferrerTraffic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referrer":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Referrer = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referrer\"")
			}
		case "count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "uniques":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Uniques = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniques\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReferrerTraffic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReferrerTraffic) {
					name = jsonFieldsNameOfReferrerTraffic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Release) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"assets_url\"" + ":")
		json.EncodeURI(e, s.AssetsURL)
	}
	{
		e.Comma()

		e.RawStr("\"upload_url\"" + ":")
		e.Str(s.UploadURL)
	}
	{
		e.Comma()

		e.RawStr("\"tarball_url\"" + ":")
		s.TarballURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"zipball_url\"" + ":")
		s.ZipballURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"tag_name\"" + ":")
		e.Str(s.TagName)
	}
	{
		e.Comma()

		e.RawStr("\"target_commitish\"" + ":")
		e.Str(s.TargetCommitish)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		s.Name.Encode(e)
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"draft\"" + ":")
		e.Bool(s.Draft)
	}
	{
		e.Comma()

		e.RawStr("\"prerelease\"" + ":")
		e.Bool(s.Prerelease)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"published_at\"" + ":")
		s.PublishedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"assets\"" + ":")
		e.ArrStart()
		if len(s.Assets) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Assets[0]
				elem.Encode(e)
			}
			for _, elem := range s.Assets[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.MentionsCount.Set {
			e.Comma()
		}
		if s.MentionsCount.Set {
			e.RawStr("\"mentions_count\"" + ":")
			s.MentionsCount.Encode(e)
		}
	}
	{
		if s.DiscussionURL.Set {
			e.Comma()
		}
		if s.DiscussionURL.Set {
			e.RawStr("\"discussion_url\"" + ":")
			s.DiscussionURL.Encode(e)
		}
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRelease = [23]string{
	0:  "url",
	1:  "html_url",
	2:  "assets_url",
	3:  "upload_url",
	4:  "tarball_url",
	5:  "zipball_url",
	6:  "id",
	7:  "node_id",
	8:  "tag_name",
	9:  "target_commitish",
	10: "name",
	11: "body",
	12: "draft",
	13: "prerelease",
	14: "created_at",
	15: "published_at",
	16: "author",
	17: "assets",
	18: "body_html",
	19: "body_text",
	20: "mentions_count",
	21: "discussion_url",
	22: "reactions",
}

// Decode decodes Release from json.
func (s *Release) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Release to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "assets_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AssetsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assets_url\"")
			}
		case "upload_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.UploadURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upload_url\"")
			}
		case "tarball_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.TarballURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tarball_url\"")
			}
		case "zipball_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.ZipballURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zipball_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "tag_name":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TagName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_name\"")
			}
		case "target_commitish":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TargetCommitish = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_commitish\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "draft":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Draft = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		case "prerelease":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Prerelease = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prerelease\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "published_at":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.PublishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"published_at\"")
			}
		case "author":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "assets":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				s.Assets = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReleaseAsset
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Assets = append(s.Assets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assets\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		case "mentions_count":
			if err := func() error {
				s.MentionsCount.Reset()
				if err := s.MentionsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mentions_count\"")
			}
		case "discussion_url":
			if err := func() error {
				s.DiscussionURL.Reset()
				if err := s.DiscussionURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discussion_url\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Release")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11110111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRelease) {
					name = jsonFieldsNameOfRelease[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReleaseAsset) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"browser_download_url\"" + ":")
		json.EncodeURI(e, s.BrowserDownloadURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"label\"" + ":")
		s.Label.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"content_type\"" + ":")
		e.Str(s.ContentType)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"download_count\"" + ":")
		e.Int(s.DownloadCount)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"uploader\"" + ":")
		s.Uploader.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReleaseAsset = [13]string{
	0:  "url",
	1:  "browser_download_url",
	2:  "id",
	3:  "node_id",
	4:  "name",
	5:  "label",
	6:  "state",
	7:  "content_type",
	8:  "size",
	9:  "download_count",
	10: "created_at",
	11: "updated_at",
	12: "uploader",
}

// Decode decodes ReleaseAsset from json.
func (s *ReleaseAsset) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReleaseAsset to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "browser_download_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.BrowserDownloadURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"browser_download_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "label":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Label.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "content_type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ContentType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "size":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "download_count":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DownloadCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download_count\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "uploader":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Uploader.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uploader\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReleaseAsset")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReleaseAsset) {
					name = jsonFieldsNameOfReleaseAsset[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReleaseAssetState as json.
func (s ReleaseAssetState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReleaseAssetState from json.
func (s *ReleaseAssetState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReleaseAssetState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReleaseAssetState(v) {
	case ReleaseAssetStateUploaded:
		*s = ReleaseAssetStateUploaded
	case ReleaseAssetStateOpen:
		*s = ReleaseAssetStateOpen
	default:
		*s = ReleaseAssetState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RepoSearchResultItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"pushed_at\"" + ":")
		json.EncodeDateTime(e, s.PushedAt)
	}
	{
		e.Comma()

		e.RawStr("\"homepage\"" + ":")
		s.Homepage.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_count\"" + ":")
		e.Int(s.StargazersCount)
	}
	{
		e.Comma()

		e.RawStr("\"watchers_count\"" + ":")
		e.Int(s.WatchersCount)
	}
	{
		e.Comma()

		e.RawStr("\"language\"" + ":")
		s.Language.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"forks_count\"" + ":")
		e.Int(s.ForksCount)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues_count\"" + ":")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.MasterBranch.Set {
			e.Comma()
		}
		if s.MasterBranch.Set {
			e.RawStr("\"master_branch\"" + ":")
			s.MasterBranch.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"default_branch\"" + ":")
		e.Str(s.DefaultBranch)
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Float64(s.Score)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		e.Str(s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"ssh_url\"" + ":")
		e.Str(s.SSHURL)
	}
	{
		e.Comma()

		e.RawStr("\"clone_url\"" + ":")
		e.Str(s.CloneURL)
	}
	{
		e.Comma()

		e.RawStr("\"svn_url\"" + ":")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		e.Comma()

		e.RawStr("\"forks\"" + ":")
		e.Int(s.Forks)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"watchers\"" + ":")
		e.Int(s.Watchers)
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"mirror_url\"" + ":")
		s.MirrorURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"has_issues\"" + ":")
		e.Bool(s.HasIssues)
	}
	{
		e.Comma()

		e.RawStr("\"has_projects\"" + ":")
		e.Bool(s.HasProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_pages\"" + ":")
		e.Bool(s.HasPages)
	}
	{
		e.Comma()

		e.RawStr("\"has_wiki\"" + ":")
		e.Bool(s.HasWiki)
	}
	{
		e.Comma()

		e.RawStr("\"has_downloads\"" + ":")
		e.Bool(s.HasDownloads)
	}
	{
		e.Comma()

		e.RawStr("\"archived\"" + ":")
		e.Bool(s.Archived)
	}
	{
		e.Comma()

		e.RawStr("\"disabled\"" + ":")
		e.Bool(s.Disabled)
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.TextMatches != nil {
			e.Comma()
		}
		if s.TextMatches != nil {
			e.RawStr("\"text_matches\"" + ":")
			s.TextMatches.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.Comma()
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRepoSearchResultItem = [85]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "owner",
	5:  "private",
	6:  "html_url",
	7:  "description",
	8:  "fork",
	9:  "url",
	10: "created_at",
	11: "updated_at",
	12: "pushed_at",
	13: "homepage",
	14: "size",
	15: "stargazers_count",
	16: "watchers_count",
	17: "language",
	18: "forks_count",
	19: "open_issues_count",
	20: "master_branch",
	21: "default_branch",
	22: "score",
	23: "forks_url",
	24: "keys_url",
	25: "collaborators_url",
	26: "teams_url",
	27: "hooks_url",
	28: "issue_events_url",
	29: "events_url",
	30: "assignees_url",
	31: "branches_url",
	32: "tags_url",
	33: "blobs_url",
	34: "git_tags_url",
	35: "git_refs_url",
	36: "trees_url",
	37: "statuses_url",
	38: "languages_url",
	39: "stargazers_url",
	40: "contributors_url",
	41: "subscribers_url",
	42: "subscription_url",
	43: "commits_url",
	44: "git_commits_url",
	45: "comments_url",
	46: "issue_comment_url",
	47: "contents_url",
	48: "compare_url",
	49: "merges_url",
	50: "archive_url",
	51: "downloads_url",
	52: "issues_url",
	53: "pulls_url",
	54: "milestones_url",
	55: "notifications_url",
	56: "labels_url",
	57: "releases_url",
	58: "deployments_url",
	59: "git_url",
	60: "ssh_url",
	61: "clone_url",
	62: "svn_url",
	63: "forks",
	64: "open_issues",
	65: "watchers",
	66: "topics",
	67: "mirror_url",
	68: "has_issues",
	69: "has_projects",
	70: "has_pages",
	71: "has_wiki",
	72: "has_downloads",
	73: "archived",
	74: "disabled",
	75: "license",
	76: "permissions",
	77: "text_matches",
	78: "temp_clone_token",
	79: "allow_merge_commit",
	80: "allow_squash_merge",
	81: "allow_rebase_merge",
	82: "allow_auto_merge",
	83: "delete_branch_on_merge",
	84: "allow_forking",
}

// Decode decodes RepoSearchResultItem from json.
func (s *RepoSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepoSearchResultItem to nil")
	}
	var requiredBitSet [11]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "pushed_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.PushedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "homepage":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "size":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "stargazers_count":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.StargazersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.WatchersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "language":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ForksCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "open_issues_count":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.OpenIssuesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "master_branch":
			if err := func() error {
				s.MasterBranch.Reset()
				if err := s.MasterBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master_branch\"")
			}
		case "default_branch":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DefaultBranch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "score":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.Score = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "forks_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "keys_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "collaborators_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "teams_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "hooks_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "issue_events_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "events_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "assignees_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "branches_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "tags_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "blobs_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_refs_url":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "trees_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "statuses_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "languages_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "stargazers_url":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "contributors_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "commits_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "git_commits_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "comments_url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "issue_comment_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "contents_url":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "compare_url":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "merges_url":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "archive_url":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "downloads_url":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "issues_url":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "pulls_url":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "milestones_url":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "labels_url":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "releases_url":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "deployments_url":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "git_url":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "ssh_url":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SSHURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "clone_url":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CloneURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "svn_url":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SvnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "forks":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Forks = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "open_issues":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "watchers":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Watchers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "mirror_url":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "has_issues":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasIssues = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.HasProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_pages":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.HasPages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_wiki":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.HasWiki = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_downloads":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HasDownloads = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Archived = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "license":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "text_matches":
			if err := func() error {
				s.TextMatches = nil
				var elem SearchResultTextMatches
				{
					var unwrapped []SearchResultTextMatchesItem
					unwrapped = nil
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem SearchResultTextMatchesItem
						if err := elem.Decode(d); err != nil {
							return err
						}
						unwrapped = append(unwrapped, elem)
						return nil
					}); err != nil {
						return err
					}
					elem = SearchResultTextMatches(unwrapped)
				}
				s.TextMatches = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_matches\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepoSearchResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [11]uint8{
		0b11111111,
		0b11111111,
		0b11101111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111011,
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRepoSearchResultItem) {
					name = jsonFieldsNameOfRepoSearchResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RepoSearchResultItemPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRepoSearchResultItemPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes RepoSearchResultItemPermissions from json.
func (s *RepoSearchResultItemPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepoSearchResultItemPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepoSearchResultItemPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRepoSearchResultItemPermissions) {
					name = jsonFieldsNameOfRepoSearchResultItemPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposAcceptInvitationApplicationJSONConflict as json.
func (s ReposAcceptInvitationApplicationJSONConflict) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposAcceptInvitationApplicationJSONConflict from json.
func (s *ReposAcceptInvitationApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAcceptInvitationApplicationJSONConflict to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAcceptInvitationApplicationJSONConflict(unwrapped)
	return nil
}

// Encode encodes ReposAcceptInvitationApplicationJSONForbidden as json.
func (s ReposAcceptInvitationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposAcceptInvitationApplicationJSONForbidden from json.
func (s *ReposAcceptInvitationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAcceptInvitationApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAcceptInvitationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposAcceptInvitationApplicationJSONNotFound as json.
func (s ReposAcceptInvitationApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposAcceptInvitationApplicationJSONNotFound from json.
func (s *ReposAcceptInvitationApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAcceptInvitationApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAcceptInvitationApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposAddAppAccessRestrictionsOKApplicationJSON as json.
func (s ReposAddAppAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Integration(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposAddAppAccessRestrictionsOKApplicationJSON from json.
func (s *ReposAddAppAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddAppAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []Integration
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Integration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddAppAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposAddAppAccessRestrictionsReq as json.
func (s ReposAddAppAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposAddAppAccessRestrictionsReq0ReposAddAppAccessRestrictionsReq:
		s.ReposAddAppAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposAddAppAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposAddAppAccessRestrictionsReq from json.
func (s *ReposAddAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddAppAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposAddAppAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposAddAppAccessRestrictionsReq0ReposAddAppAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposAddAppAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposAddAppAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"apps\"" + ":")
		e.ArrStart()
		if len(s.Apps) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Apps[0]
				e.Str(elem)
			}
			for _, elem := range s.Apps[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposAddAppAccessRestrictionsReq0 = [1]string{
	0: "apps",
}

// Decode decodes ReposAddAppAccessRestrictionsReq0 from json.
func (s *ReposAddAppAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddAppAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apps":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Apps = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Apps = append(s.Apps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposAddAppAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposAddAppAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposAddAppAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposAddCollaboratorReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	{
		if s.Permissions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposAddCollaboratorReq = [2]string{
	0: "permission",
	1: "permissions",
}

// Decode decodes ReposAddCollaboratorReq from json.
func (s *ReposAddCollaboratorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddCollaboratorReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposAddCollaboratorReq")
	}

	return nil
}

// Encode encodes ReposAddCollaboratorReqPermission as json.
func (s ReposAddCollaboratorReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposAddCollaboratorReqPermission from json.
func (s *ReposAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddCollaboratorReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposAddCollaboratorReqPermission(v) {
	case ReposAddCollaboratorReqPermissionPull:
		*s = ReposAddCollaboratorReqPermissionPull
	case ReposAddCollaboratorReqPermissionPush:
		*s = ReposAddCollaboratorReqPermissionPush
	case ReposAddCollaboratorReqPermissionAdmin:
		*s = ReposAddCollaboratorReqPermissionAdmin
	case ReposAddCollaboratorReqPermissionMaintain:
		*s = ReposAddCollaboratorReqPermissionMaintain
	case ReposAddCollaboratorReqPermissionTriage:
		*s = ReposAddCollaboratorReqPermissionTriage
	default:
		*s = ReposAddCollaboratorReqPermission(v)
	}

	return nil
}

// Encode encodes ReposAddStatusCheckContextsApplicationJSONForbidden as json.
func (s ReposAddStatusCheckContextsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposAddStatusCheckContextsApplicationJSONForbidden from json.
func (s *ReposAddStatusCheckContextsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddStatusCheckContextsApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddStatusCheckContextsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposAddStatusCheckContextsApplicationJSONNotFound as json.
func (s ReposAddStatusCheckContextsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposAddStatusCheckContextsApplicationJSONNotFound from json.
func (s *ReposAddStatusCheckContextsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddStatusCheckContextsApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddStatusCheckContextsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposAddStatusCheckContextsOKApplicationJSON as json.
func (s ReposAddStatusCheckContextsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []string(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			e.Str(elem)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			e.Str(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposAddStatusCheckContextsOKApplicationJSON from json.
func (s *ReposAddStatusCheckContextsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddStatusCheckContextsOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddStatusCheckContextsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposAddStatusCheckContextsReq as json.
func (s ReposAddStatusCheckContextsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposAddStatusCheckContextsReq0ReposAddStatusCheckContextsReq:
		s.ReposAddStatusCheckContextsReq0.Encode(e)
	case ArrayStringReposAddStatusCheckContextsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposAddStatusCheckContextsReq from json.
func (s *ReposAddStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddStatusCheckContextsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposAddStatusCheckContextsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposAddStatusCheckContextsReq0ReposAddStatusCheckContextsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposAddStatusCheckContextsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposAddStatusCheckContextsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"contexts\"" + ":")
		e.ArrStart()
		if len(s.Contexts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Contexts[0]
				e.Str(elem)
			}
			for _, elem := range s.Contexts[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposAddStatusCheckContextsReq0 = [1]string{
	0: "contexts",
}

// Decode decodes ReposAddStatusCheckContextsReq0 from json.
func (s *ReposAddStatusCheckContextsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddStatusCheckContextsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contexts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Contexts = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposAddStatusCheckContextsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposAddStatusCheckContextsReq0) {
					name = jsonFieldsNameOfReposAddStatusCheckContextsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposAddTeamAccessRestrictionsOKApplicationJSON as json.
func (s ReposAddTeamAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Team(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposAddTeamAccessRestrictionsOKApplicationJSON from json.
func (s *ReposAddTeamAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddTeamAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddTeamAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposAddTeamAccessRestrictionsReq as json.
func (s ReposAddTeamAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposAddTeamAccessRestrictionsReq0ReposAddTeamAccessRestrictionsReq:
		s.ReposAddTeamAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposAddTeamAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposAddTeamAccessRestrictionsReq from json.
func (s *ReposAddTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddTeamAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposAddTeamAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposAddTeamAccessRestrictionsReq0ReposAddTeamAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposAddTeamAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposAddTeamAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"teams\"" + ":")
		e.ArrStart()
		if len(s.Teams) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Teams[0]
				e.Str(elem)
			}
			for _, elem := range s.Teams[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposAddTeamAccessRestrictionsReq0 = [1]string{
	0: "teams",
}

// Decode decodes ReposAddTeamAccessRestrictionsReq0 from json.
func (s *ReposAddTeamAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddTeamAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "teams":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Teams = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposAddTeamAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposAddTeamAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposAddTeamAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposAddUserAccessRestrictionsOKApplicationJSON as json.
func (s ReposAddUserAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposAddUserAccessRestrictionsOKApplicationJSON from json.
func (s *ReposAddUserAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddUserAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAddUserAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposAddUserAccessRestrictionsReq as json.
func (s ReposAddUserAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposAddUserAccessRestrictionsReq0ReposAddUserAccessRestrictionsReq:
		s.ReposAddUserAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposAddUserAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposAddUserAccessRestrictionsReq from json.
func (s *ReposAddUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddUserAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposAddUserAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposAddUserAccessRestrictionsReq0ReposAddUserAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposAddUserAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposAddUserAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"users\"" + ":")
		e.ArrStart()
		if len(s.Users) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Users[0]
				e.Str(elem)
			}
			for _, elem := range s.Users[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposAddUserAccessRestrictionsReq0 = [1]string{
	0: "users",
}

// Decode decodes ReposAddUserAccessRestrictionsReq0 from json.
func (s *ReposAddUserAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposAddUserAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Users = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposAddUserAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposAddUserAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposAddUserAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposCompareCommitsApplicationJSONInternalServerError as json.
func (s ReposCompareCommitsApplicationJSONInternalServerError) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCompareCommitsApplicationJSONInternalServerError from json.
func (s *ReposCompareCommitsApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCompareCommitsApplicationJSONInternalServerError to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCompareCommitsApplicationJSONInternalServerError(unwrapped)
	return nil
}

// Encode encodes ReposCompareCommitsApplicationJSONNotFound as json.
func (s ReposCompareCommitsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCompareCommitsApplicationJSONNotFound from json.
func (s *ReposCompareCommitsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCompareCommitsApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCompareCommitsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateAutolinkReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key_prefix\"" + ":")
		e.Str(s.KeyPrefix)
	}
	{
		e.Comma()

		e.RawStr("\"url_template\"" + ":")
		e.Str(s.URLTemplate)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateAutolinkReq = [2]string{
	0: "key_prefix",
	1: "url_template",
}

// Decode decodes ReposCreateAutolinkReq from json.
func (s *ReposCreateAutolinkReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateAutolinkReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key_prefix":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.KeyPrefix = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_prefix\"")
			}
		case "url_template":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URLTemplate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url_template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateAutolinkReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateAutolinkReq) {
					name = jsonFieldsNameOfReposCreateAutolinkReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateCommitCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Position.Set {
			e.Comma()
		}
		if s.Position.Set {
			e.RawStr("\"position\"" + ":")
			s.Position.Encode(e)
		}
	}
	{
		if s.Line.Set {
			e.Comma()
		}
		if s.Line.Set {
			e.RawStr("\"line\"" + ":")
			s.Line.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateCommitCommentReq = [4]string{
	0: "body",
	1: "path",
	2: "position",
	3: "line",
}

// Decode decodes ReposCreateCommitCommentReq from json.
func (s *ReposCreateCommitCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateCommitCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "position":
			if err := func() error {
				s.Position.Reset()
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "line":
			if err := func() error {
				s.Line.Reset()
				if err := s.Line.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"line\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateCommitCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateCommitCommentReq) {
					name = jsonFieldsNameOfReposCreateCommitCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateCommitStatusReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		if s.TargetURL.Set {
			e.Comma()
		}
		if s.TargetURL.Set {
			e.RawStr("\"target_url\"" + ":")
			s.TargetURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Context.Set {
			e.Comma()
		}
		if s.Context.Set {
			e.RawStr("\"context\"" + ":")
			s.Context.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateCommitStatusReq = [4]string{
	0: "state",
	1: "target_url",
	2: "description",
	3: "context",
}

// Decode decodes ReposCreateCommitStatusReq from json.
func (s *ReposCreateCommitStatusReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateCommitStatusReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "target_url":
			if err := func() error {
				s.TargetURL.Reset()
				if err := s.TargetURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_url\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateCommitStatusReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateCommitStatusReq) {
					name = jsonFieldsNameOfReposCreateCommitStatusReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposCreateCommitStatusReqState as json.
func (s ReposCreateCommitStatusReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposCreateCommitStatusReqState from json.
func (s *ReposCreateCommitStatusReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateCommitStatusReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposCreateCommitStatusReqState(v) {
	case ReposCreateCommitStatusReqStateError:
		*s = ReposCreateCommitStatusReqStateError
	case ReposCreateCommitStatusReqStateFailure:
		*s = ReposCreateCommitStatusReqStateFailure
	case ReposCreateCommitStatusReqStatePending:
		*s = ReposCreateCommitStatusReqStatePending
	case ReposCreateCommitStatusReqStateSuccess:
		*s = ReposCreateCommitStatusReqStateSuccess
	default:
		*s = ReposCreateCommitStatusReqState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateDeployKeyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	{
		if s.ReadOnly.Set {
			e.Comma()
		}
		if s.ReadOnly.Set {
			e.RawStr("\"read_only\"" + ":")
			s.ReadOnly.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateDeployKeyReq = [3]string{
	0: "title",
	1: "key",
	2: "read_only",
}

// Decode decodes ReposCreateDeployKeyReq from json.
func (s *ReposCreateDeployKeyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeployKeyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "read_only":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"read_only\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateDeployKeyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateDeployKeyReq) {
					name = jsonFieldsNameOfReposCreateDeployKeyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateDeploymentAccepted) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateDeploymentAccepted = [1]string{
	0: "message",
}

// Decode decodes ReposCreateDeploymentAccepted from json.
func (s *ReposCreateDeploymentAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeploymentAccepted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateDeploymentAccepted")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateDeploymentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ref\"" + ":")
		e.Str(s.Ref)
	}
	{
		if s.Task.Set {
			e.Comma()
		}
		if s.Task.Set {
			e.RawStr("\"task\"" + ":")
			s.Task.Encode(e)
		}
	}
	{
		if s.AutoMerge.Set {
			e.Comma()
		}
		if s.AutoMerge.Set {
			e.RawStr("\"auto_merge\"" + ":")
			s.AutoMerge.Encode(e)
		}
	}
	{
		if s.RequiredContexts != nil {
			e.Comma()
		}
		if s.RequiredContexts != nil {
			e.RawStr("\"required_contexts\"" + ":")
			e.ArrStart()
			if len(s.RequiredContexts) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RequiredContexts[0]
					e.Str(elem)
				}
				for _, elem := range s.RequiredContexts[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Payload.Set {
			e.Comma()
		}
		if s.Payload.Set {
			e.RawStr("\"payload\"" + ":")
			s.Payload.Encode(e)
		}
	}
	{
		if s.Environment.Set {
			e.Comma()
		}
		if s.Environment.Set {
			e.RawStr("\"environment\"" + ":")
			s.Environment.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.TransientEnvironment.Set {
			e.Comma()
		}
		if s.TransientEnvironment.Set {
			e.RawStr("\"transient_environment\"" + ":")
			s.TransientEnvironment.Encode(e)
		}
	}
	{
		if s.ProductionEnvironment.Set {
			e.Comma()
		}
		if s.ProductionEnvironment.Set {
			e.RawStr("\"production_environment\"" + ":")
			s.ProductionEnvironment.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateDeploymentReq = [9]string{
	0: "ref",
	1: "task",
	2: "auto_merge",
	3: "required_contexts",
	4: "payload",
	5: "environment",
	6: "description",
	7: "transient_environment",
	8: "production_environment",
}

// Decode decodes ReposCreateDeploymentReq from json.
func (s *ReposCreateDeploymentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeploymentReq to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "task":
			if err := func() error {
				s.Task.Reset()
				if err := s.Task.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task\"")
			}
		case "auto_merge":
			if err := func() error {
				s.AutoMerge.Reset()
				if err := s.AutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_merge\"")
			}
		case "required_contexts":
			if err := func() error {
				s.RequiredContexts = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RequiredContexts = append(s.RequiredContexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_contexts\"")
			}
		case "payload":
			if err := func() error {
				s.Payload.Reset()
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "environment":
			if err := func() error {
				s.Environment.Reset()
				if err := s.Environment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "transient_environment":
			if err := func() error {
				s.TransientEnvironment.Reset()
				if err := s.TransientEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transient_environment\"")
			}
		case "production_environment":
			if err := func() error {
				s.ProductionEnvironment.Reset()
				if err := s.ProductionEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"production_environment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateDeploymentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateDeploymentReq) {
					name = jsonFieldsNameOfReposCreateDeploymentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposCreateDeploymentReqPayload as json.
func (s ReposCreateDeploymentReqPayload) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposCreateDeploymentReqPayload0ReposCreateDeploymentReqPayload:
		s.ReposCreateDeploymentReqPayload0.Encode(e)
	case StringReposCreateDeploymentReqPayload:
		e.Str(s.String)
	}
}

// Decode decodes ReposCreateDeploymentReqPayload from json.
func (s *ReposCreateDeploymentReqPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeploymentReqPayload to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		s.ReposCreateDeploymentReqPayload0 = make(ReposCreateDeploymentReqPayload0)
		if err := s.ReposCreateDeploymentReqPayload0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposCreateDeploymentReqPayload0ReposCreateDeploymentReqPayload
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringReposCreateDeploymentReqPayload
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateDeploymentReqPayload0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateDeploymentReqPayload0 = [0]string{}

// Decode decodes ReposCreateDeploymentReqPayload0 from json.
func (s ReposCreateDeploymentReqPayload0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeploymentReqPayload0 to nil")
	}

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateDeploymentReqPayload0")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateDeploymentStatusReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		if s.TargetURL.Set {
			e.Comma()
		}
		if s.TargetURL.Set {
			e.RawStr("\"target_url\"" + ":")
			s.TargetURL.Encode(e)
		}
	}
	{
		if s.LogURL.Set {
			e.Comma()
		}
		if s.LogURL.Set {
			e.RawStr("\"log_url\"" + ":")
			s.LogURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Environment.Set {
			e.Comma()
		}
		if s.Environment.Set {
			e.RawStr("\"environment\"" + ":")
			s.Environment.Encode(e)
		}
	}
	{
		if s.EnvironmentURL.Set {
			e.Comma()
		}
		if s.EnvironmentURL.Set {
			e.RawStr("\"environment_url\"" + ":")
			s.EnvironmentURL.Encode(e)
		}
	}
	{
		if s.AutoInactive.Set {
			e.Comma()
		}
		if s.AutoInactive.Set {
			e.RawStr("\"auto_inactive\"" + ":")
			s.AutoInactive.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateDeploymentStatusReq = [7]string{
	0: "state",
	1: "target_url",
	2: "log_url",
	3: "description",
	4: "environment",
	5: "environment_url",
	6: "auto_inactive",
}

// Decode decodes ReposCreateDeploymentStatusReq from json.
func (s *ReposCreateDeploymentStatusReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeploymentStatusReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "target_url":
			if err := func() error {
				s.TargetURL.Reset()
				if err := s.TargetURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_url\"")
			}
		case "log_url":
			if err := func() error {
				s.LogURL.Reset()
				if err := s.LogURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"log_url\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "environment":
			if err := func() error {
				s.Environment.Reset()
				if err := s.Environment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "environment_url":
			if err := func() error {
				s.EnvironmentURL.Reset()
				if err := s.EnvironmentURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment_url\"")
			}
		case "auto_inactive":
			if err := func() error {
				s.AutoInactive.Reset()
				if err := s.AutoInactive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_inactive\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateDeploymentStatusReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateDeploymentStatusReq) {
					name = jsonFieldsNameOfReposCreateDeploymentStatusReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposCreateDeploymentStatusReqEnvironment as json.
func (s ReposCreateDeploymentStatusReqEnvironment) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposCreateDeploymentStatusReqEnvironment from json.
func (s *ReposCreateDeploymentStatusReqEnvironment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeploymentStatusReqEnvironment to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposCreateDeploymentStatusReqEnvironment(v) {
	case ReposCreateDeploymentStatusReqEnvironmentProduction:
		*s = ReposCreateDeploymentStatusReqEnvironmentProduction
	case ReposCreateDeploymentStatusReqEnvironmentStaging:
		*s = ReposCreateDeploymentStatusReqEnvironmentStaging
	case ReposCreateDeploymentStatusReqEnvironmentQa:
		*s = ReposCreateDeploymentStatusReqEnvironmentQa
	default:
		*s = ReposCreateDeploymentStatusReqEnvironment(v)
	}

	return nil
}

// Encode encodes ReposCreateDeploymentStatusReqState as json.
func (s ReposCreateDeploymentStatusReqState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposCreateDeploymentStatusReqState from json.
func (s *ReposCreateDeploymentStatusReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDeploymentStatusReqState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposCreateDeploymentStatusReqState(v) {
	case ReposCreateDeploymentStatusReqStateError:
		*s = ReposCreateDeploymentStatusReqStateError
	case ReposCreateDeploymentStatusReqStateFailure:
		*s = ReposCreateDeploymentStatusReqStateFailure
	case ReposCreateDeploymentStatusReqStateInactive:
		*s = ReposCreateDeploymentStatusReqStateInactive
	case ReposCreateDeploymentStatusReqStateInProgress:
		*s = ReposCreateDeploymentStatusReqStateInProgress
	case ReposCreateDeploymentStatusReqStateQueued:
		*s = ReposCreateDeploymentStatusReqStateQueued
	case ReposCreateDeploymentStatusReqStatePending:
		*s = ReposCreateDeploymentStatusReqStatePending
	case ReposCreateDeploymentStatusReqStateSuccess:
		*s = ReposCreateDeploymentStatusReqStateSuccess
	default:
		*s = ReposCreateDeploymentStatusReqState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateDispatchEventReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"event_type\"" + ":")
		e.Str(s.EventType)
	}
	{
		if s.ClientPayload.Set {
			e.Comma()
		}
		if s.ClientPayload.Set {
			e.RawStr("\"client_payload\"" + ":")
			s.ClientPayload.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateDispatchEventReq = [2]string{
	0: "event_type",
	1: "client_payload",
}

// Decode decodes ReposCreateDispatchEventReq from json.
func (s *ReposCreateDispatchEventReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDispatchEventReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EventType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "client_payload":
			if err := func() error {
				s.ClientPayload.Reset()
				if err := s.ClientPayload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateDispatchEventReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateDispatchEventReq) {
					name = jsonFieldsNameOfReposCreateDispatchEventReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateDispatchEventReqClientPayload) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	for k, elem := range s {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateDispatchEventReqClientPayload = [0]string{}

// Decode decodes ReposCreateDispatchEventReqClientPayload from json.
func (s ReposCreateDispatchEventReqClientPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateDispatchEventReqClientPayload to nil")
	}
	var propertiesCount int

	m := s
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		propertiesCount++
		switch string(k) {
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateDispatchEventReqClientPayload")
	}
	// Validate properties count.
	if err := (validate.Object{
		MinProperties:    0,
		MinPropertiesSet: false,
		MaxProperties:    10,
		MaxPropertiesSet: true,
	}).ValidateProperties(propertiesCount); err != nil {
		return errors.Wrap(err, "object")
	}

	return nil
}

// Encode encodes ReposCreateForAuthenticatedUserApplicationJSONBadRequest as json.
func (s ReposCreateForAuthenticatedUserApplicationJSONBadRequest) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForAuthenticatedUserApplicationJSONBadRequest from json.
func (s *ReposCreateForAuthenticatedUserApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForAuthenticatedUserApplicationJSONBadRequest to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForAuthenticatedUserApplicationJSONBadRequest(unwrapped)
	return nil
}

// Encode encodes ReposCreateForAuthenticatedUserApplicationJSONForbidden as json.
func (s ReposCreateForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ReposCreateForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposCreateForAuthenticatedUserApplicationJSONNotFound as json.
func (s ReposCreateForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForAuthenticatedUserApplicationJSONNotFound from json.
func (s *ReposCreateForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposCreateForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ReposCreateForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ReposCreateForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateForAuthenticatedUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			e.Comma()
		}
		if s.Homepage.Set {
			e.RawStr("\"homepage\"" + ":")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.Comma()
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	{
		if s.HasIssues.Set {
			e.Comma()
		}
		if s.HasIssues.Set {
			e.RawStr("\"has_issues\"" + ":")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			e.Comma()
		}
		if s.HasProjects.Set {
			e.RawStr("\"has_projects\"" + ":")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			e.Comma()
		}
		if s.HasWiki.Set {
			e.RawStr("\"has_wiki\"" + ":")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.TeamID.Set {
			e.Comma()
		}
		if s.TeamID.Set {
			e.RawStr("\"team_id\"" + ":")
			s.TeamID.Encode(e)
		}
	}
	{
		if s.AutoInit.Set {
			e.Comma()
		}
		if s.AutoInit.Set {
			e.RawStr("\"auto_init\"" + ":")
			s.AutoInit.Encode(e)
		}
	}
	{
		if s.GitignoreTemplate.Set {
			e.Comma()
		}
		if s.GitignoreTemplate.Set {
			e.RawStr("\"gitignore_template\"" + ":")
			s.GitignoreTemplate.Encode(e)
		}
	}
	{
		if s.LicenseTemplate.Set {
			e.Comma()
		}
		if s.LicenseTemplate.Set {
			e.RawStr("\"license_template\"" + ":")
			s.LicenseTemplate.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.Comma()
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.HasDownloads.Set {
			e.Comma()
		}
		if s.HasDownloads.Set {
			e.RawStr("\"has_downloads\"" + ":")
			s.HasDownloads.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateForAuthenticatedUserReq = [18]string{
	0:  "name",
	1:  "description",
	2:  "homepage",
	3:  "private",
	4:  "has_issues",
	5:  "has_projects",
	6:  "has_wiki",
	7:  "team_id",
	8:  "auto_init",
	9:  "gitignore_template",
	10: "license_template",
	11: "allow_squash_merge",
	12: "allow_merge_commit",
	13: "allow_rebase_merge",
	14: "allow_auto_merge",
	15: "delete_branch_on_merge",
	16: "has_downloads",
	17: "is_template",
}

// Decode decodes ReposCreateForAuthenticatedUserReq from json.
func (s *ReposCreateForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForAuthenticatedUserReq to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "homepage":
			if err := func() error {
				s.Homepage.Reset()
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "has_issues":
			if err := func() error {
				s.HasIssues.Reset()
				if err := s.HasIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			if err := func() error {
				s.HasProjects.Reset()
				if err := s.HasProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			if err := func() error {
				s.HasWiki.Reset()
				if err := s.HasWiki.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "team_id":
			if err := func() error {
				s.TeamID.Reset()
				if err := s.TeamID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "auto_init":
			if err := func() error {
				s.AutoInit.Reset()
				if err := s.AutoInit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_init\"")
			}
		case "gitignore_template":
			if err := func() error {
				s.GitignoreTemplate.Reset()
				if err := s.GitignoreTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gitignore_template\"")
			}
		case "license_template":
			if err := func() error {
				s.LicenseTemplate.Reset()
				if err := s.LicenseTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license_template\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "has_downloads":
			if err := func() error {
				s.HasDownloads.Reset()
				if err := s.HasDownloads.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateForAuthenticatedUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateForAuthenticatedUserReq) {
					name = jsonFieldsNameOfReposCreateForAuthenticatedUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposCreateForkApplicationJSONBadRequest as json.
func (s ReposCreateForkApplicationJSONBadRequest) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForkApplicationJSONBadRequest from json.
func (s *ReposCreateForkApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForkApplicationJSONBadRequest to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForkApplicationJSONBadRequest(unwrapped)
	return nil
}

// Encode encodes ReposCreateForkApplicationJSONForbidden as json.
func (s ReposCreateForkApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForkApplicationJSONForbidden from json.
func (s *ReposCreateForkApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForkApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForkApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposCreateForkApplicationJSONNotFound as json.
func (s ReposCreateForkApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateForkApplicationJSONNotFound from json.
func (s *ReposCreateForkApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForkApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateForkApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateForkReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Organization.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Organization.Set {
			e.RawStr("\"organization\"" + ":")
			s.Organization.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateForkReq = [1]string{
	0: "organization",
}

// Decode decodes ReposCreateForkReq from json.
func (s *ReposCreateForkReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateForkReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "organization":
			if err := func() error {
				s.Organization.Reset()
				if err := s.Organization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateForkReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			e.Comma()
		}
		if s.Homepage.Set {
			e.RawStr("\"homepage\"" + ":")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.Comma()
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.HasIssues.Set {
			e.Comma()
		}
		if s.HasIssues.Set {
			e.RawStr("\"has_issues\"" + ":")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			e.Comma()
		}
		if s.HasProjects.Set {
			e.RawStr("\"has_projects\"" + ":")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			e.Comma()
		}
		if s.HasWiki.Set {
			e.RawStr("\"has_wiki\"" + ":")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.TeamID.Set {
			e.Comma()
		}
		if s.TeamID.Set {
			e.RawStr("\"team_id\"" + ":")
			s.TeamID.Encode(e)
		}
	}
	{
		if s.AutoInit.Set {
			e.Comma()
		}
		if s.AutoInit.Set {
			e.RawStr("\"auto_init\"" + ":")
			s.AutoInit.Encode(e)
		}
	}
	{
		if s.GitignoreTemplate.Set {
			e.Comma()
		}
		if s.GitignoreTemplate.Set {
			e.RawStr("\"gitignore_template\"" + ":")
			s.GitignoreTemplate.Encode(e)
		}
	}
	{
		if s.LicenseTemplate.Set {
			e.Comma()
		}
		if s.LicenseTemplate.Set {
			e.RawStr("\"license_template\"" + ":")
			s.LicenseTemplate.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.Comma()
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateInOrgReq = [18]string{
	0:  "name",
	1:  "description",
	2:  "homepage",
	3:  "private",
	4:  "visibility",
	5:  "has_issues",
	6:  "has_projects",
	7:  "has_wiki",
	8:  "is_template",
	9:  "team_id",
	10: "auto_init",
	11: "gitignore_template",
	12: "license_template",
	13: "allow_squash_merge",
	14: "allow_merge_commit",
	15: "allow_rebase_merge",
	16: "allow_auto_merge",
	17: "delete_branch_on_merge",
}

// Decode decodes ReposCreateInOrgReq from json.
func (s *ReposCreateInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateInOrgReq to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "homepage":
			if err := func() error {
				s.Homepage.Reset()
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "has_issues":
			if err := func() error {
				s.HasIssues.Reset()
				if err := s.HasIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			if err := func() error {
				s.HasProjects.Reset()
				if err := s.HasProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			if err := func() error {
				s.HasWiki.Reset()
				if err := s.HasWiki.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "team_id":
			if err := func() error {
				s.TeamID.Reset()
				if err := s.TeamID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "auto_init":
			if err := func() error {
				s.AutoInit.Reset()
				if err := s.AutoInit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_init\"")
			}
		case "gitignore_template":
			if err := func() error {
				s.GitignoreTemplate.Reset()
				if err := s.GitignoreTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gitignore_template\"")
			}
		case "license_template":
			if err := func() error {
				s.LicenseTemplate.Reset()
				if err := s.LicenseTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license_template\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateInOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateInOrgReq) {
					name = jsonFieldsNameOfReposCreateInOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposCreateInOrgReqVisibility as json.
func (s ReposCreateInOrgReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposCreateInOrgReqVisibility from json.
func (s *ReposCreateInOrgReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateInOrgReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposCreateInOrgReqVisibility(v) {
	case ReposCreateInOrgReqVisibilityPublic:
		*s = ReposCreateInOrgReqVisibilityPublic
	case ReposCreateInOrgReqVisibilityPrivate:
		*s = ReposCreateInOrgReqVisibilityPrivate
	case ReposCreateInOrgReqVisibilityVisibility:
		*s = ReposCreateInOrgReqVisibilityVisibility
	case ReposCreateInOrgReqVisibilityInternal:
		*s = ReposCreateInOrgReqVisibilityInternal
	default:
		*s = ReposCreateInOrgReqVisibility(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateOrUpdateEnvironmentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		{
			if s.WaitTimer.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.WaitTimer.Set {
				e.RawStr("\"wait_timer\"" + ":")
				s.WaitTimer.Encode(e)
			}
		}
		{
			if s.Reviewers.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Reviewers.Set {
				e.RawStr("\"reviewers\"" + ":")
				s.Reviewers.Encode(e)
			}
		}
		{
			if s.DeploymentBranchPolicy.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.DeploymentBranchPolicy.Set {
				e.RawStr("\"deployment_branch_policy\"" + ":")
				s.DeploymentBranchPolicy.Encode(e)
			}
		}
	}
	for k, elem := range s.AdditionalProps {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateOrUpdateEnvironmentReq = [3]string{
	0: "wait_timer",
	1: "reviewers",
	2: "deployment_branch_policy",
}

// Decode decodes ReposCreateOrUpdateEnvironmentReq from json.
func (s *ReposCreateOrUpdateEnvironmentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateEnvironmentReq to nil")
	}

	m := s.AdditionalProps
	if m == nil {
		m = map[string]jx.Raw{}
		s.AdditionalProps = m
	}
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "wait_timer":
			if err := func() error {
				s.WaitTimer.Reset()
				if err := s.WaitTimer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wait_timer\"")
			}
		case "reviewers":
			if err := func() error {
				s.Reviewers.Reset()
				if err := s.Reviewers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reviewers\"")
			}
		case "deployment_branch_policy":
			if err := func() error {
				s.DeploymentBranchPolicy.Reset()
				if err := s.DeploymentBranchPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployment_branch_policy\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateOrUpdateEnvironmentReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateOrUpdateEnvironmentReqReviewersItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateOrUpdateEnvironmentReqReviewersItem = [2]string{
	0: "type",
	1: "id",
}

// Decode decodes ReposCreateOrUpdateEnvironmentReqReviewersItem from json.
func (s *ReposCreateOrUpdateEnvironmentReqReviewersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateEnvironmentReqReviewersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateOrUpdateEnvironmentReqReviewersItem")
	}

	return nil
}

// Encode encodes ReposCreateOrUpdateFileContentsApplicationJSONConflict as json.
func (s ReposCreateOrUpdateFileContentsApplicationJSONConflict) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsApplicationJSONConflict from json.
func (s *ReposCreateOrUpdateFileContentsApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateFileContentsApplicationJSONConflict to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateOrUpdateFileContentsApplicationJSONConflict(unwrapped)
	return nil
}

// Encode encodes ReposCreateOrUpdateFileContentsApplicationJSONCreated as json.
func (s ReposCreateOrUpdateFileContentsApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := FileCommit(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsApplicationJSONCreated from json.
func (s *ReposCreateOrUpdateFileContentsApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateFileContentsApplicationJSONCreated to nil")
	}
	var unwrapped FileCommit
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateOrUpdateFileContentsApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReposCreateOrUpdateFileContentsApplicationJSONNotFound as json.
func (s ReposCreateOrUpdateFileContentsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsApplicationJSONNotFound from json.
func (s *ReposCreateOrUpdateFileContentsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateFileContentsApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateOrUpdateFileContentsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposCreateOrUpdateFileContentsApplicationJSONOK as json.
func (s ReposCreateOrUpdateFileContentsApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := FileCommit(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsApplicationJSONOK from json.
func (s *ReposCreateOrUpdateFileContentsApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateFileContentsApplicationJSONOK to nil")
	}
	var unwrapped FileCommit
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateOrUpdateFileContentsApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateOrUpdateFileContentsReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"content\"" + ":")
		e.Str(s.Content)
	}
	{
		if s.Sha.Set {
			e.Comma()
		}
		if s.Sha.Set {
			e.RawStr("\"sha\"" + ":")
			s.Sha.Encode(e)
		}
	}
	{
		if s.Branch.Set {
			e.Comma()
		}
		if s.Branch.Set {
			e.RawStr("\"branch\"" + ":")
			s.Branch.Encode(e)
		}
	}
	{
		if s.Committer.Set {
			e.Comma()
		}
		if s.Committer.Set {
			e.RawStr("\"committer\"" + ":")
			s.Committer.Encode(e)
		}
	}
	{
		if s.Author.Set {
			e.Comma()
		}
		if s.Author.Set {
			e.RawStr("\"author\"" + ":")
			s.Author.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateOrUpdateFileContentsReq = [6]string{
	0: "message",
	1: "content",
	2: "sha",
	3: "branch",
	4: "committer",
	5: "author",
}

// Decode decodes ReposCreateOrUpdateFileContentsReq from json.
func (s *ReposCreateOrUpdateFileContentsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateFileContentsReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sha":
			if err := func() error {
				s.Sha.Reset()
				if err := s.Sha.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "branch":
			if err := func() error {
				s.Branch.Reset()
				if err := s.Branch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch\"")
			}
		case "committer":
			if err := func() error {
				s.Committer.Reset()
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateOrUpdateFileContentsReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateOrUpdateFileContentsReq) {
					name = jsonFieldsNameOfReposCreateOrUpdateFileContentsReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateOrUpdateFileContentsReqAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		if s.Date.Set {
			e.Comma()
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateOrUpdateFileContentsReqAuthor = [3]string{
	0: "name",
	1: "email",
	2: "date",
}

// Decode decodes ReposCreateOrUpdateFileContentsReqAuthor from json.
func (s *ReposCreateOrUpdateFileContentsReqAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateFileContentsReqAuthor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateOrUpdateFileContentsReqAuthor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateOrUpdateFileContentsReqAuthor) {
					name = jsonFieldsNameOfReposCreateOrUpdateFileContentsReqAuthor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateOrUpdateFileContentsReqCommitter) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	{
		if s.Date.Set {
			e.Comma()
		}
		if s.Date.Set {
			e.RawStr("\"date\"" + ":")
			s.Date.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateOrUpdateFileContentsReqCommitter = [3]string{
	0: "name",
	1: "email",
	2: "date",
}

// Decode decodes ReposCreateOrUpdateFileContentsReqCommitter from json.
func (s *ReposCreateOrUpdateFileContentsReqCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateOrUpdateFileContentsReqCommitter to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateOrUpdateFileContentsReqCommitter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateOrUpdateFileContentsReqCommitter) {
					name = jsonFieldsNameOfReposCreateOrUpdateFileContentsReqCommitter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreatePagesSiteReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"source\"" + ":")
		s.Source.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreatePagesSiteReq = [1]string{
	0: "source",
}

// Decode decodes ReposCreatePagesSiteReq from json.
func (s *ReposCreatePagesSiteReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreatePagesSiteReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreatePagesSiteReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreatePagesSiteReq) {
					name = jsonFieldsNameOfReposCreatePagesSiteReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreatePagesSiteReqSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"branch\"" + ":")
		e.Str(s.Branch)
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreatePagesSiteReqSource = [2]string{
	0: "branch",
	1: "path",
}

// Decode decodes ReposCreatePagesSiteReqSource from json.
func (s *ReposCreatePagesSiteReqSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreatePagesSiteReqSource to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "branch":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Branch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreatePagesSiteReqSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreatePagesSiteReqSource) {
					name = jsonFieldsNameOfReposCreatePagesSiteReqSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposCreatePagesSiteReqSourcePath as json.
func (s ReposCreatePagesSiteReqSourcePath) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposCreatePagesSiteReqSourcePath from json.
func (s *ReposCreatePagesSiteReqSourcePath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreatePagesSiteReqSourcePath to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposCreatePagesSiteReqSourcePath(v) {
	case ReposCreatePagesSiteReqSourcePathSlash:
		*s = ReposCreatePagesSiteReqSourcePathSlash
	case ReposCreatePagesSiteReqSourcePathSlashDocs:
		*s = ReposCreatePagesSiteReqSourcePathSlashDocs
	default:
		*s = ReposCreatePagesSiteReqSourcePath(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateReleaseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"tag_name\"" + ":")
		e.Str(s.TagName)
	}
	{
		if s.TargetCommitish.Set {
			e.Comma()
		}
		if s.TargetCommitish.Set {
			e.RawStr("\"target_commitish\"" + ":")
			s.TargetCommitish.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.Comma()
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.Draft.Set {
			e.Comma()
		}
		if s.Draft.Set {
			e.RawStr("\"draft\"" + ":")
			s.Draft.Encode(e)
		}
	}
	{
		if s.Prerelease.Set {
			e.Comma()
		}
		if s.Prerelease.Set {
			e.RawStr("\"prerelease\"" + ":")
			s.Prerelease.Encode(e)
		}
	}
	{
		if s.DiscussionCategoryName.Set {
			e.Comma()
		}
		if s.DiscussionCategoryName.Set {
			e.RawStr("\"discussion_category_name\"" + ":")
			s.DiscussionCategoryName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateReleaseReq = [7]string{
	0: "tag_name",
	1: "target_commitish",
	2: "name",
	3: "body",
	4: "draft",
	5: "prerelease",
	6: "discussion_category_name",
}

// Decode decodes ReposCreateReleaseReq from json.
func (s *ReposCreateReleaseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateReleaseReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TagName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_name\"")
			}
		case "target_commitish":
			if err := func() error {
				s.TargetCommitish.Reset()
				if err := s.TargetCommitish.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_commitish\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "draft":
			if err := func() error {
				s.Draft.Reset()
				if err := s.Draft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		case "prerelease":
			if err := func() error {
				s.Prerelease.Reset()
				if err := s.Prerelease.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prerelease\"")
			}
		case "discussion_category_name":
			if err := func() error {
				s.DiscussionCategoryName.Reset()
				if err := s.DiscussionCategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discussion_category_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateReleaseReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateReleaseReq) {
					name = jsonFieldsNameOfReposCreateReleaseReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateUsingTemplateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Owner.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.IncludeAllBranches.Set {
			e.Comma()
		}
		if s.IncludeAllBranches.Set {
			e.RawStr("\"include_all_branches\"" + ":")
			s.IncludeAllBranches.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.Comma()
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateUsingTemplateReq = [5]string{
	0: "owner",
	1: "name",
	2: "description",
	3: "include_all_branches",
	4: "private",
}

// Decode decodes ReposCreateUsingTemplateReq from json.
func (s *ReposCreateUsingTemplateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateUsingTemplateReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "include_all_branches":
			if err := func() error {
				s.IncludeAllBranches.Reset()
				if err := s.IncludeAllBranches.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_all_branches\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateUsingTemplateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposCreateUsingTemplateReq) {
					name = jsonFieldsNameOfReposCreateUsingTemplateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposCreateWebhookApplicationJSONForbidden as json.
func (s ReposCreateWebhookApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateWebhookApplicationJSONForbidden from json.
func (s *ReposCreateWebhookApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateWebhookApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateWebhookApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposCreateWebhookApplicationJSONNotFound as json.
func (s ReposCreateWebhookApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCreateWebhookApplicationJSONNotFound from json.
func (s *ReposCreateWebhookApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateWebhookApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCreateWebhookApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateWebhookReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		{
			if s.Name.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Name.Set {
				e.RawStr("\"name\"" + ":")
				s.Name.Encode(e)
			}
		}
		{
			if s.Config.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Config.Set {
				e.RawStr("\"config\"" + ":")
				s.Config.Encode(e)
			}
		}
		{
			if s.Events != nil {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Events != nil {
				e.RawStr("\"events\"" + ":")
				e.ArrStart()
				if len(s.Events) >= 1 {
					// Encode first element without comma.
					{
						elem := s.Events[0]
						e.Str(elem)
					}
					for _, elem := range s.Events[1:] {
						e.Comma()
						e.Str(elem)
					}
				}
				e.ArrEnd()
			}
		}
		{
			if s.Active.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Active.Set {
				e.RawStr("\"active\"" + ":")
				s.Active.Encode(e)
			}
		}
	}
	for k, elem := range s.AdditionalProps {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateWebhookReq = [4]string{
	0: "name",
	1: "config",
	2: "events",
	3: "active",
}

// Decode decodes ReposCreateWebhookReq from json.
func (s *ReposCreateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateWebhookReq to nil")
	}
	s.setDefaults()

	m := s.AdditionalProps
	if m == nil {
		m = map[string]jx.Raw{}
		s.AdditionalProps = m
	}
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "config":
			if err := func() error {
				s.Config.Reset()
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "events":
			if err := func() error {
				s.Events = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateWebhookReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateWebhookReqConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	{
		if s.Token.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Token.Set {
			e.RawStr("\"token\"" + ":")
			s.Token.Encode(e)
		}
	}
	{
		if s.Digest.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Digest.Set {
			e.RawStr("\"digest\"" + ":")
			s.Digest.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposCreateWebhookReqConfig = [6]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
	4: "token",
	5: "digest",
}

// Decode decodes ReposCreateWebhookReqConfig from json.
func (s *ReposCreateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposCreateWebhookReqConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		case "token":
			if err := func() error {
				s.Token.Reset()
				if err := s.Token.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "digest":
			if err := func() error {
				s.Digest.Reset()
				if err := s.Digest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"digest\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposCreateWebhookReqConfig")
	}

	return nil
}

// Encode encodes ReposDeclineInvitationApplicationJSONConflict as json.
func (s ReposDeclineInvitationApplicationJSONConflict) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeclineInvitationApplicationJSONConflict from json.
func (s *ReposDeclineInvitationApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeclineInvitationApplicationJSONConflict to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeclineInvitationApplicationJSONConflict(unwrapped)
	return nil
}

// Encode encodes ReposDeclineInvitationApplicationJSONForbidden as json.
func (s ReposDeclineInvitationApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeclineInvitationApplicationJSONForbidden from json.
func (s *ReposDeclineInvitationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeclineInvitationApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeclineInvitationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposDeclineInvitationApplicationJSONNotFound as json.
func (s ReposDeclineInvitationApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeclineInvitationApplicationJSONNotFound from json.
func (s *ReposDeclineInvitationApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeclineInvitationApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeclineInvitationApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposDeleteApplicationJSONNotFound as json.
func (s ReposDeleteApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeleteApplicationJSONNotFound from json.
func (s *ReposDeleteApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeleteApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposDeleteApplicationJSONTemporaryRedirect as json.
func (s ReposDeleteApplicationJSONTemporaryRedirect) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeleteApplicationJSONTemporaryRedirect from json.
func (s *ReposDeleteApplicationJSONTemporaryRedirect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteApplicationJSONTemporaryRedirect to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeleteApplicationJSONTemporaryRedirect(unwrapped)
	return nil
}

// Encode encodes ReposDeleteFileApplicationJSONConflict as json.
func (s ReposDeleteFileApplicationJSONConflict) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeleteFileApplicationJSONConflict from json.
func (s *ReposDeleteFileApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteFileApplicationJSONConflict to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeleteFileApplicationJSONConflict(unwrapped)
	return nil
}

// Encode encodes ReposDeleteFileApplicationJSONNotFound as json.
func (s ReposDeleteFileApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeleteFileApplicationJSONNotFound from json.
func (s *ReposDeleteFileApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteFileApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeleteFileApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposDeleteFileReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		if s.Branch.Set {
			e.Comma()
		}
		if s.Branch.Set {
			e.RawStr("\"branch\"" + ":")
			s.Branch.Encode(e)
		}
	}
	{
		if s.Committer.Set {
			e.Comma()
		}
		if s.Committer.Set {
			e.RawStr("\"committer\"" + ":")
			s.Committer.Encode(e)
		}
	}
	{
		if s.Author.Set {
			e.Comma()
		}
		if s.Author.Set {
			e.RawStr("\"author\"" + ":")
			s.Author.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposDeleteFileReq = [5]string{
	0: "message",
	1: "sha",
	2: "branch",
	3: "committer",
	4: "author",
}

// Decode decodes ReposDeleteFileReq from json.
func (s *ReposDeleteFileReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteFileReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "branch":
			if err := func() error {
				s.Branch.Reset()
				if err := s.Branch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch\"")
			}
		case "committer":
			if err := func() error {
				s.Committer.Reset()
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposDeleteFileReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposDeleteFileReq) {
					name = jsonFieldsNameOfReposDeleteFileReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposDeleteFileReqAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposDeleteFileReqAuthor = [2]string{
	0: "name",
	1: "email",
}

// Decode decodes ReposDeleteFileReqAuthor from json.
func (s *ReposDeleteFileReqAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteFileReqAuthor to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposDeleteFileReqAuthor")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposDeleteFileReqCommitter) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposDeleteFileReqCommitter = [2]string{
	0: "name",
	1: "email",
}

// Decode decodes ReposDeleteFileReqCommitter from json.
func (s *ReposDeleteFileReqCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteFileReqCommitter to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposDeleteFileReqCommitter")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposDeleteForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposDeleteForbidden = [2]string{
	0: "message",
	1: "documentation_url",
}

// Decode decodes ReposDeleteForbidden from json.
func (s *ReposDeleteForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposDeleteForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposDeleteForbidden")
	}

	return nil
}

// Encode encodes ReposGetAllStatusCheckContextsOKApplicationJSON as json.
func (s ReposGetAllStatusCheckContextsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []string(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			e.Str(elem)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			e.Str(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetAllStatusCheckContextsOKApplicationJSON from json.
func (s *ReposGetAllStatusCheckContextsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetAllStatusCheckContextsOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetAllStatusCheckContextsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetApplicationJSONForbidden as json.
func (s ReposGetApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetApplicationJSONForbidden from json.
func (s *ReposGetApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposGetApplicationJSONMovedPermanently as json.
func (s ReposGetApplicationJSONMovedPermanently) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetApplicationJSONMovedPermanently from json.
func (s *ReposGetApplicationJSONMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetApplicationJSONMovedPermanently to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetApplicationJSONMovedPermanently(unwrapped)
	return nil
}

// Encode encodes ReposGetApplicationJSONNotFound as json.
func (s ReposGetApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetApplicationJSONNotFound from json.
func (s *ReposGetApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON as json.
func (s ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Integration(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON from json.
func (s *ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON to nil")
	}
	var unwrapped []Integration
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Integration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetBranchApplicationJSONMovedPermanently as json.
func (s ReposGetBranchApplicationJSONMovedPermanently) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetBranchApplicationJSONMovedPermanently from json.
func (s *ReposGetBranchApplicationJSONMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetBranchApplicationJSONMovedPermanently to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetBranchApplicationJSONMovedPermanently(unwrapped)
	return nil
}

// Encode encodes ReposGetBranchApplicationJSONNotFound as json.
func (s ReposGetBranchApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetBranchApplicationJSONNotFound from json.
func (s *ReposGetBranchApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetBranchApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetBranchApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposGetCodeFrequencyStatsOKApplicationJSON as json.
func (s ReposGetCodeFrequencyStatsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CodeFrequencyStat(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetCodeFrequencyStatsOKApplicationJSON from json.
func (s *ReposGetCodeFrequencyStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetCodeFrequencyStatsOKApplicationJSON to nil")
	}
	var unwrapped []CodeFrequencyStat
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeFrequencyStat
			{
				var unwrapped []int
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = CodeFrequencyStat(unwrapped)
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetCodeFrequencyStatsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetCommitActivityStatsOKApplicationJSON as json.
func (s ReposGetCommitActivityStatsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CommitActivity(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetCommitActivityStatsOKApplicationJSON from json.
func (s *ReposGetCommitActivityStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetCommitActivityStatsOKApplicationJSON to nil")
	}
	var unwrapped []CommitActivity
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CommitActivity
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetCommitActivityStatsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetCommitApplicationJSONInternalServerError as json.
func (s ReposGetCommitApplicationJSONInternalServerError) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetCommitApplicationJSONInternalServerError from json.
func (s *ReposGetCommitApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetCommitApplicationJSONInternalServerError to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetCommitApplicationJSONInternalServerError(unwrapped)
	return nil
}

// Encode encodes ReposGetCommitApplicationJSONNotFound as json.
func (s ReposGetCommitApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetCommitApplicationJSONNotFound from json.
func (s *ReposGetCommitApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetCommitApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetCommitApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposGetContributorsStatsOKApplicationJSON as json.
func (s ReposGetContributorsStatsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ContributorActivity(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetContributorsStatsOKApplicationJSON from json.
func (s *ReposGetContributorsStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetContributorsStatsOKApplicationJSON to nil")
	}
	var unwrapped []ContributorActivity
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ContributorActivity
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetContributorsStatsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetPunchCardStatsOKApplicationJSON as json.
func (s ReposGetPunchCardStatsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []CodeFrequencyStat(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetPunchCardStatsOKApplicationJSON from json.
func (s *ReposGetPunchCardStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetPunchCardStatsOKApplicationJSON to nil")
	}
	var unwrapped []CodeFrequencyStat
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeFrequencyStat
			{
				var unwrapped []int
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = CodeFrequencyStat(unwrapped)
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetPunchCardStatsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON as json.
func (s ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Team(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON from json.
func (s *ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON to nil")
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetTopPathsOKApplicationJSON as json.
func (s ReposGetTopPathsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ContentTraffic(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetTopPathsOKApplicationJSON from json.
func (s *ReposGetTopPathsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetTopPathsOKApplicationJSON to nil")
	}
	var unwrapped []ContentTraffic
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ContentTraffic
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetTopPathsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetTopReferrersOKApplicationJSON as json.
func (s ReposGetTopReferrersOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ReferrerTraffic(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetTopReferrersOKApplicationJSON from json.
func (s *ReposGetTopReferrersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetTopReferrersOKApplicationJSON to nil")
	}
	var unwrapped []ReferrerTraffic
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ReferrerTraffic
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetTopReferrersOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON as json.
func (s ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON from json.
func (s *ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListBranchesForHeadCommitOKApplicationJSON as json.
func (s ReposListBranchesForHeadCommitOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []BranchShort(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListBranchesForHeadCommitOKApplicationJSON from json.
func (s *ReposListBranchesForHeadCommitOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListBranchesForHeadCommitOKApplicationJSON to nil")
	}
	var unwrapped []BranchShort
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BranchShort
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListBranchesForHeadCommitOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListBranchesOKApplicationJSON as json.
func (s ReposListBranchesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []ShortBranch(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListBranchesOKApplicationJSON from json.
func (s *ReposListBranchesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListBranchesOKApplicationJSON to nil")
	}
	var unwrapped []ShortBranch
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ShortBranch
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListBranchesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListCollaboratorsOKApplicationJSON as json.
func (s ReposListCollaboratorsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Collaborator(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListCollaboratorsOKApplicationJSON from json.
func (s *ReposListCollaboratorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListCollaboratorsOKApplicationJSON to nil")
	}
	var unwrapped []Collaborator
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Collaborator
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCollaboratorsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListCommitStatusesForRefOKApplicationJSON as json.
func (s ReposListCommitStatusesForRefOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Status(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListCommitStatusesForRefOKApplicationJSON from json.
func (s *ReposListCommitStatusesForRefOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListCommitStatusesForRefOKApplicationJSON to nil")
	}
	var unwrapped []Status
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Status
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitStatusesForRefOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListCommitsApplicationJSONBadRequest as json.
func (s ReposListCommitsApplicationJSONBadRequest) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsApplicationJSONBadRequest from json.
func (s *ReposListCommitsApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListCommitsApplicationJSONBadRequest to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsApplicationJSONBadRequest(unwrapped)
	return nil
}

// Encode encodes ReposListCommitsApplicationJSONConflict as json.
func (s ReposListCommitsApplicationJSONConflict) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsApplicationJSONConflict from json.
func (s *ReposListCommitsApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListCommitsApplicationJSONConflict to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsApplicationJSONConflict(unwrapped)
	return nil
}

// Encode encodes ReposListCommitsApplicationJSONInternalServerError as json.
func (s ReposListCommitsApplicationJSONInternalServerError) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsApplicationJSONInternalServerError from json.
func (s *ReposListCommitsApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListCommitsApplicationJSONInternalServerError to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsApplicationJSONInternalServerError(unwrapped)
	return nil
}

// Encode encodes ReposListCommitsApplicationJSONNotFound as json.
func (s ReposListCommitsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsApplicationJSONNotFound from json.
func (s *ReposListCommitsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListCommitsApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposListCommitsOKApplicationJSON as json.
func (s ReposListCommitsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Commit(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListCommitsOKApplicationJSON from json.
func (s *ReposListCommitsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListCommitsOKApplicationJSON to nil")
	}
	var unwrapped []Commit
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Commit
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListContributorsApplicationJSONForbidden as json.
func (s ReposListContributorsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListContributorsApplicationJSONForbidden from json.
func (s *ReposListContributorsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListContributorsApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListContributorsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposListContributorsApplicationJSONNotFound as json.
func (s ReposListContributorsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListContributorsApplicationJSONNotFound from json.
func (s *ReposListContributorsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListContributorsApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListContributorsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposListContributorsOKApplicationJSON as json.
func (s ReposListContributorsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Contributor(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListContributorsOKApplicationJSON from json.
func (s *ReposListContributorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListContributorsOKApplicationJSON to nil")
	}
	var unwrapped []Contributor
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Contributor
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListContributorsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListDeploymentStatusesOKApplicationJSON as json.
func (s ReposListDeploymentStatusesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []DeploymentStatus(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListDeploymentStatusesOKApplicationJSON from json.
func (s *ReposListDeploymentStatusesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListDeploymentStatusesOKApplicationJSON to nil")
	}
	var unwrapped []DeploymentStatus
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem DeploymentStatus
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListDeploymentStatusesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListForAuthenticatedUserApplicationJSONForbidden as json.
func (s ReposListForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ReposListForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposListForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ReposListForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ReposListForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ReposListForAuthenticatedUserOKApplicationJSON as json.
func (s ReposListForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Repository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListForAuthenticatedUserOKApplicationJSON from json.
func (s *ReposListForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListForAuthenticatedUserOKApplicationJSON to nil")
	}
	var unwrapped []Repository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Repository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListForksOKApplicationJSON as json.
func (s ReposListForksOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListForksOKApplicationJSON from json.
func (s *ReposListForksOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListForksOKApplicationJSON to nil")
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListForksOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden as json.
func (s ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound as json.
func (s ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound from json.
func (s *ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ReposListInvitationsForAuthenticatedUserOKApplicationJSON as json.
func (s ReposListInvitationsForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []RepositoryInvitation(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListInvitationsForAuthenticatedUserOKApplicationJSON from json.
func (s *ReposListInvitationsForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListInvitationsForAuthenticatedUserOKApplicationJSON to nil")
	}
	var unwrapped []RepositoryInvitation
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem RepositoryInvitation
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListInvitationsForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListPublicOKApplicationJSON as json.
func (s ReposListPublicOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListPublicOKApplicationJSON from json.
func (s *ReposListPublicOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListPublicOKApplicationJSON to nil")
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListPublicOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListReleasesOKApplicationJSON as json.
func (s ReposListReleasesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Release(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListReleasesOKApplicationJSON from json.
func (s *ReposListReleasesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListReleasesOKApplicationJSON to nil")
	}
	var unwrapped []Release
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Release
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListReleasesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListWebhookDeliveriesOKApplicationJSON as json.
func (s ReposListWebhookDeliveriesOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []HookDeliveryItem(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListWebhookDeliveriesOKApplicationJSON from json.
func (s *ReposListWebhookDeliveriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListWebhookDeliveriesOKApplicationJSON to nil")
	}
	var unwrapped []HookDeliveryItem
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HookDeliveryItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListWebhookDeliveriesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListWebhooksOKApplicationJSON as json.
func (s ReposListWebhooksOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Hook(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposListWebhooksOKApplicationJSON from json.
func (s *ReposListWebhooksOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposListWebhooksOKApplicationJSON to nil")
	}
	var unwrapped []Hook
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Hook
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListWebhooksOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposMergeReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"base\"" + ":")
		e.Str(s.Base)
	}
	{
		e.Comma()

		e.RawStr("\"head\"" + ":")
		e.Str(s.Head)
	}
	{
		if s.CommitMessage.Set {
			e.Comma()
		}
		if s.CommitMessage.Set {
			e.RawStr("\"commit_message\"" + ":")
			s.CommitMessage.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposMergeReq = [3]string{
	0: "base",
	1: "head",
	2: "commit_message",
}

// Decode decodes ReposMergeReq from json.
func (s *ReposMergeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposMergeReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "base":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Base = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base\"")
			}
		case "head":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Head = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head\"")
			}
		case "commit_message":
			if err := func() error {
				s.CommitMessage.Reset()
				if err := s.CommitMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposMergeReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposMergeReq) {
					name = jsonFieldsNameOfReposMergeReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposMergeUpstreamReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"branch\"" + ":")
		e.Str(s.Branch)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposMergeUpstreamReq = [1]string{
	0: "branch",
}

// Decode decodes ReposMergeUpstreamReq from json.
func (s *ReposMergeUpstreamReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposMergeUpstreamReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "branch":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Branch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposMergeUpstreamReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposMergeUpstreamReq) {
					name = jsonFieldsNameOfReposMergeUpstreamReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposRemoveAppAccessRestrictionsOKApplicationJSON as json.
func (s ReposRemoveAppAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Integration(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposRemoveAppAccessRestrictionsOKApplicationJSON from json.
func (s *ReposRemoveAppAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveAppAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []Integration
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Integration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRemoveAppAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposRemoveAppAccessRestrictionsReq as json.
func (s ReposRemoveAppAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposRemoveAppAccessRestrictionsReq0ReposRemoveAppAccessRestrictionsReq:
		s.ReposRemoveAppAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposRemoveAppAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposRemoveAppAccessRestrictionsReq from json.
func (s *ReposRemoveAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveAppAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposRemoveAppAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposRemoveAppAccessRestrictionsReq0ReposRemoveAppAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposRemoveAppAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposRemoveAppAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"apps\"" + ":")
		e.ArrStart()
		if len(s.Apps) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Apps[0]
				e.Str(elem)
			}
			for _, elem := range s.Apps[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposRemoveAppAccessRestrictionsReq0 = [1]string{
	0: "apps",
}

// Decode decodes ReposRemoveAppAccessRestrictionsReq0 from json.
func (s *ReposRemoveAppAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveAppAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apps":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Apps = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Apps = append(s.Apps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposRemoveAppAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposRemoveAppAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposRemoveAppAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposRemoveStatusCheckContextsOKApplicationJSON as json.
func (s ReposRemoveStatusCheckContextsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []string(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			e.Str(elem)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			e.Str(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposRemoveStatusCheckContextsOKApplicationJSON from json.
func (s *ReposRemoveStatusCheckContextsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveStatusCheckContextsOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRemoveStatusCheckContextsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposRemoveStatusCheckContextsReq as json.
func (s ReposRemoveStatusCheckContextsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposRemoveStatusCheckContextsReq0ReposRemoveStatusCheckContextsReq:
		s.ReposRemoveStatusCheckContextsReq0.Encode(e)
	case ArrayStringReposRemoveStatusCheckContextsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposRemoveStatusCheckContextsReq from json.
func (s *ReposRemoveStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveStatusCheckContextsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposRemoveStatusCheckContextsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposRemoveStatusCheckContextsReq0ReposRemoveStatusCheckContextsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposRemoveStatusCheckContextsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposRemoveStatusCheckContextsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"contexts\"" + ":")
		e.ArrStart()
		if len(s.Contexts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Contexts[0]
				e.Str(elem)
			}
			for _, elem := range s.Contexts[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposRemoveStatusCheckContextsReq0 = [1]string{
	0: "contexts",
}

// Decode decodes ReposRemoveStatusCheckContextsReq0 from json.
func (s *ReposRemoveStatusCheckContextsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveStatusCheckContextsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contexts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Contexts = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposRemoveStatusCheckContextsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposRemoveStatusCheckContextsReq0) {
					name = jsonFieldsNameOfReposRemoveStatusCheckContextsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposRemoveTeamAccessRestrictionsOKApplicationJSON as json.
func (s ReposRemoveTeamAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Team(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposRemoveTeamAccessRestrictionsOKApplicationJSON from json.
func (s *ReposRemoveTeamAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveTeamAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRemoveTeamAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposRemoveTeamAccessRestrictionsReq as json.
func (s ReposRemoveTeamAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposRemoveTeamAccessRestrictionsReq0ReposRemoveTeamAccessRestrictionsReq:
		s.ReposRemoveTeamAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposRemoveTeamAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposRemoveTeamAccessRestrictionsReq from json.
func (s *ReposRemoveTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveTeamAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposRemoveTeamAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposRemoveTeamAccessRestrictionsReq0ReposRemoveTeamAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposRemoveTeamAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposRemoveTeamAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"teams\"" + ":")
		e.ArrStart()
		if len(s.Teams) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Teams[0]
				e.Str(elem)
			}
			for _, elem := range s.Teams[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposRemoveTeamAccessRestrictionsReq0 = [1]string{
	0: "teams",
}

// Decode decodes ReposRemoveTeamAccessRestrictionsReq0 from json.
func (s *ReposRemoveTeamAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveTeamAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "teams":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Teams = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposRemoveTeamAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposRemoveTeamAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposRemoveTeamAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposRemoveUserAccessRestrictionsOKApplicationJSON as json.
func (s ReposRemoveUserAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposRemoveUserAccessRestrictionsOKApplicationJSON from json.
func (s *ReposRemoveUserAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveUserAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRemoveUserAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposRemoveUserAccessRestrictionsReq as json.
func (s ReposRemoveUserAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposRemoveUserAccessRestrictionsReq0ReposRemoveUserAccessRestrictionsReq:
		s.ReposRemoveUserAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposRemoveUserAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposRemoveUserAccessRestrictionsReq from json.
func (s *ReposRemoveUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveUserAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposRemoveUserAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposRemoveUserAccessRestrictionsReq0ReposRemoveUserAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposRemoveUserAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposRemoveUserAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"users\"" + ":")
		e.ArrStart()
		if len(s.Users) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Users[0]
				e.Str(elem)
			}
			for _, elem := range s.Users[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposRemoveUserAccessRestrictionsReq0 = [1]string{
	0: "users",
}

// Decode decodes ReposRemoveUserAccessRestrictionsReq0 from json.
func (s *ReposRemoveUserAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRemoveUserAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Users = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposRemoveUserAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposRemoveUserAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposRemoveUserAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposRenameBranchApplicationJSONForbidden as json.
func (s ReposRenameBranchApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposRenameBranchApplicationJSONForbidden from json.
func (s *ReposRenameBranchApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRenameBranchApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRenameBranchApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposRenameBranchApplicationJSONNotFound as json.
func (s ReposRenameBranchApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposRenameBranchApplicationJSONNotFound from json.
func (s *ReposRenameBranchApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRenameBranchApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposRenameBranchApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposRenameBranchReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"new_name\"" + ":")
		e.Str(s.NewName)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposRenameBranchReq = [1]string{
	0: "new_name",
}

// Decode decodes ReposRenameBranchReq from json.
func (s *ReposRenameBranchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposRenameBranchReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "new_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NewName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposRenameBranchReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposRenameBranchReq) {
					name = jsonFieldsNameOfReposRenameBranchReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposReplaceAllTopicsReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"names\"" + ":")
		e.ArrStart()
		if len(s.Names) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Names[0]
				e.Str(elem)
			}
			for _, elem := range s.Names[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposReplaceAllTopicsReq = [1]string{
	0: "names",
}

// Decode decodes ReposReplaceAllTopicsReq from json.
func (s *ReposReplaceAllTopicsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposReplaceAllTopicsReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "names":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Names = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Names = append(s.Names, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"names\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposReplaceAllTopicsReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposReplaceAllTopicsReq) {
					name = jsonFieldsNameOfReposReplaceAllTopicsReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposSetAppAccessRestrictionsOKApplicationJSON as json.
func (s ReposSetAppAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Integration(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposSetAppAccessRestrictionsOKApplicationJSON from json.
func (s *ReposSetAppAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetAppAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []Integration
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Integration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposSetAppAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposSetAppAccessRestrictionsReq as json.
func (s ReposSetAppAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposSetAppAccessRestrictionsReq0ReposSetAppAccessRestrictionsReq:
		s.ReposSetAppAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposSetAppAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposSetAppAccessRestrictionsReq from json.
func (s *ReposSetAppAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetAppAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposSetAppAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposSetAppAccessRestrictionsReq0ReposSetAppAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposSetAppAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposSetAppAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"apps\"" + ":")
		e.ArrStart()
		if len(s.Apps) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Apps[0]
				e.Str(elem)
			}
			for _, elem := range s.Apps[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposSetAppAccessRestrictionsReq0 = [1]string{
	0: "apps",
}

// Decode decodes ReposSetAppAccessRestrictionsReq0 from json.
func (s *ReposSetAppAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetAppAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apps":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Apps = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Apps = append(s.Apps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposSetAppAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposSetAppAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposSetAppAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposSetStatusCheckContextsOKApplicationJSON as json.
func (s ReposSetStatusCheckContextsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []string(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			e.Str(elem)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			e.Str(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposSetStatusCheckContextsOKApplicationJSON from json.
func (s *ReposSetStatusCheckContextsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetStatusCheckContextsOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposSetStatusCheckContextsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposSetStatusCheckContextsReq as json.
func (s ReposSetStatusCheckContextsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposSetStatusCheckContextsReq0ReposSetStatusCheckContextsReq:
		s.ReposSetStatusCheckContextsReq0.Encode(e)
	case ArrayStringReposSetStatusCheckContextsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposSetStatusCheckContextsReq from json.
func (s *ReposSetStatusCheckContextsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetStatusCheckContextsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposSetStatusCheckContextsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposSetStatusCheckContextsReq0ReposSetStatusCheckContextsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposSetStatusCheckContextsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposSetStatusCheckContextsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"contexts\"" + ":")
		e.ArrStart()
		if len(s.Contexts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Contexts[0]
				e.Str(elem)
			}
			for _, elem := range s.Contexts[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposSetStatusCheckContextsReq0 = [1]string{
	0: "contexts",
}

// Decode decodes ReposSetStatusCheckContextsReq0 from json.
func (s *ReposSetStatusCheckContextsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetStatusCheckContextsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contexts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Contexts = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposSetStatusCheckContextsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposSetStatusCheckContextsReq0) {
					name = jsonFieldsNameOfReposSetStatusCheckContextsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposSetTeamAccessRestrictionsOKApplicationJSON as json.
func (s ReposSetTeamAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Team(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposSetTeamAccessRestrictionsOKApplicationJSON from json.
func (s *ReposSetTeamAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetTeamAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposSetTeamAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposSetTeamAccessRestrictionsReq as json.
func (s ReposSetTeamAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposSetTeamAccessRestrictionsReq0ReposSetTeamAccessRestrictionsReq:
		s.ReposSetTeamAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposSetTeamAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposSetTeamAccessRestrictionsReq from json.
func (s *ReposSetTeamAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetTeamAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposSetTeamAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposSetTeamAccessRestrictionsReq0ReposSetTeamAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposSetTeamAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposSetTeamAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"teams\"" + ":")
		e.ArrStart()
		if len(s.Teams) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Teams[0]
				e.Str(elem)
			}
			for _, elem := range s.Teams[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposSetTeamAccessRestrictionsReq0 = [1]string{
	0: "teams",
}

// Decode decodes ReposSetTeamAccessRestrictionsReq0 from json.
func (s *ReposSetTeamAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetTeamAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "teams":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Teams = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposSetTeamAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposSetTeamAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposSetTeamAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposSetUserAccessRestrictionsOKApplicationJSON as json.
func (s ReposSetUserAccessRestrictionsOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes ReposSetUserAccessRestrictionsOKApplicationJSON from json.
func (s *ReposSetUserAccessRestrictionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetUserAccessRestrictionsOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposSetUserAccessRestrictionsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposSetUserAccessRestrictionsReq as json.
func (s ReposSetUserAccessRestrictionsReq) Encode(e *jx.Writer) {
	switch s.Type {
	case ReposSetUserAccessRestrictionsReq0ReposSetUserAccessRestrictionsReq:
		s.ReposSetUserAccessRestrictionsReq0.Encode(e)
	case ArrayStringReposSetUserAccessRestrictionsReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ReposSetUserAccessRestrictionsReq from json.
func (s *ReposSetUserAccessRestrictionsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetUserAccessRestrictionsReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ReposSetUserAccessRestrictionsReq0.Decode(d); err != nil {
			return err
		}
		s.Type = ReposSetUserAccessRestrictionsReq0ReposSetUserAccessRestrictionsReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringReposSetUserAccessRestrictionsReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ReposSetUserAccessRestrictionsReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"users\"" + ":")
		e.ArrStart()
		if len(s.Users) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Users[0]
				e.Str(elem)
			}
			for _, elem := range s.Users[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposSetUserAccessRestrictionsReq0 = [1]string{
	0: "users",
}

// Decode decodes ReposSetUserAccessRestrictionsReq0 from json.
func (s *ReposSetUserAccessRestrictionsReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposSetUserAccessRestrictionsReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Users = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposSetUserAccessRestrictionsReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposSetUserAccessRestrictionsReq0) {
					name = jsonFieldsNameOfReposSetUserAccessRestrictionsReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposTransferReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"new_owner\"" + ":")
		e.Str(s.NewOwner)
	}
	{
		if s.TeamIds != nil {
			e.Comma()
		}
		if s.TeamIds != nil {
			e.RawStr("\"team_ids\"" + ":")
			e.ArrStart()
			if len(s.TeamIds) >= 1 {
				// Encode first element without comma.
				{
					elem := s.TeamIds[0]
					e.Int(elem)
				}
				for _, elem := range s.TeamIds[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposTransferReq = [2]string{
	0: "new_owner",
	1: "team_ids",
}

// Decode decodes ReposTransferReq from json.
func (s *ReposTransferReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposTransferReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "new_owner":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NewOwner = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_owner\"")
			}
		case "team_ids":
			if err := func() error {
				s.TeamIds = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.TeamIds = append(s.TeamIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposTransferReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposTransferReq) {
					name = jsonFieldsNameOfReposTransferReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReposUpdateApplicationJSONForbidden as json.
func (s ReposUpdateApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateApplicationJSONForbidden from json.
func (s *ReposUpdateApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposUpdateApplicationJSONNotFound as json.
func (s ReposUpdateApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateApplicationJSONNotFound from json.
func (s *ReposUpdateApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposUpdateApplicationJSONTemporaryRedirect as json.
func (s ReposUpdateApplicationJSONTemporaryRedirect) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateApplicationJSONTemporaryRedirect from json.
func (s *ReposUpdateApplicationJSONTemporaryRedirect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateApplicationJSONTemporaryRedirect to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateApplicationJSONTemporaryRedirect(unwrapped)
	return nil
}

// Encode encodes ReposUpdateBranchProtectionApplicationJSONForbidden as json.
func (s ReposUpdateBranchProtectionApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionApplicationJSONForbidden from json.
func (s *ReposUpdateBranchProtectionApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateBranchProtectionApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateBranchProtectionApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposUpdateBranchProtectionApplicationJSONNotFound as json.
func (s ReposUpdateBranchProtectionApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionApplicationJSONNotFound from json.
func (s *ReposUpdateBranchProtectionApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateBranchProtectionApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateBranchProtectionApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateBranchProtectionReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"required_status_checks\"" + ":")
		s.RequiredStatusChecks.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"enforce_admins\"" + ":")
		s.EnforceAdmins.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"required_pull_request_reviews\"" + ":")
		s.RequiredPullRequestReviews.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"restrictions\"" + ":")
		s.Restrictions.Encode(e)
	}
	{
		if s.RequiredLinearHistory.Set {
			e.Comma()
		}
		if s.RequiredLinearHistory.Set {
			e.RawStr("\"required_linear_history\"" + ":")
			s.RequiredLinearHistory.Encode(e)
		}
	}
	{
		if s.AllowForcePushes.Set {
			e.Comma()
		}
		if s.AllowForcePushes.Set {
			e.RawStr("\"allow_force_pushes\"" + ":")
			s.AllowForcePushes.Encode(e)
		}
	}
	{
		if s.AllowDeletions.Set {
			e.Comma()
		}
		if s.AllowDeletions.Set {
			e.RawStr("\"allow_deletions\"" + ":")
			s.AllowDeletions.Encode(e)
		}
	}
	{
		if s.RequiredConversationResolution.Set {
			e.Comma()
		}
		if s.RequiredConversationResolution.Set {
			e.RawStr("\"required_conversation_resolution\"" + ":")
			s.RequiredConversationResolution.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateBranchProtectionReq = [8]string{
	0: "required_status_checks",
	1: "enforce_admins",
	2: "required_pull_request_reviews",
	3: "restrictions",
	4: "required_linear_history",
	5: "allow_force_pushes",
	6: "allow_deletions",
	7: "required_conversation_resolution",
}

// Decode decodes ReposUpdateBranchProtectionReq from json.
func (s *ReposUpdateBranchProtectionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateBranchProtectionReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "required_status_checks":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.RequiredStatusChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_status_checks\"")
			}
		case "enforce_admins":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.EnforceAdmins.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enforce_admins\"")
			}
		case "required_pull_request_reviews":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.RequiredPullRequestReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_pull_request_reviews\"")
			}
		case "restrictions":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Restrictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restrictions\"")
			}
		case "required_linear_history":
			if err := func() error {
				s.RequiredLinearHistory.Reset()
				if err := s.RequiredLinearHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_linear_history\"")
			}
		case "allow_force_pushes":
			if err := func() error {
				s.AllowForcePushes.Reset()
				if err := s.AllowForcePushes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_force_pushes\"")
			}
		case "allow_deletions":
			if err := func() error {
				s.AllowDeletions.Reset()
				if err := s.AllowDeletions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_deletions\"")
			}
		case "required_conversation_resolution":
			if err := func() error {
				s.RequiredConversationResolution.Reset()
				if err := s.RequiredConversationResolution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_conversation_resolution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateBranchProtectionReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposUpdateBranchProtectionReq) {
					name = jsonFieldsNameOfReposUpdateBranchProtectionReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateBranchProtectionReqRequiredPullRequestReviews) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DismissalRestrictions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DismissalRestrictions.Set {
			e.RawStr("\"dismissal_restrictions\"" + ":")
			s.DismissalRestrictions.Encode(e)
		}
	}
	{
		if s.DismissStaleReviews.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DismissStaleReviews.Set {
			e.RawStr("\"dismiss_stale_reviews\"" + ":")
			s.DismissStaleReviews.Encode(e)
		}
	}
	{
		if s.RequireCodeOwnerReviews.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequireCodeOwnerReviews.Set {
			e.RawStr("\"require_code_owner_reviews\"" + ":")
			s.RequireCodeOwnerReviews.Encode(e)
		}
	}
	{
		if s.RequiredApprovingReviewCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredApprovingReviewCount.Set {
			e.RawStr("\"required_approving_review_count\"" + ":")
			s.RequiredApprovingReviewCount.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateBranchProtectionReqRequiredPullRequestReviews = [4]string{
	0: "dismissal_restrictions",
	1: "dismiss_stale_reviews",
	2: "require_code_owner_reviews",
	3: "required_approving_review_count",
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviews from json.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateBranchProtectionReqRequiredPullRequestReviews to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dismissal_restrictions":
			if err := func() error {
				s.DismissalRestrictions.Reset()
				if err := s.DismissalRestrictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissal_restrictions\"")
			}
		case "dismiss_stale_reviews":
			if err := func() error {
				s.DismissStaleReviews.Reset()
				if err := s.DismissStaleReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismiss_stale_reviews\"")
			}
		case "require_code_owner_reviews":
			if err := func() error {
				s.RequireCodeOwnerReviews.Reset()
				if err := s.RequireCodeOwnerReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"require_code_owner_reviews\"")
			}
		case "required_approving_review_count":
			if err := func() error {
				s.RequiredApprovingReviewCount.Reset()
				if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_approving_review_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateBranchProtectionReqRequiredPullRequestReviews")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Users != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Users != nil {
			e.RawStr("\"users\"" + ":")
			e.ArrStart()
			if len(s.Users) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Users[0]
					e.Str(elem)
				}
				for _, elem := range s.Users[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Teams != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Teams != nil {
			e.RawStr("\"teams\"" + ":")
			e.ArrStart()
			if len(s.Teams) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Teams[0]
					e.Str(elem)
				}
				for _, elem := range s.Teams[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions = [2]string{
	0: "users",
	1: "teams",
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions from json.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			if err := func() error {
				s.Users = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "teams":
			if err := func() error {
				s.Teams = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateBranchProtectionReqRequiredStatusChecks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"strict\"" + ":")
		e.Bool(s.Strict)
	}
	{
		e.Comma()

		e.RawStr("\"contexts\"" + ":")
		e.ArrStart()
		if len(s.Contexts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Contexts[0]
				e.Str(elem)
			}
			for _, elem := range s.Contexts[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateBranchProtectionReqRequiredStatusChecks = [2]string{
	0: "strict",
	1: "contexts",
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredStatusChecks from json.
func (s *ReposUpdateBranchProtectionReqRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateBranchProtectionReqRequiredStatusChecks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strict":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Strict = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strict\"")
			}
		case "contexts":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Contexts = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateBranchProtectionReqRequiredStatusChecks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposUpdateBranchProtectionReqRequiredStatusChecks) {
					name = jsonFieldsNameOfReposUpdateBranchProtectionReqRequiredStatusChecks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateBranchProtectionReqRestrictions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"users\"" + ":")
		e.ArrStart()
		if len(s.Users) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Users[0]
				e.Str(elem)
			}
			for _, elem := range s.Users[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"teams\"" + ":")
		e.ArrStart()
		if len(s.Teams) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Teams[0]
				e.Str(elem)
			}
			for _, elem := range s.Teams[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Apps != nil {
			e.Comma()
		}
		if s.Apps != nil {
			e.RawStr("\"apps\"" + ":")
			e.ArrStart()
			if len(s.Apps) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Apps[0]
					e.Str(elem)
				}
				for _, elem := range s.Apps[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateBranchProtectionReqRestrictions = [3]string{
	0: "users",
	1: "teams",
	2: "apps",
}

// Decode decodes ReposUpdateBranchProtectionReqRestrictions from json.
func (s *ReposUpdateBranchProtectionReqRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateBranchProtectionReqRestrictions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Users = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "teams":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Teams = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		case "apps":
			if err := func() error {
				s.Apps = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Apps = append(s.Apps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateBranchProtectionReqRestrictions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposUpdateBranchProtectionReqRestrictions) {
					name = jsonFieldsNameOfReposUpdateBranchProtectionReqRestrictions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateCommitCommentReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateCommitCommentReq = [1]string{
	0: "body",
}

// Decode decodes ReposUpdateCommitCommentReq from json.
func (s *ReposUpdateCommitCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateCommitCommentReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateCommitCommentReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposUpdateCommitCommentReq) {
					name = jsonFieldsNameOfReposUpdateCommitCommentReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateInvitationReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Permissions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateInvitationReq = [1]string{
	0: "permissions",
}

// Decode decodes ReposUpdateInvitationReq from json.
func (s *ReposUpdateInvitationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateInvitationReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateInvitationReq")
	}

	return nil
}

// Encode encodes ReposUpdateInvitationReqPermissions as json.
func (s ReposUpdateInvitationReqPermissions) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposUpdateInvitationReqPermissions from json.
func (s *ReposUpdateInvitationReqPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateInvitationReqPermissions to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposUpdateInvitationReqPermissions(v) {
	case ReposUpdateInvitationReqPermissionsRead:
		*s = ReposUpdateInvitationReqPermissionsRead
	case ReposUpdateInvitationReqPermissionsWrite:
		*s = ReposUpdateInvitationReqPermissionsWrite
	case ReposUpdateInvitationReqPermissionsMaintain:
		*s = ReposUpdateInvitationReqPermissionsMaintain
	case ReposUpdateInvitationReqPermissionsTriage:
		*s = ReposUpdateInvitationReqPermissionsTriage
	case ReposUpdateInvitationReqPermissionsAdmin:
		*s = ReposUpdateInvitationReqPermissionsAdmin
	default:
		*s = ReposUpdateInvitationReqPermissions(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdatePullRequestReviewProtectionReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.DismissalRestrictions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DismissalRestrictions.Set {
			e.RawStr("\"dismissal_restrictions\"" + ":")
			s.DismissalRestrictions.Encode(e)
		}
	}
	{
		if s.DismissStaleReviews.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DismissStaleReviews.Set {
			e.RawStr("\"dismiss_stale_reviews\"" + ":")
			s.DismissStaleReviews.Encode(e)
		}
	}
	{
		if s.RequireCodeOwnerReviews.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequireCodeOwnerReviews.Set {
			e.RawStr("\"require_code_owner_reviews\"" + ":")
			s.RequireCodeOwnerReviews.Encode(e)
		}
	}
	{
		if s.RequiredApprovingReviewCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RequiredApprovingReviewCount.Set {
			e.RawStr("\"required_approving_review_count\"" + ":")
			s.RequiredApprovingReviewCount.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdatePullRequestReviewProtectionReq = [4]string{
	0: "dismissal_restrictions",
	1: "dismiss_stale_reviews",
	2: "require_code_owner_reviews",
	3: "required_approving_review_count",
}

// Decode decodes ReposUpdatePullRequestReviewProtectionReq from json.
func (s *ReposUpdatePullRequestReviewProtectionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdatePullRequestReviewProtectionReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dismissal_restrictions":
			if err := func() error {
				s.DismissalRestrictions.Reset()
				if err := s.DismissalRestrictions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismissal_restrictions\"")
			}
		case "dismiss_stale_reviews":
			if err := func() error {
				s.DismissStaleReviews.Reset()
				if err := s.DismissStaleReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dismiss_stale_reviews\"")
			}
		case "require_code_owner_reviews":
			if err := func() error {
				s.RequireCodeOwnerReviews.Reset()
				if err := s.RequireCodeOwnerReviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"require_code_owner_reviews\"")
			}
		case "required_approving_review_count":
			if err := func() error {
				s.RequiredApprovingReviewCount.Reset()
				if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_approving_review_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdatePullRequestReviewProtectionReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Users != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Users != nil {
			e.RawStr("\"users\"" + ":")
			e.ArrStart()
			if len(s.Users) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Users[0]
					e.Str(elem)
				}
				for _, elem := range s.Users[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Teams != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Teams != nil {
			e.RawStr("\"teams\"" + ":")
			e.ArrStart()
			if len(s.Teams) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Teams[0]
					e.Str(elem)
				}
				for _, elem := range s.Teams[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdatePullRequestReviewProtectionReqDismissalRestrictions = [2]string{
	0: "users",
	1: "teams",
}

// Decode decodes ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions from json.
func (s *ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			if err := func() error {
				s.Users = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "teams":
			if err := func() error {
				s.Teams = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateReleaseAssetReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Label.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Label.Set {
			e.RawStr("\"label\"" + ":")
			s.Label.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateReleaseAssetReq = [3]string{
	0: "name",
	1: "label",
	2: "state",
}

// Decode decodes ReposUpdateReleaseAssetReq from json.
func (s *ReposUpdateReleaseAssetReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateReleaseAssetReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "label":
			if err := func() error {
				s.Label.Reset()
				if err := s.Label.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateReleaseAssetReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateReleaseReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.TagName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TagName.Set {
			e.RawStr("\"tag_name\"" + ":")
			s.TagName.Encode(e)
		}
	}
	{
		if s.TargetCommitish.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TargetCommitish.Set {
			e.RawStr("\"target_commitish\"" + ":")
			s.TargetCommitish.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	{
		if s.Draft.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Draft.Set {
			e.RawStr("\"draft\"" + ":")
			s.Draft.Encode(e)
		}
	}
	{
		if s.Prerelease.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Prerelease.Set {
			e.RawStr("\"prerelease\"" + ":")
			s.Prerelease.Encode(e)
		}
	}
	{
		if s.DiscussionCategoryName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DiscussionCategoryName.Set {
			e.RawStr("\"discussion_category_name\"" + ":")
			s.DiscussionCategoryName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateReleaseReq = [7]string{
	0: "tag_name",
	1: "target_commitish",
	2: "name",
	3: "body",
	4: "draft",
	5: "prerelease",
	6: "discussion_category_name",
}

// Decode decodes ReposUpdateReleaseReq from json.
func (s *ReposUpdateReleaseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateReleaseReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag_name":
			if err := func() error {
				s.TagName.Reset()
				if err := s.TagName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag_name\"")
			}
		case "target_commitish":
			if err := func() error {
				s.TargetCommitish.Reset()
				if err := s.TargetCommitish.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_commitish\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "draft":
			if err := func() error {
				s.Draft.Reset()
				if err := s.Draft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft\"")
			}
		case "prerelease":
			if err := func() error {
				s.Prerelease.Reset()
				if err := s.Prerelease.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prerelease\"")
			}
		case "discussion_category_name":
			if err := func() error {
				s.DiscussionCategoryName.Reset()
				if err := s.DiscussionCategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discussion_category_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateReleaseReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Homepage.Set {
			e.RawStr("\"homepage\"" + ":")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Private.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.SecurityAndAnalysis.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecurityAndAnalysis.Set {
			e.RawStr("\"security_and_analysis\"" + ":")
			s.SecurityAndAnalysis.Encode(e)
		}
	}
	{
		if s.HasIssues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasIssues.Set {
			e.RawStr("\"has_issues\"" + ":")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasProjects.Set {
			e.RawStr("\"has_projects\"" + ":")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasWiki.Set {
			e.RawStr("\"has_wiki\"" + ":")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.DefaultBranch.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultBranch.Set {
			e.RawStr("\"default_branch\"" + ":")
			s.DefaultBranch.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Archived.Set {
			e.RawStr("\"archived\"" + ":")
			s.Archived.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateReq = [18]string{
	0:  "name",
	1:  "description",
	2:  "homepage",
	3:  "private",
	4:  "visibility",
	5:  "security_and_analysis",
	6:  "has_issues",
	7:  "has_projects",
	8:  "has_wiki",
	9:  "is_template",
	10: "default_branch",
	11: "allow_squash_merge",
	12: "allow_merge_commit",
	13: "allow_rebase_merge",
	14: "allow_auto_merge",
	15: "delete_branch_on_merge",
	16: "archived",
	17: "allow_forking",
}

// Decode decodes ReposUpdateReq from json.
func (s *ReposUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "homepage":
			if err := func() error {
				s.Homepage.Reset()
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "security_and_analysis":
			if err := func() error {
				s.SecurityAndAnalysis.Reset()
				if err := s.SecurityAndAnalysis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security_and_analysis\"")
			}
		case "has_issues":
			if err := func() error {
				s.HasIssues.Reset()
				if err := s.HasIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			if err := func() error {
				s.HasProjects.Reset()
				if err := s.HasProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			if err := func() error {
				s.HasWiki.Reset()
				if err := s.HasWiki.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "default_branch":
			if err := func() error {
				s.DefaultBranch.Reset()
				if err := s.DefaultBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateReqSecurityAndAnalysis) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AdvancedSecurity.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AdvancedSecurity.Set {
			e.RawStr("\"advanced_security\"" + ":")
			s.AdvancedSecurity.Encode(e)
		}
	}
	{
		if s.SecretScanning.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretScanning.Set {
			e.RawStr("\"secret_scanning\"" + ":")
			s.SecretScanning.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateReqSecurityAndAnalysis = [2]string{
	0: "advanced_security",
	1: "secret_scanning",
}

// Decode decodes ReposUpdateReqSecurityAndAnalysis from json.
func (s *ReposUpdateReqSecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateReqSecurityAndAnalysis to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "advanced_security":
			if err := func() error {
				s.AdvancedSecurity.Reset()
				if err := s.AdvancedSecurity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"advanced_security\"")
			}
		case "secret_scanning":
			if err := func() error {
				s.SecretScanning.Reset()
				if err := s.SecretScanning.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_scanning\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateReqSecurityAndAnalysis")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateReqSecurityAndAnalysisAdvancedSecurity = [1]string{
	0: "status",
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisAdvancedSecurity from json.
func (s *ReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateReqSecurityAndAnalysisAdvancedSecurity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateReqSecurityAndAnalysisAdvancedSecurity")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateReqSecurityAndAnalysisSecretScanning) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateReqSecurityAndAnalysisSecretScanning = [1]string{
	0: "status",
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisSecretScanning from json.
func (s *ReposUpdateReqSecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateReqSecurityAndAnalysisSecretScanning to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateReqSecurityAndAnalysisSecretScanning")
	}

	return nil
}

// Encode encodes ReposUpdateReqVisibility as json.
func (s ReposUpdateReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReposUpdateReqVisibility from json.
func (s *ReposUpdateReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReposUpdateReqVisibility(v) {
	case ReposUpdateReqVisibilityPublic:
		*s = ReposUpdateReqVisibilityPublic
	case ReposUpdateReqVisibilityPrivate:
		*s = ReposUpdateReqVisibilityPrivate
	case ReposUpdateReqVisibilityVisibility:
		*s = ReposUpdateReqVisibilityVisibility
	case ReposUpdateReqVisibilityInternal:
		*s = ReposUpdateReqVisibilityInternal
	default:
		*s = ReposUpdateReqVisibility(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateStatusCheckProtectionReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Strict.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Strict.Set {
			e.RawStr("\"strict\"" + ":")
			s.Strict.Encode(e)
		}
	}
	{
		if s.Contexts != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Contexts != nil {
			e.RawStr("\"contexts\"" + ":")
			e.ArrStart()
			if len(s.Contexts) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Contexts[0]
					e.Str(elem)
				}
				for _, elem := range s.Contexts[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateStatusCheckProtectionReq = [2]string{
	0: "strict",
	1: "contexts",
}

// Decode decodes ReposUpdateStatusCheckProtectionReq from json.
func (s *ReposUpdateStatusCheckProtectionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateStatusCheckProtectionReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strict":
			if err := func() error {
				s.Strict.Reset()
				if err := s.Strict.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strict\"")
			}
		case "contexts":
			if err := func() error {
				s.Contexts = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateStatusCheckProtectionReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateWebhookConfigForRepoReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		{
			if s.URL.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.URL.Set {
				e.RawStr("\"url\"" + ":")
				s.URL.Encode(e)
			}
		}
		{
			if s.ContentType.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.ContentType.Set {
				e.RawStr("\"content_type\"" + ":")
				s.ContentType.Encode(e)
			}
		}
		{
			if s.Secret.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Secret.Set {
				e.RawStr("\"secret\"" + ":")
				s.Secret.Encode(e)
			}
		}
		{
			if s.InsecureSsl.Set {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.InsecureSsl.Set {
				e.RawStr("\"insecure_ssl\"" + ":")
				s.InsecureSsl.Encode(e)
			}
		}
	}
	for k, elem := range s.AdditionalProps {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateWebhookConfigForRepoReq = [4]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
}

// Decode decodes ReposUpdateWebhookConfigForRepoReq from json.
func (s *ReposUpdateWebhookConfigForRepoReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateWebhookConfigForRepoReq to nil")
	}

	m := s.AdditionalProps
	if m == nil {
		m = map[string]jx.Raw{}
		s.AdditionalProps = m
	}
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateWebhookConfigForRepoReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateWebhookReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Config.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Config.Set {
			e.RawStr("\"config\"" + ":")
			s.Config.Encode(e)
		}
	}
	{
		if s.Events != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Events != nil {
			e.RawStr("\"events\"" + ":")
			e.ArrStart()
			if len(s.Events) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Events[0]
					e.Str(elem)
				}
				for _, elem := range s.Events[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AddEvents != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AddEvents != nil {
			e.RawStr("\"add_events\"" + ":")
			e.ArrStart()
			if len(s.AddEvents) >= 1 {
				// Encode first element without comma.
				{
					elem := s.AddEvents[0]
					e.Str(elem)
				}
				for _, elem := range s.AddEvents[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RemoveEvents != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RemoveEvents != nil {
			e.RawStr("\"remove_events\"" + ":")
			e.ArrStart()
			if len(s.RemoveEvents) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RemoveEvents[0]
					e.Str(elem)
				}
				for _, elem := range s.RemoveEvents[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateWebhookReq = [5]string{
	0: "config",
	1: "events",
	2: "add_events",
	3: "remove_events",
	4: "active",
}

// Decode decodes ReposUpdateWebhookReq from json.
func (s *ReposUpdateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateWebhookReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			if err := func() error {
				s.Config.Reset()
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "events":
			if err := func() error {
				s.Events = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "add_events":
			if err := func() error {
				s.AddEvents = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AddEvents = append(s.AddEvents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add_events\"")
			}
		case "remove_events":
			if err := func() error {
				s.RemoveEvents = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RemoveEvents = append(s.RemoveEvents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_events\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateWebhookReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateWebhookReqConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		s.URL.Encode(e)
	}
	{
		if s.ContentType.Set {
			e.Comma()
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.Comma()
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			e.Comma()
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	{
		if s.Address.Set {
			e.Comma()
		}
		if s.Address.Set {
			e.RawStr("\"address\"" + ":")
			s.Address.Encode(e)
		}
	}
	{
		if s.Room.Set {
			e.Comma()
		}
		if s.Room.Set {
			e.RawStr("\"room\"" + ":")
			s.Room.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReposUpdateWebhookReqConfig = [6]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
	4: "address",
	5: "room",
}

// Decode decodes ReposUpdateWebhookReqConfig from json.
func (s *ReposUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReposUpdateWebhookReqConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				{
					var unwrapped url.URL
					v, err := json.DecodeURI(d)
					unwrapped = v
					if err != nil {
						return err
					}
					s.URL = WebhookConfigURL(unwrapped)
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		case "address":
			if err := func() error {
				s.Address.Reset()
				if err := s.Address.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "room":
			if err := func() error {
				s.Room.Reset()
				if err := s.Room.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"room\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReposUpdateWebhookReqConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReposUpdateWebhookReqConfig) {
					name = jsonFieldsNameOfReposUpdateWebhookReqConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Repository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		if s.Organization.Set {
			e.Comma()
		}
		if s.Organization.Set {
			e.RawStr("\"organization\"" + ":")
			s.Organization.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"forks\"" + ":")
		e.Int(s.Forks)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		e.Str(s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		e.Comma()

		e.RawStr("\"ssh_url\"" + ":")
		e.Str(s.SSHURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		e.Comma()

		e.RawStr("\"clone_url\"" + ":")
		e.Str(s.CloneURL)
	}
	{
		e.Comma()

		e.RawStr("\"mirror_url\"" + ":")
		s.MirrorURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"svn_url\"" + ":")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		e.Comma()

		e.RawStr("\"homepage\"" + ":")
		s.Homepage.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"language\"" + ":")
		s.Language.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"forks_count\"" + ":")
		e.Int(s.ForksCount)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_count\"" + ":")
		e.Int(s.StargazersCount)
	}
	{
		e.Comma()

		e.RawStr("\"watchers_count\"" + ":")
		e.Int(s.WatchersCount)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"default_branch\"" + ":")
		e.Str(s.DefaultBranch)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues_count\"" + ":")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"has_issues\"" + ":")
		e.Bool(s.HasIssues)
	}
	{
		e.Comma()

		e.RawStr("\"has_projects\"" + ":")
		e.Bool(s.HasProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_wiki\"" + ":")
		e.Bool(s.HasWiki)
	}
	{
		e.Comma()

		e.RawStr("\"has_pages\"" + ":")
		e.Bool(s.HasPages)
	}
	{
		e.Comma()

		e.RawStr("\"has_downloads\"" + ":")
		e.Bool(s.HasDownloads)
	}
	{
		e.Comma()

		e.RawStr("\"archived\"" + ":")
		e.Bool(s.Archived)
	}
	{
		e.Comma()

		e.RawStr("\"disabled\"" + ":")
		e.Bool(s.Disabled)
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pushed_at\"" + ":")
		s.PushedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.Comma()
		}
		if s.TemplateRepository.Set {
			e.RawStr("\"template_repository\"" + ":")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.Comma()
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.Comma()
		}
		if s.SubscribersCount.Set {
			e.RawStr("\"subscribers_count\"" + ":")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.Comma()
		}
		if s.NetworkCount.Set {
			e.RawStr("\"network_count\"" + ":")
			s.NetworkCount.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"watchers\"" + ":")
		e.Int(s.Watchers)
	}
	{
		if s.MasterBranch.Set {
			e.Comma()
		}
		if s.MasterBranch.Set {
			e.RawStr("\"master_branch\"" + ":")
			s.MasterBranch.Encode(e)
		}
	}
	{
		if s.StarredAt.Set {
			e.Comma()
		}
		if s.StarredAt.Set {
			e.RawStr("\"starred_at\"" + ":")
			s.StarredAt.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRepository = [90]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "license",
	5:  "organization",
	6:  "forks",
	7:  "permissions",
	8:  "owner",
	9:  "private",
	10: "html_url",
	11: "description",
	12: "fork",
	13: "url",
	14: "archive_url",
	15: "assignees_url",
	16: "blobs_url",
	17: "branches_url",
	18: "collaborators_url",
	19: "comments_url",
	20: "commits_url",
	21: "compare_url",
	22: "contents_url",
	23: "contributors_url",
	24: "deployments_url",
	25: "downloads_url",
	26: "events_url",
	27: "forks_url",
	28: "git_commits_url",
	29: "git_refs_url",
	30: "git_tags_url",
	31: "git_url",
	32: "issue_comment_url",
	33: "issue_events_url",
	34: "issues_url",
	35: "keys_url",
	36: "labels_url",
	37: "languages_url",
	38: "merges_url",
	39: "milestones_url",
	40: "notifications_url",
	41: "pulls_url",
	42: "releases_url",
	43: "ssh_url",
	44: "stargazers_url",
	45: "statuses_url",
	46: "subscribers_url",
	47: "subscription_url",
	48: "tags_url",
	49: "teams_url",
	50: "trees_url",
	51: "clone_url",
	52: "mirror_url",
	53: "hooks_url",
	54: "svn_url",
	55: "homepage",
	56: "language",
	57: "forks_count",
	58: "stargazers_count",
	59: "watchers_count",
	60: "size",
	61: "default_branch",
	62: "open_issues_count",
	63: "is_template",
	64: "topics",
	65: "has_issues",
	66: "has_projects",
	67: "has_wiki",
	68: "has_pages",
	69: "has_downloads",
	70: "archived",
	71: "disabled",
	72: "visibility",
	73: "pushed_at",
	74: "created_at",
	75: "updated_at",
	76: "allow_rebase_merge",
	77: "template_repository",
	78: "temp_clone_token",
	79: "allow_squash_merge",
	80: "allow_auto_merge",
	81: "delete_branch_on_merge",
	82: "allow_merge_commit",
	83: "allow_forking",
	84: "subscribers_count",
	85: "network_count",
	86: "open_issues",
	87: "watchers",
	88: "master_branch",
	89: "starred_at",
}

// Decode decodes Repository from json.
func (s *Repository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Repository to nil")
	}
	var requiredBitSet [12]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "license":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "organization":
			if err := func() error {
				s.Organization.Reset()
				if err := s.Organization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		case "forks":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Forks = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "owner":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.GitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.SSHURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CloneURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SvnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ForksCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.StargazersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.WatchersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DefaultBranch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.OpenIssuesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasIssues = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.HasProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.HasWiki = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasPages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.HasDownloads = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Archived = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			requiredBitSet[8] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[9] |= 1 << 3
			if err := func() error {
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "template_repository":
			if err := func() error {
				s.TemplateRepository.Reset()
				if err := s.TemplateRepository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_repository\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		case "subscribers_count":
			if err := func() error {
				s.SubscribersCount.Reset()
				if err := s.SubscribersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			if err := func() error {
				s.NetworkCount.Reset()
				if err := s.NetworkCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		case "open_issues":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "watchers":
			requiredBitSet[10] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Watchers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "master_branch":
			if err := func() error {
				s.MasterBranch.Reset()
				if err := s.MasterBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master_branch\"")
			}
		case "starred_at":
			if err := func() error {
				s.StarredAt.Reset()
				if err := s.StarredAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Repository")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [12]uint8{
		0b01011111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
		0b11111110,
		0b00001110,
		0b11000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRepository) {
					name = jsonFieldsNameOfRepository[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RepositoryCollaboratorPermission) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"permission\"" + ":")
		e.Str(s.Permission)
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRepositoryCollaboratorPermission = [2]string{
	0: "permission",
	1: "user",
}

// Decode decodes RepositoryCollaboratorPermission from json.
func (s *RepositoryCollaboratorPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositoryCollaboratorPermission to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Permission = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepositoryCollaboratorPermission")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRepositoryCollaboratorPermission) {
					name = jsonFieldsNameOfRepositoryCollaboratorPermission[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RepositoryInvitation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"invitee\"" + ":")
		s.Invitee.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"inviter\"" + ":")
		s.Inviter.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"permissions\"" + ":")
		s.Permissions.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.Expired.Set {
			e.Comma()
		}
		if s.Expired.Set {
			e.RawStr("\"expired\"" + ":")
			s.Expired.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		e.Str(s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRepositoryInvitation = [10]string{
	0: "id",
	1: "repository",
	2: "invitee",
	3: "inviter",
	4: "permissions",
	5: "created_at",
	6: "expired",
	7: "url",
	8: "html_url",
	9: "node_id",
}

// Decode decodes RepositoryInvitation from json.
func (s *RepositoryInvitation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositoryInvitation to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "repository":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "invitee":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Invitee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invitee\"")
			}
		case "inviter":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Inviter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inviter\"")
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "expired":
			if err := func() error {
				s.Expired.Reset()
				if err := s.Expired.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expired\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HTMLURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepositoryInvitation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRepositoryInvitation) {
					name = jsonFieldsNameOfRepositoryInvitation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes RepositoryInvitationPermissions as json.
func (s RepositoryInvitationPermissions) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes RepositoryInvitationPermissions from json.
func (s *RepositoryInvitationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositoryInvitationPermissions to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RepositoryInvitationPermissions(v) {
	case RepositoryInvitationPermissionsRead:
		*s = RepositoryInvitationPermissionsRead
	case RepositoryInvitationPermissionsWrite:
		*s = RepositoryInvitationPermissionsWrite
	case RepositoryInvitationPermissionsAdmin:
		*s = RepositoryInvitationPermissionsAdmin
	case RepositoryInvitationPermissionsTriage:
		*s = RepositoryInvitationPermissionsTriage
	case RepositoryInvitationPermissionsMaintain:
		*s = RepositoryInvitationPermissionsMaintain
	default:
		*s = RepositoryInvitationPermissions(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	{
		e.Comma()

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRepositoryPermissions = [5]string{
	0: "admin",
	1: "pull",
	2: "triage",
	3: "push",
	4: "maintain",
}

// Decode decodes RepositoryPermissions from json.
func (s *RepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositoryPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "pull":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepositoryPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRepositoryPermissions) {
					name = jsonFieldsNameOfRepositoryPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RepositorySubscription) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"subscribed\"" + ":")
		e.Bool(s.Subscribed)
	}
	{
		e.Comma()

		e.RawStr("\"ignored\"" + ":")
		e.Bool(s.Ignored)
	}
	{
		e.Comma()

		e.RawStr("\"reason\"" + ":")
		s.Reason.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"repository_url\"" + ":")
		json.EncodeURI(e, s.RepositoryURL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRepositorySubscription = [6]string{
	0: "subscribed",
	1: "ignored",
	2: "reason",
	3: "created_at",
	4: "url",
	5: "repository_url",
}

// Decode decodes RepositorySubscription from json.
func (s *RepositorySubscription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositorySubscription to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscribed":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Subscribed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribed\"")
			}
		case "ignored":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ignored = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignored\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "repository_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoryURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepositorySubscription")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRepositorySubscription) {
					name = jsonFieldsNameOfRepositorySubscription[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RepositoryTemplateRepository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.FullName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FullName.Set {
			e.RawStr("\"full_name\"" + ":")
			s.FullName.Encode(e)
		}
	}
	{
		if s.Owner.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Owner.Set {
			e.RawStr("\"owner\"" + ":")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Private.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Fork.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fork.Set {
			e.RawStr("\"fork\"" + ":")
			s.Fork.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ArchiveURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ArchiveURL.Set {
			e.RawStr("\"archive_url\"" + ":")
			s.ArchiveURL.Encode(e)
		}
	}
	{
		if s.AssigneesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AssigneesURL.Set {
			e.RawStr("\"assignees_url\"" + ":")
			s.AssigneesURL.Encode(e)
		}
	}
	{
		if s.BlobsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BlobsURL.Set {
			e.RawStr("\"blobs_url\"" + ":")
			s.BlobsURL.Encode(e)
		}
	}
	{
		if s.BranchesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BranchesURL.Set {
			e.RawStr("\"branches_url\"" + ":")
			s.BranchesURL.Encode(e)
		}
	}
	{
		if s.CollaboratorsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CollaboratorsURL.Set {
			e.RawStr("\"collaborators_url\"" + ":")
			s.CollaboratorsURL.Encode(e)
		}
	}
	{
		if s.CommentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommentsURL.Set {
			e.RawStr("\"comments_url\"" + ":")
			s.CommentsURL.Encode(e)
		}
	}
	{
		if s.CommitsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CommitsURL.Set {
			e.RawStr("\"commits_url\"" + ":")
			s.CommitsURL.Encode(e)
		}
	}
	{
		if s.CompareURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CompareURL.Set {
			e.RawStr("\"compare_url\"" + ":")
			s.CompareURL.Encode(e)
		}
	}
	{
		if s.ContentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentsURL.Set {
			e.RawStr("\"contents_url\"" + ":")
			s.ContentsURL.Encode(e)
		}
	}
	{
		if s.ContributorsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContributorsURL.Set {
			e.RawStr("\"contributors_url\"" + ":")
			s.ContributorsURL.Encode(e)
		}
	}
	{
		if s.DeploymentsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeploymentsURL.Set {
			e.RawStr("\"deployments_url\"" + ":")
			s.DeploymentsURL.Encode(e)
		}
	}
	{
		if s.DownloadsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DownloadsURL.Set {
			e.RawStr("\"downloads_url\"" + ":")
			s.DownloadsURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsURL.Set {
			e.RawStr("\"events_url\"" + ":")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ForksURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForksURL.Set {
			e.RawStr("\"forks_url\"" + ":")
			s.ForksURL.Encode(e)
		}
	}
	{
		if s.GitCommitsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitCommitsURL.Set {
			e.RawStr("\"git_commits_url\"" + ":")
			s.GitCommitsURL.Encode(e)
		}
	}
	{
		if s.GitRefsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitRefsURL.Set {
			e.RawStr("\"git_refs_url\"" + ":")
			s.GitRefsURL.Encode(e)
		}
	}
	{
		if s.GitTagsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitTagsURL.Set {
			e.RawStr("\"git_tags_url\"" + ":")
			s.GitTagsURL.Encode(e)
		}
	}
	{
		if s.GitURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GitURL.Set {
			e.RawStr("\"git_url\"" + ":")
			s.GitURL.Encode(e)
		}
	}
	{
		if s.IssueCommentURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IssueCommentURL.Set {
			e.RawStr("\"issue_comment_url\"" + ":")
			s.IssueCommentURL.Encode(e)
		}
	}
	{
		if s.IssueEventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IssueEventsURL.Set {
			e.RawStr("\"issue_events_url\"" + ":")
			s.IssueEventsURL.Encode(e)
		}
	}
	{
		if s.IssuesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IssuesURL.Set {
			e.RawStr("\"issues_url\"" + ":")
			s.IssuesURL.Encode(e)
		}
	}
	{
		if s.KeysURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.KeysURL.Set {
			e.RawStr("\"keys_url\"" + ":")
			s.KeysURL.Encode(e)
		}
	}
	{
		if s.LabelsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LabelsURL.Set {
			e.RawStr("\"labels_url\"" + ":")
			s.LabelsURL.Encode(e)
		}
	}
	{
		if s.LanguagesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LanguagesURL.Set {
			e.RawStr("\"languages_url\"" + ":")
			s.LanguagesURL.Encode(e)
		}
	}
	{
		if s.MergesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MergesURL.Set {
			e.RawStr("\"merges_url\"" + ":")
			s.MergesURL.Encode(e)
		}
	}
	{
		if s.MilestonesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MilestonesURL.Set {
			e.RawStr("\"milestones_url\"" + ":")
			s.MilestonesURL.Encode(e)
		}
	}
	{
		if s.NotificationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NotificationsURL.Set {
			e.RawStr("\"notifications_url\"" + ":")
			s.NotificationsURL.Encode(e)
		}
	}
	{
		if s.PullsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PullsURL.Set {
			e.RawStr("\"pulls_url\"" + ":")
			s.PullsURL.Encode(e)
		}
	}
	{
		if s.ReleasesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReleasesURL.Set {
			e.RawStr("\"releases_url\"" + ":")
			s.ReleasesURL.Encode(e)
		}
	}
	{
		if s.SSHURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SSHURL.Set {
			e.RawStr("\"ssh_url\"" + ":")
			s.SSHURL.Encode(e)
		}
	}
	{
		if s.StargazersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StargazersURL.Set {
			e.RawStr("\"stargazers_url\"" + ":")
			s.StargazersURL.Encode(e)
		}
	}
	{
		if s.StatusesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StatusesURL.Set {
			e.RawStr("\"statuses_url\"" + ":")
			s.StatusesURL.Encode(e)
		}
	}
	{
		if s.SubscribersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscribersURL.Set {
			e.RawStr("\"subscribers_url\"" + ":")
			s.SubscribersURL.Encode(e)
		}
	}
	{
		if s.SubscriptionURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscriptionURL.Set {
			e.RawStr("\"subscription_url\"" + ":")
			s.SubscriptionURL.Encode(e)
		}
	}
	{
		if s.TagsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TagsURL.Set {
			e.RawStr("\"tags_url\"" + ":")
			s.TagsURL.Encode(e)
		}
	}
	{
		if s.TeamsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TeamsURL.Set {
			e.RawStr("\"teams_url\"" + ":")
			s.TeamsURL.Encode(e)
		}
	}
	{
		if s.TreesURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TreesURL.Set {
			e.RawStr("\"trees_url\"" + ":")
			s.TreesURL.Encode(e)
		}
	}
	{
		if s.CloneURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CloneURL.Set {
			e.RawStr("\"clone_url\"" + ":")
			s.CloneURL.Encode(e)
		}
	}
	{
		if s.MirrorURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MirrorURL.Set {
			e.RawStr("\"mirror_url\"" + ":")
			s.MirrorURL.Encode(e)
		}
	}
	{
		if s.HooksURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HooksURL.Set {
			e.RawStr("\"hooks_url\"" + ":")
			s.HooksURL.Encode(e)
		}
	}
	{
		if s.SvnURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SvnURL.Set {
			e.RawStr("\"svn_url\"" + ":")
			s.SvnURL.Encode(e)
		}
	}
	{
		if s.Homepage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Homepage.Set {
			e.RawStr("\"homepage\"" + ":")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Language.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Language.Set {
			e.RawStr("\"language\"" + ":")
			s.Language.Encode(e)
		}
	}
	{
		if s.ForksCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ForksCount.Set {
			e.RawStr("\"forks_count\"" + ":")
			s.ForksCount.Encode(e)
		}
	}
	{
		if s.StargazersCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StargazersCount.Set {
			e.RawStr("\"stargazers_count\"" + ":")
			s.StargazersCount.Encode(e)
		}
	}
	{
		if s.WatchersCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.WatchersCount.Set {
			e.RawStr("\"watchers_count\"" + ":")
			s.WatchersCount.Encode(e)
		}
	}
	{
		if s.Size.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Size.Set {
			e.RawStr("\"size\"" + ":")
			s.Size.Encode(e)
		}
	}
	{
		if s.DefaultBranch.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DefaultBranch.Set {
			e.RawStr("\"default_branch\"" + ":")
			s.DefaultBranch.Encode(e)
		}
	}
	{
		if s.OpenIssuesCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OpenIssuesCount.Set {
			e.RawStr("\"open_issues_count\"" + ":")
			s.OpenIssuesCount.Encode(e)
		}
	}
	{
		if s.IsTemplate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.HasIssues.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasIssues.Set {
			e.RawStr("\"has_issues\"" + ":")
			s.HasIssues.Encode(e)
		}
	}
	{
		if s.HasProjects.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasProjects.Set {
			e.RawStr("\"has_projects\"" + ":")
			s.HasProjects.Encode(e)
		}
	}
	{
		if s.HasWiki.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasWiki.Set {
			e.RawStr("\"has_wiki\"" + ":")
			s.HasWiki.Encode(e)
		}
	}
	{
		if s.HasPages.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasPages.Set {
			e.RawStr("\"has_pages\"" + ":")
			s.HasPages.Encode(e)
		}
	}
	{
		if s.HasDownloads.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HasDownloads.Set {
			e.RawStr("\"has_downloads\"" + ":")
			s.HasDownloads.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Archived.Set {
			e.RawStr("\"archived\"" + ":")
			s.Archived.Encode(e)
		}
	}
	{
		if s.Disabled.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Disabled.Set {
			e.RawStr("\"disabled\"" + ":")
			s.Disabled.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.PushedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PushedAt.Set {
			e.RawStr("\"pushed_at\"" + ":")
			s.PushedAt.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.Permissions.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		if s.AllowRebaseMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscribersCount.Set {
			e.RawStr("\"subscribers_count\"" + ":")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NetworkCount.Set {
			e.RawStr("\"network_count\"" + ":")
			s.NetworkCount.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRepositoryTemplateRepository = [81]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "owner",
	5:  "private",
	6:  "html_url",
	7:  "description",
	8:  "fork",
	9:  "url",
	10: "archive_url",
	11: "assignees_url",
	12: "blobs_url",
	13: "branches_url",
	14: "collaborators_url",
	15: "comments_url",
	16: "commits_url",
	17: "compare_url",
	18: "contents_url",
	19: "contributors_url",
	20: "deployments_url",
	21: "downloads_url",
	22: "events_url",
	23: "forks_url",
	24: "git_commits_url",
	25: "git_refs_url",
	26: "git_tags_url",
	27: "git_url",
	28: "issue_comment_url",
	29: "issue_events_url",
	30: "issues_url",
	31: "keys_url",
	32: "labels_url",
	33: "languages_url",
	34: "merges_url",
	35: "milestones_url",
	36: "notifications_url",
	37: "pulls_url",
	38: "releases_url",
	39: "ssh_url",
	40: "stargazers_url",
	41: "statuses_url",
	42: "subscribers_url",
	43: "subscription_url",
	44: "tags_url",
	45: "teams_url",
	46: "trees_url",
	47: "clone_url",
	48: "mirror_url",
	49: "hooks_url",
	50: "svn_url",
	51: "homepage",
	52: "language",
	53: "forks_count",
	54: "stargazers_count",
	55: "watchers_count",
	56: "size",
	57: "default_branch",
	58: "open_issues_count",
	59: "is_template",
	60: "topics",
	61: "has_issues",
	62: "has_projects",
	63: "has_wiki",
	64: "has_pages",
	65: "has_downloads",
	66: "archived",
	67: "disabled",
	68: "visibility",
	69: "pushed_at",
	70: "created_at",
	71: "updated_at",
	72: "permissions",
	73: "allow_rebase_merge",
	74: "temp_clone_token",
	75: "allow_squash_merge",
	76: "allow_auto_merge",
	77: "delete_branch_on_merge",
	78: "allow_merge_commit",
	79: "subscribers_count",
	80: "network_count",
}

// Decode decodes RepositoryTemplateRepository from json.
func (s *RepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositoryTemplateRepository to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			if err := func() error {
				s.FullName.Reset()
				if err := s.FullName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			if err := func() error {
				s.Fork.Reset()
				if err := s.Fork.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			if err := func() error {
				s.ArchiveURL.Reset()
				if err := s.ArchiveURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			if err := func() error {
				s.AssigneesURL.Reset()
				if err := s.AssigneesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			if err := func() error {
				s.BlobsURL.Reset()
				if err := s.BlobsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			if err := func() error {
				s.BranchesURL.Reset()
				if err := s.BranchesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			if err := func() error {
				s.CollaboratorsURL.Reset()
				if err := s.CollaboratorsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			if err := func() error {
				s.CommentsURL.Reset()
				if err := s.CommentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			if err := func() error {
				s.CommitsURL.Reset()
				if err := s.CommitsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			if err := func() error {
				s.CompareURL.Reset()
				if err := s.CompareURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			if err := func() error {
				s.ContentsURL.Reset()
				if err := s.ContentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			if err := func() error {
				s.ContributorsURL.Reset()
				if err := s.ContributorsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			if err := func() error {
				s.DeploymentsURL.Reset()
				if err := s.DeploymentsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			if err := func() error {
				s.DownloadsURL.Reset()
				if err := s.DownloadsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			if err := func() error {
				s.EventsURL.Reset()
				if err := s.EventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			if err := func() error {
				s.ForksURL.Reset()
				if err := s.ForksURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			if err := func() error {
				s.GitCommitsURL.Reset()
				if err := s.GitCommitsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			if err := func() error {
				s.GitRefsURL.Reset()
				if err := s.GitRefsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			if err := func() error {
				s.GitTagsURL.Reset()
				if err := s.GitTagsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			if err := func() error {
				s.GitURL.Reset()
				if err := s.GitURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			if err := func() error {
				s.IssueCommentURL.Reset()
				if err := s.IssueCommentURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			if err := func() error {
				s.IssueEventsURL.Reset()
				if err := s.IssueEventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			if err := func() error {
				s.IssuesURL.Reset()
				if err := s.IssuesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			if err := func() error {
				s.KeysURL.Reset()
				if err := s.KeysURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			if err := func() error {
				s.LabelsURL.Reset()
				if err := s.LabelsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			if err := func() error {
				s.LanguagesURL.Reset()
				if err := s.LanguagesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			if err := func() error {
				s.MergesURL.Reset()
				if err := s.MergesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			if err := func() error {
				s.MilestonesURL.Reset()
				if err := s.MilestonesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			if err := func() error {
				s.NotificationsURL.Reset()
				if err := s.NotificationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			if err := func() error {
				s.PullsURL.Reset()
				if err := s.PullsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			if err := func() error {
				s.ReleasesURL.Reset()
				if err := s.ReleasesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			if err := func() error {
				s.SSHURL.Reset()
				if err := s.SSHURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			if err := func() error {
				s.StargazersURL.Reset()
				if err := s.StargazersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			if err := func() error {
				s.StatusesURL.Reset()
				if err := s.StatusesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			if err := func() error {
				s.SubscribersURL.Reset()
				if err := s.SubscribersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			if err := func() error {
				s.SubscriptionURL.Reset()
				if err := s.SubscriptionURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			if err := func() error {
				s.TagsURL.Reset()
				if err := s.TagsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			if err := func() error {
				s.TeamsURL.Reset()
				if err := s.TeamsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			if err := func() error {
				s.TreesURL.Reset()
				if err := s.TreesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			if err := func() error {
				s.CloneURL.Reset()
				if err := s.CloneURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			if err := func() error {
				s.MirrorURL.Reset()
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			if err := func() error {
				s.HooksURL.Reset()
				if err := s.HooksURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			if err := func() error {
				s.SvnURL.Reset()
				if err := s.SvnURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			if err := func() error {
				s.Homepage.Reset()
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			if err := func() error {
				s.ForksCount.Reset()
				if err := s.ForksCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			if err := func() error {
				s.StargazersCount.Reset()
				if err := s.StargazersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			if err := func() error {
				s.WatchersCount.Reset()
				if err := s.WatchersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			if err := func() error {
				s.DefaultBranch.Reset()
				if err := s.DefaultBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			if err := func() error {
				s.OpenIssuesCount.Reset()
				if err := s.OpenIssuesCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			if err := func() error {
				s.HasIssues.Reset()
				if err := s.HasIssues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			if err := func() error {
				s.HasProjects.Reset()
				if err := s.HasProjects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			if err := func() error {
				s.HasWiki.Reset()
				if err := s.HasWiki.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			if err := func() error {
				s.HasPages.Reset()
				if err := s.HasPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			if err := func() error {
				s.HasDownloads.Reset()
				if err := s.HasDownloads.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			if err := func() error {
				s.Disabled.Reset()
				if err := s.Disabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			if err := func() error {
				s.PushedAt.Reset()
				if err := s.PushedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "subscribers_count":
			if err := func() error {
				s.SubscribersCount.Reset()
				if err := s.SubscribersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			if err := func() error {
				s.NetworkCount.Reset()
				if err := s.NetworkCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepositoryTemplateRepository")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RepositoryTemplateRepositoryOwner) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Login.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Login.Set {
			e.RawStr("\"login\"" + ":")
			s.Login.Encode(e)
		}
	}
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.NodeID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NodeID.Set {
			e.RawStr("\"node_id\"" + ":")
			s.NodeID.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AvatarURL.Set {
			e.RawStr("\"avatar_url\"" + ":")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.GravatarID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GravatarID.Set {
			e.RawStr("\"gravatar_id\"" + ":")
			s.GravatarID.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.FollowersURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowersURL.Set {
			e.RawStr("\"followers_url\"" + ":")
			s.FollowersURL.Encode(e)
		}
	}
	{
		if s.FollowingURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FollowingURL.Set {
			e.RawStr("\"following_url\"" + ":")
			s.FollowingURL.Encode(e)
		}
	}
	{
		if s.GistsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GistsURL.Set {
			e.RawStr("\"gists_url\"" + ":")
			s.GistsURL.Encode(e)
		}
	}
	{
		if s.StarredURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.StarredURL.Set {
			e.RawStr("\"starred_url\"" + ":")
			s.StarredURL.Encode(e)
		}
	}
	{
		if s.SubscriptionsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SubscriptionsURL.Set {
			e.RawStr("\"subscriptions_url\"" + ":")
			s.SubscriptionsURL.Encode(e)
		}
	}
	{
		if s.OrganizationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OrganizationsURL.Set {
			e.RawStr("\"organizations_url\"" + ":")
			s.OrganizationsURL.Encode(e)
		}
	}
	{
		if s.ReposURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReposURL.Set {
			e.RawStr("\"repos_url\"" + ":")
			s.ReposURL.Encode(e)
		}
	}
	{
		if s.EventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EventsURL.Set {
			e.RawStr("\"events_url\"" + ":")
			s.EventsURL.Encode(e)
		}
	}
	{
		if s.ReceivedEventsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ReceivedEventsURL.Set {
			e.RawStr("\"received_events_url\"" + ":")
			s.ReceivedEventsURL.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.SiteAdmin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SiteAdmin.Set {
			e.RawStr("\"site_admin\"" + ":")
			s.SiteAdmin.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRepositoryTemplateRepositoryOwner = [18]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "avatar_url",
	4:  "gravatar_id",
	5:  "url",
	6:  "html_url",
	7:  "followers_url",
	8:  "following_url",
	9:  "gists_url",
	10: "starred_url",
	11: "subscriptions_url",
	12: "organizations_url",
	13: "repos_url",
	14: "events_url",
	15: "received_events_url",
	16: "type",
	17: "site_admin",
}

// Decode decodes RepositoryTemplateRepositoryOwner from json.
func (s *RepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositoryTemplateRepositoryOwner to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			if err := func() error {
				s.Login.Reset()
				if err := s.Login.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			if err := func() error {
				s.GravatarID.Reset()
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			if err := func() error {
				s.FollowersURL.Reset()
				if err := s.FollowersURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			if err := func() error {
				s.FollowingURL.Reset()
				if err := s.FollowingURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			if err := func() error {
				s.GistsURL.Reset()
				if err := s.GistsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			if err := func() error {
				s.StarredURL.Reset()
				if err := s.StarredURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			if err := func() error {
				s.SubscriptionsURL.Reset()
				if err := s.SubscriptionsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			if err := func() error {
				s.OrganizationsURL.Reset()
				if err := s.OrganizationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			if err := func() error {
				s.ReposURL.Reset()
				if err := s.ReposURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			if err := func() error {
				s.EventsURL.Reset()
				if err := s.EventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			if err := func() error {
				s.ReceivedEventsURL.Reset()
				if err := s.ReceivedEventsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			if err := func() error {
				s.SiteAdmin.Reset()
				if err := s.SiteAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepositoryTemplateRepositoryOwner")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RepositoryTemplateRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Admin.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Admin.Set {
			e.RawStr("\"admin\"" + ":")
			s.Admin.Encode(e)
		}
	}
	{
		if s.Maintain.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	{
		if s.Push.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Push.Set {
			e.RawStr("\"push\"" + ":")
			s.Push.Encode(e)
		}
	}
	{
		if s.Triage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		if s.Pull.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Pull.Set {
			e.RawStr("\"pull\"" + ":")
			s.Pull.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRepositoryTemplateRepositoryPermissions = [5]string{
	0: "admin",
	1: "maintain",
	2: "push",
	3: "triage",
	4: "pull",
}

// Decode decodes RepositoryTemplateRepositoryPermissions from json.
func (s *RepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RepositoryTemplateRepositoryPermissions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			if err := func() error {
				s.Admin.Reset()
				if err := s.Admin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "push":
			if err := func() error {
				s.Push.Reset()
				if err := s.Push.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "pull":
			if err := func() error {
				s.Pull.Reset()
				if err := s.Pull.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RepositoryTemplateRepositoryPermissions")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReviewComment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request_review_id\"" + ":")
		s.PullRequestReviewID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"diff_hunk\"" + ":")
		e.Str(s.DiffHunk)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"position\"" + ":")
		s.Position.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"original_position\"" + ":")
		e.Int(s.OriginalPosition)
	}
	{
		e.Comma()

		e.RawStr("\"commit_id\"" + ":")
		e.Str(s.CommitID)
	}
	{
		e.Comma()

		e.RawStr("\"original_commit_id\"" + ":")
		e.Str(s.OriginalCommitID)
	}
	{
		if s.InReplyToID.Set {
			e.Comma()
		}
		if s.InReplyToID.Set {
			e.RawStr("\"in_reply_to_id\"" + ":")
			s.InReplyToID.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"user\"" + ":")
		s.User.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request_url\"" + ":")
		json.EncodeURI(e, s.PullRequestURL)
	}
	{
		e.Comma()

		e.RawStr("\"author_association\"" + ":")
		s.AuthorAssociation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"_links\"" + ":")
		s.Links.Encode(e)
	}
	{
		if s.BodyText.Set {
			e.Comma()
		}
		if s.BodyText.Set {
			e.RawStr("\"body_text\"" + ":")
			s.BodyText.Encode(e)
		}
	}
	{
		if s.BodyHTML.Set {
			e.Comma()
		}
		if s.BodyHTML.Set {
			e.RawStr("\"body_html\"" + ":")
			s.BodyHTML.Encode(e)
		}
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	{
		if s.Side.Set {
			e.Comma()
		}
		if s.Side.Set {
			e.RawStr("\"side\"" + ":")
			s.Side.Encode(e)
		}
	}
	{
		if s.StartSide.Set {
			e.Comma()
		}
		if s.StartSide.Set {
			e.RawStr("\"start_side\"" + ":")
			s.StartSide.Encode(e)
		}
	}
	{
		if s.Line.Set {
			e.Comma()
		}
		if s.Line.Set {
			e.RawStr("\"line\"" + ":")
			s.Line.Encode(e)
		}
	}
	{
		if s.OriginalLine.Set {
			e.Comma()
		}
		if s.OriginalLine.Set {
			e.RawStr("\"original_line\"" + ":")
			s.OriginalLine.Encode(e)
		}
	}
	{
		if s.StartLine.Set {
			e.Comma()
		}
		if s.StartLine.Set {
			e.RawStr("\"start_line\"" + ":")
			s.StartLine.Encode(e)
		}
	}
	{
		if s.OriginalStartLine.Set {
			e.Comma()
		}
		if s.OriginalStartLine.Set {
			e.RawStr("\"original_start_line\"" + ":")
			s.OriginalStartLine.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReviewComment = [28]string{
	0:  "url",
	1:  "pull_request_review_id",
	2:  "id",
	3:  "node_id",
	4:  "diff_hunk",
	5:  "path",
	6:  "position",
	7:  "original_position",
	8:  "commit_id",
	9:  "original_commit_id",
	10: "in_reply_to_id",
	11: "user",
	12: "body",
	13: "created_at",
	14: "updated_at",
	15: "html_url",
	16: "pull_request_url",
	17: "author_association",
	18: "_links",
	19: "body_text",
	20: "body_html",
	21: "reactions",
	22: "side",
	23: "start_side",
	24: "line",
	25: "original_line",
	26: "start_line",
	27: "original_start_line",
}

// Decode decodes ReviewComment from json.
func (s *ReviewComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReviewComment to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "pull_request_review_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PullRequestReviewID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request_review_id\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "diff_hunk":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.DiffHunk = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diff_hunk\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "position":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "original_position":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.OriginalPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_position\"")
			}
		case "commit_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CommitID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit_id\"")
			}
		case "original_commit_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.OriginalCommitID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_commit_id\"")
			}
		case "in_reply_to_id":
			if err := func() error {
				s.InReplyToID.Reset()
				if err := s.InReplyToID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"in_reply_to_id\"")
			}
		case "user":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "body":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "pull_request_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.PullRequestURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request_url\"")
			}
		case "author_association":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.AuthorAssociation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_association\"")
			}
		case "_links":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_links\"")
			}
		case "body_text":
			if err := func() error {
				s.BodyText.Reset()
				if err := s.BodyText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_text\"")
			}
		case "body_html":
			if err := func() error {
				s.BodyHTML.Reset()
				if err := s.BodyHTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		case "side":
			if err := func() error {
				s.Side.Reset()
				if err := s.Side.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"side\"")
			}
		case "start_side":
			if err := func() error {
				s.StartSide.Reset()
				if err := s.StartSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_side\"")
			}
		case "line":
			if err := func() error {
				s.Line.Reset()
				if err := s.Line.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"line\"")
			}
		case "original_line":
			if err := func() error {
				s.OriginalLine.Reset()
				if err := s.OriginalLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_line\"")
			}
		case "start_line":
			if err := func() error {
				s.StartLine.Reset()
				if err := s.StartLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_line\"")
			}
		case "original_start_line":
			if err := func() error {
				s.OriginalStartLine.Reset()
				if err := s.OriginalStartLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_start_line\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReviewComment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111011,
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReviewComment) {
					name = jsonFieldsNameOfReviewComment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ReviewCommentLinks) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"self\"" + ":")
		s.Self.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"html\"" + ":")
		s.HTML.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"pull_request\"" + ":")
		s.PullRequest.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfReviewCommentLinks = [3]string{
	0: "self",
	1: "html",
	2: "pull_request",
}

// Decode decodes ReviewCommentLinks from json.
func (s *ReviewCommentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReviewCommentLinks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		case "html":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.HTML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html\"")
			}
		case "pull_request":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.PullRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_request\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReviewCommentLinks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReviewCommentLinks) {
					name = jsonFieldsNameOfReviewCommentLinks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ReviewCommentSide as json.
func (s ReviewCommentSide) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReviewCommentSide from json.
func (s *ReviewCommentSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReviewCommentSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReviewCommentSide(v) {
	case ReviewCommentSideLEFT:
		*s = ReviewCommentSideLEFT
	case ReviewCommentSideRIGHT:
		*s = ReviewCommentSideRIGHT
	default:
		*s = ReviewCommentSide(v)
	}

	return nil
}

// Encode encodes ReviewCommentStartSide as json.
func (s ReviewCommentStartSide) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ReviewCommentStartSide from json.
func (s *ReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReviewCommentStartSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReviewCommentStartSide(v) {
	case ReviewCommentStartSideLEFT:
		*s = ReviewCommentStartSideLEFT
	case ReviewCommentStartSideRIGHT:
		*s = ReviewCommentStartSideRIGHT
	default:
		*s = ReviewCommentStartSide(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Runner) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"os\"" + ":")
		e.Str(s.Os)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"busy\"" + ":")
		e.Bool(s.Busy)
	}
	{
		e.Comma()

		e.RawStr("\"labels\"" + ":")
		e.ArrStart()
		if len(s.Labels) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Labels[0]
				elem.Encode(e)
			}
			for _, elem := range s.Labels[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRunner = [6]string{
	0: "id",
	1: "name",
	2: "os",
	3: "status",
	4: "busy",
	5: "labels",
}

// Decode decodes Runner from json.
func (s *Runner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Runner to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "os":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Os = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"os\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "busy":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Busy = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"busy\"")
			}
		case "labels":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Labels = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RunnerLabelsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Labels = append(s.Labels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Runner")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunner) {
					name = jsonFieldsNameOfRunner[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RunnerApplication) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"os\"" + ":")
		e.Str(s.Os)
	}
	{
		e.Comma()

		e.RawStr("\"architecture\"" + ":")
		e.Str(s.Architecture)
	}
	{
		e.Comma()

		e.RawStr("\"download_url\"" + ":")
		e.Str(s.DownloadURL)
	}
	{
		e.Comma()

		e.RawStr("\"filename\"" + ":")
		e.Str(s.Filename)
	}
	{
		if s.TempDownloadToken.Set {
			e.Comma()
		}
		if s.TempDownloadToken.Set {
			e.RawStr("\"temp_download_token\"" + ":")
			s.TempDownloadToken.Encode(e)
		}
	}
	{
		if s.SHA256Checksum.Set {
			e.Comma()
		}
		if s.SHA256Checksum.Set {
			e.RawStr("\"sha256_checksum\"" + ":")
			s.SHA256Checksum.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRunnerApplication = [6]string{
	0: "os",
	1: "architecture",
	2: "download_url",
	3: "filename",
	4: "temp_download_token",
	5: "sha256_checksum",
}

// Decode decodes RunnerApplication from json.
func (s *RunnerApplication) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunnerApplication to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "os":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Os = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"os\"")
			}
		case "architecture":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Architecture = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"architecture\"")
			}
		case "download_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DownloadURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download_url\"")
			}
		case "filename":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Filename = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "temp_download_token":
			if err := func() error {
				s.TempDownloadToken.Reset()
				if err := s.TempDownloadToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_download_token\"")
			}
		case "sha256_checksum":
			if err := func() error {
				s.SHA256Checksum.Reset()
				if err := s.SHA256Checksum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha256_checksum\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunnerApplication")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunnerApplication) {
					name = jsonFieldsNameOfRunnerApplication[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RunnerGroupsEnterprise) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Float64(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"visibility\"" + ":")
		e.Str(s.Visibility)
	}
	{
		e.Comma()

		e.RawStr("\"default\"" + ":")
		e.Bool(s.Default)
	}
	{
		if s.SelectedOrganizationsURL.Set {
			e.Comma()
		}
		if s.SelectedOrganizationsURL.Set {
			e.RawStr("\"selected_organizations_url\"" + ":")
			s.SelectedOrganizationsURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"runners_url\"" + ":")
		e.Str(s.RunnersURL)
	}
	{
		e.Comma()

		e.RawStr("\"allows_public_repositories\"" + ":")
		e.Bool(s.AllowsPublicRepositories)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRunnerGroupsEnterprise = [7]string{
	0: "id",
	1: "name",
	2: "visibility",
	3: "default",
	4: "selected_organizations_url",
	5: "runners_url",
	6: "allows_public_repositories",
}

// Decode decodes RunnerGroupsEnterprise from json.
func (s *RunnerGroupsEnterprise) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunnerGroupsEnterprise to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.ID = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Visibility = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "default":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Default = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "selected_organizations_url":
			if err := func() error {
				s.SelectedOrganizationsURL.Reset()
				if err := s.SelectedOrganizationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_organizations_url\"")
			}
		case "runners_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.RunnersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners_url\"")
			}
		case "allows_public_repositories":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.AllowsPublicRepositories = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allows_public_repositories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunnerGroupsEnterprise")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunnerGroupsEnterprise) {
					name = jsonFieldsNameOfRunnerGroupsEnterprise[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RunnerGroupsOrg) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Float64(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"visibility\"" + ":")
		e.Str(s.Visibility)
	}
	{
		e.Comma()

		e.RawStr("\"default\"" + ":")
		e.Bool(s.Default)
	}
	{
		if s.SelectedRepositoriesURL.Set {
			e.Comma()
		}
		if s.SelectedRepositoriesURL.Set {
			e.RawStr("\"selected_repositories_url\"" + ":")
			s.SelectedRepositoriesURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"runners_url\"" + ":")
		e.Str(s.RunnersURL)
	}
	{
		e.Comma()

		e.RawStr("\"inherited\"" + ":")
		e.Bool(s.Inherited)
	}
	{
		if s.InheritedAllowsPublicRepositories.Set {
			e.Comma()
		}
		if s.InheritedAllowsPublicRepositories.Set {
			e.RawStr("\"inherited_allows_public_repositories\"" + ":")
			s.InheritedAllowsPublicRepositories.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"allows_public_repositories\"" + ":")
		e.Bool(s.AllowsPublicRepositories)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRunnerGroupsOrg = [9]string{
	0: "id",
	1: "name",
	2: "visibility",
	3: "default",
	4: "selected_repositories_url",
	5: "runners_url",
	6: "inherited",
	7: "inherited_allows_public_repositories",
	8: "allows_public_repositories",
}

// Decode decodes RunnerGroupsOrg from json.
func (s *RunnerGroupsOrg) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunnerGroupsOrg to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.ID = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Visibility = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "default":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Default = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "selected_repositories_url":
			if err := func() error {
				s.SelectedRepositoriesURL.Reset()
				if err := s.SelectedRepositoriesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_repositories_url\"")
			}
		case "runners_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.RunnersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runners_url\"")
			}
		case "inherited":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Inherited = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inherited\"")
			}
		case "inherited_allows_public_repositories":
			if err := func() error {
				s.InheritedAllowsPublicRepositories.Reset()
				if err := s.InheritedAllowsPublicRepositories.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inherited_allows_public_repositories\"")
			}
		case "allows_public_repositories":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.AllowsPublicRepositories = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allows_public_repositories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunnerGroupsOrg")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01101111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRunnerGroupsOrg) {
					name = jsonFieldsNameOfRunnerGroupsOrg[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RunnerLabelsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRunnerLabelsItem = [3]string{
	0: "id",
	1: "name",
	2: "type",
}

// Decode decodes RunnerLabelsItem from json.
func (s *RunnerLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunnerLabelsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RunnerLabelsItem")
	}

	return nil
}

// Encode encodes RunnerLabelsItemType as json.
func (s RunnerLabelsItemType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes RunnerLabelsItemType from json.
func (s *RunnerLabelsItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RunnerLabelsItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RunnerLabelsItemType(v) {
	case RunnerLabelsItemTypeReadMinusOnly:
		*s = RunnerLabelsItemTypeReadMinusOnly
	case RunnerLabelsItemTypeCustom:
		*s = RunnerLabelsItemTypeCustom
	default:
		*s = RunnerLabelsItemType(v)
	}

	return nil
}

// Encode encodes ScimDeleteUserFromOrgApplicationJSONForbidden as json.
func (s ScimDeleteUserFromOrgApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := ScimError(s)
	unwrapped.Encode(e)
}

// Decode decodes ScimDeleteUserFromOrgApplicationJSONForbidden from json.
func (s *ScimDeleteUserFromOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimDeleteUserFromOrgApplicationJSONForbidden to nil")
	}
	var unwrapped ScimError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ScimDeleteUserFromOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ScimDeleteUserFromOrgApplicationJSONNotFound as json.
func (s ScimDeleteUserFromOrgApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := ScimError(s)
	unwrapped.Encode(e)
}

// Decode decodes ScimDeleteUserFromOrgApplicationJSONNotFound from json.
func (s *ScimDeleteUserFromOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimDeleteUserFromOrgApplicationJSONNotFound to nil")
	}
	var unwrapped ScimError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ScimDeleteUserFromOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseGroup) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		if s.ExternalId.Set {
			e.Comma()
		}
		if s.ExternalId.Set {
			e.RawStr("\"externalId\"" + ":")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.DisplayName.Set {
			e.Comma()
		}
		if s.DisplayName.Set {
			e.RawStr("\"displayName\"" + ":")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.Members != nil {
			e.Comma()
		}
		if s.Members != nil {
			e.RawStr("\"members\"" + ":")
			e.ArrStart()
			if len(s.Members) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Members[0]
					elem.Encode(e)
				}
				for _, elem := range s.Members[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.Comma()
		}
		if s.Meta.Set {
			e.RawStr("\"meta\"" + ":")
			s.Meta.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimEnterpriseGroup = [6]string{
	0: "schemas",
	1: "id",
	2: "externalId",
	3: "displayName",
	4: "members",
	5: "meta",
}

// Decode decodes ScimEnterpriseGroup from json.
func (s *ScimEnterpriseGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseGroup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "externalId":
			if err := func() error {
				s.ExternalId.Reset()
				if err := s.ExternalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalId\"")
			}
		case "displayName":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "members":
			if err := func() error {
				s.Members = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimEnterpriseGroupMembersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Members = append(s.Members, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseGroup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimEnterpriseGroup) {
					name = jsonFieldsNameOfScimEnterpriseGroup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseGroupMembersItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	{
		if s.Ref.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ref.Set {
			e.RawStr("\"$ref\"" + ":")
			s.Ref.Encode(e)
		}
	}
	{
		if s.Display.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Display.Set {
			e.RawStr("\"display\"" + ":")
			s.Display.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimEnterpriseGroupMembersItem = [3]string{
	0: "value",
	1: "$ref",
	2: "display",
}

// Decode decodes ScimEnterpriseGroupMembersItem from json.
func (s *ScimEnterpriseGroupMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseGroupMembersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "$ref":
			if err := func() error {
				s.Ref.Reset()
				if err := s.Ref.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"$ref\"")
			}
		case "display":
			if err := func() error {
				s.Display.Reset()
				if err := s.Display.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseGroupMembersItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseGroupMeta) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ResourceType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceType.Set {
			e.RawStr("\"resourceType\"" + ":")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.Created.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Created.Set {
			e.RawStr("\"created\"" + ":")
			s.Created.Encode(e)
		}
	}
	{
		if s.LastModified.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastModified.Set {
			e.RawStr("\"lastModified\"" + ":")
			s.LastModified.Encode(e)
		}
	}
	{
		if s.Location.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimEnterpriseGroupMeta = [4]string{
	0: "resourceType",
	1: "created",
	2: "lastModified",
	3: "location",
}

// Decode decodes ScimEnterpriseGroupMeta from json.
func (s *ScimEnterpriseGroupMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseGroupMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "created":
			if err := func() error {
				s.Created.Reset()
				if err := s.Created.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "lastModified":
			if err := func() error {
				s.LastModified.Reset()
				if err := s.LastModified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastModified\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseGroupMeta")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		if s.ExternalId.Set {
			e.Comma()
		}
		if s.ExternalId.Set {
			e.RawStr("\"externalId\"" + ":")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.UserName.Set {
			e.Comma()
		}
		if s.UserName.Set {
			e.RawStr("\"userName\"" + ":")
			s.UserName.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Emails != nil {
			e.Comma()
		}
		if s.Emails != nil {
			e.RawStr("\"emails\"" + ":")
			e.ArrStart()
			if len(s.Emails) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Emails[0]
					elem.Encode(e)
				}
				for _, elem := range s.Emails[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Groups != nil {
			e.Comma()
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					elem.Encode(e)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.Comma()
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if s.Meta.Set {
			e.Comma()
		}
		if s.Meta.Set {
			e.RawStr("\"meta\"" + ":")
			s.Meta.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimEnterpriseUser = [9]string{
	0: "schemas",
	1: "id",
	2: "externalId",
	3: "userName",
	4: "name",
	5: "emails",
	6: "groups",
	7: "active",
	8: "meta",
}

// Decode decodes ScimEnterpriseUser from json.
func (s *ScimEnterpriseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "externalId":
			if err := func() error {
				s.ExternalId.Reset()
				if err := s.ExternalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalId\"")
			}
		case "userName":
			if err := func() error {
				s.UserName.Reset()
				if err := s.UserName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userName\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "emails":
			if err := func() error {
				s.Emails = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimEnterpriseUserEmailsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		case "groups":
			if err := func() error {
				s.Groups = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimEnterpriseUserGroupsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimEnterpriseUser) {
					name = jsonFieldsNameOfScimEnterpriseUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseUserEmailsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if s.Primary.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Primary.Set {
			e.RawStr("\"primary\"" + ":")
			s.Primary.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimEnterpriseUserEmailsItem = [3]string{
	0: "value",
	1: "type",
	2: "primary",
}

// Decode decodes ScimEnterpriseUserEmailsItem from json.
func (s *ScimEnterpriseUserEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseUserEmailsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "primary":
			if err := func() error {
				s.Primary.Reset()
				if err := s.Primary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseUserEmailsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseUserGroupsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimEnterpriseUserGroupsItem = [1]string{
	0: "value",
}

// Decode decodes ScimEnterpriseUserGroupsItem from json.
func (s *ScimEnterpriseUserGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseUserGroupsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseUserGroupsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseUserMeta) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ResourceType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceType.Set {
			e.RawStr("\"resourceType\"" + ":")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.Created.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Created.Set {
			e.RawStr("\"created\"" + ":")
			s.Created.Encode(e)
		}
	}
	{
		if s.LastModified.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastModified.Set {
			e.RawStr("\"lastModified\"" + ":")
			s.LastModified.Encode(e)
		}
	}
	{
		if s.Location.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimEnterpriseUserMeta = [4]string{
	0: "resourceType",
	1: "created",
	2: "lastModified",
	3: "location",
}

// Decode decodes ScimEnterpriseUserMeta from json.
func (s *ScimEnterpriseUserMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseUserMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "created":
			if err := func() error {
				s.Created.Reset()
				if err := s.Created.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "lastModified":
			if err := func() error {
				s.LastModified.Reset()
				if err := s.LastModified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastModified\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseUserMeta")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseUserName) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.GivenName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GivenName.Set {
			e.RawStr("\"givenName\"" + ":")
			s.GivenName.Encode(e)
		}
	}
	{
		if s.FamilyName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FamilyName.Set {
			e.RawStr("\"familyName\"" + ":")
			s.FamilyName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimEnterpriseUserName = [2]string{
	0: "givenName",
	1: "familyName",
}

// Decode decodes ScimEnterpriseUserName from json.
func (s *ScimEnterpriseUserName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimEnterpriseUserName to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			if err := func() error {
				s.GivenName.Reset()
				if err := s.GivenName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"givenName\"")
			}
		case "familyName":
			if err := func() error {
				s.FamilyName.Reset()
				if err := s.FamilyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"familyName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimEnterpriseUserName")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimError) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	{
		if s.Detail.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Detail.Set {
			e.RawStr("\"detail\"" + ":")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Status.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Status.Set {
			e.RawStr("\"status\"" + ":")
			s.Status.Encode(e)
		}
	}
	{
		if s.ScimType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ScimType.Set {
			e.RawStr("\"scimType\"" + ":")
			s.ScimType.Encode(e)
		}
	}
	{
		if s.Schemas != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Schemas != nil {
			e.RawStr("\"schemas\"" + ":")
			e.ArrStart()
			if len(s.Schemas) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Schemas[0]
					e.Str(elem)
				}
				for _, elem := range s.Schemas[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimError = [6]string{
	0: "message",
	1: "documentation_url",
	2: "detail",
	3: "status",
	4: "scimType",
	5: "schemas",
}

// Decode decodes ScimError from json.
func (s *ScimError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "scimType":
			if err := func() error {
				s.ScimType.Reset()
				if err := s.ScimType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scimType\"")
			}
		case "schemas":
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimError")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimGroupListEnterprise) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"totalResults\"" + ":")
		e.Float64(s.TotalResults)
	}
	{
		e.Comma()

		e.RawStr("\"itemsPerPage\"" + ":")
		e.Float64(s.ItemsPerPage)
	}
	{
		e.Comma()

		e.RawStr("\"startIndex\"" + ":")
		e.Float64(s.StartIndex)
	}
	{
		e.Comma()

		e.RawStr("\"Resources\"" + ":")
		e.ArrStart()
		if len(s.Resources) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Resources[0]
				elem.Encode(e)
			}
			for _, elem := range s.Resources[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimGroupListEnterprise = [5]string{
	0: "schemas",
	1: "totalResults",
	2: "itemsPerPage",
	3: "startIndex",
	4: "Resources",
}

// Decode decodes ScimGroupListEnterprise from json.
func (s *ScimGroupListEnterprise) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimGroupListEnterprise to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "totalResults":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalResults = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalResults\"")
			}
		case "itemsPerPage":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.ItemsPerPage = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemsPerPage\"")
			}
		case "startIndex":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.StartIndex = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startIndex\"")
			}
		case "Resources":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Resources = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimGroupListEnterpriseResourcesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimGroupListEnterprise")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimGroupListEnterprise) {
					name = jsonFieldsNameOfScimGroupListEnterprise[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimGroupListEnterpriseResourcesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		if s.ExternalId.Set {
			e.Comma()
		}
		if s.ExternalId.Set {
			e.RawStr("\"externalId\"" + ":")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.DisplayName.Set {
			e.Comma()
		}
		if s.DisplayName.Set {
			e.RawStr("\"displayName\"" + ":")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.Members != nil {
			e.Comma()
		}
		if s.Members != nil {
			e.RawStr("\"members\"" + ":")
			e.ArrStart()
			if len(s.Members) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Members[0]
					elem.Encode(e)
				}
				for _, elem := range s.Members[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.Comma()
		}
		if s.Meta.Set {
			e.RawStr("\"meta\"" + ":")
			s.Meta.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimGroupListEnterpriseResourcesItem = [6]string{
	0: "schemas",
	1: "id",
	2: "externalId",
	3: "displayName",
	4: "members",
	5: "meta",
}

// Decode decodes ScimGroupListEnterpriseResourcesItem from json.
func (s *ScimGroupListEnterpriseResourcesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimGroupListEnterpriseResourcesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "externalId":
			if err := func() error {
				s.ExternalId.Reset()
				if err := s.ExternalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalId\"")
			}
		case "displayName":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "members":
			if err := func() error {
				s.Members = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimGroupListEnterpriseResourcesItemMembersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Members = append(s.Members, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimGroupListEnterpriseResourcesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimGroupListEnterpriseResourcesItem) {
					name = jsonFieldsNameOfScimGroupListEnterpriseResourcesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimGroupListEnterpriseResourcesItemMembersItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	{
		if s.Ref.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ref.Set {
			e.RawStr("\"$ref\"" + ":")
			s.Ref.Encode(e)
		}
	}
	{
		if s.Display.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Display.Set {
			e.RawStr("\"display\"" + ":")
			s.Display.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimGroupListEnterpriseResourcesItemMembersItem = [3]string{
	0: "value",
	1: "$ref",
	2: "display",
}

// Decode decodes ScimGroupListEnterpriseResourcesItemMembersItem from json.
func (s *ScimGroupListEnterpriseResourcesItemMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimGroupListEnterpriseResourcesItemMembersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "$ref":
			if err := func() error {
				s.Ref.Reset()
				if err := s.Ref.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"$ref\"")
			}
		case "display":
			if err := func() error {
				s.Display.Reset()
				if err := s.Display.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimGroupListEnterpriseResourcesItemMembersItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimGroupListEnterpriseResourcesItemMeta) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ResourceType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceType.Set {
			e.RawStr("\"resourceType\"" + ":")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.Created.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Created.Set {
			e.RawStr("\"created\"" + ":")
			s.Created.Encode(e)
		}
	}
	{
		if s.LastModified.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastModified.Set {
			e.RawStr("\"lastModified\"" + ":")
			s.LastModified.Encode(e)
		}
	}
	{
		if s.Location.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimGroupListEnterpriseResourcesItemMeta = [4]string{
	0: "resourceType",
	1: "created",
	2: "lastModified",
	3: "location",
}

// Decode decodes ScimGroupListEnterpriseResourcesItemMeta from json.
func (s *ScimGroupListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimGroupListEnterpriseResourcesItemMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "created":
			if err := func() error {
				s.Created.Reset()
				if err := s.Created.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "lastModified":
			if err := func() error {
				s.LastModified.Reset()
				if err := s.LastModified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastModified\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimGroupListEnterpriseResourcesItemMeta")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimProvisionAndInviteUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"userName\"" + ":")
		e.Str(s.UserName)
	}
	{
		if s.DisplayName.Set {
			e.Comma()
		}
		if s.DisplayName.Set {
			e.RawStr("\"displayName\"" + ":")
			s.DisplayName.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		s.Name.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"emails\"" + ":")
		e.ArrStart()
		if len(s.Emails) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Emails[0]
				elem.Encode(e)
			}
			for _, elem := range s.Emails[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.Schemas != nil {
			e.Comma()
		}
		if s.Schemas != nil {
			e.RawStr("\"schemas\"" + ":")
			e.ArrStart()
			if len(s.Schemas) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Schemas[0]
					e.Str(elem)
				}
				for _, elem := range s.Schemas[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExternalId.Set {
			e.Comma()
		}
		if s.ExternalId.Set {
			e.RawStr("\"externalId\"" + ":")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.Groups != nil {
			e.Comma()
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					e.Str(elem)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.Comma()
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimProvisionAndInviteUserReq = [8]string{
	0: "userName",
	1: "displayName",
	2: "name",
	3: "emails",
	4: "schemas",
	5: "externalId",
	6: "groups",
	7: "active",
}

// Decode decodes ScimProvisionAndInviteUserReq from json.
func (s *ScimProvisionAndInviteUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimProvisionAndInviteUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UserName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userName\"")
			}
		case "displayName":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "emails":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Emails = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimProvisionAndInviteUserReqEmailsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		case "schemas":
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "externalId":
			if err := func() error {
				s.ExternalId.Reset()
				if err := s.ExternalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalId\"")
			}
		case "groups":
			if err := func() error {
				s.Groups = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimProvisionAndInviteUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimProvisionAndInviteUserReq) {
					name = jsonFieldsNameOfScimProvisionAndInviteUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimProvisionAndInviteUserReqEmailsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	{
		if s.Primary.Set {
			e.Comma()
		}
		if s.Primary.Set {
			e.RawStr("\"primary\"" + ":")
			s.Primary.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.Comma()
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimProvisionAndInviteUserReqEmailsItem = [3]string{
	0: "value",
	1: "primary",
	2: "type",
}

// Decode decodes ScimProvisionAndInviteUserReqEmailsItem from json.
func (s *ScimProvisionAndInviteUserReqEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimProvisionAndInviteUserReqEmailsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "primary":
			if err := func() error {
				s.Primary.Reset()
				if err := s.Primary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimProvisionAndInviteUserReqEmailsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimProvisionAndInviteUserReqEmailsItem) {
					name = jsonFieldsNameOfScimProvisionAndInviteUserReqEmailsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimProvisionAndInviteUserReqName) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"givenName\"" + ":")
		e.Str(s.GivenName)
	}
	{
		e.Comma()

		e.RawStr("\"familyName\"" + ":")
		e.Str(s.FamilyName)
	}
	{
		if s.Formatted.Set {
			e.Comma()
		}
		if s.Formatted.Set {
			e.RawStr("\"formatted\"" + ":")
			s.Formatted.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimProvisionAndInviteUserReqName = [3]string{
	0: "givenName",
	1: "familyName",
	2: "formatted",
}

// Decode decodes ScimProvisionAndInviteUserReqName from json.
func (s *ScimProvisionAndInviteUserReqName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimProvisionAndInviteUserReqName to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GivenName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"givenName\"")
			}
		case "familyName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FamilyName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"familyName\"")
			}
		case "formatted":
			if err := func() error {
				s.Formatted.Reset()
				if err := s.Formatted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"formatted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimProvisionAndInviteUserReqName")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimProvisionAndInviteUserReqName) {
					name = jsonFieldsNameOfScimProvisionAndInviteUserReqName[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimSetInformationForProvisionedUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Schemas != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Schemas != nil {
			e.RawStr("\"schemas\"" + ":")
			e.ArrStart()
			if len(s.Schemas) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Schemas[0]
					e.Str(elem)
				}
				for _, elem := range s.Schemas[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisplayName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DisplayName.Set {
			e.RawStr("\"displayName\"" + ":")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.ExternalId.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalId.Set {
			e.RawStr("\"externalId\"" + ":")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.Groups != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					e.Str(elem)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"userName\"" + ":")
		e.Str(s.UserName)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		s.Name.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"emails\"" + ":")
		e.ArrStart()
		if len(s.Emails) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Emails[0]
				elem.Encode(e)
			}
			for _, elem := range s.Emails[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimSetInformationForProvisionedUserReq = [8]string{
	0: "schemas",
	1: "displayName",
	2: "externalId",
	3: "groups",
	4: "active",
	5: "userName",
	6: "name",
	7: "emails",
}

// Decode decodes ScimSetInformationForProvisionedUserReq from json.
func (s *ScimSetInformationForProvisionedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimSetInformationForProvisionedUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "displayName":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "externalId":
			if err := func() error {
				s.ExternalId.Reset()
				if err := s.ExternalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalId\"")
			}
		case "groups":
			if err := func() error {
				s.Groups = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "userName":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.UserName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userName\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "emails":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.Emails = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimSetInformationForProvisionedUserReqEmailsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimSetInformationForProvisionedUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimSetInformationForProvisionedUserReq) {
					name = jsonFieldsNameOfScimSetInformationForProvisionedUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimSetInformationForProvisionedUserReqEmailsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"value\"" + ":")
		e.Str(s.Value)
	}
	{
		if s.Primary.Set {
			e.Comma()
		}
		if s.Primary.Set {
			e.RawStr("\"primary\"" + ":")
			s.Primary.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimSetInformationForProvisionedUserReqEmailsItem = [3]string{
	0: "type",
	1: "value",
	2: "primary",
}

// Decode decodes ScimSetInformationForProvisionedUserReqEmailsItem from json.
func (s *ScimSetInformationForProvisionedUserReqEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimSetInformationForProvisionedUserReqEmailsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "primary":
			if err := func() error {
				s.Primary.Reset()
				if err := s.Primary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimSetInformationForProvisionedUserReqEmailsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimSetInformationForProvisionedUserReqEmailsItem) {
					name = jsonFieldsNameOfScimSetInformationForProvisionedUserReqEmailsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimSetInformationForProvisionedUserReqName) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"givenName\"" + ":")
		e.Str(s.GivenName)
	}
	{
		e.Comma()

		e.RawStr("\"familyName\"" + ":")
		e.Str(s.FamilyName)
	}
	{
		if s.Formatted.Set {
			e.Comma()
		}
		if s.Formatted.Set {
			e.RawStr("\"formatted\"" + ":")
			s.Formatted.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimSetInformationForProvisionedUserReqName = [3]string{
	0: "givenName",
	1: "familyName",
	2: "formatted",
}

// Decode decodes ScimSetInformationForProvisionedUserReqName from json.
func (s *ScimSetInformationForProvisionedUserReqName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimSetInformationForProvisionedUserReqName to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GivenName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"givenName\"")
			}
		case "familyName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FamilyName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"familyName\"")
			}
		case "formatted":
			if err := func() error {
				s.Formatted.Reset()
				if err := s.Formatted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"formatted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimSetInformationForProvisionedUserReqName")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimSetInformationForProvisionedUserReqName) {
					name = jsonFieldsNameOfScimSetInformationForProvisionedUserReqName[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimUpdateAttributeForUserReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Schemas != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Schemas != nil {
			e.RawStr("\"schemas\"" + ":")
			e.ArrStart()
			if len(s.Schemas) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Schemas[0]
					e.Str(elem)
				}
				for _, elem := range s.Schemas[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"Operations\"" + ":")
		e.ArrStart()
		if len(s.Operations) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Operations[0]
				elem.Encode(e)
			}
			for _, elem := range s.Operations[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimUpdateAttributeForUserReq = [2]string{
	0: "schemas",
	1: "Operations",
}

// Decode decodes ScimUpdateAttributeForUserReq from json.
func (s *ScimUpdateAttributeForUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUpdateAttributeForUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "Operations":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Operations = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimUpdateAttributeForUserReqOperationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Operations = append(s.Operations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Operations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUpdateAttributeForUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimUpdateAttributeForUserReq) {
					name = jsonFieldsNameOfScimUpdateAttributeForUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimUpdateAttributeForUserReqOperationsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"op\"" + ":")
		s.Op.Encode(e)
	}
	{
		if s.Path.Set {
			e.Comma()
		}
		if s.Path.Set {
			e.RawStr("\"path\"" + ":")
			s.Path.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.Comma()
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimUpdateAttributeForUserReqOperationsItem = [3]string{
	0: "op",
	1: "path",
	2: "value",
}

// Decode decodes ScimUpdateAttributeForUserReqOperationsItem from json.
func (s *ScimUpdateAttributeForUserReqOperationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUpdateAttributeForUserReqOperationsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "op":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Op.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"op\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUpdateAttributeForUserReqOperationsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimUpdateAttributeForUserReqOperationsItem) {
					name = jsonFieldsNameOfScimUpdateAttributeForUserReqOperationsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ScimUpdateAttributeForUserReqOperationsItemOp as json.
func (s ScimUpdateAttributeForUserReqOperationsItemOp) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes ScimUpdateAttributeForUserReqOperationsItemOp from json.
func (s *ScimUpdateAttributeForUserReqOperationsItemOp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUpdateAttributeForUserReqOperationsItemOp to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ScimUpdateAttributeForUserReqOperationsItemOp(v) {
	case ScimUpdateAttributeForUserReqOperationsItemOpAdd:
		*s = ScimUpdateAttributeForUserReqOperationsItemOpAdd
	case ScimUpdateAttributeForUserReqOperationsItemOpRemove:
		*s = ScimUpdateAttributeForUserReqOperationsItemOpRemove
	case ScimUpdateAttributeForUserReqOperationsItemOpReplace:
		*s = ScimUpdateAttributeForUserReqOperationsItemOpReplace
	default:
		*s = ScimUpdateAttributeForUserReqOperationsItemOp(v)
	}

	return nil
}

// Encode encodes ScimUpdateAttributeForUserReqOperationsItemValue as json.
func (s ScimUpdateAttributeForUserReqOperationsItemValue) Encode(e *jx.Writer) {
	switch s.Type {
	case ScimUpdateAttributeForUserReqOperationsItemValue0ScimUpdateAttributeForUserReqOperationsItemValue:
		s.ScimUpdateAttributeForUserReqOperationsItemValue0.Encode(e)
	case ArrayScimUpdateAttributeForUserReqOperationsItemValue1ItemScimUpdateAttributeForUserReqOperationsItemValue:
		e.ArrStart()
		if len(s.ArrayScimUpdateAttributeForUserReqOperationsItemValue1Item) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayScimUpdateAttributeForUserReqOperationsItemValue1Item[0]
				elem.Encode(e)
			}
			for _, elem := range s.ArrayScimUpdateAttributeForUserReqOperationsItemValue1Item[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	case StringScimUpdateAttributeForUserReqOperationsItemValue:
		e.Str(s.String)
	}
}

// Decode decodes ScimUpdateAttributeForUserReqOperationsItemValue from json.
func (s *ScimUpdateAttributeForUserReqOperationsItemValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUpdateAttributeForUserReqOperationsItemValue to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ScimUpdateAttributeForUserReqOperationsItemValue0.Decode(d); err != nil {
			return err
		}
		s.Type = ScimUpdateAttributeForUserReqOperationsItemValue0ScimUpdateAttributeForUserReqOperationsItemValue
	case jx.Array:
		s.ArrayScimUpdateAttributeForUserReqOperationsItemValue1Item = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ScimUpdateAttributeForUserReqOperationsItemValue1Item
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ArrayScimUpdateAttributeForUserReqOperationsItemValue1Item = append(s.ArrayScimUpdateAttributeForUserReqOperationsItemValue1Item, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayScimUpdateAttributeForUserReqOperationsItemValue1ItemScimUpdateAttributeForUserReqOperationsItemValue
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringScimUpdateAttributeForUserReqOperationsItemValue
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ScimUpdateAttributeForUserReqOperationsItemValue0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Active.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if s.UserName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UserName.Set {
			e.RawStr("\"userName\"" + ":")
			s.UserName.Encode(e)
		}
	}
	{
		if s.ExternalId.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ExternalId.Set {
			e.RawStr("\"externalId\"" + ":")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.GivenName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GivenName.Set {
			e.RawStr("\"givenName\"" + ":")
			s.GivenName.Encode(e)
		}
	}
	{
		if s.FamilyName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FamilyName.Set {
			e.RawStr("\"familyName\"" + ":")
			s.FamilyName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimUpdateAttributeForUserReqOperationsItemValue0 = [5]string{
	0: "active",
	1: "userName",
	2: "externalId",
	3: "givenName",
	4: "familyName",
}

// Decode decodes ScimUpdateAttributeForUserReqOperationsItemValue0 from json.
func (s *ScimUpdateAttributeForUserReqOperationsItemValue0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUpdateAttributeForUserReqOperationsItemValue0 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "userName":
			if err := func() error {
				s.UserName.Reset()
				if err := s.UserName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userName\"")
			}
		case "externalId":
			if err := func() error {
				s.ExternalId.Reset()
				if err := s.ExternalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalId\"")
			}
		case "givenName":
			if err := func() error {
				s.GivenName.Reset()
				if err := s.GivenName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"givenName\"")
			}
		case "familyName":
			if err := func() error {
				s.FamilyName.Reset()
				if err := s.FamilyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"familyName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUpdateAttributeForUserReqOperationsItemValue0")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimUpdateAttributeForUserReqOperationsItemValue1Item) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	{
		if s.Primary.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Primary.Set {
			e.RawStr("\"primary\"" + ":")
			s.Primary.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimUpdateAttributeForUserReqOperationsItemValue1Item = [2]string{
	0: "value",
	1: "primary",
}

// Decode decodes ScimUpdateAttributeForUserReqOperationsItemValue1Item from json.
func (s *ScimUpdateAttributeForUserReqOperationsItemValue1Item) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUpdateAttributeForUserReqOperationsItemValue1Item to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "primary":
			if err := func() error {
				s.Primary.Reset()
				if err := s.Primary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUpdateAttributeForUserReqOperationsItemValue1Item")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterprise) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"totalResults\"" + ":")
		e.Float64(s.TotalResults)
	}
	{
		e.Comma()

		e.RawStr("\"itemsPerPage\"" + ":")
		e.Float64(s.ItemsPerPage)
	}
	{
		e.Comma()

		e.RawStr("\"startIndex\"" + ":")
		e.Float64(s.StartIndex)
	}
	{
		e.Comma()

		e.RawStr("\"Resources\"" + ":")
		e.ArrStart()
		if len(s.Resources) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Resources[0]
				elem.Encode(e)
			}
			for _, elem := range s.Resources[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimUserListEnterprise = [5]string{
	0: "schemas",
	1: "totalResults",
	2: "itemsPerPage",
	3: "startIndex",
	4: "Resources",
}

// Decode decodes ScimUserListEnterprise from json.
func (s *ScimUserListEnterprise) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUserListEnterprise to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "totalResults":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalResults = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalResults\"")
			}
		case "itemsPerPage":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.ItemsPerPage = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemsPerPage\"")
			}
		case "startIndex":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.StartIndex = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startIndex\"")
			}
		case "Resources":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Resources = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimUserListEnterpriseResourcesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUserListEnterprise")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimUserListEnterprise) {
					name = jsonFieldsNameOfScimUserListEnterprise[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterpriseResourcesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"schemas\"" + ":")
		e.ArrStart()
		if len(s.Schemas) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Schemas[0]
				e.Str(elem)
			}
			for _, elem := range s.Schemas[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		if s.ExternalId.Set {
			e.Comma()
		}
		if s.ExternalId.Set {
			e.RawStr("\"externalId\"" + ":")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.UserName.Set {
			e.Comma()
		}
		if s.UserName.Set {
			e.RawStr("\"userName\"" + ":")
			s.UserName.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Emails != nil {
			e.Comma()
		}
		if s.Emails != nil {
			e.RawStr("\"emails\"" + ":")
			e.ArrStart()
			if len(s.Emails) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Emails[0]
					elem.Encode(e)
				}
				for _, elem := range s.Emails[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Groups != nil {
			e.Comma()
		}
		if s.Groups != nil {
			e.RawStr("\"groups\"" + ":")
			e.ArrStart()
			if len(s.Groups) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Groups[0]
					elem.Encode(e)
				}
				for _, elem := range s.Groups[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Active.Set {
			e.Comma()
		}
		if s.Active.Set {
			e.RawStr("\"active\"" + ":")
			s.Active.Encode(e)
		}
	}
	{
		if s.Meta.Set {
			e.Comma()
		}
		if s.Meta.Set {
			e.RawStr("\"meta\"" + ":")
			s.Meta.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimUserListEnterpriseResourcesItem = [9]string{
	0: "schemas",
	1: "id",
	2: "externalId",
	3: "userName",
	4: "name",
	5: "emails",
	6: "groups",
	7: "active",
	8: "meta",
}

// Decode decodes ScimUserListEnterpriseResourcesItem from json.
func (s *ScimUserListEnterpriseResourcesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUserListEnterpriseResourcesItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Schemas = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Schemas = append(s.Schemas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "externalId":
			if err := func() error {
				s.ExternalId.Reset()
				if err := s.ExternalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalId\"")
			}
		case "userName":
			if err := func() error {
				s.UserName.Reset()
				if err := s.UserName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userName\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "emails":
			if err := func() error {
				s.Emails = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimUserListEnterpriseResourcesItemEmailsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		case "groups":
			if err := func() error {
				s.Groups = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScimUserListEnterpriseResourcesItemGroupsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUserListEnterpriseResourcesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScimUserListEnterpriseResourcesItem) {
					name = jsonFieldsNameOfScimUserListEnterpriseResourcesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterpriseResourcesItemEmailsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	{
		if s.Primary.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Primary.Set {
			e.RawStr("\"primary\"" + ":")
			s.Primary.Encode(e)
		}
	}
	{
		if s.Type.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Type.Set {
			e.RawStr("\"type\"" + ":")
			s.Type.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimUserListEnterpriseResourcesItemEmailsItem = [3]string{
	0: "value",
	1: "primary",
	2: "type",
}

// Decode decodes ScimUserListEnterpriseResourcesItemEmailsItem from json.
func (s *ScimUserListEnterpriseResourcesItemEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUserListEnterpriseResourcesItemEmailsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "primary":
			if err := func() error {
				s.Primary.Reset()
				if err := s.Primary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUserListEnterpriseResourcesItemEmailsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterpriseResourcesItemGroupsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Value.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimUserListEnterpriseResourcesItemGroupsItem = [1]string{
	0: "value",
}

// Decode decodes ScimUserListEnterpriseResourcesItemGroupsItem from json.
func (s *ScimUserListEnterpriseResourcesItemGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUserListEnterpriseResourcesItemGroupsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUserListEnterpriseResourcesItemGroupsItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterpriseResourcesItemMeta) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ResourceType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResourceType.Set {
			e.RawStr("\"resourceType\"" + ":")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.Created.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Created.Set {
			e.RawStr("\"created\"" + ":")
			s.Created.Encode(e)
		}
	}
	{
		if s.LastModified.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LastModified.Set {
			e.RawStr("\"lastModified\"" + ":")
			s.LastModified.Encode(e)
		}
	}
	{
		if s.Location.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimUserListEnterpriseResourcesItemMeta = [4]string{
	0: "resourceType",
	1: "created",
	2: "lastModified",
	3: "location",
}

// Decode decodes ScimUserListEnterpriseResourcesItemMeta from json.
func (s *ScimUserListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUserListEnterpriseResourcesItemMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceType\"")
			}
		case "created":
			if err := func() error {
				s.Created.Reset()
				if err := s.Created.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "lastModified":
			if err := func() error {
				s.LastModified.Reset()
				if err := s.LastModified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastModified\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUserListEnterpriseResourcesItemMeta")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterpriseResourcesItemName) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.GivenName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GivenName.Set {
			e.RawStr("\"givenName\"" + ":")
			s.GivenName.Encode(e)
		}
	}
	{
		if s.FamilyName.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FamilyName.Set {
			e.RawStr("\"familyName\"" + ":")
			s.FamilyName.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfScimUserListEnterpriseResourcesItemName = [2]string{
	0: "givenName",
	1: "familyName",
}

// Decode decodes ScimUserListEnterpriseResourcesItemName from json.
func (s *ScimUserListEnterpriseResourcesItemName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScimUserListEnterpriseResourcesItemName to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			if err := func() error {
				s.GivenName.Reset()
				if err := s.GivenName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"givenName\"")
			}
		case "familyName":
			if err := func() error {
				s.FamilyName.Reset()
				if err := s.FamilyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"familyName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScimUserListEnterpriseResourcesItemName")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SearchCodeOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"incomplete_results\"" + ":")
		e.Bool(s.IncompleteResults)
	}
	{
		e.Comma()

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSearchCodeOK = [3]string{
	0: "total_count",
	1: "incomplete_results",
	2: "items",
}

// Decode decodes SearchCodeOK from json.
func (s *SearchCodeOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchCodeOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "incomplete_results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IncompleteResults = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incomplete_results\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CodeSearchResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchCodeOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchCodeOK) {
					name = jsonFieldsNameOfSearchCodeOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SearchCommitsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"incomplete_results\"" + ":")
		e.Bool(s.IncompleteResults)
	}
	{
		e.Comma()

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSearchCommitsOK = [3]string{
	0: "total_count",
	1: "incomplete_results",
	2: "items",
}

// Decode decodes SearchCommitsOK from json.
func (s *SearchCommitsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchCommitsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "incomplete_results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IncompleteResults = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incomplete_results\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CommitSearchResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchCommitsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchCommitsOK) {
					name = jsonFieldsNameOfSearchCommitsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SearchIssuesAndPullRequestsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"incomplete_results\"" + ":")
		e.Bool(s.IncompleteResults)
	}
	{
		e.Comma()

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSearchIssuesAndPullRequestsOK = [3]string{
	0: "total_count",
	1: "incomplete_results",
	2: "items",
}

// Decode decodes SearchIssuesAndPullRequestsOK from json.
func (s *SearchIssuesAndPullRequestsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchIssuesAndPullRequestsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "incomplete_results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IncompleteResults = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incomplete_results\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IssueSearchResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchIssuesAndPullRequestsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchIssuesAndPullRequestsOK) {
					name = jsonFieldsNameOfSearchIssuesAndPullRequestsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes SearchLabelsApplicationJSONForbidden as json.
func (s SearchLabelsApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes SearchLabelsApplicationJSONForbidden from json.
func (s *SearchLabelsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchLabelsApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchLabelsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes SearchLabelsApplicationJSONNotFound as json.
func (s SearchLabelsApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes SearchLabelsApplicationJSONNotFound from json.
func (s *SearchLabelsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchLabelsApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchLabelsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s SearchLabelsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"incomplete_results\"" + ":")
		e.Bool(s.IncompleteResults)
	}
	{
		e.Comma()

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSearchLabelsOK = [3]string{
	0: "total_count",
	1: "incomplete_results",
	2: "items",
}

// Decode decodes SearchLabelsOK from json.
func (s *SearchLabelsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchLabelsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "incomplete_results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IncompleteResults = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incomplete_results\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LabelSearchResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchLabelsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchLabelsOK) {
					name = jsonFieldsNameOfSearchLabelsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SearchReposOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"incomplete_results\"" + ":")
		e.Bool(s.IncompleteResults)
	}
	{
		e.Comma()

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSearchReposOK = [3]string{
	0: "total_count",
	1: "incomplete_results",
	2: "items",
}

// Decode decodes SearchReposOK from json.
func (s *SearchReposOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchReposOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "incomplete_results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IncompleteResults = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incomplete_results\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RepoSearchResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchReposOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchReposOK) {
					name = jsonFieldsNameOfSearchReposOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes SearchResultTextMatches as json.
func (s SearchResultTextMatches) Encode(e *jx.Writer) {
	unwrapped := []SearchResultTextMatchesItem(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes SearchResultTextMatches from json.
func (s *SearchResultTextMatches) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResultTextMatches to nil")
	}
	var unwrapped []SearchResultTextMatchesItem
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SearchResultTextMatchesItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchResultTextMatches(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s SearchResultTextMatchesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ObjectURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ObjectURL.Set {
			e.RawStr("\"object_url\"" + ":")
			s.ObjectURL.Encode(e)
		}
	}
	{
		if s.ObjectType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ObjectType.Set {
			e.RawStr("\"object_type\"" + ":")
			s.ObjectType.Encode(e)
		}
	}
	{
		if s.Property.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Property.Set {
			e.RawStr("\"property\"" + ":")
			s.Property.Encode(e)
		}
	}
	{
		if s.Fragment.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Fragment.Set {
			e.RawStr("\"fragment\"" + ":")
			s.Fragment.Encode(e)
		}
	}
	{
		if s.Matches != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Matches != nil {
			e.RawStr("\"matches\"" + ":")
			e.ArrStart()
			if len(s.Matches) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Matches[0]
					elem.Encode(e)
				}
				for _, elem := range s.Matches[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSearchResultTextMatchesItem = [5]string{
	0: "object_url",
	1: "object_type",
	2: "property",
	3: "fragment",
	4: "matches",
}

// Decode decodes SearchResultTextMatchesItem from json.
func (s *SearchResultTextMatchesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResultTextMatchesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_url":
			if err := func() error {
				s.ObjectURL.Reset()
				if err := s.ObjectURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_url\"")
			}
		case "object_type":
			if err := func() error {
				s.ObjectType.Reset()
				if err := s.ObjectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_type\"")
			}
		case "property":
			if err := func() error {
				s.Property.Reset()
				if err := s.Property.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"property\"")
			}
		case "fragment":
			if err := func() error {
				s.Fragment.Reset()
				if err := s.Fragment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fragment\"")
			}
		case "matches":
			if err := func() error {
				s.Matches = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItemMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Matches = append(s.Matches, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matches\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchResultTextMatchesItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SearchResultTextMatchesItemMatchesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Text.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Text.Set {
			e.RawStr("\"text\"" + ":")
			s.Text.Encode(e)
		}
	}
	{
		if s.Indices != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Indices != nil {
			e.RawStr("\"indices\"" + ":")
			e.ArrStart()
			if len(s.Indices) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Indices[0]
					e.Int(elem)
				}
				for _, elem := range s.Indices[1:] {
					e.Comma()
					e.Int(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSearchResultTextMatchesItemMatchesItem = [2]string{
	0: "text",
	1: "indices",
}

// Decode decodes SearchResultTextMatchesItemMatchesItem from json.
func (s *SearchResultTextMatchesItemMatchesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResultTextMatchesItemMatchesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "indices":
			if err := func() error {
				s.Indices = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Indices = append(s.Indices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchResultTextMatchesItemMatchesItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SearchTopicsOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"incomplete_results\"" + ":")
		e.Bool(s.IncompleteResults)
	}
	{
		e.Comma()

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSearchTopicsOK = [3]string{
	0: "total_count",
	1: "incomplete_results",
	2: "items",
}

// Decode decodes SearchTopicsOK from json.
func (s *SearchTopicsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchTopicsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "incomplete_results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IncompleteResults = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incomplete_results\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TopicSearchResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchTopicsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchTopicsOK) {
					name = jsonFieldsNameOfSearchTopicsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SearchUsersOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_count\"" + ":")
		e.Int(s.TotalCount)
	}
	{
		e.Comma()

		e.RawStr("\"incomplete_results\"" + ":")
		e.Bool(s.IncompleteResults)
	}
	{
		e.Comma()

		e.RawStr("\"items\"" + ":")
		e.ArrStart()
		if len(s.Items) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Items[0]
				elem.Encode(e)
			}
			for _, elem := range s.Items[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSearchUsersOK = [3]string{
	0: "total_count",
	1: "incomplete_results",
	2: "items",
}

// Decode decodes SearchUsersOK from json.
func (s *SearchUsersOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchUsersOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "incomplete_results":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IncompleteResults = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incomplete_results\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserSearchResultItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchUsersOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchUsersOK) {
					name = jsonFieldsNameOfSearchUsersOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SecretScanningAlert) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Number.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Number.Set {
			e.RawStr("\"number\"" + ":")
			s.Number.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.HTMLURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.HTMLURL.Set {
			e.RawStr("\"html_url\"" + ":")
			s.HTMLURL.Encode(e)
		}
	}
	{
		if s.LocationsURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.LocationsURL.Set {
			e.RawStr("\"locations_url\"" + ":")
			s.LocationsURL.Encode(e)
		}
	}
	{
		if s.State.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.State.Set {
			e.RawStr("\"state\"" + ":")
			s.State.Encode(e)
		}
	}
	{
		if s.Resolution.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resolution.Set {
			e.RawStr("\"resolution\"" + ":")
			s.Resolution.Encode(e)
		}
	}
	{
		if s.ResolvedAt.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResolvedAt.Set {
			e.RawStr("\"resolved_at\"" + ":")
			s.ResolvedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ResolvedBy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ResolvedBy.Set {
			e.RawStr("\"resolved_by\"" + ":")
			s.ResolvedBy.Encode(e)
		}
	}
	{
		if s.SecretType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.SecretType.Set {
			e.RawStr("\"secret_type\"" + ":")
			s.SecretType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSecretScanningAlert = [11]string{
	0:  "number",
	1:  "created_at",
	2:  "url",
	3:  "html_url",
	4:  "locations_url",
	5:  "state",
	6:  "resolution",
	7:  "resolved_at",
	8:  "resolved_by",
	9:  "secret_type",
	10: "secret",
}

// Decode decodes SecretScanningAlert from json.
func (s *SecretScanningAlert) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretScanningAlert to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			if err := func() error {
				s.Number.Reset()
				if err := s.Number.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			if err := func() error {
				s.HTMLURL.Reset()
				if err := s.HTMLURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "locations_url":
			if err := func() error {
				s.LocationsURL.Reset()
				if err := s.LocationsURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locations_url\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "resolution":
			if err := func() error {
				s.Resolution.Reset()
				if err := s.Resolution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolution\"")
			}
		case "resolved_at":
			if err := func() error {
				s.ResolvedAt.Reset()
				if err := s.ResolvedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolved_at\"")
			}
		case "resolved_by":
			if err := func() error {
				s.ResolvedBy.Reset()
				if err := s.ResolvedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolved_by\"")
			}
		case "secret_type":
			if err := func() error {
				s.SecretType.Reset()
				if err := s.SecretType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretScanningAlert")
	}

	return nil
}

// Encode encodes SecretScanningAlertResolution as json.
func (s SecretScanningAlertResolution) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SecretScanningAlertResolution from json.
func (s *SecretScanningAlertResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretScanningAlertResolution to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SecretScanningAlertResolution(v) {
	case SecretScanningAlertResolutionFalsePositive:
		*s = SecretScanningAlertResolutionFalsePositive
	case SecretScanningAlertResolutionWontFix:
		*s = SecretScanningAlertResolutionWontFix
	case SecretScanningAlertResolutionRevoked:
		*s = SecretScanningAlertResolutionRevoked
	case SecretScanningAlertResolutionUsedInTests:
		*s = SecretScanningAlertResolutionUsedInTests
	default:
		*s = SecretScanningAlertResolution(v)
	}

	return nil
}

// Encode encodes SecretScanningAlertState as json.
func (s SecretScanningAlertState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SecretScanningAlertState from json.
func (s *SecretScanningAlertState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretScanningAlertState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SecretScanningAlertState(v) {
	case SecretScanningAlertStateOpen:
		*s = SecretScanningAlertStateOpen
	case SecretScanningAlertStateResolved:
		*s = SecretScanningAlertStateResolved
	default:
		*s = SecretScanningAlertState(v)
	}

	return nil
}

// Encode encodes SecretScanningListAlertsForOrgOKApplicationJSON as json.
func (s SecretScanningListAlertsForOrgOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []OrganizationSecretScanningAlert(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes SecretScanningListAlertsForOrgOKApplicationJSON from json.
func (s *SecretScanningListAlertsForOrgOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretScanningListAlertsForOrgOKApplicationJSON to nil")
	}
	var unwrapped []OrganizationSecretScanningAlert
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationSecretScanningAlert
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SecretScanningListAlertsForOrgOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes SecretScanningListAlertsForRepoOKApplicationJSON as json.
func (s SecretScanningListAlertsForRepoOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SecretScanningAlert(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes SecretScanningListAlertsForRepoOKApplicationJSON from json.
func (s *SecretScanningListAlertsForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretScanningListAlertsForRepoOKApplicationJSON to nil")
	}
	var unwrapped []SecretScanningAlert
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SecretScanningAlert
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SecretScanningListAlertsForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s SecretScanningUpdateAlertReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		if s.Resolution.Set {
			e.Comma()
		}
		if s.Resolution.Set {
			e.RawStr("\"resolution\"" + ":")
			s.Resolution.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSecretScanningUpdateAlertReq = [2]string{
	0: "state",
	1: "resolution",
}

// Decode decodes SecretScanningUpdateAlertReq from json.
func (s *SecretScanningUpdateAlertReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretScanningUpdateAlertReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "resolution":
			if err := func() error {
				s.Resolution.Reset()
				if err := s.Resolution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretScanningUpdateAlertReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSecretScanningUpdateAlertReq) {
					name = jsonFieldsNameOfSecretScanningUpdateAlertReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SelectedActions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.GithubOwnedAllowed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GithubOwnedAllowed.Set {
			e.RawStr("\"github_owned_allowed\"" + ":")
			s.GithubOwnedAllowed.Encode(e)
		}
	}
	{
		if s.VerifiedAllowed.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VerifiedAllowed.Set {
			e.RawStr("\"verified_allowed\"" + ":")
			s.VerifiedAllowed.Encode(e)
		}
	}
	{
		if s.PatternsAllowed != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.PatternsAllowed != nil {
			e.RawStr("\"patterns_allowed\"" + ":")
			e.ArrStart()
			if len(s.PatternsAllowed) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PatternsAllowed[0]
					e.Str(elem)
				}
				for _, elem := range s.PatternsAllowed[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSelectedActions = [3]string{
	0: "github_owned_allowed",
	1: "verified_allowed",
	2: "patterns_allowed",
}

// Decode decodes SelectedActions from json.
func (s *SelectedActions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectedActions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "github_owned_allowed":
			if err := func() error {
				s.GithubOwnedAllowed.Reset()
				if err := s.GithubOwnedAllowed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"github_owned_allowed\"")
			}
		case "verified_allowed":
			if err := func() error {
				s.VerifiedAllowed.Reset()
				if err := s.VerifiedAllowed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified_allowed\"")
			}
		case "patterns_allowed":
			if err := func() error {
				s.PatternsAllowed = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PatternsAllowed = append(s.PatternsAllowed, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patterns_allowed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SelectedActions")
	}

	return nil
}

// Encode encodes SelectedActionsURL as json.
func (s SelectedActionsURL) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes SelectedActionsURL from json.
func (s *SelectedActionsURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectedActionsURL to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SelectedActionsURL(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ServiceUnavailable) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Code.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Code.Set {
			e.RawStr("\"code\"" + ":")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfServiceUnavailable = [3]string{
	0: "code",
	1: "message",
	2: "documentation_url",
}

// Decode decodes ServiceUnavailable from json.
func (s *ServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceUnavailable to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceUnavailable")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ShortBlob) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfShortBlob = [2]string{
	0: "url",
	1: "sha",
}

// Decode decodes ShortBlob from json.
func (s *ShortBlob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShortBlob to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "sha":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ShortBlob")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShortBlob) {
					name = jsonFieldsNameOfShortBlob[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ShortBranch) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		s.Commit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"protected\"" + ":")
		e.Bool(s.Protected)
	}
	{
		if s.Protection.Set {
			e.Comma()
		}
		if s.Protection.Set {
			e.RawStr("\"protection\"" + ":")
			s.Protection.Encode(e)
		}
	}
	{
		if s.ProtectionURL.Set {
			e.Comma()
		}
		if s.ProtectionURL.Set {
			e.RawStr("\"protection_url\"" + ":")
			s.ProtectionURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfShortBranch = [5]string{
	0: "name",
	1: "commit",
	2: "protected",
	3: "protection",
	4: "protection_url",
}

// Decode decodes ShortBranch from json.
func (s *ShortBranch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShortBranch to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "protected":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Protected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protected\"")
			}
		case "protection":
			if err := func() error {
				s.Protection.Reset()
				if err := s.Protection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protection\"")
			}
		case "protection_url":
			if err := func() error {
				s.ProtectionURL.Reset()
				if err := s.ProtectionURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protection_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ShortBranch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShortBranch) {
					name = jsonFieldsNameOfShortBranch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ShortBranchCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfShortBranchCommit = [2]string{
	0: "sha",
	1: "url",
}

// Decode decodes ShortBranchCommit from json.
func (s *ShortBranchCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShortBranchCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ShortBranchCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShortBranchCommit) {
					name = jsonFieldsNameOfShortBranchCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SimpleCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"tree_id\"" + ":")
		e.Str(s.TreeID)
	}
	{
		e.Comma()

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"timestamp\"" + ":")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		e.Comma()

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"committer\"" + ":")
		s.Committer.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSimpleCommit = [6]string{
	0: "id",
	1: "tree_id",
	2: "message",
	3: "timestamp",
	4: "author",
	5: "committer",
}

// Decode decodes SimpleCommit from json.
func (s *SimpleCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimpleCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "tree_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TreeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tree_id\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "committer":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Committer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"committer\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimpleCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimpleCommit) {
					name = jsonFieldsNameOfSimpleCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SimpleCommitAuthor) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSimpleCommitAuthor = [2]string{
	0: "name",
	1: "email",
}

// Decode decodes SimpleCommitAuthor from json.
func (s *SimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimpleCommitAuthor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimpleCommitAuthor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimpleCommitAuthor) {
					name = jsonFieldsNameOfSimpleCommitAuthor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SimpleCommitCommitter) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"email\"" + ":")
		e.Str(s.Email)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSimpleCommitCommitter = [2]string{
	0: "name",
	1: "email",
}

// Decode decodes SimpleCommitCommitter from json.
func (s *SimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimpleCommitCommitter to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimpleCommitCommitter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimpleCommitCommitter) {
					name = jsonFieldsNameOfSimpleCommitCommitter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SimpleCommitStatus) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"context\"" + ":")
		e.Str(s.Context)
	}
	{
		e.Comma()

		e.RawStr("\"target_url\"" + ":")
		json.EncodeURI(e, s.TargetURL)
	}
	{
		if s.Required.Set {
			e.Comma()
		}
		if s.Required.Set {
			e.RawStr("\"required\"" + ":")
			s.Required.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		s.AvatarURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSimpleCommitStatus = [11]string{
	0:  "description",
	1:  "id",
	2:  "node_id",
	3:  "state",
	4:  "context",
	5:  "target_url",
	6:  "required",
	7:  "avatar_url",
	8:  "url",
	9:  "created_at",
	10: "updated_at",
}

// Decode decodes SimpleCommitStatus from json.
func (s *SimpleCommitStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimpleCommitStatus to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "context":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Context = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "target_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TargetURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_url\"")
			}
		case "required":
			if err := func() error {
				s.Required.Reset()
				if err := s.Required.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimpleCommitStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimpleCommitStatus) {
					name = jsonFieldsNameOfSimpleCommitStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SimpleUser) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		if s.StarredAt.Set {
			e.Comma()
		}
		if s.StarredAt.Set {
			e.RawStr("\"starred_at\"" + ":")
			s.StarredAt.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSimpleUser = [21]string{
	0:  "name",
	1:  "email",
	2:  "login",
	3:  "id",
	4:  "node_id",
	5:  "avatar_url",
	6:  "gravatar_id",
	7:  "url",
	8:  "html_url",
	9:  "followers_url",
	10: "following_url",
	11: "gists_url",
	12: "starred_url",
	13: "subscriptions_url",
	14: "organizations_url",
	15: "repos_url",
	16: "events_url",
	17: "received_events_url",
	18: "type",
	19: "site_admin",
	20: "starred_at",
}

// Decode decodes SimpleUser from json.
func (s *SimpleUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimpleUser to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "login":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "following_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "events_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "received_events_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "site_admin":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "starred_at":
			if err := func() error {
				s.StarredAt.Reset()
				if err := s.StarredAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimpleUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111100,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimpleUser) {
					name = jsonFieldsNameOfSimpleUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Status) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		s.AvatarURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		e.Str(s.Description)
	}
	{
		e.Comma()

		e.RawStr("\"target_url\"" + ":")
		e.Str(s.TargetURL)
	}
	{
		e.Comma()

		e.RawStr("\"context\"" + ":")
		e.Str(s.Context)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		e.Str(s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		e.Str(s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfStatus = [11]string{
	0:  "url",
	1:  "avatar_url",
	2:  "id",
	3:  "node_id",
	4:  "state",
	5:  "description",
	6:  "target_url",
	7:  "context",
	8:  "created_at",
	9:  "updated_at",
	10: "creator",
}

// Decode decodes Status from json.
func (s *Status) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Status to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "target_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TargetURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_url\"")
			}
		case "context":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Context = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "creator":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Status")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStatus) {
					name = jsonFieldsNameOfStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s StatusCheckPolicy) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"strict\"" + ":")
		e.Bool(s.Strict)
	}
	{
		e.Comma()

		e.RawStr("\"contexts\"" + ":")
		e.ArrStart()
		if len(s.Contexts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Contexts[0]
				e.Str(elem)
			}
			for _, elem := range s.Contexts[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"contexts_url\"" + ":")
		json.EncodeURI(e, s.ContextsURL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfStatusCheckPolicy = [4]string{
	0: "url",
	1: "strict",
	2: "contexts",
	3: "contexts_url",
}

// Decode decodes StatusCheckPolicy from json.
func (s *StatusCheckPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StatusCheckPolicy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "strict":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Strict = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strict\"")
			}
		case "contexts":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Contexts = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		case "contexts_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContextsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StatusCheckPolicy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStatusCheckPolicy) {
					name = jsonFieldsNameOfStatusCheckPolicy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Tag) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"commit\"" + ":")
		s.Commit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"zipball_url\"" + ":")
		json.EncodeURI(e, s.ZipballURL)
	}
	{
		e.Comma()

		e.RawStr("\"tarball_url\"" + ":")
		json.EncodeURI(e, s.TarballURL)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTag = [5]string{
	0: "name",
	1: "commit",
	2: "zipball_url",
	3: "tarball_url",
	4: "node_id",
}

// Decode decodes Tag from json.
func (s *Tag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tag to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "commit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "zipball_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ZipballURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zipball_url\"")
			}
		case "tarball_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TarballURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tarball_url\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Tag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTag) {
					name = jsonFieldsNameOfTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TagCommit) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"sha\"" + ":")
		e.Str(s.Sha)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTagCommit = [2]string{
	0: "sha",
	1: "url",
}

// Decode decodes TagCommit from json.
func (s *TagCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagCommit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Sha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagCommit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagCommit) {
					name = jsonFieldsNameOfTagCommit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Team) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"slug\"" + ":")
		e.Str(s.Slug)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		if s.Privacy.Set {
			e.Comma()
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"permission\"" + ":")
		e.Str(s.Permission)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"members_url\"" + ":")
		e.Str(s.MembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"repositories_url\"" + ":")
		json.EncodeURI(e, s.RepositoriesURL)
	}
	{
		e.Comma()

		e.RawStr("\"parent\"" + ":")
		s.Parent.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeam = [13]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "slug",
	4:  "description",
	5:  "privacy",
	6:  "permission",
	7:  "permissions",
	8:  "url",
	9:  "html_url",
	10: "members_url",
	11: "repositories_url",
	12: "parent",
}

// Decode decodes Team from json.
func (s *Team) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Team to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "slug":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Slug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "permission":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Permission = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "members_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.MembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "repositories_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoriesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories_url\"")
			}
		case "parent":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Parent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Team")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01011111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeam) {
					name = jsonFieldsNameOfTeam[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamDiscussion) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"body_html\"" + ":")
		e.Str(s.BodyHTML)
	}
	{
		e.Comma()

		e.RawStr("\"body_version\"" + ":")
		e.Str(s.BodyVersion)
	}
	{
		e.Comma()

		e.RawStr("\"comments_count\"" + ":")
		e.Int(s.CommentsCount)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		json.EncodeURI(e, s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"last_edited_at\"" + ":")
		s.LastEditedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"pinned\"" + ":")
		e.Bool(s.Pinned)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"team_url\"" + ":")
		json.EncodeURI(e, s.TeamURL)
	}
	{
		e.Comma()

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamDiscussion = [18]string{
	0:  "author",
	1:  "body",
	2:  "body_html",
	3:  "body_version",
	4:  "comments_count",
	5:  "comments_url",
	6:  "created_at",
	7:  "last_edited_at",
	8:  "html_url",
	9:  "node_id",
	10: "number",
	11: "pinned",
	12: "private",
	13: "team_url",
	14: "title",
	15: "updated_at",
	16: "url",
	17: "reactions",
}

// Decode decodes TeamDiscussion from json.
func (s *TeamDiscussion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamDiscussion to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "body_html":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BodyHTML = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_version":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.BodyVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_version\"")
			}
		case "comments_count":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.CommentsCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_count\"")
			}
		case "comments_url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.CommentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_edited_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.LastEditedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_edited_at\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "pinned":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Pinned = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pinned\"")
			}
		case "private":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "team_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_url\"")
			}
		case "title":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamDiscussion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamDiscussion) {
					name = jsonFieldsNameOfTeamDiscussion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamDiscussionComment) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"author\"" + ":")
		s.Author.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		e.Comma()

		e.RawStr("\"body_html\"" + ":")
		e.Str(s.BodyHTML)
	}
	{
		e.Comma()

		e.RawStr("\"body_version\"" + ":")
		e.Str(s.BodyVersion)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"last_edited_at\"" + ":")
		s.LastEditedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"discussion_url\"" + ":")
		json.EncodeURI(e, s.DiscussionURL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.Reactions.Set {
			e.Comma()
		}
		if s.Reactions.Set {
			e.RawStr("\"reactions\"" + ":")
			s.Reactions.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamDiscussionComment = [13]string{
	0:  "author",
	1:  "body",
	2:  "body_html",
	3:  "body_version",
	4:  "created_at",
	5:  "last_edited_at",
	6:  "discussion_url",
	7:  "html_url",
	8:  "node_id",
	9:  "number",
	10: "updated_at",
	11: "url",
	12: "reactions",
}

// Decode decodes TeamDiscussionComment from json.
func (s *TeamDiscussionComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamDiscussionComment to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "body_html":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BodyHTML = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_html\"")
			}
		case "body_version":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.BodyVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_version\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_edited_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.LastEditedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_edited_at\"")
			}
		case "discussion_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DiscussionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discussion_url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "node_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "reactions":
			if err := func() error {
				s.Reactions.Reset()
				if err := s.Reactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamDiscussionComment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamDiscussionComment) {
					name = jsonFieldsNameOfTeamDiscussionComment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamFull) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"slug\"" + ":")
		e.Str(s.Slug)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		if s.Privacy.Set {
			e.Comma()
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"permission\"" + ":")
		e.Str(s.Permission)
	}
	{
		e.Comma()

		e.RawStr("\"members_url\"" + ":")
		e.Str(s.MembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"repositories_url\"" + ":")
		json.EncodeURI(e, s.RepositoriesURL)
	}
	{
		if s.Parent.Set {
			e.Comma()
		}
		if s.Parent.Set {
			e.RawStr("\"parent\"" + ":")
			s.Parent.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"members_count\"" + ":")
		e.Int(s.MembersCount)
	}
	{
		e.Comma()

		e.RawStr("\"repos_count\"" + ":")
		e.Int(s.ReposCount)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"organization\"" + ":")
		s.Organization.Encode(e)
	}
	{
		if s.LdapDn.Set {
			e.Comma()
		}
		if s.LdapDn.Set {
			e.RawStr("\"ldap_dn\"" + ":")
			s.LdapDn.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamFull = [18]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "html_url",
	4:  "name",
	5:  "slug",
	6:  "description",
	7:  "privacy",
	8:  "permission",
	9:  "members_url",
	10: "repositories_url",
	11: "parent",
	12: "members_count",
	13: "repos_count",
	14: "created_at",
	15: "updated_at",
	16: "organization",
	17: "ldap_dn",
}

// Decode decodes TeamFull from json.
func (s *TeamFull) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamFull to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "slug":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Slug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "permission":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Permission = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "members_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "repositories_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoriesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories_url\"")
			}
		case "parent":
			if err := func() error {
				s.Parent.Reset()
				if err := s.Parent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent\"")
			}
		case "members_count":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MembersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_count\"")
			}
		case "repos_count":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ReposCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_count\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "organization":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.Organization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		case "ldap_dn":
			if err := func() error {
				s.LdapDn.Reset()
				if err := s.LdapDn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ldap_dn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamFull")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01111111,
		0b11110111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamFull) {
					name = jsonFieldsNameOfTeamFull[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes TeamFullPrivacy as json.
func (s TeamFullPrivacy) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamFullPrivacy from json.
func (s *TeamFullPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamFullPrivacy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamFullPrivacy(v) {
	case TeamFullPrivacyClosed:
		*s = TeamFullPrivacyClosed
	case TeamFullPrivacySecret:
		*s = TeamFullPrivacySecret
	default:
		*s = TeamFullPrivacy(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamMembership) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"role\"" + ":")
		s.Role.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamMembership = [3]string{
	0: "url",
	1: "role",
	2: "state",
}

// Decode decodes TeamMembership from json.
func (s *TeamMembership) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamMembership to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamMembership")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamMembership) {
					name = jsonFieldsNameOfTeamMembership[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes TeamMembershipRole as json.
func (s TeamMembershipRole) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamMembershipRole from json.
func (s *TeamMembershipRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamMembershipRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamMembershipRole(v) {
	case TeamMembershipRoleMember:
		*s = TeamMembershipRoleMember
	case TeamMembershipRoleMaintainer:
		*s = TeamMembershipRoleMaintainer
	default:
		*s = TeamMembershipRole(v)
	}

	return nil
}

// Encode encodes TeamMembershipState as json.
func (s TeamMembershipState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamMembershipState from json.
func (s *TeamMembershipState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamMembershipState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamMembershipState(v) {
	case TeamMembershipStateActive:
		*s = TeamMembershipStateActive
	case TeamMembershipStatePending:
		*s = TeamMembershipStatePending
	default:
		*s = TeamMembershipState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	{
		e.Comma()

		e.RawStr("\"triage\"" + ":")
		e.Bool(s.Triage)
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		e.Comma()

		e.RawStr("\"maintain\"" + ":")
		e.Bool(s.Maintain)
	}
	{
		e.Comma()

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamPermissions = [5]string{
	0: "pull",
	1: "triage",
	2: "push",
	3: "maintain",
	4: "admin",
}

// Decode decodes TeamPermissions from json.
func (s *TeamPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pull":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		case "triage":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Triage = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "maintain":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Maintain = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		case "admin":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamPermissions) {
					name = jsonFieldsNameOfTeamPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamProject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"owner_url\"" + ":")
		e.Str(s.OwnerURL)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		e.Str(s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"columns_url\"" + ":")
		e.Str(s.ColumnsURL)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		s.Body.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"number\"" + ":")
		e.Int(s.Number)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		e.Str(s.State)
	}
	{
		e.Comma()

		e.RawStr("\"creator\"" + ":")
		s.Creator.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		e.Str(s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		e.Str(s.UpdatedAt)
	}
	{
		if s.OrganizationPermission.Set {
			e.Comma()
		}
		if s.OrganizationPermission.Set {
			e.RawStr("\"organization_permission\"" + ":")
			s.OrganizationPermission.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.Comma()
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"permissions\"" + ":")
		s.Permissions.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamProject = [16]string{
	0:  "owner_url",
	1:  "url",
	2:  "html_url",
	3:  "columns_url",
	4:  "id",
	5:  "node_id",
	6:  "name",
	7:  "body",
	8:  "number",
	9:  "state",
	10: "creator",
	11: "created_at",
	12: "updated_at",
	13: "organization_permission",
	14: "private",
	15: "permissions",
}

// Decode decodes TeamProject from json.
func (s *TeamProject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamProject to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "owner_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OwnerURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner_url\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.HTMLURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "columns_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ColumnsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"columns_url\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "number":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "creator":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "organization_permission":
			if err := func() error {
				s.OrganizationPermission.Reset()
				if err := s.OrganizationPermission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization_permission\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "permissions":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamProject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b10011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamProject) {
					name = jsonFieldsNameOfTeamProject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamProjectPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"read\"" + ":")
		e.Bool(s.Read)
	}
	{
		e.Comma()

		e.RawStr("\"write\"" + ":")
		e.Bool(s.Write)
	}
	{
		e.Comma()

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamProjectPermissions = [3]string{
	0: "read",
	1: "write",
	2: "admin",
}

// Decode decodes TeamProjectPermissions from json.
func (s *TeamProjectPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamProjectPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "read":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Read = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"read\"")
			}
		case "write":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Write = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"write\"")
			}
		case "admin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamProjectPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamProjectPermissions) {
					name = jsonFieldsNameOfTeamProjectPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamRepository) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"full_name\"" + ":")
		e.Str(s.FullName)
	}
	{
		e.Comma()

		e.RawStr("\"license\"" + ":")
		s.License.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"forks\"" + ":")
		e.Int(s.Forks)
	}
	{
		if s.Permissions.Set {
			e.Comma()
		}
		if s.Permissions.Set {
			e.RawStr("\"permissions\"" + ":")
			s.Permissions.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"owner\"" + ":")
		s.Owner.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"private\"" + ":")
		e.Bool(s.Private)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"fork\"" + ":")
		e.Bool(s.Fork)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"archive_url\"" + ":")
		e.Str(s.ArchiveURL)
	}
	{
		e.Comma()

		e.RawStr("\"assignees_url\"" + ":")
		e.Str(s.AssigneesURL)
	}
	{
		e.Comma()

		e.RawStr("\"blobs_url\"" + ":")
		e.Str(s.BlobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"branches_url\"" + ":")
		e.Str(s.BranchesURL)
	}
	{
		e.Comma()

		e.RawStr("\"collaborators_url\"" + ":")
		e.Str(s.CollaboratorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"comments_url\"" + ":")
		e.Str(s.CommentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"commits_url\"" + ":")
		e.Str(s.CommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"compare_url\"" + ":")
		e.Str(s.CompareURL)
	}
	{
		e.Comma()

		e.RawStr("\"contents_url\"" + ":")
		e.Str(s.ContentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"contributors_url\"" + ":")
		json.EncodeURI(e, s.ContributorsURL)
	}
	{
		e.Comma()

		e.RawStr("\"deployments_url\"" + ":")
		json.EncodeURI(e, s.DeploymentsURL)
	}
	{
		e.Comma()

		e.RawStr("\"downloads_url\"" + ":")
		json.EncodeURI(e, s.DownloadsURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		json.EncodeURI(e, s.EventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"forks_url\"" + ":")
		json.EncodeURI(e, s.ForksURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_commits_url\"" + ":")
		e.Str(s.GitCommitsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_refs_url\"" + ":")
		e.Str(s.GitRefsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_tags_url\"" + ":")
		e.Str(s.GitTagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"git_url\"" + ":")
		e.Str(s.GitURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_comment_url\"" + ":")
		e.Str(s.IssueCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"issue_events_url\"" + ":")
		e.Str(s.IssueEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"issues_url\"" + ":")
		e.Str(s.IssuesURL)
	}
	{
		e.Comma()

		e.RawStr("\"keys_url\"" + ":")
		e.Str(s.KeysURL)
	}
	{
		e.Comma()

		e.RawStr("\"labels_url\"" + ":")
		e.Str(s.LabelsURL)
	}
	{
		e.Comma()

		e.RawStr("\"languages_url\"" + ":")
		json.EncodeURI(e, s.LanguagesURL)
	}
	{
		e.Comma()

		e.RawStr("\"merges_url\"" + ":")
		json.EncodeURI(e, s.MergesURL)
	}
	{
		e.Comma()

		e.RawStr("\"milestones_url\"" + ":")
		e.Str(s.MilestonesURL)
	}
	{
		e.Comma()

		e.RawStr("\"notifications_url\"" + ":")
		e.Str(s.NotificationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"pulls_url\"" + ":")
		e.Str(s.PullsURL)
	}
	{
		e.Comma()

		e.RawStr("\"releases_url\"" + ":")
		e.Str(s.ReleasesURL)
	}
	{
		e.Comma()

		e.RawStr("\"ssh_url\"" + ":")
		e.Str(s.SSHURL)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_url\"" + ":")
		json.EncodeURI(e, s.StargazersURL)
	}
	{
		e.Comma()

		e.RawStr("\"statuses_url\"" + ":")
		e.Str(s.StatusesURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscribers_url\"" + ":")
		json.EncodeURI(e, s.SubscribersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionURL)
	}
	{
		e.Comma()

		e.RawStr("\"tags_url\"" + ":")
		json.EncodeURI(e, s.TagsURL)
	}
	{
		e.Comma()

		e.RawStr("\"teams_url\"" + ":")
		json.EncodeURI(e, s.TeamsURL)
	}
	{
		e.Comma()

		e.RawStr("\"trees_url\"" + ":")
		e.Str(s.TreesURL)
	}
	{
		e.Comma()

		e.RawStr("\"clone_url\"" + ":")
		e.Str(s.CloneURL)
	}
	{
		e.Comma()

		e.RawStr("\"mirror_url\"" + ":")
		s.MirrorURL.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"hooks_url\"" + ":")
		json.EncodeURI(e, s.HooksURL)
	}
	{
		e.Comma()

		e.RawStr("\"svn_url\"" + ":")
		json.EncodeURI(e, s.SvnURL)
	}
	{
		e.Comma()

		e.RawStr("\"homepage\"" + ":")
		s.Homepage.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"language\"" + ":")
		s.Language.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"forks_count\"" + ":")
		e.Int(s.ForksCount)
	}
	{
		e.Comma()

		e.RawStr("\"stargazers_count\"" + ":")
		e.Int(s.StargazersCount)
	}
	{
		e.Comma()

		e.RawStr("\"watchers_count\"" + ":")
		e.Int(s.WatchersCount)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int(s.Size)
	}
	{
		e.Comma()

		e.RawStr("\"default_branch\"" + ":")
		e.Str(s.DefaultBranch)
	}
	{
		e.Comma()

		e.RawStr("\"open_issues_count\"" + ":")
		e.Int(s.OpenIssuesCount)
	}
	{
		if s.IsTemplate.Set {
			e.Comma()
		}
		if s.IsTemplate.Set {
			e.RawStr("\"is_template\"" + ":")
			s.IsTemplate.Encode(e)
		}
	}
	{
		if s.Topics != nil {
			e.Comma()
		}
		if s.Topics != nil {
			e.RawStr("\"topics\"" + ":")
			e.ArrStart()
			if len(s.Topics) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Topics[0]
					e.Str(elem)
				}
				for _, elem := range s.Topics[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"has_issues\"" + ":")
		e.Bool(s.HasIssues)
	}
	{
		e.Comma()

		e.RawStr("\"has_projects\"" + ":")
		e.Bool(s.HasProjects)
	}
	{
		e.Comma()

		e.RawStr("\"has_wiki\"" + ":")
		e.Bool(s.HasWiki)
	}
	{
		e.Comma()

		e.RawStr("\"has_pages\"" + ":")
		e.Bool(s.HasPages)
	}
	{
		e.Comma()

		e.RawStr("\"has_downloads\"" + ":")
		e.Bool(s.HasDownloads)
	}
	{
		e.Comma()

		e.RawStr("\"archived\"" + ":")
		e.Bool(s.Archived)
	}
	{
		e.Comma()

		e.RawStr("\"disabled\"" + ":")
		e.Bool(s.Disabled)
	}
	{
		if s.Visibility.Set {
			e.Comma()
		}
		if s.Visibility.Set {
			e.RawStr("\"visibility\"" + ":")
			s.Visibility.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"pushed_at\"" + ":")
		s.PushedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.AllowRebaseMerge.Set {
			e.Comma()
		}
		if s.AllowRebaseMerge.Set {
			e.RawStr("\"allow_rebase_merge\"" + ":")
			s.AllowRebaseMerge.Encode(e)
		}
	}
	{
		if s.TemplateRepository.Set {
			e.Comma()
		}
		if s.TemplateRepository.Set {
			e.RawStr("\"template_repository\"" + ":")
			s.TemplateRepository.Encode(e)
		}
	}
	{
		if s.TempCloneToken.Set {
			e.Comma()
		}
		if s.TempCloneToken.Set {
			e.RawStr("\"temp_clone_token\"" + ":")
			s.TempCloneToken.Encode(e)
		}
	}
	{
		if s.AllowSquashMerge.Set {
			e.Comma()
		}
		if s.AllowSquashMerge.Set {
			e.RawStr("\"allow_squash_merge\"" + ":")
			s.AllowSquashMerge.Encode(e)
		}
	}
	{
		if s.AllowAutoMerge.Set {
			e.Comma()
		}
		if s.AllowAutoMerge.Set {
			e.RawStr("\"allow_auto_merge\"" + ":")
			s.AllowAutoMerge.Encode(e)
		}
	}
	{
		if s.DeleteBranchOnMerge.Set {
			e.Comma()
		}
		if s.DeleteBranchOnMerge.Set {
			e.RawStr("\"delete_branch_on_merge\"" + ":")
			s.DeleteBranchOnMerge.Encode(e)
		}
	}
	{
		if s.AllowMergeCommit.Set {
			e.Comma()
		}
		if s.AllowMergeCommit.Set {
			e.RawStr("\"allow_merge_commit\"" + ":")
			s.AllowMergeCommit.Encode(e)
		}
	}
	{
		if s.AllowForking.Set {
			e.Comma()
		}
		if s.AllowForking.Set {
			e.RawStr("\"allow_forking\"" + ":")
			s.AllowForking.Encode(e)
		}
	}
	{
		if s.SubscribersCount.Set {
			e.Comma()
		}
		if s.SubscribersCount.Set {
			e.RawStr("\"subscribers_count\"" + ":")
			s.SubscribersCount.Encode(e)
		}
	}
	{
		if s.NetworkCount.Set {
			e.Comma()
		}
		if s.NetworkCount.Set {
			e.RawStr("\"network_count\"" + ":")
			s.NetworkCount.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"open_issues\"" + ":")
		e.Int(s.OpenIssues)
	}
	{
		e.Comma()

		e.RawStr("\"watchers\"" + ":")
		e.Int(s.Watchers)
	}
	{
		if s.MasterBranch.Set {
			e.Comma()
		}
		if s.MasterBranch.Set {
			e.RawStr("\"master_branch\"" + ":")
			s.MasterBranch.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamRepository = [88]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "full_name",
	4:  "license",
	5:  "forks",
	6:  "permissions",
	7:  "owner",
	8:  "private",
	9:  "html_url",
	10: "description",
	11: "fork",
	12: "url",
	13: "archive_url",
	14: "assignees_url",
	15: "blobs_url",
	16: "branches_url",
	17: "collaborators_url",
	18: "comments_url",
	19: "commits_url",
	20: "compare_url",
	21: "contents_url",
	22: "contributors_url",
	23: "deployments_url",
	24: "downloads_url",
	25: "events_url",
	26: "forks_url",
	27: "git_commits_url",
	28: "git_refs_url",
	29: "git_tags_url",
	30: "git_url",
	31: "issue_comment_url",
	32: "issue_events_url",
	33: "issues_url",
	34: "keys_url",
	35: "labels_url",
	36: "languages_url",
	37: "merges_url",
	38: "milestones_url",
	39: "notifications_url",
	40: "pulls_url",
	41: "releases_url",
	42: "ssh_url",
	43: "stargazers_url",
	44: "statuses_url",
	45: "subscribers_url",
	46: "subscription_url",
	47: "tags_url",
	48: "teams_url",
	49: "trees_url",
	50: "clone_url",
	51: "mirror_url",
	52: "hooks_url",
	53: "svn_url",
	54: "homepage",
	55: "language",
	56: "forks_count",
	57: "stargazers_count",
	58: "watchers_count",
	59: "size",
	60: "default_branch",
	61: "open_issues_count",
	62: "is_template",
	63: "topics",
	64: "has_issues",
	65: "has_projects",
	66: "has_wiki",
	67: "has_pages",
	68: "has_downloads",
	69: "archived",
	70: "disabled",
	71: "visibility",
	72: "pushed_at",
	73: "created_at",
	74: "updated_at",
	75: "allow_rebase_merge",
	76: "template_repository",
	77: "temp_clone_token",
	78: "allow_squash_merge",
	79: "allow_auto_merge",
	80: "delete_branch_on_merge",
	81: "allow_merge_commit",
	82: "allow_forking",
	83: "subscribers_count",
	84: "network_count",
	85: "open_issues",
	86: "watchers",
	87: "master_branch",
}

// Decode decodes TeamRepository from json.
func (s *TeamRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamRepository to nil")
	}
	var requiredBitSet [11]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "full_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"full_name\"")
			}
		case "license":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "forks":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Forks = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "owner":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "private":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Private = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "description":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fork":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Fork = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "archive_url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ArchiveURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_url\"")
			}
		case "assignees_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.AssigneesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignees_url\"")
			}
		case "blobs_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.BlobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blobs_url\"")
			}
		case "branches_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BranchesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branches_url\"")
			}
		case "collaborators_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CollaboratorsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaborators_url\"")
			}
		case "comments_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CommentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_url\"")
			}
		case "commits_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commits_url\"")
			}
		case "compare_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CompareURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_url\"")
			}
		case "contents_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ContentsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents_url\"")
			}
		case "contributors_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ContributorsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributors_url\"")
			}
		case "deployments_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DeploymentsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments_url\"")
			}
		case "downloads_url":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.DownloadsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads_url\"")
			}
		case "events_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.EventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "forks_url":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ForksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_url\"")
			}
		case "git_commits_url":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GitCommitsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_commits_url\"")
			}
		case "git_refs_url":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GitRefsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_refs_url\"")
			}
		case "git_tags_url":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.GitTagsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_tags_url\"")
			}
		case "git_url":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.GitURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"git_url\"")
			}
		case "issue_comment_url":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.IssueCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_comment_url\"")
			}
		case "issue_events_url":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IssueEventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_events_url\"")
			}
		case "issues_url":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.IssuesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "keys_url":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.KeysURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys_url\"")
			}
		case "labels_url":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.LabelsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels_url\"")
			}
		case "languages_url":
			requiredBitSet[4] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LanguagesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages_url\"")
			}
		case "merges_url":
			requiredBitSet[4] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.MergesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merges_url\"")
			}
		case "milestones_url":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.MilestonesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestones_url\"")
			}
		case "notifications_url":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.NotificationsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications_url\"")
			}
		case "pulls_url":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PullsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pulls_url\"")
			}
		case "releases_url":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ReleasesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releases_url\"")
			}
		case "ssh_url":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SSHURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh_url\"")
			}
		case "stargazers_url":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.StargazersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_url\"")
			}
		case "statuses_url":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.StatusesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses_url\"")
			}
		case "subscribers_url":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscribersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_url\"")
			}
		case "subscription_url":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "tags_url":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TagsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_url\"")
			}
		case "teams_url":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.TeamsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams_url\"")
			}
		case "trees_url":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TreesURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trees_url\"")
			}
		case "clone_url":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CloneURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clone_url\"")
			}
		case "mirror_url":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				if err := s.MirrorURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mirror_url\"")
			}
		case "hooks_url":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HooksURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hooks_url\"")
			}
		case "svn_url":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SvnURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"svn_url\"")
			}
		case "homepage":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "language":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "forks_count":
			requiredBitSet[7] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ForksCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forks_count\"")
			}
		case "stargazers_count":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.StargazersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stargazers_count\"")
			}
		case "watchers_count":
			requiredBitSet[7] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WatchersCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers_count\"")
			}
		case "size":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "default_branch":
			requiredBitSet[7] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.DefaultBranch = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_branch\"")
			}
		case "open_issues_count":
			requiredBitSet[7] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.OpenIssuesCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues_count\"")
			}
		case "is_template":
			if err := func() error {
				s.IsTemplate.Reset()
				if err := s.IsTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_template\"")
			}
		case "topics":
			if err := func() error {
				s.Topics = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Topics = append(s.Topics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topics\"")
			}
		case "has_issues":
			requiredBitSet[8] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HasIssues = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_issues\"")
			}
		case "has_projects":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasProjects = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_projects\"")
			}
		case "has_wiki":
			requiredBitSet[8] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.HasWiki = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_wiki\"")
			}
		case "has_pages":
			requiredBitSet[8] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.HasPages = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pages\"")
			}
		case "has_downloads":
			requiredBitSet[8] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.HasDownloads = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_downloads\"")
			}
		case "archived":
			requiredBitSet[8] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Archived = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "disabled":
			requiredBitSet[8] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Disabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "pushed_at":
			requiredBitSet[9] |= 1 << 0
			if err := func() error {
				if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushed_at\"")
			}
		case "created_at":
			requiredBitSet[9] |= 1 << 1
			if err := func() error {
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[9] |= 1 << 2
			if err := func() error {
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "allow_rebase_merge":
			if err := func() error {
				s.AllowRebaseMerge.Reset()
				if err := s.AllowRebaseMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_rebase_merge\"")
			}
		case "template_repository":
			if err := func() error {
				s.TemplateRepository.Reset()
				if err := s.TemplateRepository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_repository\"")
			}
		case "temp_clone_token":
			if err := func() error {
				s.TempCloneToken.Reset()
				if err := s.TempCloneToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temp_clone_token\"")
			}
		case "allow_squash_merge":
			if err := func() error {
				s.AllowSquashMerge.Reset()
				if err := s.AllowSquashMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_squash_merge\"")
			}
		case "allow_auto_merge":
			if err := func() error {
				s.AllowAutoMerge.Reset()
				if err := s.AllowAutoMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_auto_merge\"")
			}
		case "delete_branch_on_merge":
			if err := func() error {
				s.DeleteBranchOnMerge.Reset()
				if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_branch_on_merge\"")
			}
		case "allow_merge_commit":
			if err := func() error {
				s.AllowMergeCommit.Reset()
				if err := s.AllowMergeCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_merge_commit\"")
			}
		case "allow_forking":
			if err := func() error {
				s.AllowForking.Reset()
				if err := s.AllowForking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_forking\"")
			}
		case "subscribers_count":
			if err := func() error {
				s.SubscribersCount.Reset()
				if err := s.SubscribersCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribers_count\"")
			}
		case "network_count":
			if err := func() error {
				s.NetworkCount.Reset()
				if err := s.NetworkCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network_count\"")
			}
		case "open_issues":
			requiredBitSet[10] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.OpenIssues = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_issues\"")
			}
		case "watchers":
			requiredBitSet[10] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Watchers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watchers\"")
			}
		case "master_branch":
			if err := func() error {
				s.MasterBranch.Reset()
				if err := s.MasterBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master_branch\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamRepository")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [11]uint8{
		0b10111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b11111111,
		0b00111111,
		0b01111111,
		0b00000111,
		0b01100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamRepository) {
					name = jsonFieldsNameOfTeamRepository[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamRepositoryPermissions) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"admin\"" + ":")
		e.Bool(s.Admin)
	}
	{
		e.Comma()

		e.RawStr("\"pull\"" + ":")
		e.Bool(s.Pull)
	}
	{
		if s.Triage.Set {
			e.Comma()
		}
		if s.Triage.Set {
			e.RawStr("\"triage\"" + ":")
			s.Triage.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"push\"" + ":")
		e.Bool(s.Push)
	}
	{
		if s.Maintain.Set {
			e.Comma()
		}
		if s.Maintain.Set {
			e.RawStr("\"maintain\"" + ":")
			s.Maintain.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamRepositoryPermissions = [5]string{
	0: "admin",
	1: "pull",
	2: "triage",
	3: "push",
	4: "maintain",
}

// Decode decodes TeamRepositoryPermissions from json.
func (s *TeamRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamRepositoryPermissions to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Admin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		case "pull":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Pull = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull\"")
			}
		case "triage":
			if err := func() error {
				s.Triage.Reset()
				if err := s.Triage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triage\"")
			}
		case "push":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Push = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"push\"")
			}
		case "maintain":
			if err := func() error {
				s.Maintain.Reset()
				if err := s.Maintain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamRepositoryPermissions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamRepositoryPermissions) {
					name = jsonFieldsNameOfTeamRepositoryPermissions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"members_url\"" + ":")
		e.Str(s.MembersURL)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"permission\"" + ":")
		e.Str(s.Permission)
	}
	{
		if s.Privacy.Set {
			e.Comma()
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"repositories_url\"" + ":")
		json.EncodeURI(e, s.RepositoriesURL)
	}
	{
		e.Comma()

		e.RawStr("\"slug\"" + ":")
		e.Str(s.Slug)
	}
	{
		if s.LdapDn.Set {
			e.Comma()
		}
		if s.LdapDn.Set {
			e.RawStr("\"ldap_dn\"" + ":")
			s.LdapDn.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamSimple = [12]string{
	0:  "id",
	1:  "node_id",
	2:  "url",
	3:  "members_url",
	4:  "name",
	5:  "description",
	6:  "permission",
	7:  "privacy",
	8:  "html_url",
	9:  "repositories_url",
	10: "slug",
	11: "ldap_dn",
}

// Decode decodes TeamSimple from json.
func (s *TeamSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamSimple to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "members_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MembersURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_url\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "permission":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Permission = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "repositories_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.RepositoriesURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories_url\"")
			}
		case "slug":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Slug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "ldap_dn":
			if err := func() error {
				s.LdapDn.Reset()
				if err := s.LdapDn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ldap_dn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamSimple) {
					name = jsonFieldsNameOfTeamSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Role.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Role.Set {
			e.RawStr("\"role\"" + ":")
			s.Role.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsAddOrUpdateMembershipForUserInOrgReq = [1]string{
	0: "role",
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgReq from json.
func (s *TeamsAddOrUpdateMembershipForUserInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateMembershipForUserInOrgReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateMembershipForUserInOrgReq")
	}

	return nil
}

// Encode encodes TeamsAddOrUpdateMembershipForUserInOrgReqRole as json.
func (s TeamsAddOrUpdateMembershipForUserInOrgReqRole) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgReqRole from json.
func (s *TeamsAddOrUpdateMembershipForUserInOrgReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateMembershipForUserInOrgReqRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateMembershipForUserInOrgReqRole(v) {
	case TeamsAddOrUpdateMembershipForUserInOrgReqRoleMember:
		*s = TeamsAddOrUpdateMembershipForUserInOrgReqRoleMember
	case TeamsAddOrUpdateMembershipForUserInOrgReqRoleMaintainer:
		*s = TeamsAddOrUpdateMembershipForUserInOrgReqRoleMaintainer
	default:
		*s = TeamsAddOrUpdateMembershipForUserInOrgReqRole(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Role.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Role.Set {
			e.RawStr("\"role\"" + ":")
			s.Role.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsAddOrUpdateMembershipForUserLegacyReq = [1]string{
	0: "role",
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyReq from json.
func (s *TeamsAddOrUpdateMembershipForUserLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateMembershipForUserLegacyReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateMembershipForUserLegacyReq")
	}

	return nil
}

// Encode encodes TeamsAddOrUpdateMembershipForUserLegacyReqRole as json.
func (s TeamsAddOrUpdateMembershipForUserLegacyReqRole) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyReqRole from json.
func (s *TeamsAddOrUpdateMembershipForUserLegacyReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateMembershipForUserLegacyReqRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateMembershipForUserLegacyReqRole(v) {
	case TeamsAddOrUpdateMembershipForUserLegacyReqRoleMember:
		*s = TeamsAddOrUpdateMembershipForUserLegacyReqRoleMember
	case TeamsAddOrUpdateMembershipForUserLegacyReqRoleMaintainer:
		*s = TeamsAddOrUpdateMembershipForUserLegacyReqRoleMaintainer
	default:
		*s = TeamsAddOrUpdateMembershipForUserLegacyReqRole(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsInOrgForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsAddOrUpdateProjectPermissionsInOrgForbidden = [2]string{
	0: "message",
	1: "documentation_url",
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgForbidden from json.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateProjectPermissionsInOrgForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateProjectPermissionsInOrgForbidden")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsAddOrUpdateProjectPermissionsInOrgReq = [1]string{
	0: "permission",
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgReq from json.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateProjectPermissionsInOrgReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateProjectPermissionsInOrgReq")
	}

	return nil
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission as json.
func (s TeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission from json.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateProjectPermissionsInOrgReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateProjectPermissionsInOrgReqPermission(v) {
	case TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionRead:
		*s = TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionRead
	case TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionWrite:
		*s = TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionWrite
	case TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionAdmin:
		*s = TeamsAddOrUpdateProjectPermissionsInOrgReqPermissionAdmin
	default:
		*s = TeamsAddOrUpdateProjectPermissionsInOrgReqPermission(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsLegacyForbidden) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.DocumentationURL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.DocumentationURL.Set {
			e.RawStr("\"documentation_url\"" + ":")
			s.DocumentationURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsAddOrUpdateProjectPermissionsLegacyForbidden = [2]string{
	0: "message",
	1: "documentation_url",
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyForbidden from json.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateProjectPermissionsLegacyForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			if err := func() error {
				s.DocumentationURL.Reset()
				if err := s.DocumentationURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateProjectPermissionsLegacyForbidden")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsAddOrUpdateProjectPermissionsLegacyReq = [1]string{
	0: "permission",
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyReq from json.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateProjectPermissionsLegacyReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateProjectPermissionsLegacyReq")
	}

	return nil
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission as json.
func (s TeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission from json.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateProjectPermissionsLegacyReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateProjectPermissionsLegacyReqPermission(v) {
	case TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionRead:
		*s = TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionRead
	case TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionWrite:
		*s = TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionWrite
	case TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionAdmin:
		*s = TeamsAddOrUpdateProjectPermissionsLegacyReqPermissionAdmin
	default:
		*s = TeamsAddOrUpdateProjectPermissionsLegacyReqPermission(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateRepoPermissionsInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsAddOrUpdateRepoPermissionsInOrgReq = [1]string{
	0: "permission",
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgReq from json.
func (s *TeamsAddOrUpdateRepoPermissionsInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateRepoPermissionsInOrgReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateRepoPermissionsInOrgReq")
	}

	return nil
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission as json.
func (s TeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission from json.
func (s *TeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateRepoPermissionsInOrgReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateRepoPermissionsInOrgReqPermission(v) {
	case TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionPull:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionPull
	case TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionPush:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionPush
	case TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionAdmin:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionAdmin
	case TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionMaintain:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionMaintain
	case TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionTriage:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermissionTriage
	default:
		*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermission(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateRepoPermissionsLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsAddOrUpdateRepoPermissionsLegacyReq = [1]string{
	0: "permission",
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyReq from json.
func (s *TeamsAddOrUpdateRepoPermissionsLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateRepoPermissionsLegacyReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsAddOrUpdateRepoPermissionsLegacyReq")
	}

	return nil
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission as json.
func (s TeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission from json.
func (s *TeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsAddOrUpdateRepoPermissionsLegacyReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsAddOrUpdateRepoPermissionsLegacyReqPermission(v) {
	case TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionPull:
		*s = TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionPull
	case TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionPush:
		*s = TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionPush
	case TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionAdmin:
		*s = TeamsAddOrUpdateRepoPermissionsLegacyReqPermissionAdmin
	default:
		*s = TeamsAddOrUpdateRepoPermissionsLegacyReqPermission(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsCreateDiscussionCommentInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsCreateDiscussionCommentInOrgReq = [1]string{
	0: "body",
}

// Decode decodes TeamsCreateDiscussionCommentInOrgReq from json.
func (s *TeamsCreateDiscussionCommentInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateDiscussionCommentInOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateDiscussionCommentInOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateDiscussionCommentInOrgReq) {
					name = jsonFieldsNameOfTeamsCreateDiscussionCommentInOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsCreateDiscussionCommentLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsCreateDiscussionCommentLegacyReq = [1]string{
	0: "body",
}

// Decode decodes TeamsCreateDiscussionCommentLegacyReq from json.
func (s *TeamsCreateDiscussionCommentLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateDiscussionCommentLegacyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateDiscussionCommentLegacyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateDiscussionCommentLegacyReq) {
					name = jsonFieldsNameOfTeamsCreateDiscussionCommentLegacyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsCreateDiscussionInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		if s.Private.Set {
			e.Comma()
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsCreateDiscussionInOrgReq = [3]string{
	0: "title",
	1: "body",
	2: "private",
}

// Decode decodes TeamsCreateDiscussionInOrgReq from json.
func (s *TeamsCreateDiscussionInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateDiscussionInOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateDiscussionInOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateDiscussionInOrgReq) {
					name = jsonFieldsNameOfTeamsCreateDiscussionInOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsCreateDiscussionLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	{
		if s.Private.Set {
			e.Comma()
		}
		if s.Private.Set {
			e.RawStr("\"private\"" + ":")
			s.Private.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsCreateDiscussionLegacyReq = [3]string{
	0: "title",
	1: "body",
	2: "private",
}

// Decode decodes TeamsCreateDiscussionLegacyReq from json.
func (s *TeamsCreateDiscussionLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateDiscussionLegacyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateDiscussionLegacyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateDiscussionLegacyReq) {
					name = jsonFieldsNameOfTeamsCreateDiscussionLegacyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		{
			if s.Groups != nil {
				if !first {
					e.Comma()
				}
				first = false
			}
			if s.Groups != nil {
				e.RawStr("\"groups\"" + ":")
				e.ArrStart()
				if len(s.Groups) >= 1 {
					// Encode first element without comma.
					{
						elem := s.Groups[0]
						elem.Encode(e)
					}
					for _, elem := range s.Groups[1:] {
						e.Comma()
						elem.Encode(e)
					}
				}
				e.ArrEnd()
			}
		}
	}
	for k, elem := range s.AdditionalProps {
		if !first {
			e.Comma()
		}
		first = false
		e.Str(k)
		e.RawStr(`:`)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsInOrgReq = [1]string{
	0: "groups",
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq to nil")
	}

	m := s.AdditionalProps
	if m == nil {
		m = map[string]jx.Raw{}
		s.AdditionalProps = m
	}
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups":
			if err := func() error {
				s.Groups = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.Raw()
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			m[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"group_id\"" + ":")
		e.Str(s.GroupID)
	}
	{
		e.Comma()

		e.RawStr("\"group_name\"" + ":")
		e.Str(s.GroupName)
	}
	{
		e.Comma()

		e.RawStr("\"group_description\"" + ":")
		e.Str(s.GroupDescription)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem = [3]string{
	0: "group_id",
	1: "group_name",
	2: "group_description",
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GroupID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_id\"")
			}
		case "group_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GroupName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_name\"")
			}
		case "group_description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GroupDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem) {
					name = jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"groups\"" + ":")
		e.ArrStart()
		if len(s.Groups) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Groups[0]
				elem.Encode(e)
			}
			for _, elem := range s.Groups[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		if s.SyncedAt.Set {
			e.Comma()
		}
		if s.SyncedAt.Set {
			e.RawStr("\"synced_at\"" + ":")
			s.SyncedAt.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsLegacyReq = [2]string{
	0: "groups",
	1: "synced_at",
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Groups = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		case "synced_at":
			if err := func() error {
				s.SyncedAt.Reset()
				if err := s.SyncedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synced_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) {
					name = jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsLegacyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"group_id\"" + ":")
		e.Str(s.GroupID)
	}
	{
		e.Comma()

		e.RawStr("\"group_name\"" + ":")
		e.Str(s.GroupName)
	}
	{
		e.Comma()

		e.RawStr("\"group_description\"" + ":")
		e.Str(s.GroupDescription)
	}
	{
		if s.ID.Set {
			e.Comma()
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem = [6]string{
	0: "group_id",
	1: "group_name",
	2: "group_description",
	3: "id",
	4: "name",
	5: "description",
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GroupID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_id\"")
			}
		case "group_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GroupName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_name\"")
			}
		case "group_description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GroupDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_description\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem) {
					name = jsonFieldsNameOfTeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsCreateReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Maintainers != nil {
			e.Comma()
		}
		if s.Maintainers != nil {
			e.RawStr("\"maintainers\"" + ":")
			e.ArrStart()
			if len(s.Maintainers) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Maintainers[0]
					e.Str(elem)
				}
				for _, elem := range s.Maintainers[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RepoNames != nil {
			e.Comma()
		}
		if s.RepoNames != nil {
			e.RawStr("\"repo_names\"" + ":")
			e.ArrStart()
			if len(s.RepoNames) >= 1 {
				// Encode first element without comma.
				{
					elem := s.RepoNames[0]
					e.Str(elem)
				}
				for _, elem := range s.RepoNames[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Privacy.Set {
			e.Comma()
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		if s.Permission.Set {
			e.Comma()
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	{
		if s.ParentTeamID.Set {
			e.Comma()
		}
		if s.ParentTeamID.Set {
			e.RawStr("\"parent_team_id\"" + ":")
			s.ParentTeamID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsCreateReq = [7]string{
	0: "name",
	1: "description",
	2: "maintainers",
	3: "repo_names",
	4: "privacy",
	5: "permission",
	6: "parent_team_id",
}

// Decode decodes TeamsCreateReq from json.
func (s *TeamsCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "maintainers":
			if err := func() error {
				s.Maintainers = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Maintainers = append(s.Maintainers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintainers\"")
			}
		case "repo_names":
			if err := func() error {
				s.RepoNames = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RepoNames = append(s.RepoNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repo_names\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "parent_team_id":
			if err := func() error {
				s.ParentTeamID.Reset()
				if err := s.ParentTeamID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsCreateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsCreateReq) {
					name = jsonFieldsNameOfTeamsCreateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes TeamsCreateReqPermission as json.
func (s TeamsCreateReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsCreateReqPermission from json.
func (s *TeamsCreateReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsCreateReqPermission(v) {
	case TeamsCreateReqPermissionPull:
		*s = TeamsCreateReqPermissionPull
	case TeamsCreateReqPermissionPush:
		*s = TeamsCreateReqPermissionPush
	case TeamsCreateReqPermissionAdmin:
		*s = TeamsCreateReqPermissionAdmin
	default:
		*s = TeamsCreateReqPermission(v)
	}

	return nil
}

// Encode encodes TeamsCreateReqPrivacy as json.
func (s TeamsCreateReqPrivacy) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsCreateReqPrivacy from json.
func (s *TeamsCreateReqPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsCreateReqPrivacy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsCreateReqPrivacy(v) {
	case TeamsCreateReqPrivacySecret:
		*s = TeamsCreateReqPrivacySecret
	case TeamsCreateReqPrivacyClosed:
		*s = TeamsCreateReqPrivacyClosed
	default:
		*s = TeamsCreateReqPrivacy(v)
	}

	return nil
}

// Encode encodes TeamsListChildLegacyApplicationJSONForbidden as json.
func (s TeamsListChildLegacyApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListChildLegacyApplicationJSONForbidden from json.
func (s *TeamsListChildLegacyApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListChildLegacyApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListChildLegacyApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes TeamsListChildLegacyApplicationJSONNotFound as json.
func (s TeamsListChildLegacyApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListChildLegacyApplicationJSONNotFound from json.
func (s *TeamsListChildLegacyApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListChildLegacyApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListChildLegacyApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes TeamsListChildLegacyOKApplicationJSON as json.
func (s TeamsListChildLegacyOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Team(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes TeamsListChildLegacyOKApplicationJSON from json.
func (s *TeamsListChildLegacyOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListChildLegacyOKApplicationJSON to nil")
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListChildLegacyOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes TeamsListForAuthenticatedUserApplicationJSONForbidden as json.
func (s TeamsListForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListForAuthenticatedUserApplicationJSONForbidden from json.
func (s *TeamsListForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes TeamsListForAuthenticatedUserApplicationJSONNotFound as json.
func (s TeamsListForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListForAuthenticatedUserApplicationJSONNotFound from json.
func (s *TeamsListForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListForAuthenticatedUserApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes TeamsListForAuthenticatedUserOKApplicationJSON as json.
func (s TeamsListForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []TeamFull(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes TeamsListForAuthenticatedUserOKApplicationJSON from json.
func (s *TeamsListForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListForAuthenticatedUserOKApplicationJSON to nil")
	}
	var unwrapped []TeamFull
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TeamFull
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes TeamsListIdpGroupsForLegacyApplicationJSONForbidden as json.
func (s TeamsListIdpGroupsForLegacyApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListIdpGroupsForLegacyApplicationJSONForbidden from json.
func (s *TeamsListIdpGroupsForLegacyApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListIdpGroupsForLegacyApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListIdpGroupsForLegacyApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes TeamsListIdpGroupsForLegacyApplicationJSONNotFound as json.
func (s TeamsListIdpGroupsForLegacyApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListIdpGroupsForLegacyApplicationJSONNotFound from json.
func (s *TeamsListIdpGroupsForLegacyApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListIdpGroupsForLegacyApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListIdpGroupsForLegacyApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes TeamsListMembersLegacyOKApplicationJSON as json.
func (s TeamsListMembersLegacyOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes TeamsListMembersLegacyOKApplicationJSON from json.
func (s *TeamsListMembersLegacyOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListMembersLegacyOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListMembersLegacyOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes TeamsListOKApplicationJSON as json.
func (s TeamsListOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Team(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes TeamsListOKApplicationJSON from json.
func (s *TeamsListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListOKApplicationJSON to nil")
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes TeamsListProjectsLegacyOKApplicationJSON as json.
func (s TeamsListProjectsLegacyOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []TeamProject(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes TeamsListProjectsLegacyOKApplicationJSON from json.
func (s *TeamsListProjectsLegacyOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListProjectsLegacyOKApplicationJSON to nil")
	}
	var unwrapped []TeamProject
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TeamProject
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListProjectsLegacyOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes TeamsListReposLegacyOKApplicationJSON as json.
func (s TeamsListReposLegacyOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes TeamsListReposLegacyOKApplicationJSON from json.
func (s *TeamsListReposLegacyOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsListReposLegacyOKApplicationJSON to nil")
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListReposLegacyOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s TeamsUpdateDiscussionCommentInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsUpdateDiscussionCommentInOrgReq = [1]string{
	0: "body",
}

// Decode decodes TeamsUpdateDiscussionCommentInOrgReq from json.
func (s *TeamsUpdateDiscussionCommentInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateDiscussionCommentInOrgReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsUpdateDiscussionCommentInOrgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsUpdateDiscussionCommentInOrgReq) {
					name = jsonFieldsNameOfTeamsUpdateDiscussionCommentInOrgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsUpdateDiscussionCommentLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"body\"" + ":")
		e.Str(s.Body)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsUpdateDiscussionCommentLegacyReq = [1]string{
	0: "body",
}

// Decode decodes TeamsUpdateDiscussionCommentLegacyReq from json.
func (s *TeamsUpdateDiscussionCommentLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateDiscussionCommentLegacyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsUpdateDiscussionCommentLegacyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsUpdateDiscussionCommentLegacyReq) {
					name = jsonFieldsNameOfTeamsUpdateDiscussionCommentLegacyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsUpdateDiscussionInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsUpdateDiscussionInOrgReq = [2]string{
	0: "title",
	1: "body",
}

// Decode decodes TeamsUpdateDiscussionInOrgReq from json.
func (s *TeamsUpdateDiscussionInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateDiscussionInOrgReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsUpdateDiscussionInOrgReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsUpdateDiscussionLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if s.Body.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Body.Set {
			e.RawStr("\"body\"" + ":")
			s.Body.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsUpdateDiscussionLegacyReq = [2]string{
	0: "title",
	1: "body",
}

// Decode decodes TeamsUpdateDiscussionLegacyReq from json.
func (s *TeamsUpdateDiscussionLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateDiscussionLegacyReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsUpdateDiscussionLegacyReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TeamsUpdateInOrgReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Privacy.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		if s.Permission.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	{
		if s.ParentTeamID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ParentTeamID.Set {
			e.RawStr("\"parent_team_id\"" + ":")
			s.ParentTeamID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsUpdateInOrgReq = [5]string{
	0: "name",
	1: "description",
	2: "privacy",
	3: "permission",
	4: "parent_team_id",
}

// Decode decodes TeamsUpdateInOrgReq from json.
func (s *TeamsUpdateInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateInOrgReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "parent_team_id":
			if err := func() error {
				s.ParentTeamID.Reset()
				if err := s.ParentTeamID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsUpdateInOrgReq")
	}

	return nil
}

// Encode encodes TeamsUpdateInOrgReqPermission as json.
func (s TeamsUpdateInOrgReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateInOrgReqPermission from json.
func (s *TeamsUpdateInOrgReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateInOrgReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsUpdateInOrgReqPermission(v) {
	case TeamsUpdateInOrgReqPermissionPull:
		*s = TeamsUpdateInOrgReqPermissionPull
	case TeamsUpdateInOrgReqPermissionPush:
		*s = TeamsUpdateInOrgReqPermissionPush
	case TeamsUpdateInOrgReqPermissionAdmin:
		*s = TeamsUpdateInOrgReqPermissionAdmin
	default:
		*s = TeamsUpdateInOrgReqPermission(v)
	}

	return nil
}

// Encode encodes TeamsUpdateInOrgReqPrivacy as json.
func (s TeamsUpdateInOrgReqPrivacy) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateInOrgReqPrivacy from json.
func (s *TeamsUpdateInOrgReqPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateInOrgReqPrivacy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsUpdateInOrgReqPrivacy(v) {
	case TeamsUpdateInOrgReqPrivacySecret:
		*s = TeamsUpdateInOrgReqPrivacySecret
	case TeamsUpdateInOrgReqPrivacyClosed:
		*s = TeamsUpdateInOrgReqPrivacyClosed
	default:
		*s = TeamsUpdateInOrgReqPrivacy(v)
	}

	return nil
}

// Encode encodes TeamsUpdateLegacyApplicationJSONCreated as json.
func (s TeamsUpdateLegacyApplicationJSONCreated) Encode(e *jx.Writer) {
	unwrapped := TeamFull(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsUpdateLegacyApplicationJSONCreated from json.
func (s *TeamsUpdateLegacyApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateLegacyApplicationJSONCreated to nil")
	}
	var unwrapped TeamFull
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsUpdateLegacyApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes TeamsUpdateLegacyApplicationJSONForbidden as json.
func (s TeamsUpdateLegacyApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsUpdateLegacyApplicationJSONForbidden from json.
func (s *TeamsUpdateLegacyApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateLegacyApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsUpdateLegacyApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes TeamsUpdateLegacyApplicationJSONNotFound as json.
func (s TeamsUpdateLegacyApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsUpdateLegacyApplicationJSONNotFound from json.
func (s *TeamsUpdateLegacyApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateLegacyApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsUpdateLegacyApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes TeamsUpdateLegacyApplicationJSONOK as json.
func (s TeamsUpdateLegacyApplicationJSONOK) Encode(e *jx.Writer) {
	unwrapped := TeamFull(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsUpdateLegacyApplicationJSONOK from json.
func (s *TeamsUpdateLegacyApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateLegacyApplicationJSONOK to nil")
	}
	var unwrapped TeamFull
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsUpdateLegacyApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s TeamsUpdateLegacyReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.Comma()
		}
		if s.Description.Set {
			e.RawStr("\"description\"" + ":")
			s.Description.Encode(e)
		}
	}
	{
		if s.Privacy.Set {
			e.Comma()
		}
		if s.Privacy.Set {
			e.RawStr("\"privacy\"" + ":")
			s.Privacy.Encode(e)
		}
	}
	{
		if s.Permission.Set {
			e.Comma()
		}
		if s.Permission.Set {
			e.RawStr("\"permission\"" + ":")
			s.Permission.Encode(e)
		}
	}
	{
		if s.ParentTeamID.Set {
			e.Comma()
		}
		if s.ParentTeamID.Set {
			e.RawStr("\"parent_team_id\"" + ":")
			s.ParentTeamID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTeamsUpdateLegacyReq = [5]string{
	0: "name",
	1: "description",
	2: "privacy",
	3: "permission",
	4: "parent_team_id",
}

// Decode decodes TeamsUpdateLegacyReq from json.
func (s *TeamsUpdateLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateLegacyReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "privacy":
			if err := func() error {
				s.Privacy.Reset()
				if err := s.Privacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privacy\"")
			}
		case "permission":
			if err := func() error {
				s.Permission.Reset()
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		case "parent_team_id":
			if err := func() error {
				s.ParentTeamID.Reset()
				if err := s.ParentTeamID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamsUpdateLegacyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamsUpdateLegacyReq) {
					name = jsonFieldsNameOfTeamsUpdateLegacyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes TeamsUpdateLegacyReqPermission as json.
func (s TeamsUpdateLegacyReqPermission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateLegacyReqPermission from json.
func (s *TeamsUpdateLegacyReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateLegacyReqPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsUpdateLegacyReqPermission(v) {
	case TeamsUpdateLegacyReqPermissionPull:
		*s = TeamsUpdateLegacyReqPermissionPull
	case TeamsUpdateLegacyReqPermissionPush:
		*s = TeamsUpdateLegacyReqPermissionPush
	case TeamsUpdateLegacyReqPermissionAdmin:
		*s = TeamsUpdateLegacyReqPermissionAdmin
	default:
		*s = TeamsUpdateLegacyReqPermission(v)
	}

	return nil
}

// Encode encodes TeamsUpdateLegacyReqPrivacy as json.
func (s TeamsUpdateLegacyReqPrivacy) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateLegacyReqPrivacy from json.
func (s *TeamsUpdateLegacyReqPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsUpdateLegacyReqPrivacy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TeamsUpdateLegacyReqPrivacy(v) {
	case TeamsUpdateLegacyReqPrivacySecret:
		*s = TeamsUpdateLegacyReqPrivacySecret
	case TeamsUpdateLegacyReqPrivacyClosed:
		*s = TeamsUpdateLegacyReqPrivacyClosed
	default:
		*s = TeamsUpdateLegacyReqPrivacy(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Thread) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"subject\"" + ":")
		s.Subject.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"reason\"" + ":")
		e.Str(s.Reason)
	}
	{
		e.Comma()

		e.RawStr("\"unread\"" + ":")
		e.Bool(s.Unread)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		e.Str(s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"last_read_at\"" + ":")
		s.LastReadAt.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"subscription_url\"" + ":")
		e.Str(s.SubscriptionURL)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfThread = [9]string{
	0: "id",
	1: "repository",
	2: "subject",
	3: "reason",
	4: "unread",
	5: "updated_at",
	6: "last_read_at",
	7: "url",
	8: "subscription_url",
}

// Decode decodes Thread from json.
func (s *Thread) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Thread to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "repository":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "subject":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Subject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subject\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "unread":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Unread = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unread\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "last_read_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.LastReadAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_read_at\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "subscription_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Thread")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfThread) {
					name = jsonFieldsNameOfThread[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ThreadSubject) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"title\"" + ":")
		e.Str(s.Title)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"latest_comment_url\"" + ":")
		e.Str(s.LatestCommentURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfThreadSubject = [4]string{
	0: "title",
	1: "url",
	2: "latest_comment_url",
	3: "type",
}

// Decode decodes ThreadSubject from json.
func (s *ThreadSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadSubject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "latest_comment_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.LatestCommentURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_comment_url\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ThreadSubject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfThreadSubject) {
					name = jsonFieldsNameOfThreadSubject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ThreadSubscription) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"subscribed\"" + ":")
		e.Bool(s.Subscribed)
	}
	{
		e.Comma()

		e.RawStr("\"ignored\"" + ":")
		e.Bool(s.Ignored)
	}
	{
		e.Comma()

		e.RawStr("\"reason\"" + ":")
		s.Reason.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		if s.ThreadURL.Set {
			e.Comma()
		}
		if s.ThreadURL.Set {
			e.RawStr("\"thread_url\"" + ":")
			s.ThreadURL.Encode(e)
		}
	}
	{
		if s.RepositoryURL.Set {
			e.Comma()
		}
		if s.RepositoryURL.Set {
			e.RawStr("\"repository_url\"" + ":")
			s.RepositoryURL.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfThreadSubscription = [7]string{
	0: "subscribed",
	1: "ignored",
	2: "reason",
	3: "created_at",
	4: "url",
	5: "thread_url",
	6: "repository_url",
}

// Decode decodes ThreadSubscription from json.
func (s *ThreadSubscription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadSubscription to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscribed":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Subscribed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscribed\"")
			}
		case "ignored":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Ignored = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignored\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "thread_url":
			if err := func() error {
				s.ThreadURL.Reset()
				if err := s.ThreadURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_url\"")
			}
		case "repository_url":
			if err := func() error {
				s.RepositoryURL.Reset()
				if err := s.RepositoryURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ThreadSubscription")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfThreadSubscription) {
					name = jsonFieldsNameOfThreadSubscription[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Topic) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"names\"" + ":")
		e.ArrStart()
		if len(s.Names) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Names[0]
				e.Str(elem)
			}
			for _, elem := range s.Names[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTopic = [1]string{
	0: "names",
}

// Decode decodes Topic from json.
func (s *Topic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Topic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "names":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Names = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Names = append(s.Names, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"names\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Topic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTopic) {
					name = jsonFieldsNameOfTopic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TopicSearchResultItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"display_name\"" + ":")
		s.DisplayName.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"short_description\"" + ":")
		s.ShortDescription.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"description\"" + ":")
		s.Description.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_by\"" + ":")
		s.CreatedBy.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"released\"" + ":")
		s.Released.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"featured\"" + ":")
		e.Bool(s.Featured)
	}
	{
		e.Comma()

		e.RawStr("\"curated\"" + ":")
		e.Bool(s.Curated)
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Float64(s.Score)
	}
	{
		if s.RepositoryCount.Set {
			e.Comma()
		}
		if s.RepositoryCount.Set {
			e.RawStr("\"repository_count\"" + ":")
			s.RepositoryCount.Encode(e)
		}
	}
	{
		if s.LogoURL.Set {
			e.Comma()
		}
		if s.LogoURL.Set {
			e.RawStr("\"logo_url\"" + ":")
			s.LogoURL.Encode(e)
		}
	}
	{
		if s.TextMatches != nil {
			e.Comma()
		}
		if s.TextMatches != nil {
			e.RawStr("\"text_matches\"" + ":")
			s.TextMatches.Encode(e)
		}
	}
	{
		if s.Related.Set {
			e.Comma()
		}
		if s.Related.Set {
			e.RawStr("\"related\"" + ":")
			s.Related.Encode(e)
		}
	}
	{
		if s.Aliases.Set {
			e.Comma()
		}
		if s.Aliases.Set {
			e.RawStr("\"aliases\"" + ":")
			s.Aliases.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTopicSearchResultItem = [16]string{
	0:  "name",
	1:  "display_name",
	2:  "short_description",
	3:  "description",
	4:  "created_by",
	5:  "released",
	6:  "created_at",
	7:  "updated_at",
	8:  "featured",
	9:  "curated",
	10: "score",
	11: "repository_count",
	12: "logo_url",
	13: "text_matches",
	14: "related",
	15: "aliases",
}

// Decode decodes TopicSearchResultItem from json.
func (s *TopicSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TopicSearchResultItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "short_description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ShortDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"short_description\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "created_by":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "released":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Released.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"released\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "featured":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Featured = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featured\"")
			}
		case "curated":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Curated = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"curated\"")
			}
		case "score":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Score = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "repository_count":
			if err := func() error {
				s.RepositoryCount.Reset()
				if err := s.RepositoryCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository_count\"")
			}
		case "logo_url":
			if err := func() error {
				s.LogoURL.Reset()
				if err := s.LogoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logo_url\"")
			}
		case "text_matches":
			if err := func() error {
				s.TextMatches = nil
				var elem SearchResultTextMatches
				{
					var unwrapped []SearchResultTextMatchesItem
					unwrapped = nil
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem SearchResultTextMatchesItem
						if err := elem.Decode(d); err != nil {
							return err
						}
						unwrapped = append(unwrapped, elem)
						return nil
					}); err != nil {
						return err
					}
					elem = SearchResultTextMatches(unwrapped)
				}
				s.TextMatches = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_matches\"")
			}
		case "related":
			if err := func() error {
				s.Related.Reset()
				if err := s.Related.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"related\"")
			}
		case "aliases":
			if err := func() error {
				s.Aliases.Reset()
				if err := s.Aliases.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aliases\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TopicSearchResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTopicSearchResultItem) {
					name = jsonFieldsNameOfTopicSearchResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TopicSearchResultItemAliasesItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.TopicRelation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TopicRelation.Set {
			e.RawStr("\"topic_relation\"" + ":")
			s.TopicRelation.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTopicSearchResultItemAliasesItem = [1]string{
	0: "topic_relation",
}

// Decode decodes TopicSearchResultItemAliasesItem from json.
func (s *TopicSearchResultItemAliasesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TopicSearchResultItemAliasesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "topic_relation":
			if err := func() error {
				s.TopicRelation.Reset()
				if err := s.TopicRelation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topic_relation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TopicSearchResultItemAliasesItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TopicSearchResultItemAliasesItemTopicRelation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.TopicID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TopicID.Set {
			e.RawStr("\"topic_id\"" + ":")
			s.TopicID.Encode(e)
		}
	}
	{
		if s.RelationType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RelationType.Set {
			e.RawStr("\"relation_type\"" + ":")
			s.RelationType.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTopicSearchResultItemAliasesItemTopicRelation = [4]string{
	0: "id",
	1: "name",
	2: "topic_id",
	3: "relation_type",
}

// Decode decodes TopicSearchResultItemAliasesItemTopicRelation from json.
func (s *TopicSearchResultItemAliasesItemTopicRelation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TopicSearchResultItemAliasesItemTopicRelation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "topic_id":
			if err := func() error {
				s.TopicID.Reset()
				if err := s.TopicID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topic_id\"")
			}
		case "relation_type":
			if err := func() error {
				s.RelationType.Reset()
				if err := s.RelationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relation_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TopicSearchResultItemAliasesItemTopicRelation")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TopicSearchResultItemRelatedItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.TopicRelation.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TopicRelation.Set {
			e.RawStr("\"topic_relation\"" + ":")
			s.TopicRelation.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTopicSearchResultItemRelatedItem = [1]string{
	0: "topic_relation",
}

// Decode decodes TopicSearchResultItemRelatedItem from json.
func (s *TopicSearchResultItemRelatedItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TopicSearchResultItemRelatedItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "topic_relation":
			if err := func() error {
				s.TopicRelation.Reset()
				if err := s.TopicRelation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topic_relation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TopicSearchResultItemRelatedItem")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TopicSearchResultItemRelatedItemTopicRelation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.ID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ID.Set {
			e.RawStr("\"id\"" + ":")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.TopicID.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TopicID.Set {
			e.RawStr("\"topic_id\"" + ":")
			s.TopicID.Encode(e)
		}
	}
	{
		if s.RelationType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.RelationType.Set {
			e.RawStr("\"relation_type\"" + ":")
			s.RelationType.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTopicSearchResultItemRelatedItemTopicRelation = [4]string{
	0: "id",
	1: "name",
	2: "topic_id",
	3: "relation_type",
}

// Decode decodes TopicSearchResultItemRelatedItemTopicRelation from json.
func (s *TopicSearchResultItemRelatedItemTopicRelation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TopicSearchResultItemRelatedItemTopicRelation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "topic_id":
			if err := func() error {
				s.TopicID.Reset()
				if err := s.TopicID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topic_id\"")
			}
		case "relation_type":
			if err := func() error {
				s.RelationType.Reset()
				if err := s.RelationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"relation_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TopicSearchResultItemRelatedItemTopicRelation")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Traffic) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"timestamp\"" + ":")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		e.Comma()

		e.RawStr("\"uniques\"" + ":")
		e.Int(s.Uniques)
	}
	{
		e.Comma()

		e.RawStr("\"count\"" + ":")
		e.Int(s.Count)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTraffic = [3]string{
	0: "timestamp",
	1: "uniques",
	2: "count",
}

// Decode decodes Traffic from json.
func (s *Traffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Traffic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "uniques":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Uniques = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniques\"")
			}
		case "count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Traffic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTraffic) {
					name = jsonFieldsNameOfTraffic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserMarketplacePurchase) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"billing_cycle\"" + ":")
		e.Str(s.BillingCycle)
	}
	{
		e.Comma()

		e.RawStr("\"next_billing_date\"" + ":")
		s.NextBillingDate.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"unit_count\"" + ":")
		s.UnitCount.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"on_free_trial\"" + ":")
		e.Bool(s.OnFreeTrial)
	}
	{
		e.Comma()

		e.RawStr("\"free_trial_ends_on\"" + ":")
		s.FreeTrialEndsOn.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.Comma()

		e.RawStr("\"account\"" + ":")
		s.Account.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"plan\"" + ":")
		s.Plan.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserMarketplacePurchase = [8]string{
	0: "billing_cycle",
	1: "next_billing_date",
	2: "unit_count",
	3: "on_free_trial",
	4: "free_trial_ends_on",
	5: "updated_at",
	6: "account",
	7: "plan",
}

// Decode decodes UserMarketplacePurchase from json.
func (s *UserMarketplacePurchase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserMarketplacePurchase to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billing_cycle":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BillingCycle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billing_cycle\"")
			}
		case "next_billing_date":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NextBillingDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_billing_date\"")
			}
		case "unit_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.UnitCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unit_count\"")
			}
		case "on_free_trial":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.OnFreeTrial = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"on_free_trial\"")
			}
		case "free_trial_ends_on":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.FreeTrialEndsOn.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"free_trial_ends_on\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "account":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Account.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account\"")
			}
		case "plan":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserMarketplacePurchase")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserMarketplacePurchase) {
					name = jsonFieldsNameOfUserMarketplacePurchase[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserSearchResultItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"login\"" + ":")
		e.Str(s.Login)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"avatar_url\"" + ":")
		json.EncodeURI(e, s.AvatarURL)
	}
	{
		e.Comma()

		e.RawStr("\"gravatar_id\"" + ":")
		s.GravatarID.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		json.EncodeURI(e, s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		json.EncodeURI(e, s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"followers_url\"" + ":")
		json.EncodeURI(e, s.FollowersURL)
	}
	{
		e.Comma()

		e.RawStr("\"subscriptions_url\"" + ":")
		json.EncodeURI(e, s.SubscriptionsURL)
	}
	{
		e.Comma()

		e.RawStr("\"organizations_url\"" + ":")
		json.EncodeURI(e, s.OrganizationsURL)
	}
	{
		e.Comma()

		e.RawStr("\"repos_url\"" + ":")
		json.EncodeURI(e, s.ReposURL)
	}
	{
		e.Comma()

		e.RawStr("\"received_events_url\"" + ":")
		json.EncodeURI(e, s.ReceivedEventsURL)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		e.Str(s.Type)
	}
	{
		e.Comma()

		e.RawStr("\"score\"" + ":")
		e.Float64(s.Score)
	}
	{
		e.Comma()

		e.RawStr("\"following_url\"" + ":")
		e.Str(s.FollowingURL)
	}
	{
		e.Comma()

		e.RawStr("\"gists_url\"" + ":")
		e.Str(s.GistsURL)
	}
	{
		e.Comma()

		e.RawStr("\"starred_url\"" + ":")
		e.Str(s.StarredURL)
	}
	{
		e.Comma()

		e.RawStr("\"events_url\"" + ":")
		e.Str(s.EventsURL)
	}
	{
		if s.PublicRepos.Set {
			e.Comma()
		}
		if s.PublicRepos.Set {
			e.RawStr("\"public_repos\"" + ":")
			s.PublicRepos.Encode(e)
		}
	}
	{
		if s.PublicGists.Set {
			e.Comma()
		}
		if s.PublicGists.Set {
			e.RawStr("\"public_gists\"" + ":")
			s.PublicGists.Encode(e)
		}
	}
	{
		if s.Followers.Set {
			e.Comma()
		}
		if s.Followers.Set {
			e.RawStr("\"followers\"" + ":")
			s.Followers.Encode(e)
		}
	}
	{
		if s.Following.Set {
			e.Comma()
		}
		if s.Following.Set {
			e.RawStr("\"following\"" + ":")
			s.Following.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.Comma()
		}
		if s.CreatedAt.Set {
			e.RawStr("\"created_at\"" + ":")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.Comma()
		}
		if s.UpdatedAt.Set {
			e.RawStr("\"updated_at\"" + ":")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.Comma()
		}
		if s.Bio.Set {
			e.RawStr("\"bio\"" + ":")
			s.Bio.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.Comma()
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Location.Set {
			e.Comma()
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"site_admin\"" + ":")
		e.Bool(s.SiteAdmin)
	}
	{
		if s.Hireable.Set {
			e.Comma()
		}
		if s.Hireable.Set {
			e.RawStr("\"hireable\"" + ":")
			s.Hireable.Encode(e)
		}
	}
	{
		if s.TextMatches != nil {
			e.Comma()
		}
		if s.TextMatches != nil {
			e.RawStr("\"text_matches\"" + ":")
			s.TextMatches.Encode(e)
		}
	}
	{
		if s.Blog.Set {
			e.Comma()
		}
		if s.Blog.Set {
			e.RawStr("\"blog\"" + ":")
			s.Blog.Encode(e)
		}
	}
	{
		if s.Company.Set {
			e.Comma()
		}
		if s.Company.Set {
			e.RawStr("\"company\"" + ":")
			s.Company.Encode(e)
		}
	}
	{
		if s.SuspendedAt.Set {
			e.Comma()
		}
		if s.SuspendedAt.Set {
			e.RawStr("\"suspended_at\"" + ":")
			s.SuspendedAt.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserSearchResultItem = [34]string{
	0:  "login",
	1:  "id",
	2:  "node_id",
	3:  "avatar_url",
	4:  "gravatar_id",
	5:  "url",
	6:  "html_url",
	7:  "followers_url",
	8:  "subscriptions_url",
	9:  "organizations_url",
	10: "repos_url",
	11: "received_events_url",
	12: "type",
	13: "score",
	14: "following_url",
	15: "gists_url",
	16: "starred_url",
	17: "events_url",
	18: "public_repos",
	19: "public_gists",
	20: "followers",
	21: "following",
	22: "created_at",
	23: "updated_at",
	24: "name",
	25: "bio",
	26: "email",
	27: "location",
	28: "site_admin",
	29: "hireable",
	30: "text_matches",
	31: "blog",
	32: "company",
	33: "suspended_at",
}

// Decode decodes UserSearchResultItem from json.
func (s *UserSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserSearchResultItem to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Login = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"login\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.AvatarURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "gravatar_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.GravatarID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gravatar_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.HTMLURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "followers_url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.FollowersURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers_url\"")
			}
		case "subscriptions_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.SubscriptionsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions_url\"")
			}
		case "organizations_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.OrganizationsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizations_url\"")
			}
		case "repos_url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReposURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repos_url\"")
			}
		case "received_events_url":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.ReceivedEventsURL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_events_url\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "score":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.Score = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "following_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.FollowingURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following_url\"")
			}
		case "gists_url":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.GistsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gists_url\"")
			}
		case "starred_url":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.StarredURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"starred_url\"")
			}
		case "events_url":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_url\"")
			}
		case "public_repos":
			if err := func() error {
				s.PublicRepos.Reset()
				if err := s.PublicRepos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_repos\"")
			}
		case "public_gists":
			if err := func() error {
				s.PublicGists.Reset()
				if err := s.PublicGists.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_gists\"")
			}
		case "followers":
			if err := func() error {
				s.Followers.Reset()
				if err := s.Followers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers\"")
			}
		case "following":
			if err := func() error {
				s.Following.Reset()
				if err := s.Following.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"following\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "site_admin":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.SiteAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"site_admin\"")
			}
		case "hireable":
			if err := func() error {
				s.Hireable.Reset()
				if err := s.Hireable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hireable\"")
			}
		case "text_matches":
			if err := func() error {
				s.TextMatches = nil
				var elem SearchResultTextMatches
				{
					var unwrapped []SearchResultTextMatchesItem
					unwrapped = nil
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem SearchResultTextMatchesItem
						if err := elem.Decode(d); err != nil {
							return err
						}
						unwrapped = append(unwrapped, elem)
						return nil
					}); err != nil {
						return err
					}
					elem = SearchResultTextMatches(unwrapped)
				}
				s.TextMatches = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_matches\"")
			}
		case "blog":
			if err := func() error {
				s.Blog.Reset()
				if err := s.Blog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blog\"")
			}
		case "company":
			if err := func() error {
				s.Company.Reset()
				if err := s.Company.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"company\"")
			}
		case "suspended_at":
			if err := func() error {
				s.SuspendedAt.Reset()
				if err := s.SuspendedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"suspended_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserSearchResultItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b11111111,
		0b11111111,
		0b00000011,
		0b00010000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserSearchResultItem) {
					name = jsonFieldsNameOfUserSearchResultItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes UsersAddEmailForAuthenticatedApplicationJSONForbidden as json.
func (s UsersAddEmailForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersAddEmailForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersAddEmailForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersAddEmailForAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersAddEmailForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersAddEmailForAuthenticatedApplicationJSONNotFound as json.
func (s UsersAddEmailForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersAddEmailForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersAddEmailForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersAddEmailForAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersAddEmailForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersAddEmailForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersAddEmailForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersAddEmailForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersAddEmailForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersAddEmailForAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersAddEmailForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersAddEmailForAuthenticatedCreatedApplicationJSON as json.
func (s UsersAddEmailForAuthenticatedCreatedApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Email(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersAddEmailForAuthenticatedCreatedApplicationJSON from json.
func (s *UsersAddEmailForAuthenticatedCreatedApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersAddEmailForAuthenticatedCreatedApplicationJSON to nil")
	}
	var unwrapped []Email
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Email
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersAddEmailForAuthenticatedCreatedApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersAddEmailForAuthenticatedReq as json.
func (s UsersAddEmailForAuthenticatedReq) Encode(e *jx.Writer) {
	switch s.Type {
	case UsersAddEmailForAuthenticatedReq0UsersAddEmailForAuthenticatedReq:
		s.UsersAddEmailForAuthenticatedReq0.Encode(e)
	case ArrayStringUsersAddEmailForAuthenticatedReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	case StringUsersAddEmailForAuthenticatedReq:
		e.Str(s.String)
	}
}

// Decode decodes UsersAddEmailForAuthenticatedReq from json.
func (s *UsersAddEmailForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersAddEmailForAuthenticatedReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.UsersAddEmailForAuthenticatedReq0.Decode(d); err != nil {
			return err
		}
		s.Type = UsersAddEmailForAuthenticatedReq0UsersAddEmailForAuthenticatedReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringUsersAddEmailForAuthenticatedReq
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringUsersAddEmailForAuthenticatedReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s UsersAddEmailForAuthenticatedReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"emails\"" + ":")
		e.ArrStart()
		if len(s.Emails) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Emails[0]
				e.Str(elem)
			}
			for _, elem := range s.Emails[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUsersAddEmailForAuthenticatedReq0 = [1]string{
	0: "emails",
}

// Decode decodes UsersAddEmailForAuthenticatedReq0 from json.
func (s *UsersAddEmailForAuthenticatedReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersAddEmailForAuthenticatedReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "emails":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Emails = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersAddEmailForAuthenticatedReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsersAddEmailForAuthenticatedReq0) {
					name = jsonFieldsNameOfUsersAddEmailForAuthenticatedReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes UsersBlockApplicationJSONForbidden as json.
func (s UsersBlockApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersBlockApplicationJSONForbidden from json.
func (s *UsersBlockApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBlockApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersBlockApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersBlockApplicationJSONNotFound as json.
func (s UsersBlockApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersBlockApplicationJSONNotFound from json.
func (s *UsersBlockApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBlockApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersBlockApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersBlockApplicationJSONUnauthorized as json.
func (s UsersBlockApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersBlockApplicationJSONUnauthorized from json.
func (s *UsersBlockApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBlockApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersBlockApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersCheckBlockedApplicationJSONForbidden as json.
func (s UsersCheckBlockedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckBlockedApplicationJSONForbidden from json.
func (s *UsersCheckBlockedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCheckBlockedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckBlockedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersCheckBlockedApplicationJSONNotFound as json.
func (s UsersCheckBlockedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckBlockedApplicationJSONNotFound from json.
func (s *UsersCheckBlockedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCheckBlockedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckBlockedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersCheckBlockedApplicationJSONUnauthorized as json.
func (s UsersCheckBlockedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckBlockedApplicationJSONUnauthorized from json.
func (s *UsersCheckBlockedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCheckBlockedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckBlockedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden as json.
func (s UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden from json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound as json.
func (s UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound from json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersCreateGpgKeyForAuthenticatedApplicationJSONForbidden as json.
func (s UsersCreateGpgKeyForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCreateGpgKeyForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersCreateGpgKeyForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreateGpgKeyForAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreateGpgKeyForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersCreateGpgKeyForAuthenticatedApplicationJSONNotFound as json.
func (s UsersCreateGpgKeyForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCreateGpgKeyForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersCreateGpgKeyForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreateGpgKeyForAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreateGpgKeyForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersCreateGpgKeyForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersCreateGpgKeyForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCreateGpgKeyForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersCreateGpgKeyForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreateGpgKeyForAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreateGpgKeyForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersCreateGpgKeyForAuthenticatedReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"armored_public_key\"" + ":")
		e.Str(s.ArmoredPublicKey)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUsersCreateGpgKeyForAuthenticatedReq = [1]string{
	0: "armored_public_key",
}

// Decode decodes UsersCreateGpgKeyForAuthenticatedReq from json.
func (s *UsersCreateGpgKeyForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreateGpgKeyForAuthenticatedReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "armored_public_key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ArmoredPublicKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armored_public_key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersCreateGpgKeyForAuthenticatedReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsersCreateGpgKeyForAuthenticatedReq) {
					name = jsonFieldsNameOfUsersCreateGpgKeyForAuthenticatedReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONForbidden as json.
func (s UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONNotFound as json.
func (s UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersCreatePublicSSHKeyForAuthenticatedReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Title.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Title.Set {
			e.RawStr("\"title\"" + ":")
			s.Title.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"key\"" + ":")
		e.Str(s.Key)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUsersCreatePublicSSHKeyForAuthenticatedReq = [2]string{
	0: "title",
	1: "key",
}

// Decode decodes UsersCreatePublicSSHKeyForAuthenticatedReq from json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersCreatePublicSSHKeyForAuthenticatedReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersCreatePublicSSHKeyForAuthenticatedReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsersCreatePublicSSHKeyForAuthenticatedReq) {
					name = jsonFieldsNameOfUsersCreatePublicSSHKeyForAuthenticatedReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes UsersDeleteEmailForAuthenticatedApplicationJSONForbidden as json.
func (s UsersDeleteEmailForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteEmailForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersDeleteEmailForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteEmailForAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteEmailForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersDeleteEmailForAuthenticatedApplicationJSONNotFound as json.
func (s UsersDeleteEmailForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteEmailForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersDeleteEmailForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteEmailForAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteEmailForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersDeleteEmailForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersDeleteEmailForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteEmailForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersDeleteEmailForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteEmailForAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteEmailForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersDeleteEmailForAuthenticatedReq as json.
func (s UsersDeleteEmailForAuthenticatedReq) Encode(e *jx.Writer) {
	switch s.Type {
	case UsersDeleteEmailForAuthenticatedReq0UsersDeleteEmailForAuthenticatedReq:
		s.UsersDeleteEmailForAuthenticatedReq0.Encode(e)
	case ArrayStringUsersDeleteEmailForAuthenticatedReq:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	case StringUsersDeleteEmailForAuthenticatedReq:
		e.Str(s.String)
	}
}

// Decode decodes UsersDeleteEmailForAuthenticatedReq from json.
func (s *UsersDeleteEmailForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteEmailForAuthenticatedReq to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.UsersDeleteEmailForAuthenticatedReq0.Decode(d); err != nil {
			return err
		}
		s.Type = UsersDeleteEmailForAuthenticatedReq0UsersDeleteEmailForAuthenticatedReq
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringUsersDeleteEmailForAuthenticatedReq
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringUsersDeleteEmailForAuthenticatedReq
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s UsersDeleteEmailForAuthenticatedReq0) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"emails\"" + ":")
		e.ArrStart()
		if len(s.Emails) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Emails[0]
				e.Str(elem)
			}
			for _, elem := range s.Emails[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUsersDeleteEmailForAuthenticatedReq0 = [1]string{
	0: "emails",
}

// Decode decodes UsersDeleteEmailForAuthenticatedReq0 from json.
func (s *UsersDeleteEmailForAuthenticatedReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteEmailForAuthenticatedReq0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "emails":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Emails = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersDeleteEmailForAuthenticatedReq0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsersDeleteEmailForAuthenticatedReq0) {
					name = jsonFieldsNameOfUsersDeleteEmailForAuthenticatedReq0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes UsersDeleteGpgKeyForAuthenticatedApplicationJSONForbidden as json.
func (s UsersDeleteGpgKeyForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteGpgKeyForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersDeleteGpgKeyForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteGpgKeyForAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteGpgKeyForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersDeleteGpgKeyForAuthenticatedApplicationJSONNotFound as json.
func (s UsersDeleteGpgKeyForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteGpgKeyForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersDeleteGpgKeyForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteGpgKeyForAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteGpgKeyForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersDeleteGpgKeyForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersDeleteGpgKeyForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeleteGpgKeyForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersDeleteGpgKeyForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeleteGpgKeyForAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeleteGpgKeyForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden as json.
func (s UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound as json.
func (s UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersFollowApplicationJSONForbidden as json.
func (s UsersFollowApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersFollowApplicationJSONForbidden from json.
func (s *UsersFollowApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersFollowApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersFollowApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersFollowApplicationJSONNotFound as json.
func (s UsersFollowApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersFollowApplicationJSONNotFound from json.
func (s *UsersFollowApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersFollowApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersFollowApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersFollowApplicationJSONUnauthorized as json.
func (s UsersFollowApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersFollowApplicationJSONUnauthorized from json.
func (s *UsersFollowApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersFollowApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersFollowApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersGetAuthenticatedApplicationJSONForbidden as json.
func (s UsersGetAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetAuthenticatedApplicationJSONForbidden from json.
func (s *UsersGetAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersGetAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersGetAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersGetAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersGetAuthenticatedOK as json.
func (s UsersGetAuthenticatedOK) Encode(e *jx.Writer) {
	switch s.Type {
	case PrivateUserUsersGetAuthenticatedOK:
		s.PrivateUser.Encode(e)
	case PublicUserUsersGetAuthenticatedOK:
		s.PublicUser.Encode(e)
	}
}

// Decode decodes UsersGetAuthenticatedOK from json.
func (s *UsersGetAuthenticatedOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetAuthenticatedOK to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "two_factor_authentication":
				found = true
				s.Type = PrivateUserUsersGetAuthenticatedOK
			case "business_plus":
				found = true
				s.Type = PrivateUserUsersGetAuthenticatedOK
			case "ldap_dn":
				found = true
				s.Type = PrivateUserUsersGetAuthenticatedOK
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		s.Type = PublicUserUsersGetAuthenticatedOK
	}
	switch s.Type {
	case PrivateUserUsersGetAuthenticatedOK:
		if err := s.PrivateUser.Decode(d); err != nil {
			return err
		}
	case PublicUserUsersGetAuthenticatedOK:
		if err := s.PublicUser.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode encodes UsersGetByUsernameOK as json.
func (s UsersGetByUsernameOK) Encode(e *jx.Writer) {
	switch s.Type {
	case PrivateUserUsersGetByUsernameOK:
		s.PrivateUser.Encode(e)
	case PublicUserUsersGetByUsernameOK:
		s.PublicUser.Encode(e)
	}
}

// Decode decodes UsersGetByUsernameOK from json.
func (s *UsersGetByUsernameOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetByUsernameOK to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "two_factor_authentication":
				found = true
				s.Type = PrivateUserUsersGetByUsernameOK
			case "business_plus":
				found = true
				s.Type = PrivateUserUsersGetByUsernameOK
			case "ldap_dn":
				found = true
				s.Type = PrivateUserUsersGetByUsernameOK
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		s.Type = PublicUserUsersGetByUsernameOK
	}
	switch s.Type {
	case PrivateUserUsersGetByUsernameOK:
		if err := s.PrivateUser.Decode(d); err != nil {
			return err
		}
	case PublicUserUsersGetByUsernameOK:
		if err := s.PublicUser.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode encodes UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden as json.
func (s UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound as json.
func (s UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden as json.
func (s UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound as json.
func (s UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListBlockedByAuthenticatedApplicationJSONForbidden as json.
func (s UsersListBlockedByAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListBlockedByAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListBlockedByAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListBlockedByAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListBlockedByAuthenticatedApplicationJSONNotFound as json.
func (s UsersListBlockedByAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListBlockedByAuthenticatedApplicationJSONNotFound from json.
func (s *UsersListBlockedByAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListBlockedByAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersListBlockedByAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListBlockedByAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListBlockedByAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListBlockedByAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListBlockedByAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListBlockedByAuthenticatedOKApplicationJSON as json.
func (s UsersListBlockedByAuthenticatedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListBlockedByAuthenticatedOKApplicationJSON from json.
func (s *UsersListBlockedByAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListBlockedByAuthenticatedOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListEmailsForAuthenticatedApplicationJSONForbidden as json.
func (s UsersListEmailsForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListEmailsForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListEmailsForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListEmailsForAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListEmailsForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListEmailsForAuthenticatedApplicationJSONNotFound as json.
func (s UsersListEmailsForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListEmailsForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersListEmailsForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListEmailsForAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListEmailsForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersListEmailsForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListEmailsForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListEmailsForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListEmailsForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListEmailsForAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListEmailsForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListEmailsForAuthenticatedOKApplicationJSON as json.
func (s UsersListEmailsForAuthenticatedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Email(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListEmailsForAuthenticatedOKApplicationJSON from json.
func (s *UsersListEmailsForAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListEmailsForAuthenticatedOKApplicationJSON to nil")
	}
	var unwrapped []Email
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Email
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListEmailsForAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListFollowedByAuthenticatedApplicationJSONForbidden as json.
func (s UsersListFollowedByAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowedByAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListFollowedByAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListFollowedByAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowedByAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListFollowedByAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListFollowedByAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowedByAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListFollowedByAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListFollowedByAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowedByAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListFollowedByAuthenticatedOKApplicationJSON as json.
func (s UsersListFollowedByAuthenticatedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListFollowedByAuthenticatedOKApplicationJSON from json.
func (s *UsersListFollowedByAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListFollowedByAuthenticatedOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowedByAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListFollowersForAuthenticatedUserApplicationJSONForbidden as json.
func (s UsersListFollowersForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowersForAuthenticatedUserApplicationJSONForbidden from json.
func (s *UsersListFollowersForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListFollowersForAuthenticatedUserApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowersForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListFollowersForAuthenticatedUserOKApplicationJSON as json.
func (s UsersListFollowersForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListFollowersForAuthenticatedUserOKApplicationJSON from json.
func (s *UsersListFollowersForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListFollowersForAuthenticatedUserOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowersForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListGpgKeysForAuthenticatedApplicationJSONForbidden as json.
func (s UsersListGpgKeysForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListGpgKeysForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListGpgKeysForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListGpgKeysForAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListGpgKeysForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListGpgKeysForAuthenticatedApplicationJSONNotFound as json.
func (s UsersListGpgKeysForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListGpgKeysForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersListGpgKeysForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListGpgKeysForAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListGpgKeysForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListGpgKeysForAuthenticatedOKApplicationJSON as json.
func (s UsersListGpgKeysForAuthenticatedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []GpgKey(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListGpgKeysForAuthenticatedOKApplicationJSON from json.
func (s *UsersListGpgKeysForAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListGpgKeysForAuthenticatedOKApplicationJSON to nil")
	}
	var unwrapped []GpgKey
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GpgKey
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListGpgKeysForAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListOKApplicationJSON as json.
func (s UsersListOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListOKApplicationJSON from json.
func (s *UsersListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListOKApplicationJSON to nil")
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden as json.
func (s UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound as json.
func (s UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListPublicEmailsForAuthenticatedOKApplicationJSON as json.
func (s UsersListPublicEmailsForAuthenticatedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Email(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListPublicEmailsForAuthenticatedOKApplicationJSON from json.
func (s *UsersListPublicEmailsForAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListPublicEmailsForAuthenticatedOKApplicationJSON to nil")
	}
	var unwrapped []Email
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Email
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicEmailsForAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden as json.
func (s UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound as json.
func (s UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON as json.
func (s UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Key(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON from json.
func (s *UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON to nil")
	}
	var unwrapped []Key
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Key
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONForbidden as json.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONNotFound as json.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON as json.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON) Encode(e *jx.Writer) {
	unwrapped := []Email(s)
	e.ArrStart()
	if len(unwrapped) >= 1 {
		// Encode first element without comma.
		{
			elem := unwrapped[0]
			elem.Encode(e)
		}
		for _, elem := range unwrapped[1:] {
			e.Comma()
			elem.Encode(e)
		}
	}
	e.ArrEnd()
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON to nil")
	}
	var unwrapped []Email
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Email
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"visibility\"" + ":")
		s.Visibility.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUsersSetPrimaryEmailVisibilityForAuthenticatedReq = [1]string{
	0: "visibility",
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedReq from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "visibility":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersSetPrimaryEmailVisibilityForAuthenticatedReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsersSetPrimaryEmailVisibilityForAuthenticatedReq) {
					name = jsonFieldsNameOfUsersSetPrimaryEmailVisibilityForAuthenticatedReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility as json.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility(v) {
	case UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibilityPublic:
		*s = UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibilityPublic
	case UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibilityPrivate:
		*s = UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibilityPrivate
	default:
		*s = UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility(v)
	}

	return nil
}

// Encode encodes UsersUnblockApplicationJSONForbidden as json.
func (s UsersUnblockApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnblockApplicationJSONForbidden from json.
func (s *UsersUnblockApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUnblockApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnblockApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersUnblockApplicationJSONNotFound as json.
func (s UsersUnblockApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnblockApplicationJSONNotFound from json.
func (s *UsersUnblockApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUnblockApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnblockApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersUnblockApplicationJSONUnauthorized as json.
func (s UsersUnblockApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnblockApplicationJSONUnauthorized from json.
func (s *UsersUnblockApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUnblockApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnblockApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersUnfollowApplicationJSONForbidden as json.
func (s UsersUnfollowApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnfollowApplicationJSONForbidden from json.
func (s *UsersUnfollowApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUnfollowApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnfollowApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersUnfollowApplicationJSONNotFound as json.
func (s UsersUnfollowApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnfollowApplicationJSONNotFound from json.
func (s *UsersUnfollowApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUnfollowApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnfollowApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersUnfollowApplicationJSONUnauthorized as json.
func (s UsersUnfollowApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnfollowApplicationJSONUnauthorized from json.
func (s *UsersUnfollowApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUnfollowApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnfollowApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersUpdateAuthenticatedApplicationJSONForbidden as json.
func (s UsersUpdateAuthenticatedApplicationJSONForbidden) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUpdateAuthenticatedApplicationJSONForbidden from json.
func (s *UsersUpdateAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUpdateAuthenticatedApplicationJSONForbidden to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUpdateAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersUpdateAuthenticatedApplicationJSONNotFound as json.
func (s UsersUpdateAuthenticatedApplicationJSONNotFound) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUpdateAuthenticatedApplicationJSONNotFound from json.
func (s *UsersUpdateAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUpdateAuthenticatedApplicationJSONNotFound to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUpdateAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersUpdateAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersUpdateAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Writer) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUpdateAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersUpdateAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUpdateAuthenticatedApplicationJSONUnauthorized to nil")
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUpdateAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersUpdateAuthenticatedReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Name.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Email.Set {
			e.RawStr("\"email\"" + ":")
			s.Email.Encode(e)
		}
	}
	{
		if s.Blog.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Blog.Set {
			e.RawStr("\"blog\"" + ":")
			s.Blog.Encode(e)
		}
	}
	{
		if s.TwitterUsername.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.TwitterUsername.Set {
			e.RawStr("\"twitter_username\"" + ":")
			s.TwitterUsername.Encode(e)
		}
	}
	{
		if s.Company.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Company.Set {
			e.RawStr("\"company\"" + ":")
			s.Company.Encode(e)
		}
	}
	{
		if s.Location.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Location.Set {
			e.RawStr("\"location\"" + ":")
			s.Location.Encode(e)
		}
	}
	{
		if s.Hireable.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Hireable.Set {
			e.RawStr("\"hireable\"" + ":")
			s.Hireable.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Bio.Set {
			e.RawStr("\"bio\"" + ":")
			s.Bio.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUsersUpdateAuthenticatedReq = [8]string{
	0: "name",
	1: "email",
	2: "blog",
	3: "twitter_username",
	4: "company",
	5: "location",
	6: "hireable",
	7: "bio",
}

// Decode decodes UsersUpdateAuthenticatedReq from json.
func (s *UsersUpdateAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUpdateAuthenticatedReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "blog":
			if err := func() error {
				s.Blog.Reset()
				if err := s.Blog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blog\"")
			}
		case "twitter_username":
			if err := func() error {
				s.TwitterUsername.Reset()
				if err := s.TwitterUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"twitter_username\"")
			}
		case "company":
			if err := func() error {
				s.Company.Reset()
				if err := s.Company.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"company\"")
			}
		case "location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		case "hireable":
			if err := func() error {
				s.Hireable.Reset()
				if err := s.Hireable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hireable\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersUpdateAuthenticatedReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ValidationError) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"documentation_url\"" + ":")
		e.Str(s.DocumentationURL)
	}
	{
		if s.Errors != nil {
			e.Comma()
		}
		if s.Errors != nil {
			e.RawStr("\"errors\"" + ":")
			e.ArrStart()
			if len(s.Errors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Errors[0]
					elem.Encode(e)
				}
				for _, elem := range s.Errors[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfValidationError = [3]string{
	0: "message",
	1: "documentation_url",
	2: "errors",
}

// Decode decodes ValidationError from json.
func (s *ValidationError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DocumentationURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidationErrorErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidationError) {
					name = jsonFieldsNameOfValidationError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ValidationErrorErrorsItem) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Resource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Resource.Set {
			e.RawStr("\"resource\"" + ":")
			s.Resource.Encode(e)
		}
	}
	{
		if s.Field.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Field.Set {
			e.RawStr("\"field\"" + ":")
			s.Field.Encode(e)
		}
	}
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"code\"" + ":")
		e.Str(s.Code)
	}
	{
		if s.Index.Set {
			e.Comma()
		}
		if s.Index.Set {
			e.RawStr("\"index\"" + ":")
			s.Index.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.Comma()
		}
		if s.Value.Set {
			e.RawStr("\"value\"" + ":")
			s.Value.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfValidationErrorErrorsItem = [6]string{
	0: "resource",
	1: "field",
	2: "message",
	3: "code",
	4: "index",
	5: "value",
}

// Decode decodes ValidationErrorErrorsItem from json.
func (s *ValidationErrorErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationErrorErrorsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "field":
			if err := func() error {
				s.Field.Reset()
				if err := s.Field.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"field\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "index":
			if err := func() error {
				s.Index.Reset()
				if err := s.Index.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"index\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationErrorErrorsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidationErrorErrorsItem) {
					name = jsonFieldsNameOfValidationErrorErrorsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes ValidationErrorErrorsItemValue as json.
func (s ValidationErrorErrorsItemValue) Encode(e *jx.Writer) {
	switch s.Type {
	case StringValidationErrorErrorsItemValue:
		e.Str(s.String)
	case IntValidationErrorErrorsItemValue:
		e.Int(s.Int)
	case ArrayStringValidationErrorErrorsItemValue:
		e.ArrStart()
		if len(s.ArrayString) >= 1 {
			// Encode first element without comma.
			{
				elem := s.ArrayString[0]
				e.Str(elem)
			}
			for _, elem := range s.ArrayString[1:] {
				e.Comma()
				e.Str(elem)
			}
		}
		e.ArrEnd()
	}
}

// Decode decodes ValidationErrorErrorsItemValue from json.
func (s *ValidationErrorErrorsItemValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationErrorErrorsItemValue to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringValidationErrorErrorsItemValue
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntValidationErrorErrorsItemValue
	case jx.Array:
		s.ArrayString = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.ArrayString = append(s.ArrayString, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = ArrayStringValidationErrorErrorsItemValue
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ValidationErrorSimple) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"message\"" + ":")
		e.Str(s.Message)
	}
	{
		e.Comma()

		e.RawStr("\"documentation_url\"" + ":")
		e.Str(s.DocumentationURL)
	}
	{
		if s.Errors != nil {
			e.Comma()
		}
		if s.Errors != nil {
			e.RawStr("\"errors\"" + ":")
			e.ArrStart()
			if len(s.Errors) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Errors[0]
					e.Str(elem)
				}
				for _, elem := range s.Errors[1:] {
					e.Comma()
					e.Str(elem)
				}
			}
			e.ArrEnd()
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfValidationErrorSimple = [3]string{
	0: "message",
	1: "documentation_url",
	2: "errors",
}

// Decode decodes ValidationErrorSimple from json.
func (s *ValidationErrorSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationErrorSimple to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "documentation_url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DocumentationURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documentation_url\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationErrorSimple")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidationErrorSimple) {
					name = jsonFieldsNameOfValidationErrorSimple[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Verification) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"verified\"" + ":")
		e.Bool(s.Verified)
	}
	{
		e.Comma()

		e.RawStr("\"reason\"" + ":")
		e.Str(s.Reason)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"signature\"" + ":")
		s.Signature.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVerification = [4]string{
	0: "verified",
	1: "reason",
	2: "payload",
	3: "signature",
}

// Decode decodes Verification from json.
func (s *Verification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Verification to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verified":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Verified = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "signature":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Signature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signature\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Verification")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVerification) {
					name = jsonFieldsNameOfVerification[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ViewTraffic) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"count\"" + ":")
		e.Int(s.Count)
	}
	{
		e.Comma()

		e.RawStr("\"uniques\"" + ":")
		e.Int(s.Uniques)
	}
	{
		e.Comma()

		e.RawStr("\"views\"" + ":")
		e.ArrStart()
		if len(s.Views) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Views[0]
				elem.Encode(e)
			}
			for _, elem := range s.Views[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfViewTraffic = [3]string{
	0: "count",
	1: "uniques",
	2: "views",
}

// Decode decodes ViewTraffic from json.
func (s *ViewTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ViewTraffic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "uniques":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Uniques = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniques\"")
			}
		case "views":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Views = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Traffic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Views = append(s.Views, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"views\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ViewTraffic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfViewTraffic) {
					name = jsonFieldsNameOfViewTraffic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes WaitTimer as json.
func (s WaitTimer) Encode(e *jx.Writer) {
	unwrapped := int(s)
	e.Int(unwrapped)
}

// Decode decodes WaitTimer from json.
func (s *WaitTimer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WaitTimer to nil")
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WaitTimer(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s WebhookConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.URL.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.URL.Set {
			e.RawStr("\"url\"" + ":")
			s.URL.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.ContentType.Set {
			e.RawStr("\"content_type\"" + ":")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Secret.Set {
			e.RawStr("\"secret\"" + ":")
			s.Secret.Encode(e)
		}
	}
	{
		if s.InsecureSsl.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InsecureSsl.Set {
			e.RawStr("\"insecure_ssl\"" + ":")
			s.InsecureSsl.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfWebhookConfig = [4]string{
	0: "url",
	1: "content_type",
	2: "secret",
	3: "insecure_ssl",
}

// Decode decodes WebhookConfig from json.
func (s *WebhookConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "insecure_ssl":
			if err := func() error {
				s.InsecureSsl.Reset()
				if err := s.InsecureSsl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"insecure_ssl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookConfig")
	}

	return nil
}

// Encode encodes WebhookConfigContentType as json.
func (s WebhookConfigContentType) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes WebhookConfigContentType from json.
func (s *WebhookConfigContentType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookConfigContentType to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebhookConfigContentType(unwrapped)
	return nil
}

// Encode encodes WebhookConfigInsecureSsl as json.
func (s WebhookConfigInsecureSsl) Encode(e *jx.Writer) {
	switch s.Type {
	case StringWebhookConfigInsecureSsl:
		e.Str(s.String)
	case Float64WebhookConfigInsecureSsl:
		e.Float64(s.Float64)
	}
}

// Decode decodes WebhookConfigInsecureSsl from json.
func (s *WebhookConfigInsecureSsl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookConfigInsecureSsl to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringWebhookConfigInsecureSsl
	case jx.Number:
		v, err := d.Float64()
		s.Float64 = float64(v)
		if err != nil {
			return err
		}
		s.Type = Float64WebhookConfigInsecureSsl
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode encodes WebhookConfigSecret as json.
func (s WebhookConfigSecret) Encode(e *jx.Writer) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes WebhookConfigSecret from json.
func (s *WebhookConfigSecret) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookConfigSecret to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebhookConfigSecret(unwrapped)
	return nil
}

// Encode encodes WebhookConfigURL as json.
func (s WebhookConfigURL) Encode(e *jx.Writer) {
	unwrapped := url.URL(s)
	json.EncodeURI(e, unwrapped)
}

// Decode decodes WebhookConfigURL from json.
func (s *WebhookConfigURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookConfigURL to nil")
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebhookConfigURL(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s Workflow) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"path\"" + ":")
		e.Str(s.Path)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		e.Str(s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"badge_url\"" + ":")
		e.Str(s.BadgeURL)
	}
	{
		if s.DeletedAt.Set {
			e.Comma()
		}
		if s.DeletedAt.Set {
			e.RawStr("\"deleted_at\"" + ":")
			s.DeletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfWorkflow = [11]string{
	0:  "id",
	1:  "node_id",
	2:  "name",
	3:  "path",
	4:  "state",
	5:  "created_at",
	6:  "updated_at",
	7:  "url",
	8:  "html_url",
	9:  "badge_url",
	10: "deleted_at",
}

// Decode decodes Workflow from json.
func (s *Workflow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Workflow to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HTMLURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "badge_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BadgeURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"badge_url\"")
			}
		case "deleted_at":
			if err := func() error {
				s.DeletedAt.Reset()
				if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleted_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Workflow")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflow) {
					name = jsonFieldsNameOfWorkflow[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WorkflowRun) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Int(s.ID)
	}
	{
		if s.Name.Set {
			e.Comma()
		}
		if s.Name.Set {
			e.RawStr("\"name\"" + ":")
			s.Name.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"node_id\"" + ":")
		e.Str(s.NodeID)
	}
	{
		if s.CheckSuiteID.Set {
			e.Comma()
		}
		if s.CheckSuiteID.Set {
			e.RawStr("\"check_suite_id\"" + ":")
			s.CheckSuiteID.Encode(e)
		}
	}
	{
		if s.CheckSuiteNodeID.Set {
			e.Comma()
		}
		if s.CheckSuiteNodeID.Set {
			e.RawStr("\"check_suite_node_id\"" + ":")
			s.CheckSuiteNodeID.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"head_branch\"" + ":")
		s.HeadBranch.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"head_sha\"" + ":")
		e.Str(s.HeadSha)
	}
	{
		e.Comma()

		e.RawStr("\"run_number\"" + ":")
		e.Int(s.RunNumber)
	}
	{
		if s.RunAttempt.Set {
			e.Comma()
		}
		if s.RunAttempt.Set {
			e.RawStr("\"run_attempt\"" + ":")
			s.RunAttempt.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"event\"" + ":")
		e.Str(s.Event)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"conclusion\"" + ":")
		s.Conclusion.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"workflow_id\"" + ":")
		e.Int(s.WorkflowID)
	}
	{
		e.Comma()

		e.RawStr("\"url\"" + ":")
		e.Str(s.URL)
	}
	{
		e.Comma()

		e.RawStr("\"html_url\"" + ":")
		e.Str(s.HTMLURL)
	}
	{
		e.Comma()

		e.RawStr("\"pull_requests\"" + ":")
		if s.PullRequests == nil {
			e.Null()
		} else {
			e.ArrStart()
			if len(s.PullRequests) >= 1 {
				// Encode first element without comma.
				{
					elem := s.PullRequests[0]
					elem.Encode(e)
				}
				for _, elem := range s.PullRequests[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		e.Comma()

		e.RawStr("\"created_at\"" + ":")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"updated_at\"" + ":")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.Comma()

		e.RawStr("\"jobs_url\"" + ":")
		e.Str(s.JobsURL)
	}
	{
		e.Comma()

		e.RawStr("\"logs_url\"" + ":")
		e.Str(s.LogsURL)
	}
	{
		e.Comma()

		e.RawStr("\"check_suite_url\"" + ":")
		e.Str(s.CheckSuiteURL)
	}
	{
		e.Comma()

		e.RawStr("\"artifacts_url\"" + ":")
		e.Str(s.ArtifactsURL)
	}
	{
		e.Comma()

		e.RawStr("\"cancel_url\"" + ":")
		e.Str(s.CancelURL)
	}
	{
		e.Comma()

		e.RawStr("\"rerun_url\"" + ":")
		e.Str(s.RerunURL)
	}
	{
		if s.PreviousAttemptURL.Set {
			e.Comma()
		}
		if s.PreviousAttemptURL.Set {
			e.RawStr("\"previous_attempt_url\"" + ":")
			s.PreviousAttemptURL.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"workflow_url\"" + ":")
		e.Str(s.WorkflowURL)
	}
	{
		e.Comma()

		e.RawStr("\"head_commit\"" + ":")
		s.HeadCommit.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"repository\"" + ":")
		s.Repository.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"head_repository\"" + ":")
		s.HeadRepository.Encode(e)
	}
	{
		if s.HeadRepositoryID.Set {
			e.Comma()
		}
		if s.HeadRepositoryID.Set {
			e.RawStr("\"head_repository_id\"" + ":")
			s.HeadRepositoryID.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfWorkflowRun = [30]string{
	0:  "id",
	1:  "name",
	2:  "node_id",
	3:  "check_suite_id",
	4:  "check_suite_node_id",
	5:  "head_branch",
	6:  "head_sha",
	7:  "run_number",
	8:  "run_attempt",
	9:  "event",
	10: "status",
	11: "conclusion",
	12: "workflow_id",
	13: "url",
	14: "html_url",
	15: "pull_requests",
	16: "created_at",
	17: "updated_at",
	18: "jobs_url",
	19: "logs_url",
	20: "check_suite_url",
	21: "artifacts_url",
	22: "cancel_url",
	23: "rerun_url",
	24: "previous_attempt_url",
	25: "workflow_url",
	26: "head_commit",
	27: "repository",
	28: "head_repository",
	29: "head_repository_id",
}

// Decode decodes WorkflowRun from json.
func (s *WorkflowRun) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowRun to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "check_suite_id":
			if err := func() error {
				s.CheckSuiteID.Reset()
				if err := s.CheckSuiteID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_suite_id\"")
			}
		case "check_suite_node_id":
			if err := func() error {
				s.CheckSuiteNodeID.Reset()
				if err := s.CheckSuiteNodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_suite_node_id\"")
			}
		case "head_branch":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.HeadBranch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_branch\"")
			}
		case "head_sha":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HeadSha = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_sha\"")
			}
		case "run_number":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.RunNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"run_number\"")
			}
		case "run_attempt":
			if err := func() error {
				s.RunAttempt.Reset()
				if err := s.RunAttempt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"run_attempt\"")
			}
		case "event":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Event = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "conclusion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Conclusion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conclusion\"")
			}
		case "workflow_id":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WorkflowID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "html_url":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HTMLURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_url\"")
			}
		case "pull_requests":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				s.PullRequests = nil
				switch tt := d.Next(); tt {
				case jx.Null:
					if err := d.Skip(); err != nil {
						return err
					}
				default:
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem PullRequestMinimal
						if err := elem.Decode(d); err != nil {
							return err
						}
						s.PullRequests = append(s.PullRequests, elem)
						return nil
					}); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pull_requests\"")
			}
		case "created_at":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "jobs_url":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.JobsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobs_url\"")
			}
		case "logs_url":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.LogsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logs_url\"")
			}
		case "check_suite_url":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CheckSuiteURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_suite_url\"")
			}
		case "artifacts_url":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ArtifactsURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"artifacts_url\"")
			}
		case "cancel_url":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CancelURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cancel_url\"")
			}
		case "rerun_url":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.RerunURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rerun_url\"")
			}
		case "previous_attempt_url":
			if err := func() error {
				s.PreviousAttemptURL.Reset()
				if err := s.PreviousAttemptURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_attempt_url\"")
			}
		case "workflow_url":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WorkflowURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_url\"")
			}
		case "head_commit":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				if err := s.HeadCommit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_commit\"")
			}
		case "repository":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.Repository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repository\"")
			}
		case "head_repository":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.HeadRepository.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_repository\"")
			}
		case "head_repository_id":
			if err := func() error {
				s.HeadRepositoryID.Reset()
				if err := s.HeadRepositoryID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head_repository_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowRun")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11100101,
		0b11111110,
		0b11111111,
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowRun) {
					name = jsonFieldsNameOfWorkflowRun[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WorkflowRunUsage) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"billable\"" + ":")
		s.Billable.Encode(e)
	}
	{
		if s.RunDurationMs.Set {
			e.Comma()
		}
		if s.RunDurationMs.Set {
			e.RawStr("\"run_duration_ms\"" + ":")
			s.RunDurationMs.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfWorkflowRunUsage = [2]string{
	0: "billable",
	1: "run_duration_ms",
}

// Decode decodes WorkflowRunUsage from json.
func (s *WorkflowRunUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowRunUsage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billable":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Billable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billable\"")
			}
		case "run_duration_ms":
			if err := func() error {
				s.RunDurationMs.Reset()
				if err := s.RunDurationMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"run_duration_ms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowRunUsage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowRunUsage) {
					name = jsonFieldsNameOfWorkflowRunUsage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WorkflowRunUsageBillable) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.UBUNTU.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.UBUNTU.Set {
			e.RawStr("\"UBUNTU\"" + ":")
			s.UBUNTU.Encode(e)
		}
	}
	{
		if s.MACOS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MACOS.Set {
			e.RawStr("\"MACOS\"" + ":")
			s.MACOS.Encode(e)
		}
	}
	{
		if s.WINDOWS.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.WINDOWS.Set {
			e.RawStr("\"WINDOWS\"" + ":")
			s.WINDOWS.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfWorkflowRunUsageBillable = [3]string{
	0: "UBUNTU",
	1: "MACOS",
	2: "WINDOWS",
}

// Decode decodes WorkflowRunUsageBillable from json.
func (s *WorkflowRunUsageBillable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowRunUsageBillable to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "UBUNTU":
			if err := func() error {
				s.UBUNTU.Reset()
				if err := s.UBUNTU.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UBUNTU\"")
			}
		case "MACOS":
			if err := func() error {
				s.MACOS.Reset()
				if err := s.MACOS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MACOS\"")
			}
		case "WINDOWS":
			if err := func() error {
				s.WINDOWS.Reset()
				if err := s.WINDOWS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"WINDOWS\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowRunUsageBillable")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WorkflowRunUsageBillableMACOS) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_ms\"" + ":")
		e.Int(s.TotalMs)
	}
	{
		e.Comma()

		e.RawStr("\"jobs\"" + ":")
		e.Int(s.Jobs)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfWorkflowRunUsageBillableMACOS = [2]string{
	0: "total_ms",
	1: "jobs",
}

// Decode decodes WorkflowRunUsageBillableMACOS from json.
func (s *WorkflowRunUsageBillableMACOS) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowRunUsageBillableMACOS to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_ms":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_ms\"")
			}
		case "jobs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Jobs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowRunUsageBillableMACOS")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowRunUsageBillableMACOS) {
					name = jsonFieldsNameOfWorkflowRunUsageBillableMACOS[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WorkflowRunUsageBillableUBUNTU) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_ms\"" + ":")
		e.Int(s.TotalMs)
	}
	{
		e.Comma()

		e.RawStr("\"jobs\"" + ":")
		e.Int(s.Jobs)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfWorkflowRunUsageBillableUBUNTU = [2]string{
	0: "total_ms",
	1: "jobs",
}

// Decode decodes WorkflowRunUsageBillableUBUNTU from json.
func (s *WorkflowRunUsageBillableUBUNTU) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowRunUsageBillableUBUNTU to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_ms":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_ms\"")
			}
		case "jobs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Jobs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowRunUsageBillableUBUNTU")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowRunUsageBillableUBUNTU) {
					name = jsonFieldsNameOfWorkflowRunUsageBillableUBUNTU[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s WorkflowRunUsageBillableWINDOWS) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total_ms\"" + ":")
		e.Int(s.TotalMs)
	}
	{
		e.Comma()

		e.RawStr("\"jobs\"" + ":")
		e.Int(s.Jobs)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfWorkflowRunUsageBillableWINDOWS = [2]string{
	0: "total_ms",
	1: "jobs",
}

// Decode decodes WorkflowRunUsageBillableWINDOWS from json.
func (s *WorkflowRunUsageBillableWINDOWS) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowRunUsageBillableWINDOWS to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_ms":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_ms\"")
			}
		case "jobs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Jobs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowRunUsageBillableWINDOWS")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowRunUsageBillableWINDOWS) {
					name = jsonFieldsNameOfWorkflowRunUsageBillableWINDOWS[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes WorkflowState as json.
func (s WorkflowState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes WorkflowState from json.
func (s *WorkflowState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowState(v) {
	case WorkflowStateActive:
		*s = WorkflowStateActive
	case WorkflowStateDeleted:
		*s = WorkflowStateDeleted
	case WorkflowStateDisabledFork:
		*s = WorkflowStateDisabledFork
	case WorkflowStateDisabledInactivity:
		*s = WorkflowStateDisabledInactivity
	case WorkflowStateDisabledManually:
		*s = WorkflowStateDisabledManually
	default:
		*s = WorkflowState(v)
	}

	return nil
}
