// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/encoding/json"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = chi.Context{}
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
)

type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

type Client struct {
	serverURL string
	http      HTTPClient
}

func NewClient(serverURL string) *Client {
	return &Client{
		serverURL: serverURL,
		http: &http.Client{
			Timeout: time.Second * 15,
		},
	}
}

func (c *Client) MetaRoot(ctx context.Context) (_ MetaRoot, rerr error) {
	path := c.serverURL

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMetaRootResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsGetAuthenticated(ctx context.Context) (_ Integration, rerr error) {
	path := c.serverURL
	path += "/app"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsCreateFromManifest(ctx context.Context, req *AppsCreateFromManifestApplicationJSONRequest, params AppsCreateFromManifestParams) (_ AppsCreateFromManifestResponse, rerr error) {
	body, contentType, err := encodeAppsCreateFromManifestRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/app-manifests"
	{
		value := conv.StringToString(params.Code)
		path += "/" + value
	}
	path += "/conversions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsCreateFromManifestResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsGetWebhookConfigForApp(ctx context.Context) (_ AppsGetWebhookConfigForAppResponse, rerr error) {
	path := c.serverURL
	path += "/app"
	path += "/hook"
	path += "/config"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetWebhookConfigForAppResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsUpdateWebhookConfigForApp(ctx context.Context, req AppsUpdateWebhookConfigForAppRequest) (_ WebhookConfig, rerr error) {
	body, contentType, err := encodeAppsUpdateWebhookConfigForAppRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/app"
	path += "/hook"
	path += "/config"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsUpdateWebhookConfigForAppResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsListWebhookDeliveries(ctx context.Context, params AppsListWebhookDeliveriesParams) (_ AppsListWebhookDeliveriesResponse, rerr error) {
	path := c.serverURL
	path += "/app"
	path += "/hook"
	path += "/deliveries"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.StringToString(params.Cursor)
		q.Set("cursor", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsListWebhookDeliveriesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsGetWebhookDelivery(ctx context.Context, params AppsGetWebhookDeliveryParams) (_ AppsGetWebhookDeliveryResponse, rerr error) {
	path := c.serverURL
	path += "/app"
	path += "/hook"
	path += "/deliveries"
	{
		value := conv.IntToString(params.DeliveryID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetWebhookDeliveryResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsRedeliverWebhookDelivery(ctx context.Context, params AppsRedeliverWebhookDeliveryParams) (_ AppsRedeliverWebhookDeliveryResponse, rerr error) {
	path := c.serverURL
	path += "/app"
	path += "/hook"
	path += "/deliveries"
	{
		value := conv.IntToString(params.DeliveryID)
		path += "/" + value
	}
	path += "/attempts"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsRedeliverWebhookDeliveryResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsListInstallations(ctx context.Context, params AppsListInstallationsParams) (_ AppsListInstallationsResponse, rerr error) {
	path := c.serverURL
	path += "/app"
	path += "/installations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.StringToString(params.Outdated)
		q.Set("outdated", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsListInstallationsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsGetInstallation(ctx context.Context, params AppsGetInstallationParams) (_ AppsGetInstallationResponse, rerr error) {
	path := c.serverURL
	path += "/app"
	path += "/installations"
	{
		value := conv.IntToString(params.InstallationID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetInstallationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsDeleteInstallation(ctx context.Context, params AppsDeleteInstallationParams) (_ AppsDeleteInstallationResponse, rerr error) {
	path := c.serverURL
	path += "/app"
	path += "/installations"
	{
		value := conv.IntToString(params.InstallationID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsDeleteInstallationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsCreateInstallationAccessToken(ctx context.Context, req *AppsCreateInstallationAccessTokenApplicationJSONRequest, params AppsCreateInstallationAccessTokenParams) (_ AppsCreateInstallationAccessTokenResponse, rerr error) {
	body, contentType, err := encodeAppsCreateInstallationAccessTokenRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/app"
	path += "/installations"
	{
		value := conv.IntToString(params.InstallationID)
		path += "/" + value
	}
	path += "/access_tokens"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsCreateInstallationAccessTokenResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsSuspendInstallation(ctx context.Context, params AppsSuspendInstallationParams) (_ AppsSuspendInstallationResponse, rerr error) {
	path := c.serverURL
	path += "/app"
	path += "/installations"
	{
		value := conv.IntToString(params.InstallationID)
		path += "/" + value
	}
	path += "/suspended"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsSuspendInstallationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsUnsuspendInstallation(ctx context.Context, params AppsUnsuspendInstallationParams) (_ AppsUnsuspendInstallationResponse, rerr error) {
	path := c.serverURL
	path += "/app"
	path += "/installations"
	{
		value := conv.IntToString(params.InstallationID)
		path += "/" + value
	}
	path += "/suspended"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsUnsuspendInstallationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsListGrants(ctx context.Context, params OAuthAuthorizationsListGrantsParams) (_ OAuthAuthorizationsListGrantsResponse, rerr error) {
	path := c.serverURL
	path += "/applications"
	path += "/grants"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.StringToString(params.ClientID)
		q.Set("client_id", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsListGrantsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsGetGrant(ctx context.Context, params OAuthAuthorizationsGetGrantParams) (_ OAuthAuthorizationsGetGrantResponse, rerr error) {
	path := c.serverURL
	path += "/applications"
	path += "/grants"
	{
		value := conv.IntToString(params.GrantID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsGetGrantResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsDeleteGrant(ctx context.Context, params OAuthAuthorizationsDeleteGrantParams) (_ OAuthAuthorizationsDeleteGrantResponse, rerr error) {
	path := c.serverURL
	path += "/applications"
	path += "/grants"
	{
		value := conv.IntToString(params.GrantID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsDeleteGrantResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsDeleteAuthorization(ctx context.Context, req AppsDeleteAuthorizationApplicationJSONRequest, params AppsDeleteAuthorizationParams) (_ AppsDeleteAuthorizationResponse, rerr error) {
	body, contentType, err := encodeAppsDeleteAuthorizationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/applications"
	{
		value := conv.StringToString(params.ClientID)
		path += "/" + value
	}
	path += "/grant"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsDeleteAuthorizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsCheckToken(ctx context.Context, req AppsCheckTokenApplicationJSONRequest, params AppsCheckTokenParams) (_ AppsCheckTokenResponse, rerr error) {
	body, contentType, err := encodeAppsCheckTokenRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/applications"
	{
		value := conv.StringToString(params.ClientID)
		path += "/" + value
	}
	path += "/token"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsCheckTokenResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsDeleteToken(ctx context.Context, req AppsDeleteTokenApplicationJSONRequest, params AppsDeleteTokenParams) (_ AppsDeleteTokenResponse, rerr error) {
	body, contentType, err := encodeAppsDeleteTokenRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/applications"
	{
		value := conv.StringToString(params.ClientID)
		path += "/" + value
	}
	path += "/token"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsDeleteTokenResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsResetToken(ctx context.Context, req AppsResetTokenApplicationJSONRequest, params AppsResetTokenParams) (_ AppsResetTokenResponse, rerr error) {
	body, contentType, err := encodeAppsResetTokenRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/applications"
	{
		value := conv.StringToString(params.ClientID)
		path += "/" + value
	}
	path += "/token"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsResetTokenResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsScopeToken(ctx context.Context, req AppsScopeTokenApplicationJSONRequest, params AppsScopeTokenParams) (_ AppsScopeTokenResponse, rerr error) {
	body, contentType, err := encodeAppsScopeTokenRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/applications"
	{
		value := conv.StringToString(params.ClientID)
		path += "/" + value
	}
	path += "/token"
	path += "/scoped"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsScopeTokenResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsGetBySlug(ctx context.Context, params AppsGetBySlugParams) (_ AppsGetBySlugResponse, rerr error) {
	path := c.serverURL
	path += "/apps"
	{
		value := conv.StringToString(params.AppSlug)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetBySlugResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsListAuthorizations(ctx context.Context, params OAuthAuthorizationsListAuthorizationsParams) (_ OAuthAuthorizationsListAuthorizationsResponse, rerr error) {
	path := c.serverURL
	path += "/authorizations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.StringToString(params.ClientID)
		q.Set("client_id", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsListAuthorizationsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsCreateAuthorization(ctx context.Context, req *OAuthAuthorizationsCreateAuthorizationApplicationJSONRequest) (_ OAuthAuthorizationsCreateAuthorizationResponse, rerr error) {
	body, contentType, err := encodeOAuthAuthorizationsCreateAuthorizationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/authorizations"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsCreateAuthorizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsGetOrCreateAuthorizationForApp(ctx context.Context, req OAuthAuthorizationsGetOrCreateAuthorizationForAppApplicationJSONRequest, params OAuthAuthorizationsGetOrCreateAuthorizationForAppParams) (_ OAuthAuthorizationsGetOrCreateAuthorizationForAppResponse, rerr error) {
	body, contentType, err := encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/authorizations"
	path += "/clients"
	{
		value := conv.StringToString(params.ClientID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx context.Context, req OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintApplicationJSONRequest, params OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams) (_ OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintResponse, rerr error) {
	body, contentType, err := encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/authorizations"
	path += "/clients"
	{
		value := conv.StringToString(params.ClientID)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Fingerprint)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsGetAuthorization(ctx context.Context, params OAuthAuthorizationsGetAuthorizationParams) (_ OAuthAuthorizationsGetAuthorizationResponse, rerr error) {
	path := c.serverURL
	path += "/authorizations"
	{
		value := conv.IntToString(params.AuthorizationID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsGetAuthorizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsDeleteAuthorization(ctx context.Context, params OAuthAuthorizationsDeleteAuthorizationParams) (_ OAuthAuthorizationsDeleteAuthorizationResponse, rerr error) {
	path := c.serverURL
	path += "/authorizations"
	{
		value := conv.IntToString(params.AuthorizationID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsDeleteAuthorizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OAuthAuthorizationsUpdateAuthorization(ctx context.Context, req *OAuthAuthorizationsUpdateAuthorizationApplicationJSONRequest, params OAuthAuthorizationsUpdateAuthorizationParams) (_ OAuthAuthorizationsUpdateAuthorizationResponse, rerr error) {
	body, contentType, err := encodeOAuthAuthorizationsUpdateAuthorizationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/authorizations"
	{
		value := conv.IntToString(params.AuthorizationID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOAuthAuthorizationsUpdateAuthorizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CodesOfConductGetAllCodesOfConduct(ctx context.Context) (_ CodesOfConductGetAllCodesOfConductResponse, rerr error) {
	path := c.serverURL
	path += "/codes_of_conduct"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCodesOfConductGetAllCodesOfConductResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CodesOfConductGetConductCode(ctx context.Context, params CodesOfConductGetConductCodeParams) (_ CodesOfConductGetConductCodeResponse, rerr error) {
	path := c.serverURL
	path += "/codes_of_conduct"
	{
		value := conv.StringToString(params.Key)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCodesOfConductGetConductCodeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EmojisGet(ctx context.Context) (_ EmojisGetResponse, rerr error) {
	path := c.serverURL
	path += "/emojis"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEmojisGetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx context.Context, params EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams) (_ ActionsEnterprisePermissions, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx context.Context, req EnterpriseAdminSetGithubActionsPermissionsEnterpriseApplicationJSONRequest, params EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams) (_ EnterpriseAdminSetGithubActionsPermissionsEnterprise, rerr error) {
	body, contentType, err := encodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams) (_ EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"
	path += "/organizations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, req EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseApplicationJSONRequest, params EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams) (_ EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise, rerr error) {
	body, contentType, err := encodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"
	path += "/organizations"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams) (_ EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"
	path += "/organizations"
	{
		value := conv.IntToString(params.OrgID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, params EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams) (_ EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"
	path += "/organizations"
	{
		value := conv.IntToString(params.OrgID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminGetAllowedActionsEnterprise(ctx context.Context, params EnterpriseAdminGetAllowedActionsEnterpriseParams) (_ SelectedActions, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"
	path += "/selected-actions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetAllowedActionsEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminSetAllowedActionsEnterprise(ctx context.Context, req SelectedActions, params EnterpriseAdminSetAllowedActionsEnterpriseParams) (_ EnterpriseAdminSetAllowedActionsEnterprise, rerr error) {
	body, contentType, err := encodeEnterpriseAdminSetAllowedActionsEnterpriseRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"
	path += "/selected-actions"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetAllowedActionsEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams) (_ EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx context.Context, req EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseApplicationJSONRequest, params EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams) (_ RunnerGroupsEnterprise, rerr error) {
	body, contentType, err := encodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx context.Context, params EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams) (_ RunnerGroupsEnterprise, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams) (_ EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx context.Context, req *EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseApplicationJSONRequest, params EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams) (_ RunnerGroupsEnterprise, rerr error) {
	body, contentType, err := encodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (_ EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/organizations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, req EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseApplicationJSONRequest, params EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (_ EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise, rerr error) {
	body, contentType, err := encodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/organizations"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (_ EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/organizations"
	{
		value := conv.IntToString(params.OrgID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, params EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (_ EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/organizations"
	{
		value := conv.IntToString(params.OrgID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams) (_ EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/runners"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx context.Context, req EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseApplicationJSONRequest, params EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams) (_ EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise, rerr error) {
	body, contentType, err := encodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/runners"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx context.Context, params EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams) (_ EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/runners"
	{
		value := conv.IntToString(params.RunnerID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx context.Context, params EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams) (_ EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/runners"
	{
		value := conv.IntToString(params.RunnerID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListSelfHostedRunnersForEnterprise(ctx context.Context, params EnterpriseAdminListSelfHostedRunnersForEnterpriseParams) (_ EnterpriseAdminListSelfHostedRunnersForEnterprise, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListRunnerApplicationsForEnterprise(ctx context.Context, params EnterpriseAdminListRunnerApplicationsForEnterpriseParams) (_ []RunnerApplication, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"
	path += "/downloads"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListRunnerApplicationsForEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminCreateRegistrationTokenForEnterprise(ctx context.Context, params EnterpriseAdminCreateRegistrationTokenForEnterpriseParams) (_ AuthenticationToken, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"
	path += "/registration-token"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminCreateRemoveTokenForEnterprise(ctx context.Context, params EnterpriseAdminCreateRemoveTokenForEnterpriseParams) (_ AuthenticationToken, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"
	path += "/remove-token"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminCreateRemoveTokenForEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx context.Context, params EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams) (_ Runner, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"
	{
		value := conv.IntToString(params.RunnerID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams) (_ EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"
	{
		value := conv.IntToString(params.RunnerID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminGetAuditLog(ctx context.Context, params EnterpriseAdminGetAuditLogParams) (_ []AuditLogEvent, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/audit-log"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Phrase)
		q.Set("phrase", s)
	}
	{
		s := conv.StringToString(params.Include)
		q.Set("include", s)
	}
	{
		s := conv.StringToString(params.After)
		q.Set("after", s)
	}
	{
		s := conv.StringToString(params.Before)
		q.Set("before", s)
	}
	{
		s := conv.StringToString(params.Order)
		q.Set("order", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetAuditLogResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) BillingGetGithubActionsBillingGhe(ctx context.Context, params BillingGetGithubActionsBillingGheParams) (_ ActionsBillingUsage, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/settings"
	path += "/billing"
	path += "/actions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubActionsBillingGheResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) BillingGetGithubPackagesBillingGhe(ctx context.Context, params BillingGetGithubPackagesBillingGheParams) (_ PackagesBillingUsage, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/settings"
	path += "/billing"
	path += "/packages"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubPackagesBillingGheResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) BillingGetSharedStorageBillingGhe(ctx context.Context, params BillingGetSharedStorageBillingGheParams) (_ CombinedBillingUsage, rerr error) {
	path := c.serverURL
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/settings"
	path += "/billing"
	path += "/shared-storage"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetSharedStorageBillingGheResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListPublicEvents(ctx context.Context, params ActivityListPublicEventsParams) (_ ActivityListPublicEventsResponse, rerr error) {
	path := c.serverURL
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListPublicEventsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityGetFeeds(ctx context.Context) (_ Feed, rerr error) {
	path := c.serverURL
	path += "/feeds"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityGetFeedsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsList(ctx context.Context, params GistsListParams) (_ GistsListResponse, rerr error) {
	path := c.serverURL
	path += "/gists"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsCreate(ctx context.Context, req GistsCreateRequest) (_ GistsCreateResponse, rerr error) {
	body, contentType, err := encodeGistsCreateRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/gists"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsCreateResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsListPublic(ctx context.Context, params GistsListPublicParams) (_ GistsListPublicResponse, rerr error) {
	path := c.serverURL
	path += "/gists"
	path += "/public"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsListPublicResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsListStarred(ctx context.Context, params GistsListStarredParams) (_ GistsListStarredResponse, rerr error) {
	path := c.serverURL
	path += "/gists"
	path += "/starred"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsListStarredResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsGet(ctx context.Context, params GistsGetParams) (_ GistsGetResponse, rerr error) {
	path := c.serverURL
	path += "/gists"
	{
		value := conv.StringToString(params.GistID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsGetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsDelete(ctx context.Context, params GistsDeleteParams) (_ GistsDeleteResponse, rerr error) {
	path := c.serverURL
	path += "/gists"
	{
		value := conv.StringToString(params.GistID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsDeleteResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsUpdate(ctx context.Context, req GistsUpdateApplicationJSONRequest, params GistsUpdateParams) (_ GistsUpdateResponse, rerr error) {
	body, contentType, err := encodeGistsUpdateRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/gists"
	{
		value := conv.StringToString(params.GistID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsUpdateResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsListComments(ctx context.Context, params GistsListCommentsParams) (_ GistsListCommentsResponse, rerr error) {
	path := c.serverURL
	path += "/gists"
	{
		value := conv.StringToString(params.GistID)
		path += "/" + value
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsListCommentsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsCreateComment(ctx context.Context, req GistsCreateCommentApplicationJSONRequest, params GistsCreateCommentParams) (_ GistsCreateCommentResponse, rerr error) {
	body, contentType, err := encodeGistsCreateCommentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/gists"
	{
		value := conv.StringToString(params.GistID)
		path += "/" + value
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsCreateCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsGetComment(ctx context.Context, params GistsGetCommentParams) (_ GistsGetCommentResponse, rerr error) {
	path := c.serverURL
	path += "/gists"
	{
		value := conv.StringToString(params.GistID)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsGetCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsDeleteComment(ctx context.Context, params GistsDeleteCommentParams) (_ GistsDeleteCommentResponse, rerr error) {
	path := c.serverURL
	path += "/gists"
	{
		value := conv.StringToString(params.GistID)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsDeleteCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsUpdateComment(ctx context.Context, req GistsUpdateCommentApplicationJSONRequest, params GistsUpdateCommentParams) (_ GistsUpdateCommentResponse, rerr error) {
	body, contentType, err := encodeGistsUpdateCommentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/gists"
	{
		value := conv.StringToString(params.GistID)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsUpdateCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsListCommits(ctx context.Context, params GistsListCommitsParams) (_ GistsListCommitsResponse, rerr error) {
	path := c.serverURL
	path += "/gists"
	{
		value := conv.StringToString(params.GistID)
		path += "/" + value
	}
	path += "/commits"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsListCommitsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsListForks(ctx context.Context, params GistsListForksParams) (_ GistsListForksResponse, rerr error) {
	path := c.serverURL
	path += "/gists"
	{
		value := conv.StringToString(params.GistID)
		path += "/" + value
	}
	path += "/forks"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsListForksResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsFork(ctx context.Context, params GistsForkParams) (_ GistsForkResponse, rerr error) {
	path := c.serverURL
	path += "/gists"
	{
		value := conv.StringToString(params.GistID)
		path += "/" + value
	}
	path += "/forks"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsForkResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsCheckIsStarred(ctx context.Context, params GistsCheckIsStarredParams) (_ GistsCheckIsStarredResponse, rerr error) {
	path := c.serverURL
	path += "/gists"
	{
		value := conv.StringToString(params.GistID)
		path += "/" + value
	}
	path += "/star"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsCheckIsStarredResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsStar(ctx context.Context, params GistsStarParams) (_ GistsStarResponse, rerr error) {
	path := c.serverURL
	path += "/gists"
	{
		value := conv.StringToString(params.GistID)
		path += "/" + value
	}
	path += "/star"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsStarResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsUnstar(ctx context.Context, params GistsUnstarParams) (_ GistsUnstarResponse, rerr error) {
	path := c.serverURL
	path += "/gists"
	{
		value := conv.StringToString(params.GistID)
		path += "/" + value
	}
	path += "/star"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsUnstarResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsGetRevision(ctx context.Context, params GistsGetRevisionParams) (_ GistsGetRevisionResponse, rerr error) {
	path := c.serverURL
	path += "/gists"
	{
		value := conv.StringToString(params.GistID)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Sha)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsGetRevisionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GitignoreGetAllTemplates(ctx context.Context) (_ GitignoreGetAllTemplatesResponse, rerr error) {
	path := c.serverURL
	path += "/gitignore"
	path += "/templates"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGitignoreGetAllTemplatesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GitignoreGetTemplate(ctx context.Context, params GitignoreGetTemplateParams) (_ GitignoreGetTemplateResponse, rerr error) {
	path := c.serverURL
	path += "/gitignore"
	path += "/templates"
	{
		value := conv.StringToString(params.Name)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGitignoreGetTemplateResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsListReposAccessibleToInstallation(ctx context.Context, params AppsListReposAccessibleToInstallationParams) (_ AppsListReposAccessibleToInstallationResponse, rerr error) {
	path := c.serverURL
	path += "/installation"
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsListReposAccessibleToInstallationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsRevokeInstallationAccessToken(ctx context.Context) (_ AppsRevokeInstallationAccessToken, rerr error) {
	path := c.serverURL
	path += "/installation"
	path += "/token"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsRevokeInstallationAccessTokenResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesList(ctx context.Context, params IssuesListParams) (_ IssuesListResponse, rerr error) {
	path := c.serverURL
	path += "/issues"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Filter)
		q.Set("filter", s)
	}
	{
		s := conv.StringToString(params.State)
		q.Set("state", s)
	}
	{
		s := conv.StringToString(params.Labels)
		q.Set("labels", s)
	}
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.BoolToString(params.Collab)
		q.Set("collab", s)
	}
	{
		s := conv.BoolToString(params.Orgs)
		q.Set("orgs", s)
	}
	{
		s := conv.BoolToString(params.Owned)
		q.Set("owned", s)
	}
	{
		s := conv.BoolToString(params.Pulls)
		q.Set("pulls", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) LicensesGetAllCommonlyUsed(ctx context.Context, params LicensesGetAllCommonlyUsedParams) (_ LicensesGetAllCommonlyUsedResponse, rerr error) {
	path := c.serverURL
	path += "/licenses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.Featured)
		q.Set("featured", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeLicensesGetAllCommonlyUsedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) LicensesGet(ctx context.Context, params LicensesGetParams) (_ LicensesGetResponse, rerr error) {
	path := c.serverURL
	path += "/licenses"
	{
		value := conv.StringToString(params.License)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeLicensesGetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MarkdownRender(ctx context.Context, req MarkdownRenderApplicationJSONRequest) (_ MarkdownRenderResponse, rerr error) {
	body, contentType, err := encodeMarkdownRenderRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/markdown"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMarkdownRenderResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MarkdownRenderRaw(ctx context.Context, req MarkdownRenderRawRequest) (_ MarkdownRenderRawResponse, rerr error) {
	body, contentType, err := encodeMarkdownRenderRawRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/markdown"
	path += "/raw"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMarkdownRenderRawResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsGetSubscriptionPlanForAccount(ctx context.Context, params AppsGetSubscriptionPlanForAccountParams) (_ AppsGetSubscriptionPlanForAccountResponse, rerr error) {
	path := c.serverURL
	path += "/marketplace_listing"
	path += "/accounts"
	{
		value := conv.IntToString(params.AccountID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetSubscriptionPlanForAccountResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsListPlans(ctx context.Context, params AppsListPlansParams) (_ AppsListPlansResponse, rerr error) {
	path := c.serverURL
	path += "/marketplace_listing"
	path += "/plans"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsListPlansResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsListAccountsForPlan(ctx context.Context, params AppsListAccountsForPlanParams) (_ AppsListAccountsForPlanResponse, rerr error) {
	path := c.serverURL
	path += "/marketplace_listing"
	path += "/plans"
	{
		value := conv.IntToString(params.PlanID)
		path += "/" + value
	}
	path += "/accounts"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsListAccountsForPlanResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsGetSubscriptionPlanForAccountStubbed(ctx context.Context, params AppsGetSubscriptionPlanForAccountStubbedParams) (_ AppsGetSubscriptionPlanForAccountStubbedResponse, rerr error) {
	path := c.serverURL
	path += "/marketplace_listing"
	path += "/stubbed"
	path += "/accounts"
	{
		value := conv.IntToString(params.AccountID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetSubscriptionPlanForAccountStubbedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsListPlansStubbed(ctx context.Context, params AppsListPlansStubbedParams) (_ AppsListPlansStubbedResponse, rerr error) {
	path := c.serverURL
	path += "/marketplace_listing"
	path += "/stubbed"
	path += "/plans"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsListPlansStubbedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsListAccountsForPlanStubbed(ctx context.Context, params AppsListAccountsForPlanStubbedParams) (_ AppsListAccountsForPlanStubbedResponse, rerr error) {
	path := c.serverURL
	path += "/marketplace_listing"
	path += "/stubbed"
	path += "/plans"
	{
		value := conv.IntToString(params.PlanID)
		path += "/" + value
	}
	path += "/accounts"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsListAccountsForPlanStubbedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MetaGet(ctx context.Context) (_ MetaGetResponse, rerr error) {
	path := c.serverURL
	path += "/meta"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMetaGetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListPublicEventsForRepoNetwork(ctx context.Context, params ActivityListPublicEventsForRepoNetworkParams) (_ ActivityListPublicEventsForRepoNetworkResponse, rerr error) {
	path := c.serverURL
	path += "/networks"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListPublicEventsForRepoNetworkResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListNotificationsForAuthenticatedUser(ctx context.Context, params ActivityListNotificationsForAuthenticatedUserParams) (_ ActivityListNotificationsForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/notifications"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.All)
		q.Set("all", s)
	}
	{
		s := conv.BoolToString(params.Participating)
		q.Set("participating", s)
	}
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.TimeToString(params.Before)
		q.Set("before", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListNotificationsForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityMarkNotificationsAsRead(ctx context.Context, req *ActivityMarkNotificationsAsReadApplicationJSONRequest) (_ ActivityMarkNotificationsAsReadResponse, rerr error) {
	body, contentType, err := encodeActivityMarkNotificationsAsReadRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/notifications"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityMarkNotificationsAsReadResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityGetThread(ctx context.Context, params ActivityGetThreadParams) (_ ActivityGetThreadResponse, rerr error) {
	path := c.serverURL
	path += "/notifications"
	path += "/threads"
	{
		value := conv.IntToString(params.ThreadID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityGetThreadResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityMarkThreadAsRead(ctx context.Context, params ActivityMarkThreadAsReadParams) (_ ActivityMarkThreadAsReadResponse, rerr error) {
	path := c.serverURL
	path += "/notifications"
	path += "/threads"
	{
		value := conv.IntToString(params.ThreadID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityMarkThreadAsReadResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityGetThreadSubscriptionForAuthenticatedUser(ctx context.Context, params ActivityGetThreadSubscriptionForAuthenticatedUserParams) (_ ActivityGetThreadSubscriptionForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/notifications"
	path += "/threads"
	{
		value := conv.IntToString(params.ThreadID)
		path += "/" + value
	}
	path += "/subscription"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityGetThreadSubscriptionForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivitySetThreadSubscription(ctx context.Context, req *ActivitySetThreadSubscriptionApplicationJSONRequest, params ActivitySetThreadSubscriptionParams) (_ ActivitySetThreadSubscriptionResponse, rerr error) {
	body, contentType, err := encodeActivitySetThreadSubscriptionRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/notifications"
	path += "/threads"
	{
		value := conv.IntToString(params.ThreadID)
		path += "/" + value
	}
	path += "/subscription"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivitySetThreadSubscriptionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityDeleteThreadSubscription(ctx context.Context, params ActivityDeleteThreadSubscriptionParams) (_ ActivityDeleteThreadSubscriptionResponse, rerr error) {
	path := c.serverURL
	path += "/notifications"
	path += "/threads"
	{
		value := conv.IntToString(params.ThreadID)
		path += "/" + value
	}
	path += "/subscription"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityDeleteThreadSubscriptionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MetaGetOctocat(ctx context.Context, params MetaGetOctocatParams) (_ string, rerr error) {
	path := c.serverURL
	path += "/octocat"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.S)
		q.Set("s", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMetaGetOctocatResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsList(ctx context.Context, params OrgsListParams) (_ OrgsListResponse, rerr error) {
	path := c.serverURL
	path += "/organizations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsGet(ctx context.Context, params OrgsGetParams) (_ OrgsGetResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsUpdate(ctx context.Context, req *OrgsUpdateApplicationJSONRequest, params OrgsUpdateParams) (_ OrgsUpdateResponse, rerr error) {
	body, contentType, err := encodeOrgsUpdateRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsUpdateResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetGithubActionsPermissionsOrganization(ctx context.Context, params ActionsGetGithubActionsPermissionsOrganizationParams) (_ ActionsOrganizationPermissions, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetGithubActionsPermissionsOrganizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsSetGithubActionsPermissionsOrganization(ctx context.Context, req ActionsSetGithubActionsPermissionsOrganizationApplicationJSONRequest, params ActionsSetGithubActionsPermissionsOrganizationParams) (_ ActionsSetGithubActionsPermissionsOrganization, rerr error) {
	body, contentType, err := encodeActionsSetGithubActionsPermissionsOrganizationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetGithubActionsPermissionsOrganizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, params ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams) (_ ActionsListSelectedRepositoriesEnabledGithubActionsOrganization, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, req ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationApplicationJSONRequest, params ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams) (_ ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization, rerr error) {
	body, contentType, err := encodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx context.Context, params ActionsEnableSelectedRepositoryGithubActionsOrganizationParams) (_ ActionsEnableSelectedRepositoryGithubActionsOrganization, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"
	path += "/repositories"
	{
		value := conv.IntToString(params.RepositoryID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsEnableSelectedRepositoryGithubActionsOrganizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx context.Context, params ActionsDisableSelectedRepositoryGithubActionsOrganizationParams) (_ ActionsDisableSelectedRepositoryGithubActionsOrganization, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"
	path += "/repositories"
	{
		value := conv.IntToString(params.RepositoryID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsDisableSelectedRepositoryGithubActionsOrganizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetAllowedActionsOrganization(ctx context.Context, params ActionsGetAllowedActionsOrganizationParams) (_ SelectedActions, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"
	path += "/selected-actions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetAllowedActionsOrganizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsSetAllowedActionsOrganization(ctx context.Context, req *SelectedActions, params ActionsSetAllowedActionsOrganizationParams) (_ ActionsSetAllowedActionsOrganization, rerr error) {
	body, contentType, err := encodeActionsSetAllowedActionsOrganizationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"
	path += "/selected-actions"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetAllowedActionsOrganizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListSelfHostedRunnerGroupsForOrg(ctx context.Context, params ActionsListSelfHostedRunnerGroupsForOrgParams) (_ ActionsListSelfHostedRunnerGroupsForOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelfHostedRunnerGroupsForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsCreateSelfHostedRunnerGroupForOrg(ctx context.Context, req ActionsCreateSelfHostedRunnerGroupForOrgApplicationJSONRequest, params ActionsCreateSelfHostedRunnerGroupForOrgParams) (_ RunnerGroupsOrg, rerr error) {
	body, contentType, err := encodeActionsCreateSelfHostedRunnerGroupForOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateSelfHostedRunnerGroupForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetSelfHostedRunnerGroupForOrg(ctx context.Context, params ActionsGetSelfHostedRunnerGroupForOrgParams) (_ RunnerGroupsOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetSelfHostedRunnerGroupForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsDeleteSelfHostedRunnerGroupFromOrg(ctx context.Context, params ActionsDeleteSelfHostedRunnerGroupFromOrgParams) (_ ActionsDeleteSelfHostedRunnerGroupFromOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteSelfHostedRunnerGroupFromOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsUpdateSelfHostedRunnerGroupForOrg(ctx context.Context, req ActionsUpdateSelfHostedRunnerGroupForOrgApplicationJSONRequest, params ActionsUpdateSelfHostedRunnerGroupForOrgParams) (_ RunnerGroupsOrg, rerr error) {
	body, contentType, err := encodeActionsUpdateSelfHostedRunnerGroupForOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsUpdateSelfHostedRunnerGroupForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams) (_ ActionsListRepoAccessToSelfHostedRunnerGroupInOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, req ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgApplicationJSONRequest, params ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams) (_ ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg, rerr error) {
	body, contentType, err := encodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams) (_ ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/repositories"
	{
		value := conv.IntToString(params.RepositoryID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, params ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams) (_ ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/repositories"
	{
		value := conv.IntToString(params.RepositoryID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListSelfHostedRunnersInGroupForOrg(ctx context.Context, params ActionsListSelfHostedRunnersInGroupForOrgParams) (_ ActionsListSelfHostedRunnersInGroupForOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/runners"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelfHostedRunnersInGroupForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsSetSelfHostedRunnersInGroupForOrg(ctx context.Context, req ActionsSetSelfHostedRunnersInGroupForOrgApplicationJSONRequest, params ActionsSetSelfHostedRunnersInGroupForOrgParams) (_ ActionsSetSelfHostedRunnersInGroupForOrg, rerr error) {
	body, contentType, err := encodeActionsSetSelfHostedRunnersInGroupForOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/runners"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetSelfHostedRunnersInGroupForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsAddSelfHostedRunnerToGroupForOrg(ctx context.Context, params ActionsAddSelfHostedRunnerToGroupForOrgParams) (_ ActionsAddSelfHostedRunnerToGroupForOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/runners"
	{
		value := conv.IntToString(params.RunnerID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsAddSelfHostedRunnerToGroupForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx context.Context, params ActionsRemoveSelfHostedRunnerFromGroupForOrgParams) (_ ActionsRemoveSelfHostedRunnerFromGroupForOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runner-groups"
	{
		value := conv.IntToString(params.RunnerGroupID)
		path += "/" + value
	}
	path += "/runners"
	{
		value := conv.IntToString(params.RunnerID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsRemoveSelfHostedRunnerFromGroupForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListSelfHostedRunnersForOrg(ctx context.Context, params ActionsListSelfHostedRunnersForOrgParams) (_ ActionsListSelfHostedRunnersForOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelfHostedRunnersForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListRunnerApplicationsForOrg(ctx context.Context, params ActionsListRunnerApplicationsForOrgParams) (_ []RunnerApplication, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"
	path += "/downloads"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListRunnerApplicationsForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsCreateRegistrationTokenForOrg(ctx context.Context, params ActionsCreateRegistrationTokenForOrgParams) (_ AuthenticationToken, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"
	path += "/registration-token"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateRegistrationTokenForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsCreateRemoveTokenForOrg(ctx context.Context, params ActionsCreateRemoveTokenForOrgParams) (_ AuthenticationToken, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"
	path += "/remove-token"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateRemoveTokenForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetSelfHostedRunnerForOrg(ctx context.Context, params ActionsGetSelfHostedRunnerForOrgParams) (_ Runner, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"
	{
		value := conv.IntToString(params.RunnerID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetSelfHostedRunnerForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsDeleteSelfHostedRunnerFromOrg(ctx context.Context, params ActionsDeleteSelfHostedRunnerFromOrgParams) (_ ActionsDeleteSelfHostedRunnerFromOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"
	{
		value := conv.IntToString(params.RunnerID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteSelfHostedRunnerFromOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListOrgSecrets(ctx context.Context, params ActionsListOrgSecretsParams) (_ ActionsListOrgSecrets, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/secrets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListOrgSecretsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetOrgPublicKey(ctx context.Context, params ActionsGetOrgPublicKeyParams) (_ ActionsPublicKey, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/secrets"
	path += "/public-key"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetOrgPublicKeyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetOrgSecret(ctx context.Context, params ActionsGetOrgSecretParams) (_ OrganizationActionsSecret, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/secrets"
	{
		value := conv.StringToString(params.SecretName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetOrgSecretResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsCreateOrUpdateOrgSecret(ctx context.Context, req ActionsCreateOrUpdateOrgSecretApplicationJSONRequest, params ActionsCreateOrUpdateOrgSecretParams) (_ ActionsCreateOrUpdateOrgSecretResponse, rerr error) {
	body, contentType, err := encodeActionsCreateOrUpdateOrgSecretRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/secrets"
	{
		value := conv.StringToString(params.SecretName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateOrUpdateOrgSecretResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsDeleteOrgSecret(ctx context.Context, params ActionsDeleteOrgSecretParams) (_ ActionsDeleteOrgSecret, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/secrets"
	{
		value := conv.StringToString(params.SecretName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteOrgSecretResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListSelectedReposForOrgSecret(ctx context.Context, params ActionsListSelectedReposForOrgSecretParams) (_ ActionsListSelectedReposForOrgSecret, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/secrets"
	{
		value := conv.StringToString(params.SecretName)
		path += "/" + value
	}
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelectedReposForOrgSecretResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsSetSelectedReposForOrgSecret(ctx context.Context, req ActionsSetSelectedReposForOrgSecretApplicationJSONRequest, params ActionsSetSelectedReposForOrgSecretParams) (_ ActionsSetSelectedReposForOrgSecret, rerr error) {
	body, contentType, err := encodeActionsSetSelectedReposForOrgSecretRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/secrets"
	{
		value := conv.StringToString(params.SecretName)
		path += "/" + value
	}
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetSelectedReposForOrgSecretResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsAddSelectedRepoToOrgSecret(ctx context.Context, params ActionsAddSelectedRepoToOrgSecretParams) (_ ActionsAddSelectedRepoToOrgSecretResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/secrets"
	{
		value := conv.StringToString(params.SecretName)
		path += "/" + value
	}
	path += "/repositories"
	{
		value := conv.IntToString(params.RepositoryID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsAddSelectedRepoToOrgSecretResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsRemoveSelectedRepoFromOrgSecret(ctx context.Context, params ActionsRemoveSelectedRepoFromOrgSecretParams) (_ ActionsRemoveSelectedRepoFromOrgSecretResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/actions"
	path += "/secrets"
	{
		value := conv.StringToString(params.SecretName)
		path += "/" + value
	}
	path += "/repositories"
	{
		value := conv.IntToString(params.RepositoryID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsRemoveSelectedRepoFromOrgSecretResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsGetAuditLog(ctx context.Context, params OrgsGetAuditLogParams) (_ OrgsGetAuditLogResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/audit-log"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Phrase)
		q.Set("phrase", s)
	}
	{
		s := conv.StringToString(params.Include)
		q.Set("include", s)
	}
	{
		s := conv.StringToString(params.After)
		q.Set("after", s)
	}
	{
		s := conv.StringToString(params.Before)
		q.Set("before", s)
	}
	{
		s := conv.StringToString(params.Order)
		q.Set("order", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetAuditLogResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsListBlockedUsers(ctx context.Context, params OrgsListBlockedUsersParams) (_ OrgsListBlockedUsersResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/blocks"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListBlockedUsersResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsCheckBlockedUser(ctx context.Context, params OrgsCheckBlockedUserParams) (_ OrgsCheckBlockedUserResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/blocks"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsCheckBlockedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsBlockUser(ctx context.Context, params OrgsBlockUserParams) (_ OrgsBlockUserResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/blocks"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsBlockUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsUnblockUser(ctx context.Context, params OrgsUnblockUserParams) (_ OrgsUnblockUser, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/blocks"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsUnblockUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsListSamlSSOAuthorizations(ctx context.Context, params OrgsListSamlSSOAuthorizationsParams) (_ []CredentialAuthorization, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/credential-authorizations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListSamlSSOAuthorizationsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsRemoveSamlSSOAuthorization(ctx context.Context, params OrgsRemoveSamlSSOAuthorizationParams) (_ OrgsRemoveSamlSSOAuthorizationResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/credential-authorizations"
	{
		value := conv.IntToString(params.CredentialID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRemoveSamlSSOAuthorizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListPublicOrgEvents(ctx context.Context, params ActivityListPublicOrgEventsParams) (_ []Event, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListPublicOrgEventsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsListFailedInvitations(ctx context.Context, params OrgsListFailedInvitationsParams) (_ OrgsListFailedInvitationsResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/failed_invitations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListFailedInvitationsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsListWebhooks(ctx context.Context, params OrgsListWebhooksParams) (_ OrgsListWebhooksResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/hooks"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListWebhooksResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsCreateWebhook(ctx context.Context, req OrgsCreateWebhookRequest, params OrgsCreateWebhookParams) (_ OrgsCreateWebhookResponse, rerr error) {
	body, contentType, err := encodeOrgsCreateWebhookRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/hooks"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsCreateWebhookResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsGetWebhook(ctx context.Context, params OrgsGetWebhookParams) (_ OrgsGetWebhookResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetWebhookResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsDeleteWebhook(ctx context.Context, params OrgsDeleteWebhookParams) (_ OrgsDeleteWebhookResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsDeleteWebhookResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsUpdateWebhook(ctx context.Context, req OrgsUpdateWebhookRequest, params OrgsUpdateWebhookParams) (_ OrgsUpdateWebhookResponse, rerr error) {
	body, contentType, err := encodeOrgsUpdateWebhookRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsUpdateWebhookResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsGetWebhookConfigForOrg(ctx context.Context, params OrgsGetWebhookConfigForOrgParams) (_ WebhookConfig, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}
	path += "/config"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetWebhookConfigForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsUpdateWebhookConfigForOrg(ctx context.Context, req OrgsUpdateWebhookConfigForOrgRequest, params OrgsUpdateWebhookConfigForOrgParams) (_ WebhookConfig, rerr error) {
	body, contentType, err := encodeOrgsUpdateWebhookConfigForOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}
	path += "/config"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsUpdateWebhookConfigForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsListWebhookDeliveries(ctx context.Context, params OrgsListWebhookDeliveriesParams) (_ OrgsListWebhookDeliveriesResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}
	path += "/deliveries"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.StringToString(params.Cursor)
		q.Set("cursor", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListWebhookDeliveriesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsGetWebhookDelivery(ctx context.Context, params OrgsGetWebhookDeliveryParams) (_ OrgsGetWebhookDeliveryResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}
	path += "/deliveries"
	{
		value := conv.IntToString(params.DeliveryID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetWebhookDeliveryResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsRedeliverWebhookDelivery(ctx context.Context, params OrgsRedeliverWebhookDeliveryParams) (_ OrgsRedeliverWebhookDeliveryResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}
	path += "/deliveries"
	{
		value := conv.IntToString(params.DeliveryID)
		path += "/" + value
	}
	path += "/attempts"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRedeliverWebhookDeliveryResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsPingWebhook(ctx context.Context, params OrgsPingWebhookParams) (_ OrgsPingWebhookResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}
	path += "/pings"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsPingWebhookResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsGetOrgInstallation(ctx context.Context, params AppsGetOrgInstallationParams) (_ Installation, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/installation"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetOrgInstallationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsListAppInstallations(ctx context.Context, params OrgsListAppInstallationsParams) (_ OrgsListAppInstallations, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/installations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListAppInstallationsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) InteractionsGetRestrictionsForOrg(ctx context.Context, params InteractionsGetRestrictionsForOrgParams) (_ InteractionsGetRestrictionsForOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/interaction-limits"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsGetRestrictionsForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) InteractionsSetRestrictionsForOrg(ctx context.Context, req InteractionLimit, params InteractionsSetRestrictionsForOrgParams) (_ InteractionsSetRestrictionsForOrgResponse, rerr error) {
	body, contentType, err := encodeInteractionsSetRestrictionsForOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/interaction-limits"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsSetRestrictionsForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) InteractionsRemoveRestrictionsForOrg(ctx context.Context, params InteractionsRemoveRestrictionsForOrgParams) (_ InteractionsRemoveRestrictionsForOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/interaction-limits"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsRemoveRestrictionsForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsListPendingInvitations(ctx context.Context, params OrgsListPendingInvitationsParams) (_ OrgsListPendingInvitationsResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/invitations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListPendingInvitationsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsCreateInvitation(ctx context.Context, req *OrgsCreateInvitationApplicationJSONRequest, params OrgsCreateInvitationParams) (_ OrgsCreateInvitationResponse, rerr error) {
	body, contentType, err := encodeOrgsCreateInvitationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/invitations"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsCreateInvitationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsCancelInvitation(ctx context.Context, params OrgsCancelInvitationParams) (_ OrgsCancelInvitationResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/invitations"
	{
		value := conv.IntToString(params.InvitationID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsCancelInvitationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsListInvitationTeams(ctx context.Context, params OrgsListInvitationTeamsParams) (_ OrgsListInvitationTeamsResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/invitations"
	{
		value := conv.IntToString(params.InvitationID)
		path += "/" + value
	}
	path += "/teams"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListInvitationTeamsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesListForOrg(ctx context.Context, params IssuesListForOrgParams) (_ IssuesListForOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/issues"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Filter)
		q.Set("filter", s)
	}
	{
		s := conv.StringToString(params.State)
		q.Set("state", s)
	}
	{
		s := conv.StringToString(params.Labels)
		q.Set("labels", s)
	}
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsListMembers(ctx context.Context, params OrgsListMembersParams) (_ OrgsListMembersResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/members"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Filter)
		q.Set("filter", s)
	}
	{
		s := conv.StringToString(params.Role)
		q.Set("role", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListMembersResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsCheckMembershipForUser(ctx context.Context, params OrgsCheckMembershipForUserParams) (_ OrgsCheckMembershipForUserResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/members"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsCheckMembershipForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsRemoveMember(ctx context.Context, params OrgsRemoveMemberParams) (_ OrgsRemoveMemberResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/members"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRemoveMemberResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsGetMembershipForUser(ctx context.Context, params OrgsGetMembershipForUserParams) (_ OrgsGetMembershipForUserResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/memberships"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetMembershipForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsSetMembershipForUser(ctx context.Context, req *OrgsSetMembershipForUserApplicationJSONRequest, params OrgsSetMembershipForUserParams) (_ OrgsSetMembershipForUserResponse, rerr error) {
	body, contentType, err := encodeOrgsSetMembershipForUserRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/memberships"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsSetMembershipForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsRemoveMembershipForUser(ctx context.Context, params OrgsRemoveMembershipForUserParams) (_ OrgsRemoveMembershipForUserResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/memberships"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRemoveMembershipForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsListForOrg(ctx context.Context, params MigrationsListForOrgParams) (_ []Migration, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/migrations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.StringArrayToString(params.Exclude)
		for _, v := range s {
			q.Add("exclude", v)
		}
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsListForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsStartForOrg(ctx context.Context, req MigrationsStartForOrgApplicationJSONRequest, params MigrationsStartForOrgParams) (_ MigrationsStartForOrgResponse, rerr error) {
	body, contentType, err := encodeMigrationsStartForOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/migrations"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsStartForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsGetStatusForOrg(ctx context.Context, params MigrationsGetStatusForOrgParams) (_ MigrationsGetStatusForOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/migrations"
	{
		value := conv.IntToString(params.MigrationID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringArrayToString(params.Exclude)
		for _, v := range s {
			q.Add("exclude", v)
		}
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetStatusForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsDownloadArchiveForOrg(ctx context.Context, params MigrationsDownloadArchiveForOrgParams) (_ MigrationsDownloadArchiveForOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/migrations"
	{
		value := conv.IntToString(params.MigrationID)
		path += "/" + value
	}
	path += "/archive"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsDownloadArchiveForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsDeleteArchiveForOrg(ctx context.Context, params MigrationsDeleteArchiveForOrgParams) (_ MigrationsDeleteArchiveForOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/migrations"
	{
		value := conv.IntToString(params.MigrationID)
		path += "/" + value
	}
	path += "/archive"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsDeleteArchiveForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsUnlockRepoForOrg(ctx context.Context, params MigrationsUnlockRepoForOrgParams) (_ MigrationsUnlockRepoForOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/migrations"
	{
		value := conv.IntToString(params.MigrationID)
		path += "/" + value
	}
	path += "/repos"
	{
		value := conv.StringToString(params.RepoName)
		path += "/" + value
	}
	path += "/lock"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsUnlockRepoForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsListReposForOrg(ctx context.Context, params MigrationsListReposForOrgParams) (_ MigrationsListReposForOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/migrations"
	{
		value := conv.IntToString(params.MigrationID)
		path += "/" + value
	}
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsListReposForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsListOutsideCollaborators(ctx context.Context, params OrgsListOutsideCollaboratorsParams) (_ []SimpleUser, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/outside_collaborators"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Filter)
		q.Set("filter", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListOutsideCollaboratorsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsConvertMemberToOutsideCollaborator(ctx context.Context, params OrgsConvertMemberToOutsideCollaboratorParams) (_ OrgsConvertMemberToOutsideCollaboratorResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/outside_collaborators"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsConvertMemberToOutsideCollaboratorResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsRemoveOutsideCollaborator(ctx context.Context, params OrgsRemoveOutsideCollaboratorParams) (_ OrgsRemoveOutsideCollaboratorResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/outside_collaborators"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRemoveOutsideCollaboratorResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesListPackagesForOrganization(ctx context.Context, params PackagesListPackagesForOrganizationParams) (_ PackagesListPackagesForOrganizationResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/packages"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.PackageType)
		q.Set("package_type", s)
	}
	{
		s := conv.StringToString(params.Visibility)
		q.Set("visibility", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesListPackagesForOrganizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesGetPackageForOrganization(ctx context.Context, params PackagesGetPackageForOrganizationParams) (_ Package, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetPackageForOrganizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesDeletePackageForOrg(ctx context.Context, params PackagesDeletePackageForOrgParams) (_ PackagesDeletePackageForOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesDeletePackageForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesRestorePackageForOrg(ctx context.Context, params PackagesRestorePackageForOrgParams) (_ PackagesRestorePackageForOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}
	path += "/restore"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Token)
		q.Set("token", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesRestorePackageForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx context.Context, params PackagesGetAllPackageVersionsForPackageOwnedByOrgParams) (_ PackagesGetAllPackageVersionsForPackageOwnedByOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}
	path += "/versions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.StringToString(params.State)
		q.Set("state", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetAllPackageVersionsForPackageOwnedByOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesGetPackageVersionForOrganization(ctx context.Context, params PackagesGetPackageVersionForOrganizationParams) (_ PackageVersion, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}
	path += "/versions"
	{
		value := conv.IntToString(params.PackageVersionID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetPackageVersionForOrganizationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesDeletePackageVersionForOrg(ctx context.Context, params PackagesDeletePackageVersionForOrgParams) (_ PackagesDeletePackageVersionForOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}
	path += "/versions"
	{
		value := conv.IntToString(params.PackageVersionID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesDeletePackageVersionForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesRestorePackageVersionForOrg(ctx context.Context, params PackagesRestorePackageVersionForOrgParams) (_ PackagesRestorePackageVersionForOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}
	path += "/versions"
	{
		value := conv.IntToString(params.PackageVersionID)
		path += "/" + value
	}
	path += "/restore"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesRestorePackageVersionForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsListForOrg(ctx context.Context, params ProjectsListForOrgParams) (_ ProjectsListForOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/projects"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.State)
		q.Set("state", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsListForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsCreateForOrg(ctx context.Context, req ProjectsCreateForOrgApplicationJSONRequest, params ProjectsCreateForOrgParams) (_ ProjectsCreateForOrgResponse, rerr error) {
	body, contentType, err := encodeProjectsCreateForOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/projects"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsCreateForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsListPublicMembers(ctx context.Context, params OrgsListPublicMembersParams) (_ []SimpleUser, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/public_members"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListPublicMembersResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsCheckPublicMembershipForUser(ctx context.Context, params OrgsCheckPublicMembershipForUserParams) (_ OrgsCheckPublicMembershipForUserResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/public_members"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsCheckPublicMembershipForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsSetPublicMembershipForAuthenticatedUser(ctx context.Context, params OrgsSetPublicMembershipForAuthenticatedUserParams) (_ OrgsSetPublicMembershipForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/public_members"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsSetPublicMembershipForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsRemovePublicMembershipForAuthenticatedUser(ctx context.Context, params OrgsRemovePublicMembershipForAuthenticatedUserParams) (_ OrgsRemovePublicMembershipForAuthenticatedUser, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/public_members"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsRemovePublicMembershipForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListForOrg(ctx context.Context, params ReposListForOrgParams) (_ []MinimalRepository, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/repos"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Type)
		q.Set("type", s)
	}
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateInOrg(ctx context.Context, req ReposCreateInOrgApplicationJSONRequest, params ReposCreateInOrgParams) (_ ReposCreateInOrgResponse, rerr error) {
	body, contentType, err := encodeReposCreateInOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/repos"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) SecretScanningListAlertsForOrg(ctx context.Context, params SecretScanningListAlertsForOrgParams) (_ SecretScanningListAlertsForOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/secret-scanning"
	path += "/alerts"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.State)
		q.Set("state", s)
	}
	{
		s := conv.StringToString(params.SecretType)
		q.Set("secret_type", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeSecretScanningListAlertsForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) BillingGetGithubActionsBillingOrg(ctx context.Context, params BillingGetGithubActionsBillingOrgParams) (_ ActionsBillingUsage, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/settings"
	path += "/billing"
	path += "/actions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubActionsBillingOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) BillingGetGithubPackagesBillingOrg(ctx context.Context, params BillingGetGithubPackagesBillingOrgParams) (_ PackagesBillingUsage, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/settings"
	path += "/billing"
	path += "/packages"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubPackagesBillingOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) BillingGetSharedStorageBillingOrg(ctx context.Context, params BillingGetSharedStorageBillingOrgParams) (_ CombinedBillingUsage, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/settings"
	path += "/billing"
	path += "/shared-storage"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetSharedStorageBillingOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListIdpGroupsForOrg(ctx context.Context, params TeamsListIdpGroupsForOrgParams) (_ GroupMapping, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/team-sync"
	path += "/groups"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.StringToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListIdpGroupsForOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsList(ctx context.Context, params TeamsListParams) (_ TeamsListResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsCreate(ctx context.Context, req TeamsCreateApplicationJSONRequest, params TeamsCreateParams) (_ TeamsCreateResponse, rerr error) {
	body, contentType, err := encodeTeamsCreateRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsGetByName(ctx context.Context, params TeamsGetByNameParams) (_ TeamsGetByNameResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetByNameResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsDeleteInOrg(ctx context.Context, params TeamsDeleteInOrgParams) (_ TeamsDeleteInOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsUpdateInOrg(ctx context.Context, req *TeamsUpdateInOrgApplicationJSONRequest, params TeamsUpdateInOrgParams) (_ TeamFull, rerr error) {
	body, contentType, err := encodeTeamsUpdateInOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListDiscussionsInOrg(ctx context.Context, params TeamsListDiscussionsInOrgParams) (_ []TeamDiscussion, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.StringToString(params.Pinned)
		q.Set("pinned", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListDiscussionsInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsCreateDiscussionInOrg(ctx context.Context, req TeamsCreateDiscussionInOrgApplicationJSONRequest, params TeamsCreateDiscussionInOrgParams) (_ TeamDiscussion, rerr error) {
	body, contentType, err := encodeTeamsCreateDiscussionInOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateDiscussionInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsGetDiscussionInOrg(ctx context.Context, params TeamsGetDiscussionInOrgParams) (_ TeamDiscussion, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetDiscussionInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsDeleteDiscussionInOrg(ctx context.Context, params TeamsDeleteDiscussionInOrgParams) (_ TeamsDeleteDiscussionInOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteDiscussionInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsUpdateDiscussionInOrg(ctx context.Context, req *TeamsUpdateDiscussionInOrgApplicationJSONRequest, params TeamsUpdateDiscussionInOrgParams) (_ TeamDiscussion, rerr error) {
	body, contentType, err := encodeTeamsUpdateDiscussionInOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateDiscussionInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListDiscussionCommentsInOrg(ctx context.Context, params TeamsListDiscussionCommentsInOrgParams) (_ []TeamDiscussionComment, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListDiscussionCommentsInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsCreateDiscussionCommentInOrg(ctx context.Context, req TeamsCreateDiscussionCommentInOrgApplicationJSONRequest, params TeamsCreateDiscussionCommentInOrgParams) (_ TeamDiscussionComment, rerr error) {
	body, contentType, err := encodeTeamsCreateDiscussionCommentInOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateDiscussionCommentInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsGetDiscussionCommentInOrg(ctx context.Context, params TeamsGetDiscussionCommentInOrgParams) (_ TeamDiscussionComment, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetDiscussionCommentInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsDeleteDiscussionCommentInOrg(ctx context.Context, params TeamsDeleteDiscussionCommentInOrgParams) (_ TeamsDeleteDiscussionCommentInOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteDiscussionCommentInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsUpdateDiscussionCommentInOrg(ctx context.Context, req TeamsUpdateDiscussionCommentInOrgApplicationJSONRequest, params TeamsUpdateDiscussionCommentInOrgParams) (_ TeamDiscussionComment, rerr error) {
	body, contentType, err := encodeTeamsUpdateDiscussionCommentInOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateDiscussionCommentInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsListForTeamDiscussionCommentInOrg(ctx context.Context, params ReactionsListForTeamDiscussionCommentInOrgParams) (_ []Reaction, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentNumber)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Content)
		q.Set("content", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForTeamDiscussionCommentInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsCreateForTeamDiscussionCommentInOrg(ctx context.Context, req ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONRequest, params ReactionsCreateForTeamDiscussionCommentInOrgParams) (_ ReactionsCreateForTeamDiscussionCommentInOrgResponse, rerr error) {
	body, contentType, err := encodeReactionsCreateForTeamDiscussionCommentInOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentNumber)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForTeamDiscussionCommentInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsDeleteForTeamDiscussionComment(ctx context.Context, params ReactionsDeleteForTeamDiscussionCommentParams) (_ ReactionsDeleteForTeamDiscussionComment, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentNumber)
		path += "/" + value
	}
	path += "/reactions"
	{
		value := conv.IntToString(params.ReactionID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForTeamDiscussionCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsListForTeamDiscussionInOrg(ctx context.Context, params ReactionsListForTeamDiscussionInOrgParams) (_ []Reaction, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Content)
		q.Set("content", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForTeamDiscussionInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsCreateForTeamDiscussionInOrg(ctx context.Context, req ReactionsCreateForTeamDiscussionInOrgApplicationJSONRequest, params ReactionsCreateForTeamDiscussionInOrgParams) (_ ReactionsCreateForTeamDiscussionInOrgResponse, rerr error) {
	body, contentType, err := encodeReactionsCreateForTeamDiscussionInOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForTeamDiscussionInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsDeleteForTeamDiscussion(ctx context.Context, params ReactionsDeleteForTeamDiscussionParams) (_ ReactionsDeleteForTeamDiscussion, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/reactions"
	{
		value := conv.IntToString(params.ReactionID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForTeamDiscussionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListPendingInvitationsInOrg(ctx context.Context, params TeamsListPendingInvitationsInOrgParams) (_ []OrganizationInvitation, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/invitations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListPendingInvitationsInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListMembersInOrg(ctx context.Context, params TeamsListMembersInOrgParams) (_ []SimpleUser, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/members"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Role)
		q.Set("role", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListMembersInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsGetMembershipForUserInOrg(ctx context.Context, params TeamsGetMembershipForUserInOrgParams) (_ TeamsGetMembershipForUserInOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/memberships"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetMembershipForUserInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsAddOrUpdateMembershipForUserInOrg(ctx context.Context, req *TeamsAddOrUpdateMembershipForUserInOrgApplicationJSONRequest, params TeamsAddOrUpdateMembershipForUserInOrgParams) (_ TeamsAddOrUpdateMembershipForUserInOrgResponse, rerr error) {
	body, contentType, err := encodeTeamsAddOrUpdateMembershipForUserInOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/memberships"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateMembershipForUserInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsRemoveMembershipForUserInOrg(ctx context.Context, params TeamsRemoveMembershipForUserInOrgParams) (_ TeamsRemoveMembershipForUserInOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/memberships"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveMembershipForUserInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListProjectsInOrg(ctx context.Context, params TeamsListProjectsInOrgParams) (_ []TeamProject, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/projects"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListProjectsInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsCheckPermissionsForProjectInOrg(ctx context.Context, params TeamsCheckPermissionsForProjectInOrgParams) (_ TeamsCheckPermissionsForProjectInOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/projects"
	{
		value := conv.IntToString(params.ProjectID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCheckPermissionsForProjectInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsAddOrUpdateProjectPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateProjectPermissionsInOrgApplicationJSONRequest, params TeamsAddOrUpdateProjectPermissionsInOrgParams) (_ TeamsAddOrUpdateProjectPermissionsInOrgResponse, rerr error) {
	body, contentType, err := encodeTeamsAddOrUpdateProjectPermissionsInOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/projects"
	{
		value := conv.IntToString(params.ProjectID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateProjectPermissionsInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsRemoveProjectInOrg(ctx context.Context, params TeamsRemoveProjectInOrgParams) (_ TeamsRemoveProjectInOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/projects"
	{
		value := conv.IntToString(params.ProjectID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveProjectInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListReposInOrg(ctx context.Context, params TeamsListReposInOrgParams) (_ []MinimalRepository, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/repos"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListReposInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsCheckPermissionsForRepoInOrg(ctx context.Context, params TeamsCheckPermissionsForRepoInOrgParams) (_ TeamsCheckPermissionsForRepoInOrgResponse, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCheckPermissionsForRepoInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsAddOrUpdateRepoPermissionsInOrg(ctx context.Context, req *TeamsAddOrUpdateRepoPermissionsInOrgApplicationJSONRequest, params TeamsAddOrUpdateRepoPermissionsInOrgParams) (_ TeamsAddOrUpdateRepoPermissionsInOrg, rerr error) {
	body, contentType, err := encodeTeamsAddOrUpdateRepoPermissionsInOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateRepoPermissionsInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsRemoveRepoInOrg(ctx context.Context, params TeamsRemoveRepoInOrgParams) (_ TeamsRemoveRepoInOrg, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveRepoInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListIdpGroupsInOrg(ctx context.Context, params TeamsListIdpGroupsInOrgParams) (_ GroupMapping, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/team-sync"
	path += "/group-mappings"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListIdpGroupsInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx context.Context, req TeamsCreateOrUpdateIdpGroupConnectionsInOrgApplicationJSONRequest, params TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams) (_ GroupMapping, rerr error) {
	body, contentType, err := encodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/team-sync"
	path += "/group-mappings"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListChildInOrg(ctx context.Context, params TeamsListChildInOrgParams) (_ []Team, rerr error) {
	path := c.serverURL
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/teams"
	{
		value := conv.StringToString(params.TeamSlug)
		path += "/" + value
	}
	path += "/teams"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListChildInOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsGetCard(ctx context.Context, params ProjectsGetCardParams) (_ ProjectsGetCardResponse, rerr error) {
	path := c.serverURL
	path += "/projects"
	path += "/columns"
	path += "/cards"
	{
		value := conv.IntToString(params.CardID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsGetCardResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsDeleteCard(ctx context.Context, params ProjectsDeleteCardParams) (_ ProjectsDeleteCardResponse, rerr error) {
	path := c.serverURL
	path += "/projects"
	path += "/columns"
	path += "/cards"
	{
		value := conv.IntToString(params.CardID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsDeleteCardResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsUpdateCard(ctx context.Context, req *ProjectsUpdateCardApplicationJSONRequest, params ProjectsUpdateCardParams) (_ ProjectsUpdateCardResponse, rerr error) {
	body, contentType, err := encodeProjectsUpdateCardRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/projects"
	path += "/columns"
	path += "/cards"
	{
		value := conv.IntToString(params.CardID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsUpdateCardResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsMoveCard(ctx context.Context, req ProjectsMoveCardApplicationJSONRequest, params ProjectsMoveCardParams) (_ ProjectsMoveCardResponse, rerr error) {
	body, contentType, err := encodeProjectsMoveCardRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/projects"
	path += "/columns"
	path += "/cards"
	{
		value := conv.IntToString(params.CardID)
		path += "/" + value
	}
	path += "/moves"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsMoveCardResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsGetColumn(ctx context.Context, params ProjectsGetColumnParams) (_ ProjectsGetColumnResponse, rerr error) {
	path := c.serverURL
	path += "/projects"
	path += "/columns"
	{
		value := conv.IntToString(params.ColumnID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsGetColumnResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsDeleteColumn(ctx context.Context, params ProjectsDeleteColumnParams) (_ ProjectsDeleteColumnResponse, rerr error) {
	path := c.serverURL
	path += "/projects"
	path += "/columns"
	{
		value := conv.IntToString(params.ColumnID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsDeleteColumnResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsUpdateColumn(ctx context.Context, req ProjectsUpdateColumnApplicationJSONRequest, params ProjectsUpdateColumnParams) (_ ProjectsUpdateColumnResponse, rerr error) {
	body, contentType, err := encodeProjectsUpdateColumnRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/projects"
	path += "/columns"
	{
		value := conv.IntToString(params.ColumnID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsUpdateColumnResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsListCards(ctx context.Context, params ProjectsListCardsParams) (_ ProjectsListCardsResponse, rerr error) {
	path := c.serverURL
	path += "/projects"
	path += "/columns"
	{
		value := conv.IntToString(params.ColumnID)
		path += "/" + value
	}
	path += "/cards"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.ArchivedState)
		q.Set("archived_state", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsListCardsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsCreateCard(ctx context.Context, req ProjectsCreateCardRequest, params ProjectsCreateCardParams) (_ ProjectsCreateCardResponse, rerr error) {
	body, contentType, err := encodeProjectsCreateCardRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/projects"
	path += "/columns"
	{
		value := conv.IntToString(params.ColumnID)
		path += "/" + value
	}
	path += "/cards"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsCreateCardResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsMoveColumn(ctx context.Context, req ProjectsMoveColumnApplicationJSONRequest, params ProjectsMoveColumnParams) (_ ProjectsMoveColumnResponse, rerr error) {
	body, contentType, err := encodeProjectsMoveColumnRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/projects"
	path += "/columns"
	{
		value := conv.IntToString(params.ColumnID)
		path += "/" + value
	}
	path += "/moves"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsMoveColumnResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsGet(ctx context.Context, params ProjectsGetParams) (_ ProjectsGetResponse, rerr error) {
	path := c.serverURL
	path += "/projects"
	{
		value := conv.IntToString(params.ProjectID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsGetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsDelete(ctx context.Context, params ProjectsDeleteParams) (_ ProjectsDeleteResponse, rerr error) {
	path := c.serverURL
	path += "/projects"
	{
		value := conv.IntToString(params.ProjectID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsDeleteResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsUpdate(ctx context.Context, req *ProjectsUpdateApplicationJSONRequest, params ProjectsUpdateParams) (_ ProjectsUpdateResponse, rerr error) {
	body, contentType, err := encodeProjectsUpdateRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/projects"
	{
		value := conv.IntToString(params.ProjectID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsUpdateResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsListCollaborators(ctx context.Context, params ProjectsListCollaboratorsParams) (_ ProjectsListCollaboratorsResponse, rerr error) {
	path := c.serverURL
	path += "/projects"
	{
		value := conv.IntToString(params.ProjectID)
		path += "/" + value
	}
	path += "/collaborators"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Affiliation)
		q.Set("affiliation", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsListCollaboratorsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsAddCollaborator(ctx context.Context, req *ProjectsAddCollaboratorApplicationJSONRequest, params ProjectsAddCollaboratorParams) (_ ProjectsAddCollaboratorResponse, rerr error) {
	body, contentType, err := encodeProjectsAddCollaboratorRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/projects"
	{
		value := conv.IntToString(params.ProjectID)
		path += "/" + value
	}
	path += "/collaborators"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsAddCollaboratorResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsRemoveCollaborator(ctx context.Context, params ProjectsRemoveCollaboratorParams) (_ ProjectsRemoveCollaboratorResponse, rerr error) {
	path := c.serverURL
	path += "/projects"
	{
		value := conv.IntToString(params.ProjectID)
		path += "/" + value
	}
	path += "/collaborators"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsRemoveCollaboratorResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsGetPermissionForUser(ctx context.Context, params ProjectsGetPermissionForUserParams) (_ ProjectsGetPermissionForUserResponse, rerr error) {
	path := c.serverURL
	path += "/projects"
	{
		value := conv.IntToString(params.ProjectID)
		path += "/" + value
	}
	path += "/collaborators"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/permission"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsGetPermissionForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsListColumns(ctx context.Context, params ProjectsListColumnsParams) (_ ProjectsListColumnsResponse, rerr error) {
	path := c.serverURL
	path += "/projects"
	{
		value := conv.IntToString(params.ProjectID)
		path += "/" + value
	}
	path += "/columns"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsListColumnsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsCreateColumn(ctx context.Context, req ProjectsCreateColumnApplicationJSONRequest, params ProjectsCreateColumnParams) (_ ProjectsCreateColumnResponse, rerr error) {
	body, contentType, err := encodeProjectsCreateColumnRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/projects"
	{
		value := conv.IntToString(params.ProjectID)
		path += "/" + value
	}
	path += "/columns"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsCreateColumnResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) RateLimitGet(ctx context.Context) (_ RateLimitGetResponse, rerr error) {
	path := c.serverURL
	path += "/rate_limit"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeRateLimitGetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsDeleteLegacy(ctx context.Context, params ReactionsDeleteLegacyParams) (_ ReactionsDeleteLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/reactions"
	{
		value := conv.IntToString(params.ReactionID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGet(ctx context.Context, params ReposGetParams) (_ ReposGetResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDelete(ctx context.Context, params ReposDeleteParams) (_ ReposDeleteResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposUpdate(ctx context.Context, req *ReposUpdateApplicationJSONRequest, params ReposUpdateParams) (_ ReposUpdateResponse, rerr error) {
	body, contentType, err := encodeReposUpdateRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListArtifactsForRepo(ctx context.Context, params ActionsListArtifactsForRepoParams) (_ ActionsListArtifactsForRepo, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/artifacts"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListArtifactsForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetArtifact(ctx context.Context, params ActionsGetArtifactParams) (_ Artifact, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/artifacts"
	{
		value := conv.IntToString(params.ArtifactID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetArtifactResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsDeleteArtifact(ctx context.Context, params ActionsDeleteArtifactParams) (_ ActionsDeleteArtifact, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/artifacts"
	{
		value := conv.IntToString(params.ArtifactID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteArtifactResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsDownloadArtifact(ctx context.Context, params ActionsDownloadArtifactParams) (_ ActionsDownloadArtifact, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/artifacts"
	{
		value := conv.IntToString(params.ArtifactID)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.ArchiveFormat)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsDownloadArtifactResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetJobForWorkflowRun(ctx context.Context, params ActionsGetJobForWorkflowRunParams) (_ Job, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/jobs"
	{
		value := conv.IntToString(params.JobID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetJobForWorkflowRunResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsDownloadJobLogsForWorkflowRun(ctx context.Context, params ActionsDownloadJobLogsForWorkflowRunParams) (_ ActionsDownloadJobLogsForWorkflowRun, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/jobs"
	{
		value := conv.IntToString(params.JobID)
		path += "/" + value
	}
	path += "/logs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsDownloadJobLogsForWorkflowRunResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetGithubActionsPermissionsRepository(ctx context.Context, params ActionsGetGithubActionsPermissionsRepositoryParams) (_ ActionsRepositoryPermissions, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetGithubActionsPermissionsRepositoryResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsSetGithubActionsPermissionsRepository(ctx context.Context, req ActionsSetGithubActionsPermissionsRepositoryApplicationJSONRequest, params ActionsSetGithubActionsPermissionsRepositoryParams) (_ ActionsSetGithubActionsPermissionsRepository, rerr error) {
	body, contentType, err := encodeActionsSetGithubActionsPermissionsRepositoryRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetGithubActionsPermissionsRepositoryResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetAllowedActionsRepository(ctx context.Context, params ActionsGetAllowedActionsRepositoryParams) (_ SelectedActions, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"
	path += "/selected-actions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetAllowedActionsRepositoryResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsSetAllowedActionsRepository(ctx context.Context, req *SelectedActions, params ActionsSetAllowedActionsRepositoryParams) (_ ActionsSetAllowedActionsRepository, rerr error) {
	body, contentType, err := encodeActionsSetAllowedActionsRepositoryRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/permissions"
	path += "/selected-actions"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsSetAllowedActionsRepositoryResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListSelfHostedRunnersForRepo(ctx context.Context, params ActionsListSelfHostedRunnersForRepoParams) (_ ActionsListSelfHostedRunnersForRepo, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListSelfHostedRunnersForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListRunnerApplicationsForRepo(ctx context.Context, params ActionsListRunnerApplicationsForRepoParams) (_ []RunnerApplication, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"
	path += "/downloads"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListRunnerApplicationsForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsCreateRegistrationTokenForRepo(ctx context.Context, params ActionsCreateRegistrationTokenForRepoParams) (_ AuthenticationToken, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"
	path += "/registration-token"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateRegistrationTokenForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsCreateRemoveTokenForRepo(ctx context.Context, params ActionsCreateRemoveTokenForRepoParams) (_ AuthenticationToken, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"
	path += "/remove-token"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateRemoveTokenForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetSelfHostedRunnerForRepo(ctx context.Context, params ActionsGetSelfHostedRunnerForRepoParams) (_ Runner, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"
	{
		value := conv.IntToString(params.RunnerID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetSelfHostedRunnerForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsDeleteSelfHostedRunnerFromRepo(ctx context.Context, params ActionsDeleteSelfHostedRunnerFromRepoParams) (_ ActionsDeleteSelfHostedRunnerFromRepo, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runners"
	{
		value := conv.IntToString(params.RunnerID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteSelfHostedRunnerFromRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListWorkflowRunsForRepo(ctx context.Context, params ActionsListWorkflowRunsForRepoParams) (_ ActionsListWorkflowRunsForRepo, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Actor)
		q.Set("actor", s)
	}
	{
		s := conv.StringToString(params.Branch)
		q.Set("branch", s)
	}
	{
		s := conv.StringToString(params.Event)
		q.Set("event", s)
	}
	{
		s := conv.StringToString(params.Status)
		q.Set("status", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.TimeToString(params.Created)
		q.Set("created", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListWorkflowRunsForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetWorkflowRun(ctx context.Context, params ActionsGetWorkflowRunParams) (_ WorkflowRun, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runs"
	{
		value := conv.IntToString(params.RunID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetWorkflowRunResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsDeleteWorkflowRun(ctx context.Context, params ActionsDeleteWorkflowRunParams) (_ ActionsDeleteWorkflowRun, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runs"
	{
		value := conv.IntToString(params.RunID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteWorkflowRunResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetReviewsForRun(ctx context.Context, params ActionsGetReviewsForRunParams) (_ []EnvironmentApprovals, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runs"
	{
		value := conv.IntToString(params.RunID)
		path += "/" + value
	}
	path += "/approvals"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetReviewsForRunResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsApproveWorkflowRun(ctx context.Context, params ActionsApproveWorkflowRunParams) (_ ActionsApproveWorkflowRunResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runs"
	{
		value := conv.IntToString(params.RunID)
		path += "/" + value
	}
	path += "/approve"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsApproveWorkflowRunResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListWorkflowRunArtifacts(ctx context.Context, params ActionsListWorkflowRunArtifactsParams) (_ ActionsListWorkflowRunArtifacts, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runs"
	{
		value := conv.IntToString(params.RunID)
		path += "/" + value
	}
	path += "/artifacts"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListWorkflowRunArtifactsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsCancelWorkflowRun(ctx context.Context, params ActionsCancelWorkflowRunParams) (_ ActionsCancelWorkflowRun, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runs"
	{
		value := conv.IntToString(params.RunID)
		path += "/" + value
	}
	path += "/cancel"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsCancelWorkflowRunResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListJobsForWorkflowRun(ctx context.Context, params ActionsListJobsForWorkflowRunParams) (_ ActionsListJobsForWorkflowRun, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runs"
	{
		value := conv.IntToString(params.RunID)
		path += "/" + value
	}
	path += "/jobs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Filter)
		q.Set("filter", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListJobsForWorkflowRunResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsDownloadWorkflowRunLogs(ctx context.Context, params ActionsDownloadWorkflowRunLogsParams) (_ ActionsDownloadWorkflowRunLogs, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runs"
	{
		value := conv.IntToString(params.RunID)
		path += "/" + value
	}
	path += "/logs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsDownloadWorkflowRunLogsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsDeleteWorkflowRunLogs(ctx context.Context, params ActionsDeleteWorkflowRunLogsParams) (_ ActionsDeleteWorkflowRunLogs, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runs"
	{
		value := conv.IntToString(params.RunID)
		path += "/" + value
	}
	path += "/logs"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteWorkflowRunLogsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetPendingDeploymentsForRun(ctx context.Context, params ActionsGetPendingDeploymentsForRunParams) (_ ActionsGetPendingDeploymentsForRunResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runs"
	{
		value := conv.IntToString(params.RunID)
		path += "/" + value
	}
	path += "/pending_deployments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetPendingDeploymentsForRunResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsReviewPendingDeploymentsForRun(ctx context.Context, req ActionsReviewPendingDeploymentsForRunApplicationJSONRequest, params ActionsReviewPendingDeploymentsForRunParams) (_ []Deployment, rerr error) {
	body, contentType, err := encodeActionsReviewPendingDeploymentsForRunRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runs"
	{
		value := conv.IntToString(params.RunID)
		path += "/" + value
	}
	path += "/pending_deployments"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsReviewPendingDeploymentsForRunResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsReRunWorkflow(ctx context.Context, params ActionsReRunWorkflowParams) (_ ActionsReRunWorkflow, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runs"
	{
		value := conv.IntToString(params.RunID)
		path += "/" + value
	}
	path += "/rerun"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsReRunWorkflowResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsRetryWorkflow(ctx context.Context, params ActionsRetryWorkflowParams) (_ ActionsRetryWorkflow, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runs"
	{
		value := conv.IntToString(params.RunID)
		path += "/" + value
	}
	path += "/retry"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsRetryWorkflowResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetWorkflowRunUsage(ctx context.Context, params ActionsGetWorkflowRunUsageParams) (_ WorkflowRunUsage, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/runs"
	{
		value := conv.IntToString(params.RunID)
		path += "/" + value
	}
	path += "/timing"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetWorkflowRunUsageResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListRepoSecrets(ctx context.Context, params ActionsListRepoSecretsParams) (_ ActionsListRepoSecrets, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/secrets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListRepoSecretsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetRepoPublicKey(ctx context.Context, params ActionsGetRepoPublicKeyParams) (_ ActionsPublicKey, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/secrets"
	path += "/public-key"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetRepoPublicKeyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetRepoSecret(ctx context.Context, params ActionsGetRepoSecretParams) (_ ActionsSecret, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/secrets"
	{
		value := conv.StringToString(params.SecretName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetRepoSecretResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsCreateOrUpdateRepoSecret(ctx context.Context, req ActionsCreateOrUpdateRepoSecretApplicationJSONRequest, params ActionsCreateOrUpdateRepoSecretParams) (_ ActionsCreateOrUpdateRepoSecretResponse, rerr error) {
	body, contentType, err := encodeActionsCreateOrUpdateRepoSecretRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/secrets"
	{
		value := conv.StringToString(params.SecretName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateOrUpdateRepoSecretResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsDeleteRepoSecret(ctx context.Context, params ActionsDeleteRepoSecretParams) (_ ActionsDeleteRepoSecret, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/secrets"
	{
		value := conv.StringToString(params.SecretName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteRepoSecretResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListRepoWorkflows(ctx context.Context, params ActionsListRepoWorkflowsParams) (_ ActionsListRepoWorkflows, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/actions"
	path += "/workflows"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListRepoWorkflowsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesListAssignees(ctx context.Context, params IssuesListAssigneesParams) (_ IssuesListAssigneesResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/assignees"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListAssigneesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesCheckUserCanBeAssigned(ctx context.Context, params IssuesCheckUserCanBeAssignedParams) (_ IssuesCheckUserCanBeAssignedResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/assignees"
	{
		value := conv.StringToString(params.Assignee)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesCheckUserCanBeAssignedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListAutolinks(ctx context.Context, params ReposListAutolinksParams) (_ []Autolink, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/autolinks"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListAutolinksResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateAutolink(ctx context.Context, req ReposCreateAutolinkApplicationJSONRequest, params ReposCreateAutolinkParams) (_ ReposCreateAutolinkResponse, rerr error) {
	body, contentType, err := encodeReposCreateAutolinkRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/autolinks"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateAutolinkResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetAutolink(ctx context.Context, params ReposGetAutolinkParams) (_ ReposGetAutolinkResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/autolinks"
	{
		value := conv.IntToString(params.AutolinkID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAutolinkResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeleteAutolink(ctx context.Context, params ReposDeleteAutolinkParams) (_ ReposDeleteAutolinkResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/autolinks"
	{
		value := conv.IntToString(params.AutolinkID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteAutolinkResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposEnableAutomatedSecurityFixes(ctx context.Context, params ReposEnableAutomatedSecurityFixesParams) (_ ReposEnableAutomatedSecurityFixes, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/automated-security-fixes"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposEnableAutomatedSecurityFixesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDisableAutomatedSecurityFixes(ctx context.Context, params ReposDisableAutomatedSecurityFixesParams) (_ ReposDisableAutomatedSecurityFixes, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/automated-security-fixes"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDisableAutomatedSecurityFixesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListBranches(ctx context.Context, params ReposListBranchesParams) (_ ReposListBranchesResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.Protected)
		q.Set("protected", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListBranchesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetBranch(ctx context.Context, params ReposGetBranchParams) (_ ReposGetBranchResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetBranchResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetBranchProtection(ctx context.Context, params ReposGetBranchProtectionParams) (_ ReposGetBranchProtectionResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetBranchProtectionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposUpdateBranchProtection(ctx context.Context, req ReposUpdateBranchProtectionApplicationJSONRequest, params ReposUpdateBranchProtectionParams) (_ ReposUpdateBranchProtectionResponse, rerr error) {
	body, contentType, err := encodeReposUpdateBranchProtectionRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateBranchProtectionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeleteBranchProtection(ctx context.Context, params ReposDeleteBranchProtectionParams) (_ ReposDeleteBranchProtectionResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteBranchProtectionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetAdminBranchProtection(ctx context.Context, params ReposGetAdminBranchProtectionParams) (_ ProtectedBranchAdminEnforced, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/enforce_admins"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAdminBranchProtectionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposSetAdminBranchProtection(ctx context.Context, params ReposSetAdminBranchProtectionParams) (_ ProtectedBranchAdminEnforced, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/enforce_admins"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposSetAdminBranchProtectionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeleteAdminBranchProtection(ctx context.Context, params ReposDeleteAdminBranchProtectionParams) (_ ReposDeleteAdminBranchProtectionResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/enforce_admins"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteAdminBranchProtectionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetPullRequestReviewProtection(ctx context.Context, params ReposGetPullRequestReviewProtectionParams) (_ ProtectedBranchPullRequestReview, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/required_pull_request_reviews"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetPullRequestReviewProtectionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeletePullRequestReviewProtection(ctx context.Context, params ReposDeletePullRequestReviewProtectionParams) (_ ReposDeletePullRequestReviewProtectionResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/required_pull_request_reviews"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeletePullRequestReviewProtectionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposUpdatePullRequestReviewProtection(ctx context.Context, req *ReposUpdatePullRequestReviewProtectionApplicationJSONRequest, params ReposUpdatePullRequestReviewProtectionParams) (_ ReposUpdatePullRequestReviewProtectionResponse, rerr error) {
	body, contentType, err := encodeReposUpdatePullRequestReviewProtectionRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/required_pull_request_reviews"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdatePullRequestReviewProtectionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetCommitSignatureProtection(ctx context.Context, params ReposGetCommitSignatureProtectionParams) (_ ReposGetCommitSignatureProtectionResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/required_signatures"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCommitSignatureProtectionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateCommitSignatureProtection(ctx context.Context, params ReposCreateCommitSignatureProtectionParams) (_ ReposCreateCommitSignatureProtectionResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/required_signatures"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateCommitSignatureProtectionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeleteCommitSignatureProtection(ctx context.Context, params ReposDeleteCommitSignatureProtectionParams) (_ ReposDeleteCommitSignatureProtectionResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/required_signatures"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteCommitSignatureProtectionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetStatusChecksProtection(ctx context.Context, params ReposGetStatusChecksProtectionParams) (_ ReposGetStatusChecksProtectionResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/required_status_checks"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetStatusChecksProtectionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposRemoveStatusCheckProtection(ctx context.Context, params ReposRemoveStatusCheckProtectionParams) (_ ReposRemoveStatusCheckProtection, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/required_status_checks"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposRemoveStatusCheckProtectionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposUpdateStatusCheckProtection(ctx context.Context, req *ReposUpdateStatusCheckProtectionApplicationJSONRequest, params ReposUpdateStatusCheckProtectionParams) (_ ReposUpdateStatusCheckProtectionResponse, rerr error) {
	body, contentType, err := encodeReposUpdateStatusCheckProtectionRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/required_status_checks"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateStatusCheckProtectionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetAllStatusCheckContexts(ctx context.Context, params ReposGetAllStatusCheckContextsParams) (_ ReposGetAllStatusCheckContextsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/required_status_checks"
	path += "/contexts"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAllStatusCheckContextsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposSetStatusCheckContexts(ctx context.Context, req ReposSetStatusCheckContextsRequest, params ReposSetStatusCheckContextsParams) (_ ReposSetStatusCheckContextsResponse, rerr error) {
	body, contentType, err := encodeReposSetStatusCheckContextsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/required_status_checks"
	path += "/contexts"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposSetStatusCheckContextsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposAddStatusCheckContexts(ctx context.Context, req ReposAddStatusCheckContextsRequest, params ReposAddStatusCheckContextsParams) (_ ReposAddStatusCheckContextsResponse, rerr error) {
	body, contentType, err := encodeReposAddStatusCheckContextsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/required_status_checks"
	path += "/contexts"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposAddStatusCheckContextsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposRemoveStatusCheckContexts(ctx context.Context, req ReposRemoveStatusCheckContextsRequest, params ReposRemoveStatusCheckContextsParams) (_ ReposRemoveStatusCheckContextsResponse, rerr error) {
	body, contentType, err := encodeReposRemoveStatusCheckContextsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/required_status_checks"
	path += "/contexts"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposRemoveStatusCheckContextsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetAccessRestrictions(ctx context.Context, params ReposGetAccessRestrictionsParams) (_ ReposGetAccessRestrictionsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/restrictions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAccessRestrictionsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeleteAccessRestrictions(ctx context.Context, params ReposDeleteAccessRestrictionsParams) (_ ReposDeleteAccessRestrictions, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/restrictions"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteAccessRestrictionsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetAppsWithAccessToProtectedBranch(ctx context.Context, params ReposGetAppsWithAccessToProtectedBranchParams) (_ ReposGetAppsWithAccessToProtectedBranchResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/restrictions"
	path += "/apps"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAppsWithAccessToProtectedBranchResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposSetAppAccessRestrictions(ctx context.Context, req ReposSetAppAccessRestrictionsRequest, params ReposSetAppAccessRestrictionsParams) (_ ReposSetAppAccessRestrictionsResponse, rerr error) {
	body, contentType, err := encodeReposSetAppAccessRestrictionsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/restrictions"
	path += "/apps"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposSetAppAccessRestrictionsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposAddAppAccessRestrictions(ctx context.Context, req ReposAddAppAccessRestrictionsRequest, params ReposAddAppAccessRestrictionsParams) (_ ReposAddAppAccessRestrictionsResponse, rerr error) {
	body, contentType, err := encodeReposAddAppAccessRestrictionsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/restrictions"
	path += "/apps"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposAddAppAccessRestrictionsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposRemoveAppAccessRestrictions(ctx context.Context, req ReposRemoveAppAccessRestrictionsRequest, params ReposRemoveAppAccessRestrictionsParams) (_ ReposRemoveAppAccessRestrictionsResponse, rerr error) {
	body, contentType, err := encodeReposRemoveAppAccessRestrictionsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/restrictions"
	path += "/apps"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposRemoveAppAccessRestrictionsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetTeamsWithAccessToProtectedBranch(ctx context.Context, params ReposGetTeamsWithAccessToProtectedBranchParams) (_ ReposGetTeamsWithAccessToProtectedBranchResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/restrictions"
	path += "/teams"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetTeamsWithAccessToProtectedBranchResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposSetTeamAccessRestrictions(ctx context.Context, req ReposSetTeamAccessRestrictionsRequest, params ReposSetTeamAccessRestrictionsParams) (_ ReposSetTeamAccessRestrictionsResponse, rerr error) {
	body, contentType, err := encodeReposSetTeamAccessRestrictionsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/restrictions"
	path += "/teams"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposSetTeamAccessRestrictionsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposAddTeamAccessRestrictions(ctx context.Context, req ReposAddTeamAccessRestrictionsRequest, params ReposAddTeamAccessRestrictionsParams) (_ ReposAddTeamAccessRestrictionsResponse, rerr error) {
	body, contentType, err := encodeReposAddTeamAccessRestrictionsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/restrictions"
	path += "/teams"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposAddTeamAccessRestrictionsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposRemoveTeamAccessRestrictions(ctx context.Context, req ReposRemoveTeamAccessRestrictionsRequest, params ReposRemoveTeamAccessRestrictionsParams) (_ ReposRemoveTeamAccessRestrictionsResponse, rerr error) {
	body, contentType, err := encodeReposRemoveTeamAccessRestrictionsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/restrictions"
	path += "/teams"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposRemoveTeamAccessRestrictionsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetUsersWithAccessToProtectedBranch(ctx context.Context, params ReposGetUsersWithAccessToProtectedBranchParams) (_ ReposGetUsersWithAccessToProtectedBranchResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/restrictions"
	path += "/users"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetUsersWithAccessToProtectedBranchResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposSetUserAccessRestrictions(ctx context.Context, req ReposSetUserAccessRestrictionsRequest, params ReposSetUserAccessRestrictionsParams) (_ ReposSetUserAccessRestrictionsResponse, rerr error) {
	body, contentType, err := encodeReposSetUserAccessRestrictionsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/restrictions"
	path += "/users"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposSetUserAccessRestrictionsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposAddUserAccessRestrictions(ctx context.Context, req ReposAddUserAccessRestrictionsRequest, params ReposAddUserAccessRestrictionsParams) (_ ReposAddUserAccessRestrictionsResponse, rerr error) {
	body, contentType, err := encodeReposAddUserAccessRestrictionsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/restrictions"
	path += "/users"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposAddUserAccessRestrictionsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposRemoveUserAccessRestrictions(ctx context.Context, req ReposRemoveUserAccessRestrictionsRequest, params ReposRemoveUserAccessRestrictionsParams) (_ ReposRemoveUserAccessRestrictionsResponse, rerr error) {
	body, contentType, err := encodeReposRemoveUserAccessRestrictionsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/protection"
	path += "/restrictions"
	path += "/users"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposRemoveUserAccessRestrictionsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposRenameBranch(ctx context.Context, req *ReposRenameBranchApplicationJSONRequest, params ReposRenameBranchParams) (_ ReposRenameBranchResponse, rerr error) {
	body, contentType, err := encodeReposRenameBranchRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/branches"
	{
		value := conv.StringToString(params.Branch)
		path += "/" + value
	}
	path += "/rename"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposRenameBranchResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ChecksCreate(ctx context.Context, req ChecksCreateApplicationJSONRequest, params ChecksCreateParams) (_ CheckRun, rerr error) {
	body, contentType, err := encodeChecksCreateRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/check-runs"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeChecksCreateResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ChecksGet(ctx context.Context, params ChecksGetParams) (_ CheckRun, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/check-runs"
	{
		value := conv.IntToString(params.CheckRunID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeChecksGetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ChecksUpdate(ctx context.Context, req *ChecksUpdateApplicationJSONRequest, params ChecksUpdateParams) (_ CheckRun, rerr error) {
	body, contentType, err := encodeChecksUpdateRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/check-runs"
	{
		value := conv.IntToString(params.CheckRunID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeChecksUpdateResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ChecksListAnnotations(ctx context.Context, params ChecksListAnnotationsParams) (_ []CheckAnnotation, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/check-runs"
	{
		value := conv.IntToString(params.CheckRunID)
		path += "/" + value
	}
	path += "/annotations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeChecksListAnnotationsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ChecksCreateSuite(ctx context.Context, req ChecksCreateSuiteApplicationJSONRequest, params ChecksCreateSuiteParams) (_ ChecksCreateSuiteResponse, rerr error) {
	body, contentType, err := encodeChecksCreateSuiteRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/check-suites"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeChecksCreateSuiteResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ChecksSetSuitesPreferences(ctx context.Context, req ChecksSetSuitesPreferencesApplicationJSONRequest, params ChecksSetSuitesPreferencesParams) (_ CheckSuitePreference, rerr error) {
	body, contentType, err := encodeChecksSetSuitesPreferencesRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/check-suites"
	path += "/preferences"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeChecksSetSuitesPreferencesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ChecksGetSuite(ctx context.Context, params ChecksGetSuiteParams) (_ CheckSuite, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/check-suites"
	{
		value := conv.IntToString(params.CheckSuiteID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeChecksGetSuiteResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ChecksListForSuite(ctx context.Context, params ChecksListForSuiteParams) (_ ChecksListForSuite, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/check-suites"
	{
		value := conv.IntToString(params.CheckSuiteID)
		path += "/" + value
	}
	path += "/check-runs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.CheckName)
		q.Set("check_name", s)
	}
	{
		s := conv.StringToString(params.Status)
		q.Set("status", s)
	}
	{
		s := conv.StringToString(params.Filter)
		q.Set("filter", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeChecksListForSuiteResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ChecksRerequestSuite(ctx context.Context, params ChecksRerequestSuiteParams) (_ ChecksRerequestSuite, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/check-suites"
	{
		value := conv.IntToString(params.CheckSuiteID)
		path += "/" + value
	}
	path += "/rerequest"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeChecksRerequestSuiteResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CodeScanningListAlertsForRepo(ctx context.Context, params CodeScanningListAlertsForRepoParams) (_ CodeScanningListAlertsForRepoResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/code-scanning"
	path += "/alerts"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.ToolName)
		q.Set("tool_name", s)
	}
	{
		s := conv.StringToString(params.ToolGUID)
		q.Set("tool_guid", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.StringToString(params.Ref)
		q.Set("ref", s)
	}
	{
		s := conv.StringToString(params.State)
		q.Set("state", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningListAlertsForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CodeScanningGetAlert(ctx context.Context, params CodeScanningGetAlertParams) (_ CodeScanningGetAlertResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/code-scanning"
	path += "/alerts"
	{
		value := conv.IntToString(params.AlertNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningGetAlertResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CodeScanningUpdateAlert(ctx context.Context, req CodeScanningUpdateAlertApplicationJSONRequest, params CodeScanningUpdateAlertParams) (_ CodeScanningUpdateAlertResponse, rerr error) {
	body, contentType, err := encodeCodeScanningUpdateAlertRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/code-scanning"
	path += "/alerts"
	{
		value := conv.IntToString(params.AlertNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningUpdateAlertResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CodeScanningListAlertInstances(ctx context.Context, params CodeScanningListAlertInstancesParams) (_ CodeScanningListAlertInstancesResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/code-scanning"
	path += "/alerts"
	{
		value := conv.IntToString(params.AlertNumber)
		path += "/" + value
	}
	path += "/instances"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.StringToString(params.Ref)
		q.Set("ref", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningListAlertInstancesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CodeScanningListRecentAnalyses(ctx context.Context, params CodeScanningListRecentAnalysesParams) (_ CodeScanningListRecentAnalysesResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/code-scanning"
	path += "/analyses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.ToolName)
		q.Set("tool_name", s)
	}
	{
		s := conv.StringToString(params.ToolGUID)
		q.Set("tool_guid", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.StringToString(params.Ref)
		q.Set("ref", s)
	}
	{
		s := conv.StringToString(params.SarifID)
		q.Set("sarif_id", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningListRecentAnalysesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CodeScanningGetAnalysis(ctx context.Context, params CodeScanningGetAnalysisParams) (_ CodeScanningGetAnalysisResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/code-scanning"
	path += "/analyses"
	{
		value := conv.IntToString(params.AnalysisID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningGetAnalysisResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CodeScanningDeleteAnalysis(ctx context.Context, params CodeScanningDeleteAnalysisParams) (_ CodeScanningDeleteAnalysisResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/code-scanning"
	path += "/analyses"
	{
		value := conv.IntToString(params.AnalysisID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.ConfirmDelete)
		q.Set("confirm_delete", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningDeleteAnalysisResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CodeScanningUploadSarif(ctx context.Context, req CodeScanningUploadSarifApplicationJSONRequest, params CodeScanningUploadSarifParams) (_ CodeScanningUploadSarifResponse, rerr error) {
	body, contentType, err := encodeCodeScanningUploadSarifRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/code-scanning"
	path += "/sarifs"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningUploadSarifResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) CodeScanningGetSarif(ctx context.Context, params CodeScanningGetSarifParams) (_ CodeScanningGetSarifResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/code-scanning"
	path += "/sarifs"
	{
		value := conv.StringToString(params.SarifID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeCodeScanningGetSarifResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListCollaborators(ctx context.Context, params ReposListCollaboratorsParams) (_ ReposListCollaboratorsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/collaborators"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Affiliation)
		q.Set("affiliation", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListCollaboratorsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCheckCollaborator(ctx context.Context, params ReposCheckCollaboratorParams) (_ ReposCheckCollaboratorResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/collaborators"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCheckCollaboratorResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposAddCollaborator(ctx context.Context, req *ReposAddCollaboratorApplicationJSONRequest, params ReposAddCollaboratorParams) (_ ReposAddCollaboratorResponse, rerr error) {
	body, contentType, err := encodeReposAddCollaboratorRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/collaborators"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposAddCollaboratorResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposRemoveCollaborator(ctx context.Context, params ReposRemoveCollaboratorParams) (_ ReposRemoveCollaborator, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/collaborators"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposRemoveCollaboratorResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetCollaboratorPermissionLevel(ctx context.Context, params ReposGetCollaboratorPermissionLevelParams) (_ ReposGetCollaboratorPermissionLevelResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/collaborators"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/permission"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCollaboratorPermissionLevelResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListCommitCommentsForRepo(ctx context.Context, params ReposListCommitCommentsForRepoParams) (_ []CommitComment, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListCommitCommentsForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetCommitComment(ctx context.Context, params ReposGetCommitCommentParams) (_ ReposGetCommitCommentResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCommitCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeleteCommitComment(ctx context.Context, params ReposDeleteCommitCommentParams) (_ ReposDeleteCommitCommentResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteCommitCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposUpdateCommitComment(ctx context.Context, req ReposUpdateCommitCommentApplicationJSONRequest, params ReposUpdateCommitCommentParams) (_ ReposUpdateCommitCommentResponse, rerr error) {
	body, contentType, err := encodeReposUpdateCommitCommentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateCommitCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsListForCommitComment(ctx context.Context, params ReactionsListForCommitCommentParams) (_ ReactionsListForCommitCommentResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Content)
		q.Set("content", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForCommitCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsCreateForCommitComment(ctx context.Context, req ReactionsCreateForCommitCommentApplicationJSONRequest, params ReactionsCreateForCommitCommentParams) (_ ReactionsCreateForCommitCommentResponse, rerr error) {
	body, contentType, err := encodeReactionsCreateForCommitCommentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForCommitCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsDeleteForCommitComment(ctx context.Context, params ReactionsDeleteForCommitCommentParams) (_ ReactionsDeleteForCommitComment, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}
	path += "/reactions"
	{
		value := conv.IntToString(params.ReactionID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForCommitCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListCommits(ctx context.Context, params ReposListCommitsParams) (_ ReposListCommitsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/commits"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Sha)
		q.Set("sha", s)
	}
	{
		s := conv.StringToString(params.Path)
		q.Set("path", s)
	}
	{
		s := conv.StringToString(params.Author)
		q.Set("author", s)
	}
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.TimeToString(params.Until)
		q.Set("until", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListCommitsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListBranchesForHeadCommit(ctx context.Context, params ReposListBranchesForHeadCommitParams) (_ ReposListBranchesForHeadCommitResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/commits"
	{
		value := conv.StringToString(params.CommitSha)
		path += "/" + value
	}
	path += "/branches-where-head"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListBranchesForHeadCommitResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListCommentsForCommit(ctx context.Context, params ReposListCommentsForCommitParams) (_ []CommitComment, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/commits"
	{
		value := conv.StringToString(params.CommitSha)
		path += "/" + value
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListCommentsForCommitResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateCommitComment(ctx context.Context, req ReposCreateCommitCommentApplicationJSONRequest, params ReposCreateCommitCommentParams) (_ ReposCreateCommitCommentResponse, rerr error) {
	body, contentType, err := encodeReposCreateCommitCommentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/commits"
	{
		value := conv.StringToString(params.CommitSha)
		path += "/" + value
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateCommitCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListPullRequestsAssociatedWithCommit(ctx context.Context, params ReposListPullRequestsAssociatedWithCommitParams) (_ []PullRequestSimple, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/commits"
	{
		value := conv.StringToString(params.CommitSha)
		path += "/" + value
	}
	path += "/pulls"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListPullRequestsAssociatedWithCommitResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetCommit(ctx context.Context, params ReposGetCommitParams) (_ ReposGetCommitResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/commits"
	{
		value := conv.StringToString(params.Ref)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCommitResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ChecksListForRef(ctx context.Context, params ChecksListForRefParams) (_ ChecksListForRefResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/commits"
	{
		value := conv.StringToString(params.Ref)
		path += "/" + value
	}
	path += "/check-runs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.CheckName)
		q.Set("check_name", s)
	}
	{
		s := conv.StringToString(params.Status)
		q.Set("status", s)
	}
	{
		s := conv.StringToString(params.Filter)
		q.Set("filter", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.IntToString(params.AppID)
		q.Set("app_id", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeChecksListForRefResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ChecksListSuitesForRef(ctx context.Context, params ChecksListSuitesForRefParams) (_ ChecksListSuitesForRef, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/commits"
	{
		value := conv.StringToString(params.Ref)
		path += "/" + value
	}
	path += "/check-suites"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.AppID)
		q.Set("app_id", s)
	}
	{
		s := conv.StringToString(params.CheckName)
		q.Set("check_name", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeChecksListSuitesForRefResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetCombinedStatusForRef(ctx context.Context, params ReposGetCombinedStatusForRefParams) (_ ReposGetCombinedStatusForRefResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/commits"
	{
		value := conv.StringToString(params.Ref)
		path += "/" + value
	}
	path += "/status"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCombinedStatusForRefResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListCommitStatusesForRef(ctx context.Context, params ReposListCommitStatusesForRefParams) (_ ReposListCommitStatusesForRefResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/commits"
	{
		value := conv.StringToString(params.Ref)
		path += "/" + value
	}
	path += "/statuses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListCommitStatusesForRefResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetCommunityProfileMetrics(ctx context.Context, params ReposGetCommunityProfileMetricsParams) (_ CommunityProfile, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/community"
	path += "/profile"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCommunityProfileMetricsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCompareCommits(ctx context.Context, params ReposCompareCommitsParams) (_ ReposCompareCommitsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/compare"
	{
		value := conv.StringToString(params.Basehead)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCompareCommitsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsCreateContentAttachment(ctx context.Context, req AppsCreateContentAttachmentApplicationJSONRequest, params AppsCreateContentAttachmentParams) (_ AppsCreateContentAttachmentResponse, rerr error) {
	body, contentType, err := encodeAppsCreateContentAttachmentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/content_references"
	{
		value := conv.IntToString(params.ContentReferenceID)
		path += "/" + value
	}
	path += "/attachments"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsCreateContentAttachmentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetContent(ctx context.Context, params ReposGetContentParams) (_ ReposGetContentResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/contents"
	{
		value := conv.StringToString(params.Path)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Ref)
		q.Set("ref", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetContentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateOrUpdateFileContents(ctx context.Context, req ReposCreateOrUpdateFileContentsApplicationJSONRequest, params ReposCreateOrUpdateFileContentsParams) (_ ReposCreateOrUpdateFileContentsResponse, rerr error) {
	body, contentType, err := encodeReposCreateOrUpdateFileContentsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/contents"
	{
		value := conv.StringToString(params.Path)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateOrUpdateFileContentsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeleteFile(ctx context.Context, req ReposDeleteFileApplicationJSONRequest, params ReposDeleteFileParams) (_ ReposDeleteFileResponse, rerr error) {
	body, contentType, err := encodeReposDeleteFileRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/contents"
	{
		value := conv.StringToString(params.Path)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteFileResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListContributors(ctx context.Context, params ReposListContributorsParams) (_ ReposListContributorsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/contributors"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Anon)
		q.Set("anon", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListContributorsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListDeployments(ctx context.Context, params ReposListDeploymentsParams) (_ []Deployment, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/deployments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Sha)
		q.Set("sha", s)
	}
	{
		s := conv.StringToString(params.Ref)
		q.Set("ref", s)
	}
	{
		s := conv.StringToString(params.Task)
		q.Set("task", s)
	}
	{
		s := conv.StringToString(params.Environment)
		q.Set("environment", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListDeploymentsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateDeployment(ctx context.Context, req ReposCreateDeploymentRequest, params ReposCreateDeploymentParams) (_ ReposCreateDeploymentResponse, rerr error) {
	body, contentType, err := encodeReposCreateDeploymentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/deployments"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateDeploymentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetDeployment(ctx context.Context, params ReposGetDeploymentParams) (_ ReposGetDeploymentResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/deployments"
	{
		value := conv.IntToString(params.DeploymentID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetDeploymentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeleteDeployment(ctx context.Context, params ReposDeleteDeploymentParams) (_ ReposDeleteDeploymentResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/deployments"
	{
		value := conv.IntToString(params.DeploymentID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteDeploymentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListDeploymentStatuses(ctx context.Context, params ReposListDeploymentStatusesParams) (_ ReposListDeploymentStatusesResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/deployments"
	{
		value := conv.IntToString(params.DeploymentID)
		path += "/" + value
	}
	path += "/statuses"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListDeploymentStatusesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateDeploymentStatus(ctx context.Context, req ReposCreateDeploymentStatusApplicationJSONRequest, params ReposCreateDeploymentStatusParams) (_ ReposCreateDeploymentStatusResponse, rerr error) {
	body, contentType, err := encodeReposCreateDeploymentStatusRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/deployments"
	{
		value := conv.IntToString(params.DeploymentID)
		path += "/" + value
	}
	path += "/statuses"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateDeploymentStatusResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetDeploymentStatus(ctx context.Context, params ReposGetDeploymentStatusParams) (_ ReposGetDeploymentStatusResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/deployments"
	{
		value := conv.IntToString(params.DeploymentID)
		path += "/" + value
	}
	path += "/statuses"
	{
		value := conv.IntToString(params.StatusID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetDeploymentStatusResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateDispatchEvent(ctx context.Context, req ReposCreateDispatchEventApplicationJSONRequest, params ReposCreateDispatchEventParams) (_ ReposCreateDispatchEventResponse, rerr error) {
	body, contentType, err := encodeReposCreateDispatchEventRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/dispatches"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateDispatchEventResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetAllEnvironments(ctx context.Context, params ReposGetAllEnvironmentsParams) (_ ReposGetAllEnvironmentsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/environments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAllEnvironmentsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetEnvironment(ctx context.Context, params ReposGetEnvironmentParams) (_ Environment, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/environments"
	{
		value := conv.StringToString(params.EnvironmentName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetEnvironmentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateOrUpdateEnvironment(ctx context.Context, req *ReposCreateOrUpdateEnvironmentApplicationJSONRequest, params ReposCreateOrUpdateEnvironmentParams) (_ ReposCreateOrUpdateEnvironmentResponse, rerr error) {
	body, contentType, err := encodeReposCreateOrUpdateEnvironmentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/environments"
	{
		value := conv.StringToString(params.EnvironmentName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateOrUpdateEnvironmentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeleteAnEnvironment(ctx context.Context, params ReposDeleteAnEnvironmentParams) (_ ReposDeleteAnEnvironment, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/environments"
	{
		value := conv.StringToString(params.EnvironmentName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteAnEnvironmentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListRepoEvents(ctx context.Context, params ActivityListRepoEventsParams) (_ []Event, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListRepoEventsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListForks(ctx context.Context, params ReposListForksParams) (_ ReposListForksResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/forks"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListForksResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateFork(ctx context.Context, req *ReposCreateForkApplicationJSONRequest, params ReposCreateForkParams) (_ ReposCreateForkResponse, rerr error) {
	body, contentType, err := encodeReposCreateForkRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/forks"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateForkResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GitCreateBlob(ctx context.Context, req GitCreateBlobApplicationJSONRequest, params GitCreateBlobParams) (_ GitCreateBlobResponse, rerr error) {
	body, contentType, err := encodeGitCreateBlobRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/git"
	path += "/blobs"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGitCreateBlobResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GitGetBlob(ctx context.Context, params GitGetBlobParams) (_ GitGetBlobResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/git"
	path += "/blobs"
	{
		value := conv.StringToString(params.FileSha)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGitGetBlobResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GitCreateCommit(ctx context.Context, req GitCreateCommitApplicationJSONRequest, params GitCreateCommitParams) (_ GitCreateCommitResponse, rerr error) {
	body, contentType, err := encodeGitCreateCommitRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/git"
	path += "/commits"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGitCreateCommitResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GitGetCommit(ctx context.Context, params GitGetCommitParams) (_ GitGetCommitResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/git"
	path += "/commits"
	{
		value := conv.StringToString(params.CommitSha)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGitGetCommitResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GitListMatchingRefs(ctx context.Context, params GitListMatchingRefsParams) (_ []GitRef, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/git"
	path += "/matching-refs"
	{
		value := conv.StringToString(params.Ref)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGitListMatchingRefsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GitGetRef(ctx context.Context, params GitGetRefParams) (_ GitGetRefResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/git"
	path += "/ref"
	{
		value := conv.StringToString(params.Ref)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGitGetRefResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GitCreateRef(ctx context.Context, req GitCreateRefApplicationJSONRequest, params GitCreateRefParams) (_ GitCreateRefResponse, rerr error) {
	body, contentType, err := encodeGitCreateRefRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/git"
	path += "/refs"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGitCreateRefResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GitDeleteRef(ctx context.Context, params GitDeleteRefParams) (_ GitDeleteRefResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/git"
	path += "/refs"
	{
		value := conv.StringToString(params.Ref)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGitDeleteRefResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GitUpdateRef(ctx context.Context, req GitUpdateRefApplicationJSONRequest, params GitUpdateRefParams) (_ GitUpdateRefResponse, rerr error) {
	body, contentType, err := encodeGitUpdateRefRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/git"
	path += "/refs"
	{
		value := conv.StringToString(params.Ref)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGitUpdateRefResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GitCreateTag(ctx context.Context, req GitCreateTagApplicationJSONRequest, params GitCreateTagParams) (_ GitCreateTagResponse, rerr error) {
	body, contentType, err := encodeGitCreateTagRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/git"
	path += "/tags"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGitCreateTagResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GitGetTag(ctx context.Context, params GitGetTagParams) (_ GitGetTagResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/git"
	path += "/tags"
	{
		value := conv.StringToString(params.TagSha)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGitGetTagResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GitCreateTree(ctx context.Context, req GitCreateTreeApplicationJSONRequest, params GitCreateTreeParams) (_ GitCreateTreeResponse, rerr error) {
	body, contentType, err := encodeGitCreateTreeRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/git"
	path += "/trees"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGitCreateTreeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GitGetTree(ctx context.Context, params GitGetTreeParams) (_ GitGetTreeResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/git"
	path += "/trees"
	{
		value := conv.StringToString(params.TreeSha)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Recursive)
		q.Set("recursive", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGitGetTreeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListWebhooks(ctx context.Context, params ReposListWebhooksParams) (_ ReposListWebhooksResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/hooks"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListWebhooksResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateWebhook(ctx context.Context, req ReposCreateWebhookRequest, params ReposCreateWebhookParams) (_ ReposCreateWebhookResponse, rerr error) {
	body, contentType, err := encodeReposCreateWebhookRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/hooks"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateWebhookResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetWebhook(ctx context.Context, params ReposGetWebhookParams) (_ ReposGetWebhookResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetWebhookResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeleteWebhook(ctx context.Context, params ReposDeleteWebhookParams) (_ ReposDeleteWebhookResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteWebhookResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposUpdateWebhook(ctx context.Context, req ReposUpdateWebhookRequest, params ReposUpdateWebhookParams) (_ ReposUpdateWebhookResponse, rerr error) {
	body, contentType, err := encodeReposUpdateWebhookRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateWebhookResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetWebhookConfigForRepo(ctx context.Context, params ReposGetWebhookConfigForRepoParams) (_ WebhookConfig, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}
	path += "/config"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetWebhookConfigForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposUpdateWebhookConfigForRepo(ctx context.Context, req ReposUpdateWebhookConfigForRepoRequest, params ReposUpdateWebhookConfigForRepoParams) (_ WebhookConfig, rerr error) {
	body, contentType, err := encodeReposUpdateWebhookConfigForRepoRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}
	path += "/config"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateWebhookConfigForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListWebhookDeliveries(ctx context.Context, params ReposListWebhookDeliveriesParams) (_ ReposListWebhookDeliveriesResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}
	path += "/deliveries"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.StringToString(params.Cursor)
		q.Set("cursor", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListWebhookDeliveriesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetWebhookDelivery(ctx context.Context, params ReposGetWebhookDeliveryParams) (_ ReposGetWebhookDeliveryResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}
	path += "/deliveries"
	{
		value := conv.IntToString(params.DeliveryID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetWebhookDeliveryResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposRedeliverWebhookDelivery(ctx context.Context, params ReposRedeliverWebhookDeliveryParams) (_ ReposRedeliverWebhookDeliveryResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}
	path += "/deliveries"
	{
		value := conv.IntToString(params.DeliveryID)
		path += "/" + value
	}
	path += "/attempts"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposRedeliverWebhookDeliveryResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposPingWebhook(ctx context.Context, params ReposPingWebhookParams) (_ ReposPingWebhookResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}
	path += "/pings"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposPingWebhookResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposTestPushWebhook(ctx context.Context, params ReposTestPushWebhookParams) (_ ReposTestPushWebhookResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/hooks"
	{
		value := conv.IntToString(params.HookID)
		path += "/" + value
	}
	path += "/tests"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposTestPushWebhookResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsGetImportStatus(ctx context.Context, params MigrationsGetImportStatusParams) (_ MigrationsGetImportStatusResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/import"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetImportStatusResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsStartImport(ctx context.Context, req MigrationsStartImportApplicationJSONRequest, params MigrationsStartImportParams) (_ MigrationsStartImportResponse, rerr error) {
	body, contentType, err := encodeMigrationsStartImportRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/import"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsStartImportResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsCancelImport(ctx context.Context, params MigrationsCancelImportParams) (_ MigrationsCancelImport, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/import"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsCancelImportResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsUpdateImport(ctx context.Context, req *MigrationsUpdateImportApplicationJSONRequest, params MigrationsUpdateImportParams) (_ Import, rerr error) {
	body, contentType, err := encodeMigrationsUpdateImportRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/import"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsUpdateImportResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsGetCommitAuthors(ctx context.Context, params MigrationsGetCommitAuthorsParams) (_ MigrationsGetCommitAuthorsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/import"
	path += "/authors"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.Since)
		q.Set("since", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetCommitAuthorsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsMapCommitAuthor(ctx context.Context, req *MigrationsMapCommitAuthorApplicationJSONRequest, params MigrationsMapCommitAuthorParams) (_ MigrationsMapCommitAuthorResponse, rerr error) {
	body, contentType, err := encodeMigrationsMapCommitAuthorRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/import"
	path += "/authors"
	{
		value := conv.IntToString(params.AuthorID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsMapCommitAuthorResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsGetLargeFiles(ctx context.Context, params MigrationsGetLargeFilesParams) (_ []PorterLargeFile, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/import"
	path += "/large_files"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetLargeFilesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsSetLfsPreference(ctx context.Context, req MigrationsSetLfsPreferenceApplicationJSONRequest, params MigrationsSetLfsPreferenceParams) (_ MigrationsSetLfsPreferenceResponse, rerr error) {
	body, contentType, err := encodeMigrationsSetLfsPreferenceRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/import"
	path += "/lfs"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsSetLfsPreferenceResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsGetRepoInstallation(ctx context.Context, params AppsGetRepoInstallationParams) (_ AppsGetRepoInstallationResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/installation"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetRepoInstallationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) InteractionsGetRestrictionsForRepo(ctx context.Context, params InteractionsGetRestrictionsForRepoParams) (_ InteractionsGetRestrictionsForRepoResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/interaction-limits"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsGetRestrictionsForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) InteractionsSetRestrictionsForRepo(ctx context.Context, req InteractionLimit, params InteractionsSetRestrictionsForRepoParams) (_ InteractionsSetRestrictionsForRepoResponse, rerr error) {
	body, contentType, err := encodeInteractionsSetRestrictionsForRepoRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/interaction-limits"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsSetRestrictionsForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) InteractionsRemoveRestrictionsForRepo(ctx context.Context, params InteractionsRemoveRestrictionsForRepoParams) (_ InteractionsRemoveRestrictionsForRepoResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/interaction-limits"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsRemoveRestrictionsForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListInvitations(ctx context.Context, params ReposListInvitationsParams) (_ []RepositoryInvitation, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/invitations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListInvitationsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeleteInvitation(ctx context.Context, params ReposDeleteInvitationParams) (_ ReposDeleteInvitation, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/invitations"
	{
		value := conv.IntToString(params.InvitationID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteInvitationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposUpdateInvitation(ctx context.Context, req *ReposUpdateInvitationApplicationJSONRequest, params ReposUpdateInvitationParams) (_ RepositoryInvitation, rerr error) {
	body, contentType, err := encodeReposUpdateInvitationRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/invitations"
	{
		value := conv.IntToString(params.InvitationID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateInvitationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesListForRepo(ctx context.Context, params IssuesListForRepoParams) (_ IssuesListForRepoResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Milestone)
		q.Set("milestone", s)
	}
	{
		s := conv.StringToString(params.State)
		q.Set("state", s)
	}
	{
		s := conv.StringToString(params.Assignee)
		q.Set("assignee", s)
	}
	{
		s := conv.StringToString(params.Creator)
		q.Set("creator", s)
	}
	{
		s := conv.StringToString(params.Mentioned)
		q.Set("mentioned", s)
	}
	{
		s := conv.StringToString(params.Labels)
		q.Set("labels", s)
	}
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesCreate(ctx context.Context, req IssuesCreateRequest, params IssuesCreateParams) (_ IssuesCreateResponse, rerr error) {
	body, contentType, err := encodeIssuesCreateRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesCreateResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesListCommentsForRepo(ctx context.Context, params IssuesListCommentsForRepoParams) (_ IssuesListCommentsForRepoResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListCommentsForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesGetComment(ctx context.Context, params IssuesGetCommentParams) (_ IssuesGetCommentResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesGetCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesDeleteComment(ctx context.Context, params IssuesDeleteCommentParams) (_ IssuesDeleteComment, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesDeleteCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesUpdateComment(ctx context.Context, req IssuesUpdateCommentApplicationJSONRequest, params IssuesUpdateCommentParams) (_ IssuesUpdateCommentResponse, rerr error) {
	body, contentType, err := encodeIssuesUpdateCommentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesUpdateCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsListForIssueComment(ctx context.Context, params ReactionsListForIssueCommentParams) (_ ReactionsListForIssueCommentResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Content)
		q.Set("content", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForIssueCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsCreateForIssueComment(ctx context.Context, req ReactionsCreateForIssueCommentApplicationJSONRequest, params ReactionsCreateForIssueCommentParams) (_ ReactionsCreateForIssueCommentResponse, rerr error) {
	body, contentType, err := encodeReactionsCreateForIssueCommentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForIssueCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsDeleteForIssueComment(ctx context.Context, params ReactionsDeleteForIssueCommentParams) (_ ReactionsDeleteForIssueComment, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}
	path += "/reactions"
	{
		value := conv.IntToString(params.ReactionID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForIssueCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesListEventsForRepo(ctx context.Context, params IssuesListEventsForRepoParams) (_ IssuesListEventsForRepoResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListEventsForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesGetEvent(ctx context.Context, params IssuesGetEventParams) (_ IssuesGetEventResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	path += "/events"
	{
		value := conv.IntToString(params.EventID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesGetEventResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesGet(ctx context.Context, params IssuesGetParams) (_ IssuesGetResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesGetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesUpdate(ctx context.Context, req IssuesUpdateRequest, params IssuesUpdateParams) (_ IssuesUpdateResponse, rerr error) {
	body, contentType, err := encodeIssuesUpdateRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesUpdateResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesAddAssignees(ctx context.Context, req *IssuesAddAssigneesApplicationJSONRequest, params IssuesAddAssigneesParams) (_ IssueSimple, rerr error) {
	body, contentType, err := encodeIssuesAddAssigneesRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/assignees"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesAddAssigneesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesRemoveAssignees(ctx context.Context, req *IssuesRemoveAssigneesApplicationJSONRequest, params IssuesRemoveAssigneesParams) (_ IssueSimple, rerr error) {
	body, contentType, err := encodeIssuesRemoveAssigneesRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/assignees"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesRemoveAssigneesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesListComments(ctx context.Context, params IssuesListCommentsParams) (_ IssuesListCommentsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListCommentsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesCreateComment(ctx context.Context, req IssuesCreateCommentApplicationJSONRequest, params IssuesCreateCommentParams) (_ IssuesCreateCommentResponse, rerr error) {
	body, contentType, err := encodeIssuesCreateCommentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesCreateCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesListEvents(ctx context.Context, params IssuesListEventsParams) (_ IssuesListEventsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListEventsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesListLabelsOnIssue(ctx context.Context, params IssuesListLabelsOnIssueParams) (_ IssuesListLabelsOnIssueResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/labels"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListLabelsOnIssueResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesSetLabels(ctx context.Context, req IssuesSetLabelsRequest, params IssuesSetLabelsParams) (_ IssuesSetLabelsResponse, rerr error) {
	body, contentType, err := encodeIssuesSetLabelsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/labels"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesSetLabelsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesAddLabels(ctx context.Context, req IssuesAddLabelsRequest, params IssuesAddLabelsParams) (_ IssuesAddLabelsResponse, rerr error) {
	body, contentType, err := encodeIssuesAddLabelsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/labels"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesAddLabelsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesRemoveAllLabels(ctx context.Context, params IssuesRemoveAllLabelsParams) (_ IssuesRemoveAllLabelsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/labels"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesRemoveAllLabelsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesRemoveLabel(ctx context.Context, params IssuesRemoveLabelParams) (_ IssuesRemoveLabelResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/labels"
	{
		value := conv.StringToString(params.Name)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesRemoveLabelResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesLock(ctx context.Context, req *IssuesLockApplicationJSONRequest, params IssuesLockParams) (_ IssuesLockResponse, rerr error) {
	body, contentType, err := encodeIssuesLockRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/lock"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesLockResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesUnlock(ctx context.Context, params IssuesUnlockParams) (_ IssuesUnlockResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/lock"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesUnlockResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsListForIssue(ctx context.Context, params ReactionsListForIssueParams) (_ ReactionsListForIssueResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Content)
		q.Set("content", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForIssueResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsCreateForIssue(ctx context.Context, req ReactionsCreateForIssueApplicationJSONRequest, params ReactionsCreateForIssueParams) (_ ReactionsCreateForIssueResponse, rerr error) {
	body, contentType, err := encodeReactionsCreateForIssueRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForIssueResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsDeleteForIssue(ctx context.Context, params ReactionsDeleteForIssueParams) (_ ReactionsDeleteForIssue, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/reactions"
	{
		value := conv.IntToString(params.ReactionID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForIssueResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesListEventsForTimeline(ctx context.Context, params IssuesListEventsForTimelineParams) (_ IssuesListEventsForTimelineResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/issues"
	{
		value := conv.IntToString(params.IssueNumber)
		path += "/" + value
	}
	path += "/timeline"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListEventsForTimelineResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListDeployKeys(ctx context.Context, params ReposListDeployKeysParams) (_ []DeployKey, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/keys"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListDeployKeysResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateDeployKey(ctx context.Context, req ReposCreateDeployKeyApplicationJSONRequest, params ReposCreateDeployKeyParams) (_ ReposCreateDeployKeyResponse, rerr error) {
	body, contentType, err := encodeReposCreateDeployKeyRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/keys"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateDeployKeyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetDeployKey(ctx context.Context, params ReposGetDeployKeyParams) (_ ReposGetDeployKeyResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/keys"
	{
		value := conv.IntToString(params.KeyID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetDeployKeyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeleteDeployKey(ctx context.Context, params ReposDeleteDeployKeyParams) (_ ReposDeleteDeployKey, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/keys"
	{
		value := conv.IntToString(params.KeyID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteDeployKeyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesListLabelsForRepo(ctx context.Context, params IssuesListLabelsForRepoParams) (_ IssuesListLabelsForRepoResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/labels"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListLabelsForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesCreateLabel(ctx context.Context, req IssuesCreateLabelApplicationJSONRequest, params IssuesCreateLabelParams) (_ IssuesCreateLabelResponse, rerr error) {
	body, contentType, err := encodeIssuesCreateLabelRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/labels"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesCreateLabelResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesGetLabel(ctx context.Context, params IssuesGetLabelParams) (_ IssuesGetLabelResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/labels"
	{
		value := conv.StringToString(params.Name)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesGetLabelResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesDeleteLabel(ctx context.Context, params IssuesDeleteLabelParams) (_ IssuesDeleteLabel, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/labels"
	{
		value := conv.StringToString(params.Name)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesDeleteLabelResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesUpdateLabel(ctx context.Context, req *IssuesUpdateLabelApplicationJSONRequest, params IssuesUpdateLabelParams) (_ Label, rerr error) {
	body, contentType, err := encodeIssuesUpdateLabelRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/labels"
	{
		value := conv.StringToString(params.Name)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesUpdateLabelResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListLanguages(ctx context.Context, params ReposListLanguagesParams) (_ ReposListLanguages, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/languages"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListLanguagesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposEnableLfsForRepo(ctx context.Context, params ReposEnableLfsForRepoParams) (_ ReposEnableLfsForRepoResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/lfs"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposEnableLfsForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDisableLfsForRepo(ctx context.Context, params ReposDisableLfsForRepoParams) (_ ReposDisableLfsForRepo, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/lfs"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDisableLfsForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) LicensesGetForRepo(ctx context.Context, params LicensesGetForRepoParams) (_ LicenseContent, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/license"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeLicensesGetForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposMergeUpstream(ctx context.Context, req ReposMergeUpstreamApplicationJSONRequest, params ReposMergeUpstreamParams) (_ ReposMergeUpstreamResponse, rerr error) {
	body, contentType, err := encodeReposMergeUpstreamRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/merge-upstream"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposMergeUpstreamResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposMerge(ctx context.Context, req ReposMergeApplicationJSONRequest, params ReposMergeParams) (_ ReposMergeResponse, rerr error) {
	body, contentType, err := encodeReposMergeRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/merges"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposMergeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesListMilestones(ctx context.Context, params IssuesListMilestonesParams) (_ IssuesListMilestonesResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/milestones"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.State)
		q.Set("state", s)
	}
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListMilestonesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesCreateMilestone(ctx context.Context, req IssuesCreateMilestoneApplicationJSONRequest, params IssuesCreateMilestoneParams) (_ IssuesCreateMilestoneResponse, rerr error) {
	body, contentType, err := encodeIssuesCreateMilestoneRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/milestones"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesCreateMilestoneResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesGetMilestone(ctx context.Context, params IssuesGetMilestoneParams) (_ IssuesGetMilestoneResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/milestones"
	{
		value := conv.IntToString(params.MilestoneNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesGetMilestoneResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesDeleteMilestone(ctx context.Context, params IssuesDeleteMilestoneParams) (_ IssuesDeleteMilestoneResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/milestones"
	{
		value := conv.IntToString(params.MilestoneNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesDeleteMilestoneResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesUpdateMilestone(ctx context.Context, req *IssuesUpdateMilestoneApplicationJSONRequest, params IssuesUpdateMilestoneParams) (_ Milestone, rerr error) {
	body, contentType, err := encodeIssuesUpdateMilestoneRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/milestones"
	{
		value := conv.IntToString(params.MilestoneNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesUpdateMilestoneResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesListLabelsForMilestone(ctx context.Context, params IssuesListLabelsForMilestoneParams) (_ []Label, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/milestones"
	{
		value := conv.IntToString(params.MilestoneNumber)
		path += "/" + value
	}
	path += "/labels"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListLabelsForMilestoneResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListRepoNotificationsForAuthenticatedUser(ctx context.Context, params ActivityListRepoNotificationsForAuthenticatedUserParams) (_ []Thread, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/notifications"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.BoolToString(params.All)
		q.Set("all", s)
	}
	{
		s := conv.BoolToString(params.Participating)
		q.Set("participating", s)
	}
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.TimeToString(params.Before)
		q.Set("before", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListRepoNotificationsForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityMarkRepoNotificationsAsRead(ctx context.Context, req *ActivityMarkRepoNotificationsAsReadApplicationJSONRequest, params ActivityMarkRepoNotificationsAsReadParams) (_ ActivityMarkRepoNotificationsAsReadResponse, rerr error) {
	body, contentType, err := encodeActivityMarkRepoNotificationsAsReadRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/notifications"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityMarkRepoNotificationsAsReadResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetPages(ctx context.Context, params ReposGetPagesParams) (_ ReposGetPagesResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pages"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetPagesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposUpdateInformationAboutPagesSite(ctx context.Context, req ReposUpdateInformationAboutPagesSiteRequest, params ReposUpdateInformationAboutPagesSiteParams) (_ ReposUpdateInformationAboutPagesSiteResponse, rerr error) {
	body, contentType, err := encodeReposUpdateInformationAboutPagesSiteRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pages"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateInformationAboutPagesSiteResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreatePagesSite(ctx context.Context, req ReposCreatePagesSiteApplicationJSONRequest, params ReposCreatePagesSiteParams) (_ ReposCreatePagesSiteResponse, rerr error) {
	body, contentType, err := encodeReposCreatePagesSiteRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pages"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreatePagesSiteResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeletePagesSite(ctx context.Context, params ReposDeletePagesSiteParams) (_ ReposDeletePagesSiteResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pages"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeletePagesSiteResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListPagesBuilds(ctx context.Context, params ReposListPagesBuildsParams) (_ []PageBuild, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pages"
	path += "/builds"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListPagesBuildsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposRequestPagesBuild(ctx context.Context, params ReposRequestPagesBuildParams) (_ PageBuildStatus, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pages"
	path += "/builds"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposRequestPagesBuildResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetLatestPagesBuild(ctx context.Context, params ReposGetLatestPagesBuildParams) (_ PageBuild, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pages"
	path += "/builds"
	path += "/latest"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetLatestPagesBuildResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetPagesBuild(ctx context.Context, params ReposGetPagesBuildParams) (_ PageBuild, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pages"
	path += "/builds"
	{
		value := conv.IntToString(params.BuildID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetPagesBuildResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetPagesHealthCheck(ctx context.Context, params ReposGetPagesHealthCheckParams) (_ ReposGetPagesHealthCheckResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pages"
	path += "/health"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetPagesHealthCheckResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsListForRepo(ctx context.Context, params ProjectsListForRepoParams) (_ ProjectsListForRepoResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/projects"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.State)
		q.Set("state", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsListForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsCreateForRepo(ctx context.Context, req ProjectsCreateForRepoApplicationJSONRequest, params ProjectsCreateForRepoParams) (_ ProjectsCreateForRepoResponse, rerr error) {
	body, contentType, err := encodeProjectsCreateForRepoRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/projects"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsCreateForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsList(ctx context.Context, params PullsListParams) (_ PullsListResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.State)
		q.Set("state", s)
	}
	{
		s := conv.StringToString(params.Head)
		q.Set("head", s)
	}
	{
		s := conv.StringToString(params.Base)
		q.Set("base", s)
	}
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsCreate(ctx context.Context, req PullsCreateApplicationJSONRequest, params PullsCreateParams) (_ PullsCreateResponse, rerr error) {
	body, contentType, err := encodePullsCreateRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsCreateResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsListReviewCommentsForRepo(ctx context.Context, params PullsListReviewCommentsForRepoParams) (_ []PullRequestReviewComment, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsListReviewCommentsForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsGetReviewComment(ctx context.Context, params PullsGetReviewCommentParams) (_ PullsGetReviewCommentResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsGetReviewCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsDeleteReviewComment(ctx context.Context, params PullsDeleteReviewCommentParams) (_ PullsDeleteReviewCommentResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsDeleteReviewCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsUpdateReviewComment(ctx context.Context, req PullsUpdateReviewCommentApplicationJSONRequest, params PullsUpdateReviewCommentParams) (_ PullRequestReviewComment, rerr error) {
	body, contentType, err := encodePullsUpdateReviewCommentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsUpdateReviewCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsListForPullRequestReviewComment(ctx context.Context, params ReactionsListForPullRequestReviewCommentParams) (_ ReactionsListForPullRequestReviewCommentResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Content)
		q.Set("content", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForPullRequestReviewCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsCreateForPullRequestReviewComment(ctx context.Context, req ReactionsCreateForPullRequestReviewCommentApplicationJSONRequest, params ReactionsCreateForPullRequestReviewCommentParams) (_ ReactionsCreateForPullRequestReviewCommentResponse, rerr error) {
	body, contentType, err := encodeReactionsCreateForPullRequestReviewCommentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForPullRequestReviewCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsDeleteForPullRequestComment(ctx context.Context, params ReactionsDeleteForPullRequestCommentParams) (_ ReactionsDeleteForPullRequestComment, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}
	path += "/reactions"
	{
		value := conv.IntToString(params.ReactionID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsDeleteForPullRequestCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsGet(ctx context.Context, params PullsGetParams) (_ PullsGetResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsGetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsUpdate(ctx context.Context, req *PullsUpdateApplicationJSONRequest, params PullsUpdateParams) (_ PullsUpdateResponse, rerr error) {
	body, contentType, err := encodePullsUpdateRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsUpdateResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsListReviewComments(ctx context.Context, params PullsListReviewCommentsParams) (_ []PullRequestReviewComment, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsListReviewCommentsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsCreateReviewComment(ctx context.Context, req PullsCreateReviewCommentApplicationJSONRequest, params PullsCreateReviewCommentParams) (_ PullsCreateReviewCommentResponse, rerr error) {
	body, contentType, err := encodePullsCreateReviewCommentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsCreateReviewCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsCreateReplyForReviewComment(ctx context.Context, req PullsCreateReplyForReviewCommentApplicationJSONRequest, params PullsCreateReplyForReviewCommentParams) (_ PullsCreateReplyForReviewCommentResponse, rerr error) {
	body, contentType, err := encodePullsCreateReplyForReviewCommentRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentID)
		path += "/" + value
	}
	path += "/replies"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsCreateReplyForReviewCommentResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsListCommits(ctx context.Context, params PullsListCommitsParams) (_ []Commit, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/commits"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsListCommitsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsListFiles(ctx context.Context, params PullsListFilesParams) (_ PullsListFilesResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/files"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsListFilesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsCheckIfMerged(ctx context.Context, params PullsCheckIfMergedParams) (_ PullsCheckIfMergedResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/merge"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsCheckIfMergedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsMerge(ctx context.Context, req *PullsMergeApplicationJSONRequest, params PullsMergeParams) (_ PullsMergeResponse, rerr error) {
	body, contentType, err := encodePullsMergeRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/merge"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsMergeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsListRequestedReviewers(ctx context.Context, params PullsListRequestedReviewersParams) (_ PullRequestReviewRequest, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/requested_reviewers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsListRequestedReviewersResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsRequestReviewers(ctx context.Context, req *PullsRequestReviewersApplicationJSONRequest, params PullsRequestReviewersParams) (_ PullsRequestReviewersResponse, rerr error) {
	body, contentType, err := encodePullsRequestReviewersRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/requested_reviewers"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsRequestReviewersResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsRemoveRequestedReviewers(ctx context.Context, req PullsRemoveRequestedReviewersApplicationJSONRequest, params PullsRemoveRequestedReviewersParams) (_ PullsRemoveRequestedReviewersResponse, rerr error) {
	body, contentType, err := encodePullsRemoveRequestedReviewersRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/requested_reviewers"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsRemoveRequestedReviewersResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsListReviews(ctx context.Context, params PullsListReviewsParams) (_ []PullRequestReview, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/reviews"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsListReviewsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsCreateReview(ctx context.Context, req *PullsCreateReviewApplicationJSONRequest, params PullsCreateReviewParams) (_ PullsCreateReviewResponse, rerr error) {
	body, contentType, err := encodePullsCreateReviewRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/reviews"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsCreateReviewResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsGetReview(ctx context.Context, params PullsGetReviewParams) (_ PullsGetReviewResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/reviews"
	{
		value := conv.IntToString(params.ReviewID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsGetReviewResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsUpdateReview(ctx context.Context, req PullsUpdateReviewApplicationJSONRequest, params PullsUpdateReviewParams) (_ PullsUpdateReviewResponse, rerr error) {
	body, contentType, err := encodePullsUpdateReviewRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/reviews"
	{
		value := conv.IntToString(params.ReviewID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsUpdateReviewResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsDeletePendingReview(ctx context.Context, params PullsDeletePendingReviewParams) (_ PullsDeletePendingReviewResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/reviews"
	{
		value := conv.IntToString(params.ReviewID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsDeletePendingReviewResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsListCommentsForReview(ctx context.Context, params PullsListCommentsForReviewParams) (_ PullsListCommentsForReviewResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/reviews"
	{
		value := conv.IntToString(params.ReviewID)
		path += "/" + value
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsListCommentsForReviewResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsDismissReview(ctx context.Context, req PullsDismissReviewApplicationJSONRequest, params PullsDismissReviewParams) (_ PullsDismissReviewResponse, rerr error) {
	body, contentType, err := encodePullsDismissReviewRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/reviews"
	{
		value := conv.IntToString(params.ReviewID)
		path += "/" + value
	}
	path += "/dismissals"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsDismissReviewResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsSubmitReview(ctx context.Context, req PullsSubmitReviewApplicationJSONRequest, params PullsSubmitReviewParams) (_ PullsSubmitReviewResponse, rerr error) {
	body, contentType, err := encodePullsSubmitReviewRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/reviews"
	{
		value := conv.IntToString(params.ReviewID)
		path += "/" + value
	}
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsSubmitReviewResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PullsUpdateBranch(ctx context.Context, req *PullsUpdateBranchApplicationJSONRequest, params PullsUpdateBranchParams) (_ PullsUpdateBranchResponse, rerr error) {
	body, contentType, err := encodePullsUpdateBranchRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/pulls"
	{
		value := conv.IntToString(params.PullNumber)
		path += "/" + value
	}
	path += "/update-branch"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePullsUpdateBranchResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetReadme(ctx context.Context, params ReposGetReadmeParams) (_ ReposGetReadmeResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/readme"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Ref)
		q.Set("ref", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetReadmeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetReadmeInDirectory(ctx context.Context, params ReposGetReadmeInDirectoryParams) (_ ReposGetReadmeInDirectoryResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/readme"
	{
		value := conv.StringToString(params.Dir)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Ref)
		q.Set("ref", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetReadmeInDirectoryResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListReleases(ctx context.Context, params ReposListReleasesParams) (_ ReposListReleasesResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/releases"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListReleasesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateRelease(ctx context.Context, req ReposCreateReleaseApplicationJSONRequest, params ReposCreateReleaseParams) (_ ReposCreateReleaseResponse, rerr error) {
	body, contentType, err := encodeReposCreateReleaseRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/releases"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateReleaseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetReleaseAsset(ctx context.Context, params ReposGetReleaseAssetParams) (_ ReposGetReleaseAssetResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/releases"
	path += "/assets"
	{
		value := conv.IntToString(params.AssetID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetReleaseAssetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeleteReleaseAsset(ctx context.Context, params ReposDeleteReleaseAssetParams) (_ ReposDeleteReleaseAsset, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/releases"
	path += "/assets"
	{
		value := conv.IntToString(params.AssetID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteReleaseAssetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposUpdateReleaseAsset(ctx context.Context, req *ReposUpdateReleaseAssetApplicationJSONRequest, params ReposUpdateReleaseAssetParams) (_ ReleaseAsset, rerr error) {
	body, contentType, err := encodeReposUpdateReleaseAssetRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/releases"
	path += "/assets"
	{
		value := conv.IntToString(params.AssetID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateReleaseAssetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetLatestRelease(ctx context.Context, params ReposGetLatestReleaseParams) (_ Release, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/releases"
	path += "/latest"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetLatestReleaseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetReleaseByTag(ctx context.Context, params ReposGetReleaseByTagParams) (_ ReposGetReleaseByTagResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/releases"
	path += "/tags"
	{
		value := conv.StringToString(params.Tag)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetReleaseByTagResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetRelease(ctx context.Context, params ReposGetReleaseParams) (_ ReposGetReleaseResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/releases"
	{
		value := conv.IntToString(params.ReleaseID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetReleaseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeleteRelease(ctx context.Context, params ReposDeleteReleaseParams) (_ ReposDeleteRelease, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/releases"
	{
		value := conv.IntToString(params.ReleaseID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeleteReleaseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposUpdateRelease(ctx context.Context, req *ReposUpdateReleaseApplicationJSONRequest, params ReposUpdateReleaseParams) (_ ReposUpdateReleaseResponse, rerr error) {
	body, contentType, err := encodeReposUpdateReleaseRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/releases"
	{
		value := conv.IntToString(params.ReleaseID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposUpdateReleaseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListReleaseAssets(ctx context.Context, params ReposListReleaseAssetsParams) (_ []ReleaseAsset, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/releases"
	{
		value := conv.IntToString(params.ReleaseID)
		path += "/" + value
	}
	path += "/assets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListReleaseAssetsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposUploadReleaseAsset(ctx context.Context, req *string, params ReposUploadReleaseAssetParams) (_ ReleaseAsset, rerr error) {
	body, contentType, err := encodeReposUploadReleaseAssetRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/releases"
	{
		value := conv.IntToString(params.ReleaseID)
		path += "/" + value
	}
	path += "/assets"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Name)
		q.Set("name", s)
	}
	{
		s := conv.StringToString(params.Label)
		q.Set("label", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposUploadReleaseAssetResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsCreateForRelease(ctx context.Context, req ReactionsCreateForReleaseApplicationJSONRequest, params ReactionsCreateForReleaseParams) (_ ReactionsCreateForReleaseResponse, rerr error) {
	body, contentType, err := encodeReactionsCreateForReleaseRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/releases"
	{
		value := conv.IntToString(params.ReleaseID)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForReleaseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) SecretScanningListAlertsForRepo(ctx context.Context, params SecretScanningListAlertsForRepoParams) (_ SecretScanningListAlertsForRepoResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/secret-scanning"
	path += "/alerts"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.State)
		q.Set("state", s)
	}
	{
		s := conv.StringToString(params.SecretType)
		q.Set("secret_type", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeSecretScanningListAlertsForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) SecretScanningGetAlert(ctx context.Context, params SecretScanningGetAlertParams) (_ SecretScanningGetAlertResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/secret-scanning"
	path += "/alerts"
	{
		value := conv.IntToString(params.AlertNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeSecretScanningGetAlertResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) SecretScanningUpdateAlert(ctx context.Context, req SecretScanningUpdateAlertApplicationJSONRequest, params SecretScanningUpdateAlertParams) (_ SecretScanningUpdateAlertResponse, rerr error) {
	body, contentType, err := encodeSecretScanningUpdateAlertRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/secret-scanning"
	path += "/alerts"
	{
		value := conv.IntToString(params.AlertNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeSecretScanningUpdateAlertResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListStargazersForRepo(ctx context.Context, params ActivityListStargazersForRepoParams) (_ ActivityListStargazersForRepoResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/stargazers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListStargazersForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetCodeFrequencyStats(ctx context.Context, params ReposGetCodeFrequencyStatsParams) (_ ReposGetCodeFrequencyStatsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/stats"
	path += "/code_frequency"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCodeFrequencyStatsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetCommitActivityStats(ctx context.Context, params ReposGetCommitActivityStatsParams) (_ ReposGetCommitActivityStatsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/stats"
	path += "/commit_activity"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetCommitActivityStatsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetContributorsStats(ctx context.Context, params ReposGetContributorsStatsParams) (_ ReposGetContributorsStatsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/stats"
	path += "/contributors"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetContributorsStatsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetParticipationStats(ctx context.Context, params ReposGetParticipationStatsParams) (_ ReposGetParticipationStatsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/stats"
	path += "/participation"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetParticipationStatsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetPunchCardStats(ctx context.Context, params ReposGetPunchCardStatsParams) (_ ReposGetPunchCardStatsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/stats"
	path += "/punch_card"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetPunchCardStatsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateCommitStatus(ctx context.Context, req ReposCreateCommitStatusApplicationJSONRequest, params ReposCreateCommitStatusParams) (_ Status, rerr error) {
	body, contentType, err := encodeReposCreateCommitStatusRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/statuses"
	{
		value := conv.StringToString(params.Sha)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateCommitStatusResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListWatchersForRepo(ctx context.Context, params ActivityListWatchersForRepoParams) (_ []SimpleUser, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/subscribers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListWatchersForRepoResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityGetRepoSubscription(ctx context.Context, params ActivityGetRepoSubscriptionParams) (_ ActivityGetRepoSubscriptionResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/subscription"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityGetRepoSubscriptionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivitySetRepoSubscription(ctx context.Context, req *ActivitySetRepoSubscriptionApplicationJSONRequest, params ActivitySetRepoSubscriptionParams) (_ RepositorySubscription, rerr error) {
	body, contentType, err := encodeActivitySetRepoSubscriptionRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/subscription"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivitySetRepoSubscriptionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityDeleteRepoSubscription(ctx context.Context, params ActivityDeleteRepoSubscriptionParams) (_ ActivityDeleteRepoSubscription, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/subscription"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityDeleteRepoSubscriptionResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListTags(ctx context.Context, params ReposListTagsParams) (_ []Tag, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/tags"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListTagsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDownloadTarballArchive(ctx context.Context, params ReposDownloadTarballArchiveParams) (_ ReposDownloadTarballArchive, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/tarball"
	{
		value := conv.StringToString(params.Ref)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDownloadTarballArchiveResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListTeams(ctx context.Context, params ReposListTeamsParams) (_ []Team, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/teams"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListTeamsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetAllTopics(ctx context.Context, params ReposGetAllTopicsParams) (_ ReposGetAllTopicsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/topics"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetAllTopicsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposReplaceAllTopics(ctx context.Context, req ReposReplaceAllTopicsApplicationJSONRequest, params ReposReplaceAllTopicsParams) (_ ReposReplaceAllTopicsResponse, rerr error) {
	body, contentType, err := encodeReposReplaceAllTopicsRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/topics"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposReplaceAllTopicsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetClones(ctx context.Context, params ReposGetClonesParams) (_ ReposGetClonesResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/traffic"
	path += "/clones"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Per)
		q.Set("per", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetClonesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetTopPaths(ctx context.Context, params ReposGetTopPathsParams) (_ ReposGetTopPathsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/traffic"
	path += "/popular"
	path += "/paths"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetTopPathsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetTopReferrers(ctx context.Context, params ReposGetTopReferrersParams) (_ ReposGetTopReferrersResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/traffic"
	path += "/popular"
	path += "/referrers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetTopReferrersResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposGetViews(ctx context.Context, params ReposGetViewsParams) (_ ReposGetViewsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/traffic"
	path += "/views"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Per)
		q.Set("per", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposGetViewsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposTransfer(ctx context.Context, req ReposTransferApplicationJSONRequest, params ReposTransferParams) (_ MinimalRepository, rerr error) {
	body, contentType, err := encodeReposTransferRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/transfer"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposTransferResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCheckVulnerabilityAlerts(ctx context.Context, params ReposCheckVulnerabilityAlertsParams) (_ ReposCheckVulnerabilityAlertsResponse, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/vulnerability-alerts"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCheckVulnerabilityAlertsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposEnableVulnerabilityAlerts(ctx context.Context, params ReposEnableVulnerabilityAlertsParams) (_ ReposEnableVulnerabilityAlerts, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/vulnerability-alerts"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposEnableVulnerabilityAlertsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDisableVulnerabilityAlerts(ctx context.Context, params ReposDisableVulnerabilityAlertsParams) (_ ReposDisableVulnerabilityAlerts, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/vulnerability-alerts"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDisableVulnerabilityAlertsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDownloadZipballArchive(ctx context.Context, params ReposDownloadZipballArchiveParams) (_ ReposDownloadZipballArchive, rerr error) {
	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}
	path += "/zipball"
	{
		value := conv.StringToString(params.Ref)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDownloadZipballArchiveResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateUsingTemplate(ctx context.Context, req ReposCreateUsingTemplateApplicationJSONRequest, params ReposCreateUsingTemplateParams) (_ Repository, rerr error) {
	body, contentType, err := encodeReposCreateUsingTemplateRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repos"
	{
		value := conv.StringToString(params.TemplateOwner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.TemplateRepo)
		path += "/" + value
	}
	path += "/generate"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateUsingTemplateResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListPublic(ctx context.Context, params ReposListPublicParams) (_ ReposListPublicResponse, rerr error) {
	path := c.serverURL
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.Since)
		q.Set("since", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListPublicResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsListEnvironmentSecrets(ctx context.Context, params ActionsListEnvironmentSecretsParams) (_ ActionsListEnvironmentSecrets, rerr error) {
	path := c.serverURL
	path += "/repositories"
	{
		value := conv.IntToString(params.RepositoryID)
		path += "/" + value
	}
	path += "/environments"
	{
		value := conv.StringToString(params.EnvironmentName)
		path += "/" + value
	}
	path += "/secrets"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsListEnvironmentSecretsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetEnvironmentPublicKey(ctx context.Context, params ActionsGetEnvironmentPublicKeyParams) (_ ActionsPublicKey, rerr error) {
	path := c.serverURL
	path += "/repositories"
	{
		value := conv.IntToString(params.RepositoryID)
		path += "/" + value
	}
	path += "/environments"
	{
		value := conv.StringToString(params.EnvironmentName)
		path += "/" + value
	}
	path += "/secrets"
	path += "/public-key"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetEnvironmentPublicKeyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsGetEnvironmentSecret(ctx context.Context, params ActionsGetEnvironmentSecretParams) (_ ActionsSecret, rerr error) {
	path := c.serverURL
	path += "/repositories"
	{
		value := conv.IntToString(params.RepositoryID)
		path += "/" + value
	}
	path += "/environments"
	{
		value := conv.StringToString(params.EnvironmentName)
		path += "/" + value
	}
	path += "/secrets"
	{
		value := conv.StringToString(params.SecretName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsGetEnvironmentSecretResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsCreateOrUpdateEnvironmentSecret(ctx context.Context, req ActionsCreateOrUpdateEnvironmentSecretApplicationJSONRequest, params ActionsCreateOrUpdateEnvironmentSecretParams) (_ ActionsCreateOrUpdateEnvironmentSecretResponse, rerr error) {
	body, contentType, err := encodeActionsCreateOrUpdateEnvironmentSecretRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/repositories"
	{
		value := conv.IntToString(params.RepositoryID)
		path += "/" + value
	}
	path += "/environments"
	{
		value := conv.StringToString(params.EnvironmentName)
		path += "/" + value
	}
	path += "/secrets"
	{
		value := conv.StringToString(params.SecretName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsCreateOrUpdateEnvironmentSecretResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActionsDeleteEnvironmentSecret(ctx context.Context, params ActionsDeleteEnvironmentSecretParams) (_ ActionsDeleteEnvironmentSecret, rerr error) {
	path := c.serverURL
	path += "/repositories"
	{
		value := conv.IntToString(params.RepositoryID)
		path += "/" + value
	}
	path += "/environments"
	{
		value := conv.StringToString(params.EnvironmentName)
		path += "/" + value
	}
	path += "/secrets"
	{
		value := conv.StringToString(params.SecretName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActionsDeleteEnvironmentSecretResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListProvisionedGroupsEnterprise(ctx context.Context, params EnterpriseAdminListProvisionedGroupsEnterpriseParams) (_ ScimGroupListEnterprise, rerr error) {
	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/Groups"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.StartIndex)
		q.Set("startIndex", s)
	}
	{
		s := conv.IntToString(params.Count)
		q.Set("count", s)
	}
	{
		s := conv.StringToString(params.Filter)
		q.Set("filter", s)
	}
	{
		s := conv.StringToString(params.ExcludedAttributes)
		q.Set("excludedAttributes", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListProvisionedGroupsEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx context.Context, req EnterpriseAdminProvisionAndInviteEnterpriseGroupApplicationJSONRequest, params EnterpriseAdminProvisionAndInviteEnterpriseGroupParams) (_ ScimEnterpriseGroup, rerr error) {
	body, contentType, err := encodeEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/Groups"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx context.Context, params EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams) (_ ScimEnterpriseGroup, rerr error) {
	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/Groups"
	{
		value := conv.StringToString(params.ScimGroupID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.ExcludedAttributes)
		q.Set("excludedAttributes", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx context.Context, req EnterpriseAdminSetInformationForProvisionedEnterpriseGroupApplicationJSONRequest, params EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams) (_ ScimEnterpriseGroup, rerr error) {
	body, contentType, err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/Groups"
	{
		value := conv.StringToString(params.ScimGroupID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminDeleteScimGroupFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteScimGroupFromEnterpriseParams) (_ EnterpriseAdminDeleteScimGroupFromEnterprise, rerr error) {
	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/Groups"
	{
		value := conv.StringToString(params.ScimGroupID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminDeleteScimGroupFromEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminUpdateAttributeForEnterpriseGroup(ctx context.Context, req EnterpriseAdminUpdateAttributeForEnterpriseGroupRequest, params EnterpriseAdminUpdateAttributeForEnterpriseGroupParams) (_ ScimEnterpriseGroup, rerr error) {
	body, contentType, err := encodeEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/Groups"
	{
		value := conv.StringToString(params.ScimGroupID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseGroupResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminListProvisionedIdentitiesEnterprise(ctx context.Context, params EnterpriseAdminListProvisionedIdentitiesEnterpriseParams) (_ ScimUserListEnterprise, rerr error) {
	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/Users"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.StartIndex)
		q.Set("startIndex", s)
	}
	{
		s := conv.IntToString(params.Count)
		q.Set("count", s)
	}
	{
		s := conv.StringToString(params.Filter)
		q.Set("filter", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminProvisionAndInviteEnterpriseUser(ctx context.Context, req EnterpriseAdminProvisionAndInviteEnterpriseUserApplicationJSONRequest, params EnterpriseAdminProvisionAndInviteEnterpriseUserParams) (_ ScimEnterpriseUser, rerr error) {
	body, contentType, err := encodeEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/Users"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx context.Context, params EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams) (_ ScimEnterpriseUser, rerr error) {
	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/Users"
	{
		value := conv.StringToString(params.ScimUserID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx context.Context, req EnterpriseAdminSetInformationForProvisionedEnterpriseUserApplicationJSONRequest, params EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams) (_ ScimEnterpriseUser, rerr error) {
	body, contentType, err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/Users"
	{
		value := conv.StringToString(params.ScimUserID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminDeleteUserFromEnterprise(ctx context.Context, params EnterpriseAdminDeleteUserFromEnterpriseParams) (_ EnterpriseAdminDeleteUserFromEnterprise, rerr error) {
	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/Users"
	{
		value := conv.StringToString(params.ScimUserID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminDeleteUserFromEnterpriseResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) EnterpriseAdminUpdateAttributeForEnterpriseUser(ctx context.Context, req EnterpriseAdminUpdateAttributeForEnterpriseUserApplicationJSONRequest, params EnterpriseAdminUpdateAttributeForEnterpriseUserParams) (_ ScimEnterpriseUser, rerr error) {
	body, contentType, err := encodeEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/enterprises"
	{
		value := conv.StringToString(params.Enterprise)
		path += "/" + value
	}
	path += "/Users"
	{
		value := conv.StringToString(params.ScimUserID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ScimListProvisionedIdentities(ctx context.Context, params ScimListProvisionedIdentitiesParams) (_ ScimListProvisionedIdentitiesResponse, rerr error) {
	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/organizations"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/Users"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.StartIndex)
		q.Set("startIndex", s)
	}
	{
		s := conv.IntToString(params.Count)
		q.Set("count", s)
	}
	{
		s := conv.StringToString(params.Filter)
		q.Set("filter", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeScimListProvisionedIdentitiesResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ScimProvisionAndInviteUser(ctx context.Context, req ScimProvisionAndInviteUserApplicationJSONRequest, params ScimProvisionAndInviteUserParams) (_ ScimProvisionAndInviteUserResponse, rerr error) {
	body, contentType, err := encodeScimProvisionAndInviteUserRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/organizations"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/Users"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeScimProvisionAndInviteUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ScimGetProvisioningInformationForUser(ctx context.Context, params ScimGetProvisioningInformationForUserParams) (_ ScimGetProvisioningInformationForUserResponse, rerr error) {
	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/organizations"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/Users"
	{
		value := conv.StringToString(params.ScimUserID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeScimGetProvisioningInformationForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ScimSetInformationForProvisionedUser(ctx context.Context, req ScimSetInformationForProvisionedUserApplicationJSONRequest, params ScimSetInformationForProvisionedUserParams) (_ ScimSetInformationForProvisionedUserResponse, rerr error) {
	body, contentType, err := encodeScimSetInformationForProvisionedUserRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/organizations"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/Users"
	{
		value := conv.StringToString(params.ScimUserID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeScimSetInformationForProvisionedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ScimDeleteUserFromOrg(ctx context.Context, params ScimDeleteUserFromOrgParams) (_ ScimDeleteUserFromOrgResponse, rerr error) {
	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/organizations"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/Users"
	{
		value := conv.StringToString(params.ScimUserID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeScimDeleteUserFromOrgResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ScimUpdateAttributeForUser(ctx context.Context, req ScimUpdateAttributeForUserRequest, params ScimUpdateAttributeForUserParams) (_ ScimUpdateAttributeForUserResponse, rerr error) {
	body, contentType, err := encodeScimUpdateAttributeForUserRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/scim"
	path += "/v2"
	path += "/organizations"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}
	path += "/Users"
	{
		value := conv.StringToString(params.ScimUserID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeScimUpdateAttributeForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) SearchCode(ctx context.Context, params SearchCodeParams) (_ SearchCodeResponse, rerr error) {
	path := c.serverURL
	path += "/search"
	path += "/code"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Q)
		q.Set("q", s)
	}
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Order)
		q.Set("order", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeSearchCodeResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) SearchCommits(ctx context.Context, params SearchCommitsParams) (_ SearchCommitsResponse, rerr error) {
	path := c.serverURL
	path += "/search"
	path += "/commits"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Q)
		q.Set("q", s)
	}
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Order)
		q.Set("order", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeSearchCommitsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) SearchIssuesAndPullRequests(ctx context.Context, params SearchIssuesAndPullRequestsParams) (_ SearchIssuesAndPullRequestsResponse, rerr error) {
	path := c.serverURL
	path += "/search"
	path += "/issues"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Q)
		q.Set("q", s)
	}
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Order)
		q.Set("order", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeSearchIssuesAndPullRequestsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) SearchLabels(ctx context.Context, params SearchLabelsParams) (_ SearchLabelsResponse, rerr error) {
	path := c.serverURL
	path += "/search"
	path += "/labels"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.RepositoryID)
		q.Set("repository_id", s)
	}
	{
		s := conv.StringToString(params.Q)
		q.Set("q", s)
	}
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Order)
		q.Set("order", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeSearchLabelsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) SearchRepos(ctx context.Context, params SearchReposParams) (_ SearchReposResponse, rerr error) {
	path := c.serverURL
	path += "/search"
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Q)
		q.Set("q", s)
	}
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Order)
		q.Set("order", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeSearchReposResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) SearchTopics(ctx context.Context, params SearchTopicsParams) (_ SearchTopicsResponse, rerr error) {
	path := c.serverURL
	path += "/search"
	path += "/topics"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Q)
		q.Set("q", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeSearchTopicsResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) SearchUsers(ctx context.Context, params SearchUsersParams) (_ SearchUsersResponse, rerr error) {
	path := c.serverURL
	path += "/search"
	path += "/users"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Q)
		q.Set("q", s)
	}
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Order)
		q.Set("order", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeSearchUsersResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsGetLegacy(ctx context.Context, params TeamsGetLegacyParams) (_ TeamsGetLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsDeleteLegacy(ctx context.Context, params TeamsDeleteLegacyParams) (_ TeamsDeleteLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsUpdateLegacy(ctx context.Context, req TeamsUpdateLegacyApplicationJSONRequest, params TeamsUpdateLegacyParams) (_ TeamsUpdateLegacyResponse, rerr error) {
	body, contentType, err := encodeTeamsUpdateLegacyRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListDiscussionsLegacy(ctx context.Context, params TeamsListDiscussionsLegacyParams) (_ []TeamDiscussion, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/discussions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListDiscussionsLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsCreateDiscussionLegacy(ctx context.Context, req TeamsCreateDiscussionLegacyApplicationJSONRequest, params TeamsCreateDiscussionLegacyParams) (_ TeamDiscussion, rerr error) {
	body, contentType, err := encodeTeamsCreateDiscussionLegacyRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/discussions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateDiscussionLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsGetDiscussionLegacy(ctx context.Context, params TeamsGetDiscussionLegacyParams) (_ TeamDiscussion, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetDiscussionLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsDeleteDiscussionLegacy(ctx context.Context, params TeamsDeleteDiscussionLegacyParams) (_ TeamsDeleteDiscussionLegacy, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteDiscussionLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsUpdateDiscussionLegacy(ctx context.Context, req *TeamsUpdateDiscussionLegacyApplicationJSONRequest, params TeamsUpdateDiscussionLegacyParams) (_ TeamDiscussion, rerr error) {
	body, contentType, err := encodeTeamsUpdateDiscussionLegacyRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateDiscussionLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListDiscussionCommentsLegacy(ctx context.Context, params TeamsListDiscussionCommentsLegacyParams) (_ []TeamDiscussionComment, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListDiscussionCommentsLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsCreateDiscussionCommentLegacy(ctx context.Context, req TeamsCreateDiscussionCommentLegacyApplicationJSONRequest, params TeamsCreateDiscussionCommentLegacyParams) (_ TeamDiscussionComment, rerr error) {
	body, contentType, err := encodeTeamsCreateDiscussionCommentLegacyRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/comments"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateDiscussionCommentLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsGetDiscussionCommentLegacy(ctx context.Context, params TeamsGetDiscussionCommentLegacyParams) (_ TeamDiscussionComment, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetDiscussionCommentLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsDeleteDiscussionCommentLegacy(ctx context.Context, params TeamsDeleteDiscussionCommentLegacyParams) (_ TeamsDeleteDiscussionCommentLegacy, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsDeleteDiscussionCommentLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsUpdateDiscussionCommentLegacy(ctx context.Context, req TeamsUpdateDiscussionCommentLegacyApplicationJSONRequest, params TeamsUpdateDiscussionCommentLegacyParams) (_ TeamDiscussionComment, rerr error) {
	body, contentType, err := encodeTeamsUpdateDiscussionCommentLegacyRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentNumber)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsUpdateDiscussionCommentLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsListForTeamDiscussionCommentLegacy(ctx context.Context, params ReactionsListForTeamDiscussionCommentLegacyParams) (_ []Reaction, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentNumber)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Content)
		q.Set("content", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForTeamDiscussionCommentLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsCreateForTeamDiscussionCommentLegacy(ctx context.Context, req ReactionsCreateForTeamDiscussionCommentLegacyApplicationJSONRequest, params ReactionsCreateForTeamDiscussionCommentLegacyParams) (_ Reaction, rerr error) {
	body, contentType, err := encodeReactionsCreateForTeamDiscussionCommentLegacyRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/comments"
	{
		value := conv.IntToString(params.CommentNumber)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForTeamDiscussionCommentLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsListForTeamDiscussionLegacy(ctx context.Context, params ReactionsListForTeamDiscussionLegacyParams) (_ []Reaction, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Content)
		q.Set("content", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsListForTeamDiscussionLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReactionsCreateForTeamDiscussionLegacy(ctx context.Context, req ReactionsCreateForTeamDiscussionLegacyApplicationJSONRequest, params ReactionsCreateForTeamDiscussionLegacyParams) (_ Reaction, rerr error) {
	body, contentType, err := encodeReactionsCreateForTeamDiscussionLegacyRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/discussions"
	{
		value := conv.IntToString(params.DiscussionNumber)
		path += "/" + value
	}
	path += "/reactions"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReactionsCreateForTeamDiscussionLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListPendingInvitationsLegacy(ctx context.Context, params TeamsListPendingInvitationsLegacyParams) (_ []OrganizationInvitation, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/invitations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListPendingInvitationsLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListMembersLegacy(ctx context.Context, params TeamsListMembersLegacyParams) (_ TeamsListMembersLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/members"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Role)
		q.Set("role", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListMembersLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsGetMemberLegacy(ctx context.Context, params TeamsGetMemberLegacyParams) (_ TeamsGetMemberLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/members"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetMemberLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsAddMemberLegacy(ctx context.Context, params TeamsAddMemberLegacyParams) (_ TeamsAddMemberLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/members"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddMemberLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsRemoveMemberLegacy(ctx context.Context, params TeamsRemoveMemberLegacyParams) (_ TeamsRemoveMemberLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/members"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveMemberLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsGetMembershipForUserLegacy(ctx context.Context, params TeamsGetMembershipForUserLegacyParams) (_ TeamsGetMembershipForUserLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/memberships"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsGetMembershipForUserLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsAddOrUpdateMembershipForUserLegacy(ctx context.Context, req *TeamsAddOrUpdateMembershipForUserLegacyApplicationJSONRequest, params TeamsAddOrUpdateMembershipForUserLegacyParams) (_ TeamsAddOrUpdateMembershipForUserLegacyResponse, rerr error) {
	body, contentType, err := encodeTeamsAddOrUpdateMembershipForUserLegacyRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/memberships"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateMembershipForUserLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsRemoveMembershipForUserLegacy(ctx context.Context, params TeamsRemoveMembershipForUserLegacyParams) (_ TeamsRemoveMembershipForUserLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/memberships"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveMembershipForUserLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListProjectsLegacy(ctx context.Context, params TeamsListProjectsLegacyParams) (_ TeamsListProjectsLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/projects"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListProjectsLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsCheckPermissionsForProjectLegacy(ctx context.Context, params TeamsCheckPermissionsForProjectLegacyParams) (_ TeamsCheckPermissionsForProjectLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/projects"
	{
		value := conv.IntToString(params.ProjectID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCheckPermissionsForProjectLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsAddOrUpdateProjectPermissionsLegacy(ctx context.Context, req *TeamsAddOrUpdateProjectPermissionsLegacyApplicationJSONRequest, params TeamsAddOrUpdateProjectPermissionsLegacyParams) (_ TeamsAddOrUpdateProjectPermissionsLegacyResponse, rerr error) {
	body, contentType, err := encodeTeamsAddOrUpdateProjectPermissionsLegacyRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/projects"
	{
		value := conv.IntToString(params.ProjectID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateProjectPermissionsLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsRemoveProjectLegacy(ctx context.Context, params TeamsRemoveProjectLegacyParams) (_ TeamsRemoveProjectLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/projects"
	{
		value := conv.IntToString(params.ProjectID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveProjectLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListReposLegacy(ctx context.Context, params TeamsListReposLegacyParams) (_ TeamsListReposLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/repos"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListReposLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsCheckPermissionsForRepoLegacy(ctx context.Context, params TeamsCheckPermissionsForRepoLegacyParams) (_ TeamsCheckPermissionsForRepoLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCheckPermissionsForRepoLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsAddOrUpdateRepoPermissionsLegacy(ctx context.Context, req *TeamsAddOrUpdateRepoPermissionsLegacyApplicationJSONRequest, params TeamsAddOrUpdateRepoPermissionsLegacyParams) (_ TeamsAddOrUpdateRepoPermissionsLegacyResponse, rerr error) {
	body, contentType, err := encodeTeamsAddOrUpdateRepoPermissionsLegacyRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsAddOrUpdateRepoPermissionsLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsRemoveRepoLegacy(ctx context.Context, params TeamsRemoveRepoLegacyParams) (_ TeamsRemoveRepoLegacy, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/repos"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsRemoveRepoLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListIdpGroupsForLegacy(ctx context.Context, params TeamsListIdpGroupsForLegacyParams) (_ TeamsListIdpGroupsForLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/team-sync"
	path += "/group-mappings"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListIdpGroupsForLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx context.Context, req TeamsCreateOrUpdateIdpGroupConnectionsLegacyApplicationJSONRequest, params TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams) (_ TeamsCreateOrUpdateIdpGroupConnectionsLegacyResponse, rerr error) {
	body, contentType, err := encodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/team-sync"
	path += "/group-mappings"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListChildLegacy(ctx context.Context, params TeamsListChildLegacyParams) (_ TeamsListChildLegacyResponse, rerr error) {
	path := c.serverURL
	path += "/teams"
	{
		value := conv.IntToString(params.TeamID)
		path += "/" + value
	}
	path += "/teams"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListChildLegacyResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersGetAuthenticated(ctx context.Context) (_ UsersGetAuthenticatedResponse, rerr error) {
	path := c.serverURL
	path += "/user"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersGetAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersUpdateAuthenticated(ctx context.Context, req *UsersUpdateAuthenticatedApplicationJSONRequest) (_ UsersUpdateAuthenticatedResponse, rerr error) {
	body, contentType, err := encodeUsersUpdateAuthenticatedRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/user"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersUpdateAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersListBlockedByAuthenticated(ctx context.Context) (_ UsersListBlockedByAuthenticatedResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/blocks"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersListBlockedByAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersCheckBlocked(ctx context.Context, params UsersCheckBlockedParams) (_ UsersCheckBlockedResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/blocks"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersCheckBlockedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersBlock(ctx context.Context, params UsersBlockParams) (_ UsersBlockResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/blocks"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersBlockResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersUnblock(ctx context.Context, params UsersUnblockParams) (_ UsersUnblockResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/blocks"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersUnblockResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersSetPrimaryEmailVisibilityForAuthenticated(ctx context.Context, req UsersSetPrimaryEmailVisibilityForAuthenticatedApplicationJSONRequest) (_ UsersSetPrimaryEmailVisibilityForAuthenticatedResponse, rerr error) {
	body, contentType, err := encodeUsersSetPrimaryEmailVisibilityForAuthenticatedRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/user"
	path += "/email"
	path += "/visibility"

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersSetPrimaryEmailVisibilityForAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersListEmailsForAuthenticated(ctx context.Context, params UsersListEmailsForAuthenticatedParams) (_ UsersListEmailsForAuthenticatedResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/emails"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersListEmailsForAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersAddEmailForAuthenticated(ctx context.Context, req UsersAddEmailForAuthenticatedRequest) (_ UsersAddEmailForAuthenticatedResponse, rerr error) {
	body, contentType, err := encodeUsersAddEmailForAuthenticatedRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/user"
	path += "/emails"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersAddEmailForAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersDeleteEmailForAuthenticated(ctx context.Context, req UsersDeleteEmailForAuthenticatedRequest) (_ UsersDeleteEmailForAuthenticatedResponse, rerr error) {
	body, contentType, err := encodeUsersDeleteEmailForAuthenticatedRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/user"
	path += "/emails"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersDeleteEmailForAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersListFollowersForAuthenticatedUser(ctx context.Context, params UsersListFollowersForAuthenticatedUserParams) (_ UsersListFollowersForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/followers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersListFollowersForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersListFollowedByAuthenticated(ctx context.Context, params UsersListFollowedByAuthenticatedParams) (_ UsersListFollowedByAuthenticatedResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/following"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersListFollowedByAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersCheckPersonIsFollowedByAuthenticated(ctx context.Context, params UsersCheckPersonIsFollowedByAuthenticatedParams) (_ UsersCheckPersonIsFollowedByAuthenticatedResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/following"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersCheckPersonIsFollowedByAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersFollow(ctx context.Context, params UsersFollowParams) (_ UsersFollowResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/following"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersFollowResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersUnfollow(ctx context.Context, params UsersUnfollowParams) (_ UsersUnfollowResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/following"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersUnfollowResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersListGpgKeysForAuthenticated(ctx context.Context, params UsersListGpgKeysForAuthenticatedParams) (_ UsersListGpgKeysForAuthenticatedResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/gpg_keys"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersListGpgKeysForAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersCreateGpgKeyForAuthenticated(ctx context.Context, req UsersCreateGpgKeyForAuthenticatedApplicationJSONRequest) (_ UsersCreateGpgKeyForAuthenticatedResponse, rerr error) {
	body, contentType, err := encodeUsersCreateGpgKeyForAuthenticatedRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/user"
	path += "/gpg_keys"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersCreateGpgKeyForAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersGetGpgKeyForAuthenticated(ctx context.Context, params UsersGetGpgKeyForAuthenticatedParams) (_ UsersGetGpgKeyForAuthenticatedResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/gpg_keys"
	{
		value := conv.IntToString(params.GpgKeyID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersGetGpgKeyForAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersDeleteGpgKeyForAuthenticated(ctx context.Context, params UsersDeleteGpgKeyForAuthenticatedParams) (_ UsersDeleteGpgKeyForAuthenticatedResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/gpg_keys"
	{
		value := conv.IntToString(params.GpgKeyID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersDeleteGpgKeyForAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsListInstallationsForAuthenticatedUser(ctx context.Context, params AppsListInstallationsForAuthenticatedUserParams) (_ AppsListInstallationsForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/installations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsListInstallationsForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsListInstallationReposForAuthenticatedUser(ctx context.Context, params AppsListInstallationReposForAuthenticatedUserParams) (_ AppsListInstallationReposForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/installations"
	{
		value := conv.IntToString(params.InstallationID)
		path += "/" + value
	}
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsListInstallationReposForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsAddRepoToInstallation(ctx context.Context, params AppsAddRepoToInstallationParams) (_ AppsAddRepoToInstallationResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/installations"
	{
		value := conv.IntToString(params.InstallationID)
		path += "/" + value
	}
	path += "/repositories"
	{
		value := conv.IntToString(params.RepositoryID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsAddRepoToInstallationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsRemoveRepoFromInstallation(ctx context.Context, params AppsRemoveRepoFromInstallationParams) (_ AppsRemoveRepoFromInstallationResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/installations"
	{
		value := conv.IntToString(params.InstallationID)
		path += "/" + value
	}
	path += "/repositories"
	{
		value := conv.IntToString(params.RepositoryID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsRemoveRepoFromInstallationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) InteractionsGetRestrictionsForAuthenticatedUser(ctx context.Context) (_ InteractionsGetRestrictionsForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/interaction-limits"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsGetRestrictionsForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) InteractionsSetRestrictionsForAuthenticatedUser(ctx context.Context, req InteractionLimit) (_ InteractionsSetRestrictionsForAuthenticatedUserResponse, rerr error) {
	body, contentType, err := encodeInteractionsSetRestrictionsForAuthenticatedUserRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/user"
	path += "/interaction-limits"

	r, err := http.NewRequestWithContext(ctx, "PUT", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsSetRestrictionsForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) InteractionsRemoveRestrictionsForAuthenticatedUser(ctx context.Context) (_ InteractionsRemoveRestrictionsForAuthenticatedUser, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/interaction-limits"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeInteractionsRemoveRestrictionsForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) IssuesListForAuthenticatedUser(ctx context.Context, params IssuesListForAuthenticatedUserParams) (_ IssuesListForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/issues"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Filter)
		q.Set("filter", s)
	}
	{
		s := conv.StringToString(params.State)
		q.Set("state", s)
	}
	{
		s := conv.StringToString(params.Labels)
		q.Set("labels", s)
	}
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeIssuesListForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersListPublicSSHKeysForAuthenticated(ctx context.Context, params UsersListPublicSSHKeysForAuthenticatedParams) (_ UsersListPublicSSHKeysForAuthenticatedResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/keys"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersListPublicSSHKeysForAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersCreatePublicSSHKeyForAuthenticated(ctx context.Context, req UsersCreatePublicSSHKeyForAuthenticatedApplicationJSONRequest) (_ UsersCreatePublicSSHKeyForAuthenticatedResponse, rerr error) {
	body, contentType, err := encodeUsersCreatePublicSSHKeyForAuthenticatedRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/user"
	path += "/keys"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersCreatePublicSSHKeyForAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersGetPublicSSHKeyForAuthenticated(ctx context.Context, params UsersGetPublicSSHKeyForAuthenticatedParams) (_ UsersGetPublicSSHKeyForAuthenticatedResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/keys"
	{
		value := conv.IntToString(params.KeyID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersGetPublicSSHKeyForAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersDeletePublicSSHKeyForAuthenticated(ctx context.Context, params UsersDeletePublicSSHKeyForAuthenticatedParams) (_ UsersDeletePublicSSHKeyForAuthenticatedResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/keys"
	{
		value := conv.IntToString(params.KeyID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersDeletePublicSSHKeyForAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsListSubscriptionsForAuthenticatedUser(ctx context.Context, params AppsListSubscriptionsForAuthenticatedUserParams) (_ AppsListSubscriptionsForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/marketplace_purchases"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsListSubscriptionsForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, params AppsListSubscriptionsForAuthenticatedUserStubbedParams) (_ AppsListSubscriptionsForAuthenticatedUserStubbedResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/marketplace_purchases"
	path += "/stubbed"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsListSubscriptionsForAuthenticatedUserStubbedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsListMembershipsForAuthenticatedUser(ctx context.Context, params OrgsListMembershipsForAuthenticatedUserParams) (_ OrgsListMembershipsForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/memberships"
	path += "/orgs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.State)
		q.Set("state", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListMembershipsForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsGetMembershipForAuthenticatedUser(ctx context.Context, params OrgsGetMembershipForAuthenticatedUserParams) (_ OrgsGetMembershipForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/memberships"
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsGetMembershipForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsUpdateMembershipForAuthenticatedUser(ctx context.Context, req OrgsUpdateMembershipForAuthenticatedUserApplicationJSONRequest, params OrgsUpdateMembershipForAuthenticatedUserParams) (_ OrgsUpdateMembershipForAuthenticatedUserResponse, rerr error) {
	body, contentType, err := encodeOrgsUpdateMembershipForAuthenticatedUserRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/user"
	path += "/memberships"
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsUpdateMembershipForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsListForAuthenticatedUser(ctx context.Context, params MigrationsListForAuthenticatedUserParams) (_ MigrationsListForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/migrations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsListForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsStartForAuthenticatedUser(ctx context.Context, req MigrationsStartForAuthenticatedUserApplicationJSONRequest) (_ MigrationsStartForAuthenticatedUserResponse, rerr error) {
	body, contentType, err := encodeMigrationsStartForAuthenticatedUserRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/user"
	path += "/migrations"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsStartForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsGetStatusForAuthenticatedUser(ctx context.Context, params MigrationsGetStatusForAuthenticatedUserParams) (_ MigrationsGetStatusForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/migrations"
	{
		value := conv.IntToString(params.MigrationID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringArrayToString(params.Exclude)
		for _, v := range s {
			q.Add("exclude", v)
		}
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetStatusForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsGetArchiveForAuthenticatedUser(ctx context.Context, params MigrationsGetArchiveForAuthenticatedUserParams) (_ MigrationsGetArchiveForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/migrations"
	{
		value := conv.IntToString(params.MigrationID)
		path += "/" + value
	}
	path += "/archive"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsGetArchiveForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsDeleteArchiveForAuthenticatedUser(ctx context.Context, params MigrationsDeleteArchiveForAuthenticatedUserParams) (_ MigrationsDeleteArchiveForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/migrations"
	{
		value := conv.IntToString(params.MigrationID)
		path += "/" + value
	}
	path += "/archive"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsDeleteArchiveForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsUnlockRepoForAuthenticatedUser(ctx context.Context, params MigrationsUnlockRepoForAuthenticatedUserParams) (_ MigrationsUnlockRepoForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/migrations"
	{
		value := conv.IntToString(params.MigrationID)
		path += "/" + value
	}
	path += "/repos"
	{
		value := conv.StringToString(params.RepoName)
		path += "/" + value
	}
	path += "/lock"

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsUnlockRepoForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MigrationsListReposForUser(ctx context.Context, params MigrationsListReposForUserParams) (_ MigrationsListReposForUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/migrations"
	{
		value := conv.IntToString(params.MigrationID)
		path += "/" + value
	}
	path += "/repositories"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMigrationsListReposForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsListForAuthenticatedUser(ctx context.Context, params OrgsListForAuthenticatedUserParams) (_ OrgsListForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/orgs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesListPackagesForAuthenticatedUser(ctx context.Context, params PackagesListPackagesForAuthenticatedUserParams) (_ []Package, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/packages"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.PackageType)
		q.Set("package_type", s)
	}
	{
		s := conv.StringToString(params.Visibility)
		q.Set("visibility", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesListPackagesForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesGetPackageForAuthenticatedUser(ctx context.Context, params PackagesGetPackageForAuthenticatedUserParams) (_ Package, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetPackageForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesDeletePackageForAuthenticatedUser(ctx context.Context, params PackagesDeletePackageForAuthenticatedUserParams) (_ PackagesDeletePackageForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesDeletePackageForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesRestorePackageForAuthenticatedUser(ctx context.Context, params PackagesRestorePackageForAuthenticatedUserParams) (_ PackagesRestorePackageForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}
	path += "/restore"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Token)
		q.Set("token", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesRestorePackageForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx context.Context, params PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams) (_ PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}
	path += "/versions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.StringToString(params.State)
		q.Set("state", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesGetPackageVersionForAuthenticatedUser(ctx context.Context, params PackagesGetPackageVersionForAuthenticatedUserParams) (_ PackageVersion, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}
	path += "/versions"
	{
		value := conv.IntToString(params.PackageVersionID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetPackageVersionForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesDeletePackageVersionForAuthenticatedUser(ctx context.Context, params PackagesDeletePackageVersionForAuthenticatedUserParams) (_ PackagesDeletePackageVersionForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}
	path += "/versions"
	{
		value := conv.IntToString(params.PackageVersionID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesDeletePackageVersionForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesRestorePackageVersionForAuthenticatedUser(ctx context.Context, params PackagesRestorePackageVersionForAuthenticatedUserParams) (_ PackagesRestorePackageVersionForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}
	path += "/versions"
	{
		value := conv.IntToString(params.PackageVersionID)
		path += "/" + value
	}
	path += "/restore"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesRestorePackageVersionForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsCreateForAuthenticatedUser(ctx context.Context, req ProjectsCreateForAuthenticatedUserApplicationJSONRequest) (_ ProjectsCreateForAuthenticatedUserResponse, rerr error) {
	body, contentType, err := encodeProjectsCreateForAuthenticatedUserRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/user"
	path += "/projects"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsCreateForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersListPublicEmailsForAuthenticated(ctx context.Context, params UsersListPublicEmailsForAuthenticatedParams) (_ UsersListPublicEmailsForAuthenticatedResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/public_emails"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersListPublicEmailsForAuthenticatedResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListForAuthenticatedUser(ctx context.Context, params ReposListForAuthenticatedUserParams) (_ ReposListForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/repos"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Visibility)
		q.Set("visibility", s)
	}
	{
		s := conv.StringToString(params.Affiliation)
		q.Set("affiliation", s)
	}
	{
		s := conv.StringToString(params.Type)
		q.Set("type", s)
	}
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.TimeToString(params.Before)
		q.Set("before", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposCreateForAuthenticatedUser(ctx context.Context, req ReposCreateForAuthenticatedUserApplicationJSONRequest) (_ ReposCreateForAuthenticatedUserResponse, rerr error) {
	body, contentType, err := encodeReposCreateForAuthenticatedUserRequest(req)
	if err != nil {
		rerr = err
		return
	}

	path := c.serverURL
	path += "/user"
	path += "/repos"

	r, err := http.NewRequestWithContext(ctx, "POST", path, bytes.NewReader(body))
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	r.Header.Set("Content-Type", contentType)

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposCreateForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListInvitationsForAuthenticatedUser(ctx context.Context, params ReposListInvitationsForAuthenticatedUserParams) (_ ReposListInvitationsForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/repository_invitations"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListInvitationsForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposDeclineInvitation(ctx context.Context, params ReposDeclineInvitationParams) (_ ReposDeclineInvitationResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/repository_invitations"
	{
		value := conv.IntToString(params.InvitationID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposDeclineInvitationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposAcceptInvitation(ctx context.Context, params ReposAcceptInvitationParams) (_ ReposAcceptInvitationResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/repository_invitations"
	{
		value := conv.IntToString(params.InvitationID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PATCH", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposAcceptInvitationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListReposStarredByAuthenticatedUser(ctx context.Context, params ActivityListReposStarredByAuthenticatedUserParams) (_ ActivityListReposStarredByAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/starred"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListReposStarredByAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityCheckRepoIsStarredByAuthenticatedUser(ctx context.Context, params ActivityCheckRepoIsStarredByAuthenticatedUserParams) (_ ActivityCheckRepoIsStarredByAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/starred"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityCheckRepoIsStarredByAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityStarRepoForAuthenticatedUser(ctx context.Context, params ActivityStarRepoForAuthenticatedUserParams) (_ ActivityStarRepoForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/starred"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "PUT", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityStarRepoForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityUnstarRepoForAuthenticatedUser(ctx context.Context, params ActivityUnstarRepoForAuthenticatedUserParams) (_ ActivityUnstarRepoForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/starred"
	{
		value := conv.StringToString(params.Owner)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.Repo)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityUnstarRepoForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListWatchedReposForAuthenticatedUser(ctx context.Context, params ActivityListWatchedReposForAuthenticatedUserParams) (_ ActivityListWatchedReposForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/subscriptions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListWatchedReposForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) TeamsListForAuthenticatedUser(ctx context.Context, params TeamsListForAuthenticatedUserParams) (_ TeamsListForAuthenticatedUserResponse, rerr error) {
	path := c.serverURL
	path += "/user"
	path += "/teams"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeTeamsListForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersList(ctx context.Context, params UsersListParams) (_ UsersListResponse, rerr error) {
	path := c.serverURL
	path += "/users"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersListResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersGetByUsername(ctx context.Context, params UsersGetByUsernameParams) (_ UsersGetByUsernameResponse, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersGetByUsernameResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListEventsForAuthenticatedUser(ctx context.Context, params ActivityListEventsForAuthenticatedUserParams) (_ []Event, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListEventsForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListOrgEventsForAuthenticatedUser(ctx context.Context, params ActivityListOrgEventsForAuthenticatedUserParams) (_ []Event, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/events"
	path += "/orgs"
	{
		value := conv.StringToString(params.Org)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListOrgEventsForAuthenticatedUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListPublicEventsForUser(ctx context.Context, params ActivityListPublicEventsForUserParams) (_ []Event, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/events"
	path += "/public"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListPublicEventsForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersListFollowersForUser(ctx context.Context, params UsersListFollowersForUserParams) (_ []SimpleUser, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/followers"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersListFollowersForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersListFollowingForUser(ctx context.Context, params UsersListFollowingForUserParams) (_ []SimpleUser, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/following"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersListFollowingForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersCheckFollowingForUser(ctx context.Context, params UsersCheckFollowingForUserParams) (_ UsersCheckFollowingForUserResponse, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/following"
	{
		value := conv.StringToString(params.TargetUser)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersCheckFollowingForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) GistsListForUser(ctx context.Context, params GistsListForUserParams) (_ GistsListForUserResponse, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/gists"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.TimeToString(params.Since)
		q.Set("since", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeGistsListForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersListGpgKeysForUser(ctx context.Context, params UsersListGpgKeysForUserParams) (_ UsersListGpgKeysForUserResponse, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/gpg_keys"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersListGpgKeysForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersGetContextForUser(ctx context.Context, params UsersGetContextForUserParams) (_ UsersGetContextForUserResponse, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/hovercard"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.SubjectType)
		q.Set("subject_type", s)
	}
	{
		s := conv.StringToString(params.SubjectID)
		q.Set("subject_id", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersGetContextForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) AppsGetUserInstallation(ctx context.Context, params AppsGetUserInstallationParams) (_ Installation, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/installation"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeAppsGetUserInstallationResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) UsersListPublicKeysForUser(ctx context.Context, params UsersListPublicKeysForUserParams) (_ []KeySimple, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/keys"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeUsersListPublicKeysForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) OrgsListForUser(ctx context.Context, params OrgsListForUserParams) (_ []OrganizationSimple, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/orgs"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeOrgsListForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesListPackagesForUser(ctx context.Context, params PackagesListPackagesForUserParams) (_ PackagesListPackagesForUserResponse, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/packages"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.PackageType)
		q.Set("package_type", s)
	}
	{
		s := conv.StringToString(params.Visibility)
		q.Set("visibility", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesListPackagesForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesGetPackageForUser(ctx context.Context, params PackagesGetPackageForUserParams) (_ Package, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetPackageForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesDeletePackageForUser(ctx context.Context, params PackagesDeletePackageForUserParams) (_ PackagesDeletePackageForUserResponse, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesDeletePackageForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesRestorePackageForUser(ctx context.Context, params PackagesRestorePackageForUserParams) (_ PackagesRestorePackageForUserResponse, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}
	path += "/restore"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Token)
		q.Set("token", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesRestorePackageForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesGetAllPackageVersionsForPackageOwnedByUser(ctx context.Context, params PackagesGetAllPackageVersionsForPackageOwnedByUserParams) (_ PackagesGetAllPackageVersionsForPackageOwnedByUserResponse, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}
	path += "/versions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetAllPackageVersionsForPackageOwnedByUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesGetPackageVersionForUser(ctx context.Context, params PackagesGetPackageVersionForUserParams) (_ PackagesGetPackageVersionForUserResponse, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}
	path += "/versions"
	{
		value := conv.IntToString(params.PackageVersionID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesGetPackageVersionForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesDeletePackageVersionForUser(ctx context.Context, params PackagesDeletePackageVersionForUserParams) (_ PackagesDeletePackageVersionForUserResponse, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}
	path += "/versions"
	{
		value := conv.IntToString(params.PackageVersionID)
		path += "/" + value
	}

	r, err := http.NewRequestWithContext(ctx, "DELETE", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesDeletePackageVersionForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) PackagesRestorePackageVersionForUser(ctx context.Context, params PackagesRestorePackageVersionForUserParams) (_ PackagesRestorePackageVersionForUserResponse, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/packages"
	{
		value := conv.StringToString(params.PackageType)
		path += "/" + value
	}
	{
		value := conv.StringToString(params.PackageName)
		path += "/" + value
	}
	path += "/versions"
	{
		value := conv.IntToString(params.PackageVersionID)
		path += "/" + value
	}
	path += "/restore"

	r, err := http.NewRequestWithContext(ctx, "POST", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodePackagesRestorePackageVersionForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ProjectsListForUser(ctx context.Context, params ProjectsListForUserParams) (_ ProjectsListForUserResponse, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/projects"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.State)
		q.Set("state", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeProjectsListForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListReceivedEventsForUser(ctx context.Context, params ActivityListReceivedEventsForUserParams) (_ []Event, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/received_events"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListReceivedEventsForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListReceivedPublicEventsForUser(ctx context.Context, params ActivityListReceivedPublicEventsForUserParams) (_ []Event, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/received_events"
	path += "/public"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListReceivedPublicEventsForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ReposListForUser(ctx context.Context, params ReposListForUserParams) (_ []MinimalRepository, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/repos"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Type)
		q.Set("type", s)
	}
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeReposListForUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) BillingGetGithubActionsBillingUser(ctx context.Context, params BillingGetGithubActionsBillingUserParams) (_ ActionsBillingUsage, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/settings"
	path += "/billing"
	path += "/actions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubActionsBillingUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) BillingGetGithubPackagesBillingUser(ctx context.Context, params BillingGetGithubPackagesBillingUserParams) (_ PackagesBillingUsage, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/settings"
	path += "/billing"
	path += "/packages"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetGithubPackagesBillingUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) BillingGetSharedStorageBillingUser(ctx context.Context, params BillingGetSharedStorageBillingUserParams) (_ CombinedBillingUsage, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/settings"
	path += "/billing"
	path += "/shared-storage"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeBillingGetSharedStorageBillingUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListReposStarredByUser(ctx context.Context, params ActivityListReposStarredByUserParams) (_ ActivityListReposStarredByUserResponse, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/starred"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.StringToString(params.Sort)
		q.Set("sort", s)
	}
	{
		s := conv.StringToString(params.Direction)
		q.Set("direction", s)
	}
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListReposStarredByUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) ActivityListReposWatchedByUser(ctx context.Context, params ActivityListReposWatchedByUserParams) (_ []MinimalRepository, rerr error) {
	path := c.serverURL
	path += "/users"
	{
		value := conv.StringToString(params.Username)
		path += "/" + value
	}
	path += "/subscriptions"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	q := r.URL.Query()
	{
		s := conv.IntToString(params.PerPage)
		q.Set("per_page", s)
	}
	{
		s := conv.IntToString(params.Page)
		q.Set("page", s)
	}
	r.URL.RawQuery = q.Encode()

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeActivityListReposWatchedByUserResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}

func (c *Client) MetaGetZen(ctx context.Context) (_ string, rerr error) {
	path := c.serverURL
	path += "/zen"

	r, err := http.NewRequestWithContext(ctx, "GET", path, nil)
	if err != nil {
		rerr = fmt.Errorf("create request: %w", err)
		return
	}

	resp, err := c.http.Do(r)
	if err != nil {
		rerr = fmt.Errorf("do request: %w", err)
		return
	}
	defer resp.Body.Close()

	result, err := decodeMetaGetZenResponse(resp)
	if err != nil {
		rerr = fmt.Errorf("decode response: %w", err)
		return
	}

	return result, nil
}
