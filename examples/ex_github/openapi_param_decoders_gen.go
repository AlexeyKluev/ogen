// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/encoding/json"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = chi.Context{}
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
)

func decodeAppsCreateFromManifestParams(r *http.Request) (AppsCreateFromManifestParams, error) {
	var params AppsCreateFromManifestParams
	{
		param := chi.URLParam(r, "code")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'code' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'code': %w", err)
		}

		params.Code = v
	}

	return params, nil
}

func decodeAppsListWebhookDeliveriesParams(r *http.Request) (AppsListWebhookDeliveriesParams, error) {
	var params AppsListWebhookDeliveriesParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("cursor")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'cursor': %w", err)
			}

			params.Cursor = v
		}
	}

	return params, nil
}

func decodeAppsGetWebhookDeliveryParams(r *http.Request) (AppsGetWebhookDeliveryParams, error) {
	var params AppsGetWebhookDeliveryParams
	{
		param := chi.URLParam(r, "delivery_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'delivery_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'delivery_id': %w", err)
		}

		params.DeliveryID = v
	}

	return params, nil
}

func decodeAppsRedeliverWebhookDeliveryParams(r *http.Request) (AppsRedeliverWebhookDeliveryParams, error) {
	var params AppsRedeliverWebhookDeliveryParams
	{
		param := chi.URLParam(r, "delivery_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'delivery_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'delivery_id': %w", err)
		}

		params.DeliveryID = v
	}

	return params, nil
}

func decodeAppsListInstallationsParams(r *http.Request) (AppsListInstallationsParams, error) {
	var params AppsListInstallationsParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("outdated")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'outdated': %w", err)
			}

			params.Outdated = v
		}
	}

	return params, nil
}

func decodeAppsGetInstallationParams(r *http.Request) (AppsGetInstallationParams, error) {
	var params AppsGetInstallationParams
	{
		param := chi.URLParam(r, "installation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'installation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'installation_id': %w", err)
		}

		params.InstallationID = v
	}

	return params, nil
}

func decodeAppsDeleteInstallationParams(r *http.Request) (AppsDeleteInstallationParams, error) {
	var params AppsDeleteInstallationParams
	{
		param := chi.URLParam(r, "installation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'installation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'installation_id': %w", err)
		}

		params.InstallationID = v
	}

	return params, nil
}

func decodeAppsCreateInstallationAccessTokenParams(r *http.Request) (AppsCreateInstallationAccessTokenParams, error) {
	var params AppsCreateInstallationAccessTokenParams
	{
		param := chi.URLParam(r, "installation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'installation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'installation_id': %w", err)
		}

		params.InstallationID = v
	}

	return params, nil
}

func decodeAppsSuspendInstallationParams(r *http.Request) (AppsSuspendInstallationParams, error) {
	var params AppsSuspendInstallationParams
	{
		param := chi.URLParam(r, "installation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'installation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'installation_id': %w", err)
		}

		params.InstallationID = v
	}

	return params, nil
}

func decodeAppsUnsuspendInstallationParams(r *http.Request) (AppsUnsuspendInstallationParams, error) {
	var params AppsUnsuspendInstallationParams
	{
		param := chi.URLParam(r, "installation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'installation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'installation_id': %w", err)
		}

		params.InstallationID = v
	}

	return params, nil
}

func decodeOAuthAuthorizationsListGrantsParams(r *http.Request) (OAuthAuthorizationsListGrantsParams, error) {
	var params OAuthAuthorizationsListGrantsParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("client_id")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'client_id': %w", err)
			}

			params.ClientID = v
		}
	}

	return params, nil
}

func decodeOAuthAuthorizationsGetGrantParams(r *http.Request) (OAuthAuthorizationsGetGrantParams, error) {
	var params OAuthAuthorizationsGetGrantParams
	{
		param := chi.URLParam(r, "grant_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'grant_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'grant_id': %w", err)
		}

		params.GrantID = v
	}

	return params, nil
}

func decodeOAuthAuthorizationsDeleteGrantParams(r *http.Request) (OAuthAuthorizationsDeleteGrantParams, error) {
	var params OAuthAuthorizationsDeleteGrantParams
	{
		param := chi.URLParam(r, "grant_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'grant_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'grant_id': %w", err)
		}

		params.GrantID = v
	}

	return params, nil
}

func decodeAppsDeleteAuthorizationParams(r *http.Request) (AppsDeleteAuthorizationParams, error) {
	var params AppsDeleteAuthorizationParams
	{
		param := chi.URLParam(r, "client_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'client_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'client_id': %w", err)
		}

		params.ClientID = v
	}

	return params, nil
}

func decodeAppsCheckTokenParams(r *http.Request) (AppsCheckTokenParams, error) {
	var params AppsCheckTokenParams
	{
		param := chi.URLParam(r, "client_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'client_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'client_id': %w", err)
		}

		params.ClientID = v
	}

	return params, nil
}

func decodeAppsDeleteTokenParams(r *http.Request) (AppsDeleteTokenParams, error) {
	var params AppsDeleteTokenParams
	{
		param := chi.URLParam(r, "client_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'client_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'client_id': %w", err)
		}

		params.ClientID = v
	}

	return params, nil
}

func decodeAppsResetTokenParams(r *http.Request) (AppsResetTokenParams, error) {
	var params AppsResetTokenParams
	{
		param := chi.URLParam(r, "client_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'client_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'client_id': %w", err)
		}

		params.ClientID = v
	}

	return params, nil
}

func decodeAppsScopeTokenParams(r *http.Request) (AppsScopeTokenParams, error) {
	var params AppsScopeTokenParams
	{
		param := chi.URLParam(r, "client_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'client_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'client_id': %w", err)
		}

		params.ClientID = v
	}

	return params, nil
}

func decodeAppsGetBySlugParams(r *http.Request) (AppsGetBySlugParams, error) {
	var params AppsGetBySlugParams
	{
		param := chi.URLParam(r, "app_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'app_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'app_slug': %w", err)
		}

		params.AppSlug = v
	}

	return params, nil
}

func decodeOAuthAuthorizationsListAuthorizationsParams(r *http.Request) (OAuthAuthorizationsListAuthorizationsParams, error) {
	var params OAuthAuthorizationsListAuthorizationsParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("client_id")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'client_id': %w", err)
			}

			params.ClientID = v
		}
	}

	return params, nil
}

func decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppParams(r *http.Request) (OAuthAuthorizationsGetOrCreateAuthorizationForAppParams, error) {
	var params OAuthAuthorizationsGetOrCreateAuthorizationForAppParams
	{
		param := chi.URLParam(r, "client_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'client_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'client_id': %w", err)
		}

		params.ClientID = v
	}

	return params, nil
}

func decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams(r *http.Request) (OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams, error) {
	var params OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams
	{
		param := chi.URLParam(r, "client_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'client_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'client_id': %w", err)
		}

		params.ClientID = v
	}
	{
		param := chi.URLParam(r, "fingerprint")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'fingerprint' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'fingerprint': %w", err)
		}

		params.Fingerprint = v
	}

	return params, nil
}

func decodeOAuthAuthorizationsGetAuthorizationParams(r *http.Request) (OAuthAuthorizationsGetAuthorizationParams, error) {
	var params OAuthAuthorizationsGetAuthorizationParams
	{
		param := chi.URLParam(r, "authorization_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'authorization_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'authorization_id': %w", err)
		}

		params.AuthorizationID = v
	}

	return params, nil
}

func decodeOAuthAuthorizationsDeleteAuthorizationParams(r *http.Request) (OAuthAuthorizationsDeleteAuthorizationParams, error) {
	var params OAuthAuthorizationsDeleteAuthorizationParams
	{
		param := chi.URLParam(r, "authorization_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'authorization_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'authorization_id': %w", err)
		}

		params.AuthorizationID = v
	}

	return params, nil
}

func decodeOAuthAuthorizationsUpdateAuthorizationParams(r *http.Request) (OAuthAuthorizationsUpdateAuthorizationParams, error) {
	var params OAuthAuthorizationsUpdateAuthorizationParams
	{
		param := chi.URLParam(r, "authorization_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'authorization_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'authorization_id': %w", err)
		}

		params.AuthorizationID = v
	}

	return params, nil
}

func decodeCodesOfConductGetConductCodeParams(r *http.Request) (CodesOfConductGetConductCodeParams, error) {
	var params CodesOfConductGetConductCodeParams
	{
		param := chi.URLParam(r, "key")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'key' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'key': %w", err)
		}

		params.Key = v
	}

	return params, nil
}

func decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams(r *http.Request) (EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams, error) {
	var params EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams(r *http.Request) (EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams, error) {
	var params EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams(r *http.Request) (EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams, error) {
	var params EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams(r *http.Request) (EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams, error) {
	var params EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams(r *http.Request) (EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams, error) {
	var params EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "org_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org_id': %w", err)
		}

		params.OrgID = v
	}

	return params, nil
}

func decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams(r *http.Request) (EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams, error) {
	var params EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "org_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org_id': %w", err)
		}

		params.OrgID = v
	}

	return params, nil
}

func decodeEnterpriseAdminGetAllowedActionsEnterpriseParams(r *http.Request) (EnterpriseAdminGetAllowedActionsEnterpriseParams, error) {
	var params EnterpriseAdminGetAllowedActionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminSetAllowedActionsEnterpriseParams(r *http.Request) (EnterpriseAdminSetAllowedActionsEnterpriseParams, error) {
	var params EnterpriseAdminSetAllowedActionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams(r *http.Request) (EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams, error) {
	var params EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams(r *http.Request) (EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams, error) {
	var params EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams(r *http.Request) (EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams, error) {
	var params EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams(r *http.Request) (EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams, error) {
	var params EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams(r *http.Request) (EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams, error) {
	var params EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r *http.Request) (EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var params EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r *http.Request) (EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var params EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r *http.Request) (EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var params EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "org_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org_id': %w", err)
		}

		params.OrgID = v
	}

	return params, nil
}

func decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r *http.Request) (EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var params EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "org_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org_id': %w", err)
		}

		params.OrgID = v
	}

	return params, nil
}

func decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams(r *http.Request) (EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams, error) {
	var params EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams(r *http.Request) (EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams, error) {
	var params EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams(r *http.Request) (EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams, error) {
	var params EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams(r *http.Request) (EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams, error) {
	var params EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseParams(r *http.Request) (EnterpriseAdminListSelfHostedRunnersForEnterpriseParams, error) {
	var params EnterpriseAdminListSelfHostedRunnersForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminListRunnerApplicationsForEnterpriseParams(r *http.Request) (EnterpriseAdminListRunnerApplicationsForEnterpriseParams, error) {
	var params EnterpriseAdminListRunnerApplicationsForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseParams(r *http.Request) (EnterpriseAdminCreateRegistrationTokenForEnterpriseParams, error) {
	var params EnterpriseAdminCreateRegistrationTokenForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminCreateRemoveTokenForEnterpriseParams(r *http.Request) (EnterpriseAdminCreateRemoveTokenForEnterpriseParams, error) {
	var params EnterpriseAdminCreateRemoveTokenForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams(r *http.Request) (EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams, error) {
	var params EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams(r *http.Request) (EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams, error) {
	var params EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeEnterpriseAdminGetAuditLogParams(r *http.Request) (EnterpriseAdminGetAuditLogParams, error) {
	var params EnterpriseAdminGetAuditLogParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := r.URL.Query().Get("phrase")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'phrase': %w", err)
			}

			params.Phrase = v
		}
	}
	{
		param := r.URL.Query().Get("include")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'include': %w", err)
			}

			params.Include = v
		}
	}
	{
		param := r.URL.Query().Get("after")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'after': %w", err)
			}

			params.After = v
		}
	}
	{
		param := r.URL.Query().Get("before")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'before': %w", err)
			}

			params.Before = v
		}
	}
	{
		param := r.URL.Query().Get("order")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'order': %w", err)
			}

			params.Order = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}

	return params, nil
}

func decodeBillingGetGithubActionsBillingGheParams(r *http.Request) (BillingGetGithubActionsBillingGheParams, error) {
	var params BillingGetGithubActionsBillingGheParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeBillingGetGithubPackagesBillingGheParams(r *http.Request) (BillingGetGithubPackagesBillingGheParams, error) {
	var params BillingGetGithubPackagesBillingGheParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeBillingGetSharedStorageBillingGheParams(r *http.Request) (BillingGetSharedStorageBillingGheParams, error) {
	var params BillingGetSharedStorageBillingGheParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeActivityListPublicEventsParams(r *http.Request) (ActivityListPublicEventsParams, error) {
	var params ActivityListPublicEventsParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGistsListParams(r *http.Request) (GistsListParams, error) {
	var params GistsListParams
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGistsListPublicParams(r *http.Request) (GistsListPublicParams, error) {
	var params GistsListPublicParams
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGistsListStarredParams(r *http.Request) (GistsListStarredParams, error) {
	var params GistsListStarredParams
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGistsGetParams(r *http.Request) (GistsGetParams, error) {
	var params GistsGetParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}

	return params, nil
}

func decodeGistsDeleteParams(r *http.Request) (GistsDeleteParams, error) {
	var params GistsDeleteParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}

	return params, nil
}

func decodeGistsUpdateParams(r *http.Request) (GistsUpdateParams, error) {
	var params GistsUpdateParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}

	return params, nil
}

func decodeGistsListCommentsParams(r *http.Request) (GistsListCommentsParams, error) {
	var params GistsListCommentsParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGistsCreateCommentParams(r *http.Request) (GistsCreateCommentParams, error) {
	var params GistsCreateCommentParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}

	return params, nil
}

func decodeGistsGetCommentParams(r *http.Request) (GistsGetCommentParams, error) {
	var params GistsGetCommentParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeGistsDeleteCommentParams(r *http.Request) (GistsDeleteCommentParams, error) {
	var params GistsDeleteCommentParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeGistsUpdateCommentParams(r *http.Request) (GistsUpdateCommentParams, error) {
	var params GistsUpdateCommentParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeGistsListCommitsParams(r *http.Request) (GistsListCommitsParams, error) {
	var params GistsListCommitsParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGistsListForksParams(r *http.Request) (GistsListForksParams, error) {
	var params GistsListForksParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGistsForkParams(r *http.Request) (GistsForkParams, error) {
	var params GistsForkParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}

	return params, nil
}

func decodeGistsCheckIsStarredParams(r *http.Request) (GistsCheckIsStarredParams, error) {
	var params GistsCheckIsStarredParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}

	return params, nil
}

func decodeGistsStarParams(r *http.Request) (GistsStarParams, error) {
	var params GistsStarParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}

	return params, nil
}

func decodeGistsUnstarParams(r *http.Request) (GistsUnstarParams, error) {
	var params GistsUnstarParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}

	return params, nil
}

func decodeGistsGetRevisionParams(r *http.Request) (GistsGetRevisionParams, error) {
	var params GistsGetRevisionParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}
	{
		param := chi.URLParam(r, "sha")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'sha' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'sha': %w", err)
		}

		params.Sha = v
	}

	return params, nil
}

func decodeGitignoreGetTemplateParams(r *http.Request) (GitignoreGetTemplateParams, error) {
	var params GitignoreGetTemplateParams
	{
		param := chi.URLParam(r, "name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'name': %w", err)
		}

		params.Name = v
	}

	return params, nil
}

func decodeAppsListReposAccessibleToInstallationParams(r *http.Request) (AppsListReposAccessibleToInstallationParams, error) {
	var params AppsListReposAccessibleToInstallationParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesListParams(r *http.Request) (IssuesListParams, error) {
	var params IssuesListParams
	{
		param := r.URL.Query().Get("filter")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'filter': %w", err)
			}

			params.Filter = v
		}
	}
	{
		param := r.URL.Query().Get("state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'state': %w", err)
			}

			params.State = v
		}
	}
	{
		param := r.URL.Query().Get("labels")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'labels': %w", err)
			}

			params.Labels = v
		}
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("collab")
		if len(param) > 0 {
			v, err := conv.ToBool(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'collab': %w", err)
			}

			params.Collab = v
		}
	}
	{
		param := r.URL.Query().Get("orgs")
		if len(param) > 0 {
			v, err := conv.ToBool(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'orgs': %w", err)
			}

			params.Orgs = v
		}
	}
	{
		param := r.URL.Query().Get("owned")
		if len(param) > 0 {
			v, err := conv.ToBool(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'owned': %w", err)
			}

			params.Owned = v
		}
	}
	{
		param := r.URL.Query().Get("pulls")
		if len(param) > 0 {
			v, err := conv.ToBool(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'pulls': %w", err)
			}

			params.Pulls = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeLicensesGetAllCommonlyUsedParams(r *http.Request) (LicensesGetAllCommonlyUsedParams, error) {
	var params LicensesGetAllCommonlyUsedParams
	{
		param := r.URL.Query().Get("featured")
		if len(param) > 0 {
			v, err := conv.ToBool(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'featured': %w", err)
			}

			params.Featured = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeLicensesGetParams(r *http.Request) (LicensesGetParams, error) {
	var params LicensesGetParams
	{
		param := chi.URLParam(r, "license")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'license' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'license': %w", err)
		}

		params.License = v
	}

	return params, nil
}

func decodeAppsGetSubscriptionPlanForAccountParams(r *http.Request) (AppsGetSubscriptionPlanForAccountParams, error) {
	var params AppsGetSubscriptionPlanForAccountParams
	{
		param := chi.URLParam(r, "account_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'account_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'account_id': %w", err)
		}

		params.AccountID = v
	}

	return params, nil
}

func decodeAppsListPlansParams(r *http.Request) (AppsListPlansParams, error) {
	var params AppsListPlansParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeAppsListAccountsForPlanParams(r *http.Request) (AppsListAccountsForPlanParams, error) {
	var params AppsListAccountsForPlanParams
	{
		param := chi.URLParam(r, "plan_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'plan_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'plan_id': %w", err)
		}

		params.PlanID = v
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeAppsGetSubscriptionPlanForAccountStubbedParams(r *http.Request) (AppsGetSubscriptionPlanForAccountStubbedParams, error) {
	var params AppsGetSubscriptionPlanForAccountStubbedParams
	{
		param := chi.URLParam(r, "account_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'account_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'account_id': %w", err)
		}

		params.AccountID = v
	}

	return params, nil
}

func decodeAppsListPlansStubbedParams(r *http.Request) (AppsListPlansStubbedParams, error) {
	var params AppsListPlansStubbedParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeAppsListAccountsForPlanStubbedParams(r *http.Request) (AppsListAccountsForPlanStubbedParams, error) {
	var params AppsListAccountsForPlanStubbedParams
	{
		param := chi.URLParam(r, "plan_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'plan_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'plan_id': %w", err)
		}

		params.PlanID = v
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityListPublicEventsForRepoNetworkParams(r *http.Request) (ActivityListPublicEventsForRepoNetworkParams, error) {
	var params ActivityListPublicEventsForRepoNetworkParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityListNotificationsForAuthenticatedUserParams(r *http.Request) (ActivityListNotificationsForAuthenticatedUserParams, error) {
	var params ActivityListNotificationsForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("all")
		if len(param) > 0 {
			v, err := conv.ToBool(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'all': %w", err)
			}

			params.All = v
		}
	}
	{
		param := r.URL.Query().Get("participating")
		if len(param) > 0 {
			v, err := conv.ToBool(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'participating': %w", err)
			}

			params.Participating = v
		}
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("before")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'before': %w", err)
			}

			params.Before = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityGetThreadParams(r *http.Request) (ActivityGetThreadParams, error) {
	var params ActivityGetThreadParams
	{
		param := chi.URLParam(r, "thread_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'thread_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'thread_id': %w", err)
		}

		params.ThreadID = v
	}

	return params, nil
}

func decodeActivityMarkThreadAsReadParams(r *http.Request) (ActivityMarkThreadAsReadParams, error) {
	var params ActivityMarkThreadAsReadParams
	{
		param := chi.URLParam(r, "thread_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'thread_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'thread_id': %w", err)
		}

		params.ThreadID = v
	}

	return params, nil
}

func decodeActivityGetThreadSubscriptionForAuthenticatedUserParams(r *http.Request) (ActivityGetThreadSubscriptionForAuthenticatedUserParams, error) {
	var params ActivityGetThreadSubscriptionForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "thread_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'thread_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'thread_id': %w", err)
		}

		params.ThreadID = v
	}

	return params, nil
}

func decodeActivitySetThreadSubscriptionParams(r *http.Request) (ActivitySetThreadSubscriptionParams, error) {
	var params ActivitySetThreadSubscriptionParams
	{
		param := chi.URLParam(r, "thread_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'thread_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'thread_id': %w", err)
		}

		params.ThreadID = v
	}

	return params, nil
}

func decodeActivityDeleteThreadSubscriptionParams(r *http.Request) (ActivityDeleteThreadSubscriptionParams, error) {
	var params ActivityDeleteThreadSubscriptionParams
	{
		param := chi.URLParam(r, "thread_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'thread_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'thread_id': %w", err)
		}

		params.ThreadID = v
	}

	return params, nil
}

func decodeMetaGetOctocatParams(r *http.Request) (MetaGetOctocatParams, error) {
	var params MetaGetOctocatParams
	{
		param := r.URL.Query().Get("s")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 's': %w", err)
			}

			params.S = v
		}
	}

	return params, nil
}

func decodeOrgsListParams(r *http.Request) (OrgsListParams, error) {
	var params OrgsListParams
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}

	return params, nil
}

func decodeOrgsGetParams(r *http.Request) (OrgsGetParams, error) {
	var params OrgsGetParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeOrgsUpdateParams(r *http.Request) (OrgsUpdateParams, error) {
	var params OrgsUpdateParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsGetGithubActionsPermissionsOrganizationParams(r *http.Request) (ActionsGetGithubActionsPermissionsOrganizationParams, error) {
	var params ActionsGetGithubActionsPermissionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsSetGithubActionsPermissionsOrganizationParams(r *http.Request) (ActionsSetGithubActionsPermissionsOrganizationParams, error) {
	var params ActionsSetGithubActionsPermissionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams(r *http.Request) (ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams, error) {
	var params ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams(r *http.Request) (ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams, error) {
	var params ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsEnableSelectedRepositoryGithubActionsOrganizationParams(r *http.Request) (ActionsEnableSelectedRepositoryGithubActionsOrganizationParams, error) {
	var params ActionsEnableSelectedRepositoryGithubActionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeActionsDisableSelectedRepositoryGithubActionsOrganizationParams(r *http.Request) (ActionsDisableSelectedRepositoryGithubActionsOrganizationParams, error) {
	var params ActionsDisableSelectedRepositoryGithubActionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeActionsGetAllowedActionsOrganizationParams(r *http.Request) (ActionsGetAllowedActionsOrganizationParams, error) {
	var params ActionsGetAllowedActionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsSetAllowedActionsOrganizationParams(r *http.Request) (ActionsSetAllowedActionsOrganizationParams, error) {
	var params ActionsSetAllowedActionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsListSelfHostedRunnerGroupsForOrgParams(r *http.Request) (ActionsListSelfHostedRunnerGroupsForOrgParams, error) {
	var params ActionsListSelfHostedRunnerGroupsForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsCreateSelfHostedRunnerGroupForOrgParams(r *http.Request) (ActionsCreateSelfHostedRunnerGroupForOrgParams, error) {
	var params ActionsCreateSelfHostedRunnerGroupForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsGetSelfHostedRunnerGroupForOrgParams(r *http.Request) (ActionsGetSelfHostedRunnerGroupForOrgParams, error) {
	var params ActionsGetSelfHostedRunnerGroupForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeActionsDeleteSelfHostedRunnerGroupFromOrgParams(r *http.Request) (ActionsDeleteSelfHostedRunnerGroupFromOrgParams, error) {
	var params ActionsDeleteSelfHostedRunnerGroupFromOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeActionsUpdateSelfHostedRunnerGroupForOrgParams(r *http.Request) (ActionsUpdateSelfHostedRunnerGroupForOrgParams, error) {
	var params ActionsUpdateSelfHostedRunnerGroupForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams(r *http.Request) (ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var params ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}

	return params, nil
}

func decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams(r *http.Request) (ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var params ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams(r *http.Request) (ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var params ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams(r *http.Request) (ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var params ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeActionsListSelfHostedRunnersInGroupForOrgParams(r *http.Request) (ActionsListSelfHostedRunnersInGroupForOrgParams, error) {
	var params ActionsListSelfHostedRunnersInGroupForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsSetSelfHostedRunnersInGroupForOrgParams(r *http.Request) (ActionsSetSelfHostedRunnersInGroupForOrgParams, error) {
	var params ActionsSetSelfHostedRunnersInGroupForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeActionsAddSelfHostedRunnerToGroupForOrgParams(r *http.Request) (ActionsAddSelfHostedRunnerToGroupForOrgParams, error) {
	var params ActionsAddSelfHostedRunnerToGroupForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeActionsRemoveSelfHostedRunnerFromGroupForOrgParams(r *http.Request) (ActionsRemoveSelfHostedRunnerFromGroupForOrgParams, error) {
	var params ActionsRemoveSelfHostedRunnerFromGroupForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeActionsListSelfHostedRunnersForOrgParams(r *http.Request) (ActionsListSelfHostedRunnersForOrgParams, error) {
	var params ActionsListSelfHostedRunnersForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsListRunnerApplicationsForOrgParams(r *http.Request) (ActionsListRunnerApplicationsForOrgParams, error) {
	var params ActionsListRunnerApplicationsForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsCreateRegistrationTokenForOrgParams(r *http.Request) (ActionsCreateRegistrationTokenForOrgParams, error) {
	var params ActionsCreateRegistrationTokenForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsCreateRemoveTokenForOrgParams(r *http.Request) (ActionsCreateRemoveTokenForOrgParams, error) {
	var params ActionsCreateRemoveTokenForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsGetSelfHostedRunnerForOrgParams(r *http.Request) (ActionsGetSelfHostedRunnerForOrgParams, error) {
	var params ActionsGetSelfHostedRunnerForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeActionsDeleteSelfHostedRunnerFromOrgParams(r *http.Request) (ActionsDeleteSelfHostedRunnerFromOrgParams, error) {
	var params ActionsDeleteSelfHostedRunnerFromOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeActionsListOrgSecretsParams(r *http.Request) (ActionsListOrgSecretsParams, error) {
	var params ActionsListOrgSecretsParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsGetOrgPublicKeyParams(r *http.Request) (ActionsGetOrgPublicKeyParams, error) {
	var params ActionsGetOrgPublicKeyParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsGetOrgSecretParams(r *http.Request) (ActionsGetOrgSecretParams, error) {
	var params ActionsGetOrgSecretParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsCreateOrUpdateOrgSecretParams(r *http.Request) (ActionsCreateOrUpdateOrgSecretParams, error) {
	var params ActionsCreateOrUpdateOrgSecretParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsDeleteOrgSecretParams(r *http.Request) (ActionsDeleteOrgSecretParams, error) {
	var params ActionsDeleteOrgSecretParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsListSelectedReposForOrgSecretParams(r *http.Request) (ActionsListSelectedReposForOrgSecretParams, error) {
	var params ActionsListSelectedReposForOrgSecretParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}

	return params, nil
}

func decodeActionsSetSelectedReposForOrgSecretParams(r *http.Request) (ActionsSetSelectedReposForOrgSecretParams, error) {
	var params ActionsSetSelectedReposForOrgSecretParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsAddSelectedRepoToOrgSecretParams(r *http.Request) (ActionsAddSelectedRepoToOrgSecretParams, error) {
	var params ActionsAddSelectedRepoToOrgSecretParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeActionsRemoveSelectedRepoFromOrgSecretParams(r *http.Request) (ActionsRemoveSelectedRepoFromOrgSecretParams, error) {
	var params ActionsRemoveSelectedRepoFromOrgSecretParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeOrgsGetAuditLogParams(r *http.Request) (OrgsGetAuditLogParams, error) {
	var params OrgsGetAuditLogParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("phrase")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'phrase': %w", err)
			}

			params.Phrase = v
		}
	}
	{
		param := r.URL.Query().Get("include")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'include': %w", err)
			}

			params.Include = v
		}
	}
	{
		param := r.URL.Query().Get("after")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'after': %w", err)
			}

			params.After = v
		}
	}
	{
		param := r.URL.Query().Get("before")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'before': %w", err)
			}

			params.Before = v
		}
	}
	{
		param := r.URL.Query().Get("order")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'order': %w", err)
			}

			params.Order = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsListBlockedUsersParams(r *http.Request) (OrgsListBlockedUsersParams, error) {
	var params OrgsListBlockedUsersParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeOrgsCheckBlockedUserParams(r *http.Request) (OrgsCheckBlockedUserParams, error) {
	var params OrgsCheckBlockedUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsBlockUserParams(r *http.Request) (OrgsBlockUserParams, error) {
	var params OrgsBlockUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsUnblockUserParams(r *http.Request) (OrgsUnblockUserParams, error) {
	var params OrgsUnblockUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsListSamlSSOAuthorizationsParams(r *http.Request) (OrgsListSamlSSOAuthorizationsParams, error) {
	var params OrgsListSamlSSOAuthorizationsParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeOrgsRemoveSamlSSOAuthorizationParams(r *http.Request) (OrgsRemoveSamlSSOAuthorizationParams, error) {
	var params OrgsRemoveSamlSSOAuthorizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "credential_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'credential_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'credential_id': %w", err)
		}

		params.CredentialID = v
	}

	return params, nil
}

func decodeActivityListPublicOrgEventsParams(r *http.Request) (ActivityListPublicOrgEventsParams, error) {
	var params ActivityListPublicOrgEventsParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsListFailedInvitationsParams(r *http.Request) (OrgsListFailedInvitationsParams, error) {
	var params OrgsListFailedInvitationsParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsListWebhooksParams(r *http.Request) (OrgsListWebhooksParams, error) {
	var params OrgsListWebhooksParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsCreateWebhookParams(r *http.Request) (OrgsCreateWebhookParams, error) {
	var params OrgsCreateWebhookParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeOrgsGetWebhookParams(r *http.Request) (OrgsGetWebhookParams, error) {
	var params OrgsGetWebhookParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeOrgsDeleteWebhookParams(r *http.Request) (OrgsDeleteWebhookParams, error) {
	var params OrgsDeleteWebhookParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeOrgsUpdateWebhookParams(r *http.Request) (OrgsUpdateWebhookParams, error) {
	var params OrgsUpdateWebhookParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeOrgsGetWebhookConfigForOrgParams(r *http.Request) (OrgsGetWebhookConfigForOrgParams, error) {
	var params OrgsGetWebhookConfigForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeOrgsUpdateWebhookConfigForOrgParams(r *http.Request) (OrgsUpdateWebhookConfigForOrgParams, error) {
	var params OrgsUpdateWebhookConfigForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeOrgsListWebhookDeliveriesParams(r *http.Request) (OrgsListWebhookDeliveriesParams, error) {
	var params OrgsListWebhookDeliveriesParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("cursor")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'cursor': %w", err)
			}

			params.Cursor = v
		}
	}

	return params, nil
}

func decodeOrgsGetWebhookDeliveryParams(r *http.Request) (OrgsGetWebhookDeliveryParams, error) {
	var params OrgsGetWebhookDeliveryParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}
	{
		param := chi.URLParam(r, "delivery_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'delivery_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'delivery_id': %w", err)
		}

		params.DeliveryID = v
	}

	return params, nil
}

func decodeOrgsRedeliverWebhookDeliveryParams(r *http.Request) (OrgsRedeliverWebhookDeliveryParams, error) {
	var params OrgsRedeliverWebhookDeliveryParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}
	{
		param := chi.URLParam(r, "delivery_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'delivery_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'delivery_id': %w", err)
		}

		params.DeliveryID = v
	}

	return params, nil
}

func decodeOrgsPingWebhookParams(r *http.Request) (OrgsPingWebhookParams, error) {
	var params OrgsPingWebhookParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeAppsGetOrgInstallationParams(r *http.Request) (AppsGetOrgInstallationParams, error) {
	var params AppsGetOrgInstallationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeOrgsListAppInstallationsParams(r *http.Request) (OrgsListAppInstallationsParams, error) {
	var params OrgsListAppInstallationsParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeInteractionsGetRestrictionsForOrgParams(r *http.Request) (InteractionsGetRestrictionsForOrgParams, error) {
	var params InteractionsGetRestrictionsForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeInteractionsSetRestrictionsForOrgParams(r *http.Request) (InteractionsSetRestrictionsForOrgParams, error) {
	var params InteractionsSetRestrictionsForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeInteractionsRemoveRestrictionsForOrgParams(r *http.Request) (InteractionsRemoveRestrictionsForOrgParams, error) {
	var params InteractionsRemoveRestrictionsForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeOrgsListPendingInvitationsParams(r *http.Request) (OrgsListPendingInvitationsParams, error) {
	var params OrgsListPendingInvitationsParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsCreateInvitationParams(r *http.Request) (OrgsCreateInvitationParams, error) {
	var params OrgsCreateInvitationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeOrgsCancelInvitationParams(r *http.Request) (OrgsCancelInvitationParams, error) {
	var params OrgsCancelInvitationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "invitation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'invitation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'invitation_id': %w", err)
		}

		params.InvitationID = v
	}

	return params, nil
}

func decodeOrgsListInvitationTeamsParams(r *http.Request) (OrgsListInvitationTeamsParams, error) {
	var params OrgsListInvitationTeamsParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "invitation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'invitation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'invitation_id': %w", err)
		}

		params.InvitationID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesListForOrgParams(r *http.Request) (IssuesListForOrgParams, error) {
	var params IssuesListForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("filter")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'filter': %w", err)
			}

			params.Filter = v
		}
	}
	{
		param := r.URL.Query().Get("state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'state': %w", err)
			}

			params.State = v
		}
	}
	{
		param := r.URL.Query().Get("labels")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'labels': %w", err)
			}

			params.Labels = v
		}
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsListMembersParams(r *http.Request) (OrgsListMembersParams, error) {
	var params OrgsListMembersParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("filter")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'filter': %w", err)
			}

			params.Filter = v
		}
	}
	{
		param := r.URL.Query().Get("role")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'role': %w", err)
			}

			params.Role = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsCheckMembershipForUserParams(r *http.Request) (OrgsCheckMembershipForUserParams, error) {
	var params OrgsCheckMembershipForUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsRemoveMemberParams(r *http.Request) (OrgsRemoveMemberParams, error) {
	var params OrgsRemoveMemberParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsGetMembershipForUserParams(r *http.Request) (OrgsGetMembershipForUserParams, error) {
	var params OrgsGetMembershipForUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsSetMembershipForUserParams(r *http.Request) (OrgsSetMembershipForUserParams, error) {
	var params OrgsSetMembershipForUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsRemoveMembershipForUserParams(r *http.Request) (OrgsRemoveMembershipForUserParams, error) {
	var params OrgsRemoveMembershipForUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeMigrationsListForOrgParams(r *http.Request) (MigrationsListForOrgParams, error) {
	var params MigrationsListForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("exclude")
		if len(param) > 0 {
			v, err := conv.ToStringArray(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'exclude': %w", err)
			}

			params.Exclude = v
		}
	}

	return params, nil
}

func decodeMigrationsStartForOrgParams(r *http.Request) (MigrationsStartForOrgParams, error) {
	var params MigrationsStartForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeMigrationsGetStatusForOrgParams(r *http.Request) (MigrationsGetStatusForOrgParams, error) {
	var params MigrationsGetStatusForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}
	{
		param := r.URL.Query().Get("exclude")
		if len(param) > 0 {
			v, err := conv.ToStringArray(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'exclude': %w", err)
			}

			params.Exclude = v
		}
	}

	return params, nil
}

func decodeMigrationsDownloadArchiveForOrgParams(r *http.Request) (MigrationsDownloadArchiveForOrgParams, error) {
	var params MigrationsDownloadArchiveForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}

	return params, nil
}

func decodeMigrationsDeleteArchiveForOrgParams(r *http.Request) (MigrationsDeleteArchiveForOrgParams, error) {
	var params MigrationsDeleteArchiveForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}

	return params, nil
}

func decodeMigrationsUnlockRepoForOrgParams(r *http.Request) (MigrationsUnlockRepoForOrgParams, error) {
	var params MigrationsUnlockRepoForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}
	{
		param := chi.URLParam(r, "repo_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo_name': %w", err)
		}

		params.RepoName = v
	}

	return params, nil
}

func decodeMigrationsListReposForOrgParams(r *http.Request) (MigrationsListReposForOrgParams, error) {
	var params MigrationsListReposForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsListOutsideCollaboratorsParams(r *http.Request) (OrgsListOutsideCollaboratorsParams, error) {
	var params OrgsListOutsideCollaboratorsParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("filter")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'filter': %w", err)
			}

			params.Filter = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsConvertMemberToOutsideCollaboratorParams(r *http.Request) (OrgsConvertMemberToOutsideCollaboratorParams, error) {
	var params OrgsConvertMemberToOutsideCollaboratorParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsRemoveOutsideCollaboratorParams(r *http.Request) (OrgsRemoveOutsideCollaboratorParams, error) {
	var params OrgsRemoveOutsideCollaboratorParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodePackagesListPackagesForOrganizationParams(r *http.Request) (PackagesListPackagesForOrganizationParams, error) {
	var params PackagesListPackagesForOrganizationParams
	{
		param := r.URL.Query().Get("package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("query param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse query param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("visibility")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'visibility': %w", err)
			}

			params.Visibility = v
		}
	}

	return params, nil
}

func decodePackagesGetPackageForOrganizationParams(r *http.Request) (PackagesGetPackageForOrganizationParams, error) {
	var params PackagesGetPackageForOrganizationParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodePackagesDeletePackageForOrgParams(r *http.Request) (PackagesDeletePackageForOrgParams, error) {
	var params PackagesDeletePackageForOrgParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodePackagesRestorePackageForOrgParams(r *http.Request) (PackagesRestorePackageForOrgParams, error) {
	var params PackagesRestorePackageForOrgParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("token")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'token': %w", err)
			}

			params.Token = v
		}
	}

	return params, nil
}

func decodePackagesGetAllPackageVersionsForPackageOwnedByOrgParams(r *http.Request) (PackagesGetAllPackageVersionsForPackageOwnedByOrgParams, error) {
	var params PackagesGetAllPackageVersionsForPackageOwnedByOrgParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'state': %w", err)
			}

			params.State = v
		}
	}

	return params, nil
}

func decodePackagesGetPackageVersionForOrganizationParams(r *http.Request) (PackagesGetPackageVersionForOrganizationParams, error) {
	var params PackagesGetPackageVersionForOrganizationParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "package_version_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_version_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_version_id': %w", err)
		}

		params.PackageVersionID = v
	}

	return params, nil
}

func decodePackagesDeletePackageVersionForOrgParams(r *http.Request) (PackagesDeletePackageVersionForOrgParams, error) {
	var params PackagesDeletePackageVersionForOrgParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "package_version_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_version_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_version_id': %w", err)
		}

		params.PackageVersionID = v
	}

	return params, nil
}

func decodePackagesRestorePackageVersionForOrgParams(r *http.Request) (PackagesRestorePackageVersionForOrgParams, error) {
	var params PackagesRestorePackageVersionForOrgParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "package_version_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_version_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_version_id': %w", err)
		}

		params.PackageVersionID = v
	}

	return params, nil
}

func decodeProjectsListForOrgParams(r *http.Request) (ProjectsListForOrgParams, error) {
	var params ProjectsListForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'state': %w", err)
			}

			params.State = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeProjectsCreateForOrgParams(r *http.Request) (ProjectsCreateForOrgParams, error) {
	var params ProjectsCreateForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeOrgsListPublicMembersParams(r *http.Request) (OrgsListPublicMembersParams, error) {
	var params OrgsListPublicMembersParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsCheckPublicMembershipForUserParams(r *http.Request) (OrgsCheckPublicMembershipForUserParams, error) {
	var params OrgsCheckPublicMembershipForUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsSetPublicMembershipForAuthenticatedUserParams(r *http.Request) (OrgsSetPublicMembershipForAuthenticatedUserParams, error) {
	var params OrgsSetPublicMembershipForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsRemovePublicMembershipForAuthenticatedUserParams(r *http.Request) (OrgsRemovePublicMembershipForAuthenticatedUserParams, error) {
	var params OrgsRemovePublicMembershipForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeReposListForOrgParams(r *http.Request) (ReposListForOrgParams, error) {
	var params ReposListForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("type")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'type': %w", err)
			}

			params.Type = v
		}
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposCreateInOrgParams(r *http.Request) (ReposCreateInOrgParams, error) {
	var params ReposCreateInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeSecretScanningListAlertsForOrgParams(r *http.Request) (SecretScanningListAlertsForOrgParams, error) {
	var params SecretScanningListAlertsForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'state': %w", err)
			}

			params.State = v
		}
	}
	{
		param := r.URL.Query().Get("secret_type")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'secret_type': %w", err)
			}

			params.SecretType = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}

	return params, nil
}

func decodeBillingGetGithubActionsBillingOrgParams(r *http.Request) (BillingGetGithubActionsBillingOrgParams, error) {
	var params BillingGetGithubActionsBillingOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeBillingGetGithubPackagesBillingOrgParams(r *http.Request) (BillingGetGithubPackagesBillingOrgParams, error) {
	var params BillingGetGithubPackagesBillingOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeBillingGetSharedStorageBillingOrgParams(r *http.Request) (BillingGetSharedStorageBillingOrgParams, error) {
	var params BillingGetSharedStorageBillingOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeTeamsListIdpGroupsForOrgParams(r *http.Request) (TeamsListIdpGroupsForOrgParams, error) {
	var params TeamsListIdpGroupsForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsListParams(r *http.Request) (TeamsListParams, error) {
	var params TeamsListParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsCreateParams(r *http.Request) (TeamsCreateParams, error) {
	var params TeamsCreateParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeTeamsGetByNameParams(r *http.Request) (TeamsGetByNameParams, error) {
	var params TeamsGetByNameParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}

	return params, nil
}

func decodeTeamsDeleteInOrgParams(r *http.Request) (TeamsDeleteInOrgParams, error) {
	var params TeamsDeleteInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}

	return params, nil
}

func decodeTeamsUpdateInOrgParams(r *http.Request) (TeamsUpdateInOrgParams, error) {
	var params TeamsUpdateInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}

	return params, nil
}

func decodeTeamsListDiscussionsInOrgParams(r *http.Request) (TeamsListDiscussionsInOrgParams, error) {
	var params TeamsListDiscussionsInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("pinned")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'pinned': %w", err)
			}

			params.Pinned = v
		}
	}

	return params, nil
}

func decodeTeamsCreateDiscussionInOrgParams(r *http.Request) (TeamsCreateDiscussionInOrgParams, error) {
	var params TeamsCreateDiscussionInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}

	return params, nil
}

func decodeTeamsGetDiscussionInOrgParams(r *http.Request) (TeamsGetDiscussionInOrgParams, error) {
	var params TeamsGetDiscussionInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsDeleteDiscussionInOrgParams(r *http.Request) (TeamsDeleteDiscussionInOrgParams, error) {
	var params TeamsDeleteDiscussionInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsUpdateDiscussionInOrgParams(r *http.Request) (TeamsUpdateDiscussionInOrgParams, error) {
	var params TeamsUpdateDiscussionInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsListDiscussionCommentsInOrgParams(r *http.Request) (TeamsListDiscussionCommentsInOrgParams, error) {
	var params TeamsListDiscussionCommentsInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsCreateDiscussionCommentInOrgParams(r *http.Request) (TeamsCreateDiscussionCommentInOrgParams, error) {
	var params TeamsCreateDiscussionCommentInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsGetDiscussionCommentInOrgParams(r *http.Request) (TeamsGetDiscussionCommentInOrgParams, error) {
	var params TeamsGetDiscussionCommentInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeTeamsDeleteDiscussionCommentInOrgParams(r *http.Request) (TeamsDeleteDiscussionCommentInOrgParams, error) {
	var params TeamsDeleteDiscussionCommentInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeTeamsUpdateDiscussionCommentInOrgParams(r *http.Request) (TeamsUpdateDiscussionCommentInOrgParams, error) {
	var params TeamsUpdateDiscussionCommentInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeReactionsListForTeamDiscussionCommentInOrgParams(r *http.Request) (ReactionsListForTeamDiscussionCommentInOrgParams, error) {
	var params ReactionsListForTeamDiscussionCommentInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}
	{
		param := r.URL.Query().Get("content")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'content': %w", err)
			}

			params.Content = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReactionsCreateForTeamDiscussionCommentInOrgParams(r *http.Request) (ReactionsCreateForTeamDiscussionCommentInOrgParams, error) {
	var params ReactionsCreateForTeamDiscussionCommentInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeReactionsDeleteForTeamDiscussionCommentParams(r *http.Request) (ReactionsDeleteForTeamDiscussionCommentParams, error) {
	var params ReactionsDeleteForTeamDiscussionCommentParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}
	{
		param := chi.URLParam(r, "reaction_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'reaction_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'reaction_id': %w", err)
		}

		params.ReactionID = v
	}

	return params, nil
}

func decodeReactionsListForTeamDiscussionInOrgParams(r *http.Request) (ReactionsListForTeamDiscussionInOrgParams, error) {
	var params ReactionsListForTeamDiscussionInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := r.URL.Query().Get("content")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'content': %w", err)
			}

			params.Content = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReactionsCreateForTeamDiscussionInOrgParams(r *http.Request) (ReactionsCreateForTeamDiscussionInOrgParams, error) {
	var params ReactionsCreateForTeamDiscussionInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeReactionsDeleteForTeamDiscussionParams(r *http.Request) (ReactionsDeleteForTeamDiscussionParams, error) {
	var params ReactionsDeleteForTeamDiscussionParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "reaction_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'reaction_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'reaction_id': %w", err)
		}

		params.ReactionID = v
	}

	return params, nil
}

func decodeTeamsListPendingInvitationsInOrgParams(r *http.Request) (TeamsListPendingInvitationsInOrgParams, error) {
	var params TeamsListPendingInvitationsInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsListMembersInOrgParams(r *http.Request) (TeamsListMembersInOrgParams, error) {
	var params TeamsListMembersInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := r.URL.Query().Get("role")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'role': %w", err)
			}

			params.Role = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsGetMembershipForUserInOrgParams(r *http.Request) (TeamsGetMembershipForUserInOrgParams, error) {
	var params TeamsGetMembershipForUserInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsAddOrUpdateMembershipForUserInOrgParams(r *http.Request) (TeamsAddOrUpdateMembershipForUserInOrgParams, error) {
	var params TeamsAddOrUpdateMembershipForUserInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsRemoveMembershipForUserInOrgParams(r *http.Request) (TeamsRemoveMembershipForUserInOrgParams, error) {
	var params TeamsRemoveMembershipForUserInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsListProjectsInOrgParams(r *http.Request) (TeamsListProjectsInOrgParams, error) {
	var params TeamsListProjectsInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsCheckPermissionsForProjectInOrgParams(r *http.Request) (TeamsCheckPermissionsForProjectInOrgParams, error) {
	var params TeamsCheckPermissionsForProjectInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeTeamsAddOrUpdateProjectPermissionsInOrgParams(r *http.Request) (TeamsAddOrUpdateProjectPermissionsInOrgParams, error) {
	var params TeamsAddOrUpdateProjectPermissionsInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeTeamsRemoveProjectInOrgParams(r *http.Request) (TeamsRemoveProjectInOrgParams, error) {
	var params TeamsRemoveProjectInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeTeamsListReposInOrgParams(r *http.Request) (TeamsListReposInOrgParams, error) {
	var params TeamsListReposInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsCheckPermissionsForRepoInOrgParams(r *http.Request) (TeamsCheckPermissionsForRepoInOrgParams, error) {
	var params TeamsCheckPermissionsForRepoInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeTeamsAddOrUpdateRepoPermissionsInOrgParams(r *http.Request) (TeamsAddOrUpdateRepoPermissionsInOrgParams, error) {
	var params TeamsAddOrUpdateRepoPermissionsInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeTeamsRemoveRepoInOrgParams(r *http.Request) (TeamsRemoveRepoInOrgParams, error) {
	var params TeamsRemoveRepoInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeTeamsListIdpGroupsInOrgParams(r *http.Request) (TeamsListIdpGroupsInOrgParams, error) {
	var params TeamsListIdpGroupsInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}

	return params, nil
}

func decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams(r *http.Request) (TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams, error) {
	var params TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}

	return params, nil
}

func decodeTeamsListChildInOrgParams(r *http.Request) (TeamsListChildInOrgParams, error) {
	var params TeamsListChildInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeProjectsGetCardParams(r *http.Request) (ProjectsGetCardParams, error) {
	var params ProjectsGetCardParams
	{
		param := chi.URLParam(r, "card_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'card_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'card_id': %w", err)
		}

		params.CardID = v
	}

	return params, nil
}

func decodeProjectsDeleteCardParams(r *http.Request) (ProjectsDeleteCardParams, error) {
	var params ProjectsDeleteCardParams
	{
		param := chi.URLParam(r, "card_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'card_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'card_id': %w", err)
		}

		params.CardID = v
	}

	return params, nil
}

func decodeProjectsUpdateCardParams(r *http.Request) (ProjectsUpdateCardParams, error) {
	var params ProjectsUpdateCardParams
	{
		param := chi.URLParam(r, "card_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'card_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'card_id': %w", err)
		}

		params.CardID = v
	}

	return params, nil
}

func decodeProjectsMoveCardParams(r *http.Request) (ProjectsMoveCardParams, error) {
	var params ProjectsMoveCardParams
	{
		param := chi.URLParam(r, "card_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'card_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'card_id': %w", err)
		}

		params.CardID = v
	}

	return params, nil
}

func decodeProjectsGetColumnParams(r *http.Request) (ProjectsGetColumnParams, error) {
	var params ProjectsGetColumnParams
	{
		param := chi.URLParam(r, "column_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'column_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'column_id': %w", err)
		}

		params.ColumnID = v
	}

	return params, nil
}

func decodeProjectsDeleteColumnParams(r *http.Request) (ProjectsDeleteColumnParams, error) {
	var params ProjectsDeleteColumnParams
	{
		param := chi.URLParam(r, "column_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'column_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'column_id': %w", err)
		}

		params.ColumnID = v
	}

	return params, nil
}

func decodeProjectsUpdateColumnParams(r *http.Request) (ProjectsUpdateColumnParams, error) {
	var params ProjectsUpdateColumnParams
	{
		param := chi.URLParam(r, "column_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'column_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'column_id': %w", err)
		}

		params.ColumnID = v
	}

	return params, nil
}

func decodeProjectsListCardsParams(r *http.Request) (ProjectsListCardsParams, error) {
	var params ProjectsListCardsParams
	{
		param := chi.URLParam(r, "column_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'column_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'column_id': %w", err)
		}

		params.ColumnID = v
	}
	{
		param := r.URL.Query().Get("archived_state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'archived_state': %w", err)
			}

			params.ArchivedState = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeProjectsCreateCardParams(r *http.Request) (ProjectsCreateCardParams, error) {
	var params ProjectsCreateCardParams
	{
		param := chi.URLParam(r, "column_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'column_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'column_id': %w", err)
		}

		params.ColumnID = v
	}

	return params, nil
}

func decodeProjectsMoveColumnParams(r *http.Request) (ProjectsMoveColumnParams, error) {
	var params ProjectsMoveColumnParams
	{
		param := chi.URLParam(r, "column_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'column_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'column_id': %w", err)
		}

		params.ColumnID = v
	}

	return params, nil
}

func decodeProjectsGetParams(r *http.Request) (ProjectsGetParams, error) {
	var params ProjectsGetParams
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeProjectsDeleteParams(r *http.Request) (ProjectsDeleteParams, error) {
	var params ProjectsDeleteParams
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeProjectsUpdateParams(r *http.Request) (ProjectsUpdateParams, error) {
	var params ProjectsUpdateParams
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeProjectsListCollaboratorsParams(r *http.Request) (ProjectsListCollaboratorsParams, error) {
	var params ProjectsListCollaboratorsParams
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}
	{
		param := r.URL.Query().Get("affiliation")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'affiliation': %w", err)
			}

			params.Affiliation = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeProjectsAddCollaboratorParams(r *http.Request) (ProjectsAddCollaboratorParams, error) {
	var params ProjectsAddCollaboratorParams
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeProjectsRemoveCollaboratorParams(r *http.Request) (ProjectsRemoveCollaboratorParams, error) {
	var params ProjectsRemoveCollaboratorParams
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeProjectsGetPermissionForUserParams(r *http.Request) (ProjectsGetPermissionForUserParams, error) {
	var params ProjectsGetPermissionForUserParams
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeProjectsListColumnsParams(r *http.Request) (ProjectsListColumnsParams, error) {
	var params ProjectsListColumnsParams
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeProjectsCreateColumnParams(r *http.Request) (ProjectsCreateColumnParams, error) {
	var params ProjectsCreateColumnParams
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeReactionsDeleteLegacyParams(r *http.Request) (ReactionsDeleteLegacyParams, error) {
	var params ReactionsDeleteLegacyParams
	{
		param := chi.URLParam(r, "reaction_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'reaction_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'reaction_id': %w", err)
		}

		params.ReactionID = v
	}

	return params, nil
}

func decodeReposGetParams(r *http.Request) (ReposGetParams, error) {
	var params ReposGetParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposDeleteParams(r *http.Request) (ReposDeleteParams, error) {
	var params ReposDeleteParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposUpdateParams(r *http.Request) (ReposUpdateParams, error) {
	var params ReposUpdateParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsListArtifactsForRepoParams(r *http.Request) (ActionsListArtifactsForRepoParams, error) {
	var params ActionsListArtifactsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsGetArtifactParams(r *http.Request) (ActionsGetArtifactParams, error) {
	var params ActionsGetArtifactParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "artifact_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'artifact_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'artifact_id': %w", err)
		}

		params.ArtifactID = v
	}

	return params, nil
}

func decodeActionsDeleteArtifactParams(r *http.Request) (ActionsDeleteArtifactParams, error) {
	var params ActionsDeleteArtifactParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "artifact_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'artifact_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'artifact_id': %w", err)
		}

		params.ArtifactID = v
	}

	return params, nil
}

func decodeActionsDownloadArtifactParams(r *http.Request) (ActionsDownloadArtifactParams, error) {
	var params ActionsDownloadArtifactParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "artifact_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'artifact_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'artifact_id': %w", err)
		}

		params.ArtifactID = v
	}
	{
		param := chi.URLParam(r, "archive_format")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'archive_format' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'archive_format': %w", err)
		}

		params.ArchiveFormat = v
	}

	return params, nil
}

func decodeActionsGetJobForWorkflowRunParams(r *http.Request) (ActionsGetJobForWorkflowRunParams, error) {
	var params ActionsGetJobForWorkflowRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "job_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'job_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'job_id': %w", err)
		}

		params.JobID = v
	}

	return params, nil
}

func decodeActionsDownloadJobLogsForWorkflowRunParams(r *http.Request) (ActionsDownloadJobLogsForWorkflowRunParams, error) {
	var params ActionsDownloadJobLogsForWorkflowRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "job_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'job_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'job_id': %w", err)
		}

		params.JobID = v
	}

	return params, nil
}

func decodeActionsGetGithubActionsPermissionsRepositoryParams(r *http.Request) (ActionsGetGithubActionsPermissionsRepositoryParams, error) {
	var params ActionsGetGithubActionsPermissionsRepositoryParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsSetGithubActionsPermissionsRepositoryParams(r *http.Request) (ActionsSetGithubActionsPermissionsRepositoryParams, error) {
	var params ActionsSetGithubActionsPermissionsRepositoryParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsGetAllowedActionsRepositoryParams(r *http.Request) (ActionsGetAllowedActionsRepositoryParams, error) {
	var params ActionsGetAllowedActionsRepositoryParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsSetAllowedActionsRepositoryParams(r *http.Request) (ActionsSetAllowedActionsRepositoryParams, error) {
	var params ActionsSetAllowedActionsRepositoryParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsListSelfHostedRunnersForRepoParams(r *http.Request) (ActionsListSelfHostedRunnersForRepoParams, error) {
	var params ActionsListSelfHostedRunnersForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsListRunnerApplicationsForRepoParams(r *http.Request) (ActionsListRunnerApplicationsForRepoParams, error) {
	var params ActionsListRunnerApplicationsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsCreateRegistrationTokenForRepoParams(r *http.Request) (ActionsCreateRegistrationTokenForRepoParams, error) {
	var params ActionsCreateRegistrationTokenForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsCreateRemoveTokenForRepoParams(r *http.Request) (ActionsCreateRemoveTokenForRepoParams, error) {
	var params ActionsCreateRemoveTokenForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsGetSelfHostedRunnerForRepoParams(r *http.Request) (ActionsGetSelfHostedRunnerForRepoParams, error) {
	var params ActionsGetSelfHostedRunnerForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeActionsDeleteSelfHostedRunnerFromRepoParams(r *http.Request) (ActionsDeleteSelfHostedRunnerFromRepoParams, error) {
	var params ActionsDeleteSelfHostedRunnerFromRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeActionsListWorkflowRunsForRepoParams(r *http.Request) (ActionsListWorkflowRunsForRepoParams, error) {
	var params ActionsListWorkflowRunsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("actor")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'actor': %w", err)
			}

			params.Actor = v
		}
	}
	{
		param := r.URL.Query().Get("branch")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'branch': %w", err)
			}

			params.Branch = v
		}
	}
	{
		param := r.URL.Query().Get("event")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'event': %w", err)
			}

			params.Event = v
		}
	}
	{
		param := r.URL.Query().Get("status")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'status': %w", err)
			}

			params.Status = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("created")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'created': %w", err)
			}

			params.Created = v
		}
	}

	return params, nil
}

func decodeActionsGetWorkflowRunParams(r *http.Request) (ActionsGetWorkflowRunParams, error) {
	var params ActionsGetWorkflowRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsDeleteWorkflowRunParams(r *http.Request) (ActionsDeleteWorkflowRunParams, error) {
	var params ActionsDeleteWorkflowRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsGetReviewsForRunParams(r *http.Request) (ActionsGetReviewsForRunParams, error) {
	var params ActionsGetReviewsForRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsApproveWorkflowRunParams(r *http.Request) (ActionsApproveWorkflowRunParams, error) {
	var params ActionsApproveWorkflowRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsListWorkflowRunArtifactsParams(r *http.Request) (ActionsListWorkflowRunArtifactsParams, error) {
	var params ActionsListWorkflowRunArtifactsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsCancelWorkflowRunParams(r *http.Request) (ActionsCancelWorkflowRunParams, error) {
	var params ActionsCancelWorkflowRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsListJobsForWorkflowRunParams(r *http.Request) (ActionsListJobsForWorkflowRunParams, error) {
	var params ActionsListJobsForWorkflowRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}
	{
		param := r.URL.Query().Get("filter")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'filter': %w", err)
			}

			params.Filter = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsDownloadWorkflowRunLogsParams(r *http.Request) (ActionsDownloadWorkflowRunLogsParams, error) {
	var params ActionsDownloadWorkflowRunLogsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsDeleteWorkflowRunLogsParams(r *http.Request) (ActionsDeleteWorkflowRunLogsParams, error) {
	var params ActionsDeleteWorkflowRunLogsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsGetPendingDeploymentsForRunParams(r *http.Request) (ActionsGetPendingDeploymentsForRunParams, error) {
	var params ActionsGetPendingDeploymentsForRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsReviewPendingDeploymentsForRunParams(r *http.Request) (ActionsReviewPendingDeploymentsForRunParams, error) {
	var params ActionsReviewPendingDeploymentsForRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsReRunWorkflowParams(r *http.Request) (ActionsReRunWorkflowParams, error) {
	var params ActionsReRunWorkflowParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsRetryWorkflowParams(r *http.Request) (ActionsRetryWorkflowParams, error) {
	var params ActionsRetryWorkflowParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsGetWorkflowRunUsageParams(r *http.Request) (ActionsGetWorkflowRunUsageParams, error) {
	var params ActionsGetWorkflowRunUsageParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsListRepoSecretsParams(r *http.Request) (ActionsListRepoSecretsParams, error) {
	var params ActionsListRepoSecretsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsGetRepoPublicKeyParams(r *http.Request) (ActionsGetRepoPublicKeyParams, error) {
	var params ActionsGetRepoPublicKeyParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsGetRepoSecretParams(r *http.Request) (ActionsGetRepoSecretParams, error) {
	var params ActionsGetRepoSecretParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsCreateOrUpdateRepoSecretParams(r *http.Request) (ActionsCreateOrUpdateRepoSecretParams, error) {
	var params ActionsCreateOrUpdateRepoSecretParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsDeleteRepoSecretParams(r *http.Request) (ActionsDeleteRepoSecretParams, error) {
	var params ActionsDeleteRepoSecretParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsListRepoWorkflowsParams(r *http.Request) (ActionsListRepoWorkflowsParams, error) {
	var params ActionsListRepoWorkflowsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesListAssigneesParams(r *http.Request) (IssuesListAssigneesParams, error) {
	var params IssuesListAssigneesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesCheckUserCanBeAssignedParams(r *http.Request) (IssuesCheckUserCanBeAssignedParams, error) {
	var params IssuesCheckUserCanBeAssignedParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "assignee")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'assignee' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'assignee': %w", err)
		}

		params.Assignee = v
	}

	return params, nil
}

func decodeReposListAutolinksParams(r *http.Request) (ReposListAutolinksParams, error) {
	var params ReposListAutolinksParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposCreateAutolinkParams(r *http.Request) (ReposCreateAutolinkParams, error) {
	var params ReposCreateAutolinkParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetAutolinkParams(r *http.Request) (ReposGetAutolinkParams, error) {
	var params ReposGetAutolinkParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "autolink_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'autolink_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'autolink_id': %w", err)
		}

		params.AutolinkID = v
	}

	return params, nil
}

func decodeReposDeleteAutolinkParams(r *http.Request) (ReposDeleteAutolinkParams, error) {
	var params ReposDeleteAutolinkParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "autolink_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'autolink_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'autolink_id': %w", err)
		}

		params.AutolinkID = v
	}

	return params, nil
}

func decodeReposEnableAutomatedSecurityFixesParams(r *http.Request) (ReposEnableAutomatedSecurityFixesParams, error) {
	var params ReposEnableAutomatedSecurityFixesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposDisableAutomatedSecurityFixesParams(r *http.Request) (ReposDisableAutomatedSecurityFixesParams, error) {
	var params ReposDisableAutomatedSecurityFixesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposListBranchesParams(r *http.Request) (ReposListBranchesParams, error) {
	var params ReposListBranchesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("protected")
		if len(param) > 0 {
			v, err := conv.ToBool(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'protected': %w", err)
			}

			params.Protected = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetBranchParams(r *http.Request) (ReposGetBranchParams, error) {
	var params ReposGetBranchParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetBranchProtectionParams(r *http.Request) (ReposGetBranchProtectionParams, error) {
	var params ReposGetBranchProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposUpdateBranchProtectionParams(r *http.Request) (ReposUpdateBranchProtectionParams, error) {
	var params ReposUpdateBranchProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposDeleteBranchProtectionParams(r *http.Request) (ReposDeleteBranchProtectionParams, error) {
	var params ReposDeleteBranchProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetAdminBranchProtectionParams(r *http.Request) (ReposGetAdminBranchProtectionParams, error) {
	var params ReposGetAdminBranchProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposSetAdminBranchProtectionParams(r *http.Request) (ReposSetAdminBranchProtectionParams, error) {
	var params ReposSetAdminBranchProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposDeleteAdminBranchProtectionParams(r *http.Request) (ReposDeleteAdminBranchProtectionParams, error) {
	var params ReposDeleteAdminBranchProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetPullRequestReviewProtectionParams(r *http.Request) (ReposGetPullRequestReviewProtectionParams, error) {
	var params ReposGetPullRequestReviewProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposDeletePullRequestReviewProtectionParams(r *http.Request) (ReposDeletePullRequestReviewProtectionParams, error) {
	var params ReposDeletePullRequestReviewProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposUpdatePullRequestReviewProtectionParams(r *http.Request) (ReposUpdatePullRequestReviewProtectionParams, error) {
	var params ReposUpdatePullRequestReviewProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetCommitSignatureProtectionParams(r *http.Request) (ReposGetCommitSignatureProtectionParams, error) {
	var params ReposGetCommitSignatureProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposCreateCommitSignatureProtectionParams(r *http.Request) (ReposCreateCommitSignatureProtectionParams, error) {
	var params ReposCreateCommitSignatureProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposDeleteCommitSignatureProtectionParams(r *http.Request) (ReposDeleteCommitSignatureProtectionParams, error) {
	var params ReposDeleteCommitSignatureProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetStatusChecksProtectionParams(r *http.Request) (ReposGetStatusChecksProtectionParams, error) {
	var params ReposGetStatusChecksProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposRemoveStatusCheckProtectionParams(r *http.Request) (ReposRemoveStatusCheckProtectionParams, error) {
	var params ReposRemoveStatusCheckProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposUpdateStatusCheckProtectionParams(r *http.Request) (ReposUpdateStatusCheckProtectionParams, error) {
	var params ReposUpdateStatusCheckProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetAllStatusCheckContextsParams(r *http.Request) (ReposGetAllStatusCheckContextsParams, error) {
	var params ReposGetAllStatusCheckContextsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposSetStatusCheckContextsParams(r *http.Request) (ReposSetStatusCheckContextsParams, error) {
	var params ReposSetStatusCheckContextsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposAddStatusCheckContextsParams(r *http.Request) (ReposAddStatusCheckContextsParams, error) {
	var params ReposAddStatusCheckContextsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposRemoveStatusCheckContextsParams(r *http.Request) (ReposRemoveStatusCheckContextsParams, error) {
	var params ReposRemoveStatusCheckContextsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetAccessRestrictionsParams(r *http.Request) (ReposGetAccessRestrictionsParams, error) {
	var params ReposGetAccessRestrictionsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposDeleteAccessRestrictionsParams(r *http.Request) (ReposDeleteAccessRestrictionsParams, error) {
	var params ReposDeleteAccessRestrictionsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetAppsWithAccessToProtectedBranchParams(r *http.Request) (ReposGetAppsWithAccessToProtectedBranchParams, error) {
	var params ReposGetAppsWithAccessToProtectedBranchParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposSetAppAccessRestrictionsParams(r *http.Request) (ReposSetAppAccessRestrictionsParams, error) {
	var params ReposSetAppAccessRestrictionsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposAddAppAccessRestrictionsParams(r *http.Request) (ReposAddAppAccessRestrictionsParams, error) {
	var params ReposAddAppAccessRestrictionsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposRemoveAppAccessRestrictionsParams(r *http.Request) (ReposRemoveAppAccessRestrictionsParams, error) {
	var params ReposRemoveAppAccessRestrictionsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetTeamsWithAccessToProtectedBranchParams(r *http.Request) (ReposGetTeamsWithAccessToProtectedBranchParams, error) {
	var params ReposGetTeamsWithAccessToProtectedBranchParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposSetTeamAccessRestrictionsParams(r *http.Request) (ReposSetTeamAccessRestrictionsParams, error) {
	var params ReposSetTeamAccessRestrictionsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposAddTeamAccessRestrictionsParams(r *http.Request) (ReposAddTeamAccessRestrictionsParams, error) {
	var params ReposAddTeamAccessRestrictionsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposRemoveTeamAccessRestrictionsParams(r *http.Request) (ReposRemoveTeamAccessRestrictionsParams, error) {
	var params ReposRemoveTeamAccessRestrictionsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetUsersWithAccessToProtectedBranchParams(r *http.Request) (ReposGetUsersWithAccessToProtectedBranchParams, error) {
	var params ReposGetUsersWithAccessToProtectedBranchParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposSetUserAccessRestrictionsParams(r *http.Request) (ReposSetUserAccessRestrictionsParams, error) {
	var params ReposSetUserAccessRestrictionsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposAddUserAccessRestrictionsParams(r *http.Request) (ReposAddUserAccessRestrictionsParams, error) {
	var params ReposAddUserAccessRestrictionsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposRemoveUserAccessRestrictionsParams(r *http.Request) (ReposRemoveUserAccessRestrictionsParams, error) {
	var params ReposRemoveUserAccessRestrictionsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposRenameBranchParams(r *http.Request) (ReposRenameBranchParams, error) {
	var params ReposRenameBranchParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeChecksCreateParams(r *http.Request) (ChecksCreateParams, error) {
	var params ChecksCreateParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeChecksGetParams(r *http.Request) (ChecksGetParams, error) {
	var params ChecksGetParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "check_run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'check_run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'check_run_id': %w", err)
		}

		params.CheckRunID = v
	}

	return params, nil
}

func decodeChecksUpdateParams(r *http.Request) (ChecksUpdateParams, error) {
	var params ChecksUpdateParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "check_run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'check_run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'check_run_id': %w", err)
		}

		params.CheckRunID = v
	}

	return params, nil
}

func decodeChecksListAnnotationsParams(r *http.Request) (ChecksListAnnotationsParams, error) {
	var params ChecksListAnnotationsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "check_run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'check_run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'check_run_id': %w", err)
		}

		params.CheckRunID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeChecksCreateSuiteParams(r *http.Request) (ChecksCreateSuiteParams, error) {
	var params ChecksCreateSuiteParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeChecksSetSuitesPreferencesParams(r *http.Request) (ChecksSetSuitesPreferencesParams, error) {
	var params ChecksSetSuitesPreferencesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeChecksGetSuiteParams(r *http.Request) (ChecksGetSuiteParams, error) {
	var params ChecksGetSuiteParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "check_suite_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'check_suite_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'check_suite_id': %w", err)
		}

		params.CheckSuiteID = v
	}

	return params, nil
}

func decodeChecksListForSuiteParams(r *http.Request) (ChecksListForSuiteParams, error) {
	var params ChecksListForSuiteParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "check_suite_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'check_suite_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'check_suite_id': %w", err)
		}

		params.CheckSuiteID = v
	}
	{
		param := r.URL.Query().Get("check_name")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'check_name': %w", err)
			}

			params.CheckName = v
		}
	}
	{
		param := r.URL.Query().Get("status")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'status': %w", err)
			}

			params.Status = v
		}
	}
	{
		param := r.URL.Query().Get("filter")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'filter': %w", err)
			}

			params.Filter = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeChecksRerequestSuiteParams(r *http.Request) (ChecksRerequestSuiteParams, error) {
	var params ChecksRerequestSuiteParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "check_suite_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'check_suite_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'check_suite_id': %w", err)
		}

		params.CheckSuiteID = v
	}

	return params, nil
}

func decodeCodeScanningListAlertsForRepoParams(r *http.Request) (CodeScanningListAlertsForRepoParams, error) {
	var params CodeScanningListAlertsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("tool_name")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'tool_name': %w", err)
			}

			params.ToolName = v
		}
	}
	{
		param := r.URL.Query().Get("tool_guid")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'tool_guid': %w", err)
			}

			params.ToolGUID = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("ref")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'ref': %w", err)
			}

			params.Ref = v
		}
	}
	{
		param := r.URL.Query().Get("state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'state': %w", err)
			}

			params.State = v
		}
	}

	return params, nil
}

func decodeCodeScanningGetAlertParams(r *http.Request) (CodeScanningGetAlertParams, error) {
	var params CodeScanningGetAlertParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "alert_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'alert_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'alert_number': %w", err)
		}

		params.AlertNumber = v
	}

	return params, nil
}

func decodeCodeScanningUpdateAlertParams(r *http.Request) (CodeScanningUpdateAlertParams, error) {
	var params CodeScanningUpdateAlertParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "alert_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'alert_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'alert_number': %w", err)
		}

		params.AlertNumber = v
	}

	return params, nil
}

func decodeCodeScanningListAlertInstancesParams(r *http.Request) (CodeScanningListAlertInstancesParams, error) {
	var params CodeScanningListAlertInstancesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "alert_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'alert_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'alert_number': %w", err)
		}

		params.AlertNumber = v
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("ref")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'ref': %w", err)
			}

			params.Ref = v
		}
	}

	return params, nil
}

func decodeCodeScanningListRecentAnalysesParams(r *http.Request) (CodeScanningListRecentAnalysesParams, error) {
	var params CodeScanningListRecentAnalysesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("tool_name")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'tool_name': %w", err)
			}

			params.ToolName = v
		}
	}
	{
		param := r.URL.Query().Get("tool_guid")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'tool_guid': %w", err)
			}

			params.ToolGUID = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("ref")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'ref': %w", err)
			}

			params.Ref = v
		}
	}
	{
		param := r.URL.Query().Get("sarif_id")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sarif_id': %w", err)
			}

			params.SarifID = v
		}
	}

	return params, nil
}

func decodeCodeScanningGetAnalysisParams(r *http.Request) (CodeScanningGetAnalysisParams, error) {
	var params CodeScanningGetAnalysisParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "analysis_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'analysis_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'analysis_id': %w", err)
		}

		params.AnalysisID = v
	}

	return params, nil
}

func decodeCodeScanningDeleteAnalysisParams(r *http.Request) (CodeScanningDeleteAnalysisParams, error) {
	var params CodeScanningDeleteAnalysisParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "analysis_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'analysis_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'analysis_id': %w", err)
		}

		params.AnalysisID = v
	}
	{
		param := r.URL.Query().Get("confirm_delete")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'confirm_delete': %w", err)
			}

			params.ConfirmDelete = v
		}
	}

	return params, nil
}

func decodeCodeScanningUploadSarifParams(r *http.Request) (CodeScanningUploadSarifParams, error) {
	var params CodeScanningUploadSarifParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeCodeScanningGetSarifParams(r *http.Request) (CodeScanningGetSarifParams, error) {
	var params CodeScanningGetSarifParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "sarif_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'sarif_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'sarif_id': %w", err)
		}

		params.SarifID = v
	}

	return params, nil
}

func decodeReposListCollaboratorsParams(r *http.Request) (ReposListCollaboratorsParams, error) {
	var params ReposListCollaboratorsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("affiliation")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'affiliation': %w", err)
			}

			params.Affiliation = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposCheckCollaboratorParams(r *http.Request) (ReposCheckCollaboratorParams, error) {
	var params ReposCheckCollaboratorParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeReposAddCollaboratorParams(r *http.Request) (ReposAddCollaboratorParams, error) {
	var params ReposAddCollaboratorParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeReposRemoveCollaboratorParams(r *http.Request) (ReposRemoveCollaboratorParams, error) {
	var params ReposRemoveCollaboratorParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeReposGetCollaboratorPermissionLevelParams(r *http.Request) (ReposGetCollaboratorPermissionLevelParams, error) {
	var params ReposGetCollaboratorPermissionLevelParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeReposListCommitCommentsForRepoParams(r *http.Request) (ReposListCommitCommentsForRepoParams, error) {
	var params ReposListCommitCommentsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetCommitCommentParams(r *http.Request) (ReposGetCommitCommentParams, error) {
	var params ReposGetCommitCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeReposDeleteCommitCommentParams(r *http.Request) (ReposDeleteCommitCommentParams, error) {
	var params ReposDeleteCommitCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeReposUpdateCommitCommentParams(r *http.Request) (ReposUpdateCommitCommentParams, error) {
	var params ReposUpdateCommitCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeReactionsListForCommitCommentParams(r *http.Request) (ReactionsListForCommitCommentParams, error) {
	var params ReactionsListForCommitCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}
	{
		param := r.URL.Query().Get("content")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'content': %w", err)
			}

			params.Content = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReactionsCreateForCommitCommentParams(r *http.Request) (ReactionsCreateForCommitCommentParams, error) {
	var params ReactionsCreateForCommitCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeReactionsDeleteForCommitCommentParams(r *http.Request) (ReactionsDeleteForCommitCommentParams, error) {
	var params ReactionsDeleteForCommitCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}
	{
		param := chi.URLParam(r, "reaction_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'reaction_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'reaction_id': %w", err)
		}

		params.ReactionID = v
	}

	return params, nil
}

func decodeReposListCommitsParams(r *http.Request) (ReposListCommitsParams, error) {
	var params ReposListCommitsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("sha")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sha': %w", err)
			}

			params.Sha = v
		}
	}
	{
		param := r.URL.Query().Get("path")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'path': %w", err)
			}

			params.Path = v
		}
	}
	{
		param := r.URL.Query().Get("author")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'author': %w", err)
			}

			params.Author = v
		}
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("until")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'until': %w", err)
			}

			params.Until = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposListBranchesForHeadCommitParams(r *http.Request) (ReposListBranchesForHeadCommitParams, error) {
	var params ReposListBranchesForHeadCommitParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "commit_sha")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'commit_sha' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'commit_sha': %w", err)
		}

		params.CommitSha = v
	}

	return params, nil
}

func decodeReposListCommentsForCommitParams(r *http.Request) (ReposListCommentsForCommitParams, error) {
	var params ReposListCommentsForCommitParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "commit_sha")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'commit_sha' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'commit_sha': %w", err)
		}

		params.CommitSha = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposCreateCommitCommentParams(r *http.Request) (ReposCreateCommitCommentParams, error) {
	var params ReposCreateCommitCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "commit_sha")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'commit_sha' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'commit_sha': %w", err)
		}

		params.CommitSha = v
	}

	return params, nil
}

func decodeReposListPullRequestsAssociatedWithCommitParams(r *http.Request) (ReposListPullRequestsAssociatedWithCommitParams, error) {
	var params ReposListPullRequestsAssociatedWithCommitParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "commit_sha")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'commit_sha' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'commit_sha': %w", err)
		}

		params.CommitSha = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetCommitParams(r *http.Request) (ReposGetCommitParams, error) {
	var params ReposGetCommitParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}

	return params, nil
}

func decodeChecksListForRefParams(r *http.Request) (ChecksListForRefParams, error) {
	var params ChecksListForRefParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}
	{
		param := r.URL.Query().Get("check_name")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'check_name': %w", err)
			}

			params.CheckName = v
		}
	}
	{
		param := r.URL.Query().Get("status")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'status': %w", err)
			}

			params.Status = v
		}
	}
	{
		param := r.URL.Query().Get("filter")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'filter': %w", err)
			}

			params.Filter = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("app_id")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'app_id': %w", err)
			}

			params.AppID = v
		}
	}

	return params, nil
}

func decodeChecksListSuitesForRefParams(r *http.Request) (ChecksListSuitesForRefParams, error) {
	var params ChecksListSuitesForRefParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}
	{
		param := r.URL.Query().Get("app_id")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'app_id': %w", err)
			}

			params.AppID = v
		}
	}
	{
		param := r.URL.Query().Get("check_name")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'check_name': %w", err)
			}

			params.CheckName = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetCombinedStatusForRefParams(r *http.Request) (ReposGetCombinedStatusForRefParams, error) {
	var params ReposGetCombinedStatusForRefParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposListCommitStatusesForRefParams(r *http.Request) (ReposListCommitStatusesForRefParams, error) {
	var params ReposListCommitStatusesForRefParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetCommunityProfileMetricsParams(r *http.Request) (ReposGetCommunityProfileMetricsParams, error) {
	var params ReposGetCommunityProfileMetricsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposCompareCommitsParams(r *http.Request) (ReposCompareCommitsParams, error) {
	var params ReposCompareCommitsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := chi.URLParam(r, "basehead")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'basehead' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'basehead': %w", err)
		}

		params.Basehead = v
	}

	return params, nil
}

func decodeAppsCreateContentAttachmentParams(r *http.Request) (AppsCreateContentAttachmentParams, error) {
	var params AppsCreateContentAttachmentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "content_reference_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'content_reference_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'content_reference_id': %w", err)
		}

		params.ContentReferenceID = v
	}

	return params, nil
}

func decodeReposGetContentParams(r *http.Request) (ReposGetContentParams, error) {
	var params ReposGetContentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "path")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'path' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'path': %w", err)
		}

		params.Path = v
	}
	{
		param := r.URL.Query().Get("ref")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'ref': %w", err)
			}

			params.Ref = v
		}
	}

	return params, nil
}

func decodeReposCreateOrUpdateFileContentsParams(r *http.Request) (ReposCreateOrUpdateFileContentsParams, error) {
	var params ReposCreateOrUpdateFileContentsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "path")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'path' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'path': %w", err)
		}

		params.Path = v
	}

	return params, nil
}

func decodeReposDeleteFileParams(r *http.Request) (ReposDeleteFileParams, error) {
	var params ReposDeleteFileParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "path")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'path' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'path': %w", err)
		}

		params.Path = v
	}

	return params, nil
}

func decodeReposListContributorsParams(r *http.Request) (ReposListContributorsParams, error) {
	var params ReposListContributorsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("anon")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'anon': %w", err)
			}

			params.Anon = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposListDeploymentsParams(r *http.Request) (ReposListDeploymentsParams, error) {
	var params ReposListDeploymentsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("sha")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sha': %w", err)
			}

			params.Sha = v
		}
	}
	{
		param := r.URL.Query().Get("ref")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'ref': %w", err)
			}

			params.Ref = v
		}
	}
	{
		param := r.URL.Query().Get("task")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'task': %w", err)
			}

			params.Task = v
		}
	}
	{
		param := r.URL.Query().Get("environment")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'environment': %w", err)
			}

			params.Environment = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposCreateDeploymentParams(r *http.Request) (ReposCreateDeploymentParams, error) {
	var params ReposCreateDeploymentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetDeploymentParams(r *http.Request) (ReposGetDeploymentParams, error) {
	var params ReposGetDeploymentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "deployment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'deployment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'deployment_id': %w", err)
		}

		params.DeploymentID = v
	}

	return params, nil
}

func decodeReposDeleteDeploymentParams(r *http.Request) (ReposDeleteDeploymentParams, error) {
	var params ReposDeleteDeploymentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "deployment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'deployment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'deployment_id': %w", err)
		}

		params.DeploymentID = v
	}

	return params, nil
}

func decodeReposListDeploymentStatusesParams(r *http.Request) (ReposListDeploymentStatusesParams, error) {
	var params ReposListDeploymentStatusesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "deployment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'deployment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'deployment_id': %w", err)
		}

		params.DeploymentID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposCreateDeploymentStatusParams(r *http.Request) (ReposCreateDeploymentStatusParams, error) {
	var params ReposCreateDeploymentStatusParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "deployment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'deployment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'deployment_id': %w", err)
		}

		params.DeploymentID = v
	}

	return params, nil
}

func decodeReposGetDeploymentStatusParams(r *http.Request) (ReposGetDeploymentStatusParams, error) {
	var params ReposGetDeploymentStatusParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "deployment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'deployment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'deployment_id': %w", err)
		}

		params.DeploymentID = v
	}
	{
		param := chi.URLParam(r, "status_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'status_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'status_id': %w", err)
		}

		params.StatusID = v
	}

	return params, nil
}

func decodeReposCreateDispatchEventParams(r *http.Request) (ReposCreateDispatchEventParams, error) {
	var params ReposCreateDispatchEventParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetAllEnvironmentsParams(r *http.Request) (ReposGetAllEnvironmentsParams, error) {
	var params ReposGetAllEnvironmentsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetEnvironmentParams(r *http.Request) (ReposGetEnvironmentParams, error) {
	var params ReposGetEnvironmentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "environment_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'environment_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'environment_name': %w", err)
		}

		params.EnvironmentName = v
	}

	return params, nil
}

func decodeReposCreateOrUpdateEnvironmentParams(r *http.Request) (ReposCreateOrUpdateEnvironmentParams, error) {
	var params ReposCreateOrUpdateEnvironmentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "environment_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'environment_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'environment_name': %w", err)
		}

		params.EnvironmentName = v
	}

	return params, nil
}

func decodeReposDeleteAnEnvironmentParams(r *http.Request) (ReposDeleteAnEnvironmentParams, error) {
	var params ReposDeleteAnEnvironmentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "environment_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'environment_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'environment_name': %w", err)
		}

		params.EnvironmentName = v
	}

	return params, nil
}

func decodeActivityListRepoEventsParams(r *http.Request) (ActivityListRepoEventsParams, error) {
	var params ActivityListRepoEventsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposListForksParams(r *http.Request) (ReposListForksParams, error) {
	var params ReposListForksParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposCreateForkParams(r *http.Request) (ReposCreateForkParams, error) {
	var params ReposCreateForkParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeGitCreateBlobParams(r *http.Request) (GitCreateBlobParams, error) {
	var params GitCreateBlobParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeGitGetBlobParams(r *http.Request) (GitGetBlobParams, error) {
	var params GitGetBlobParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "file_sha")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'file_sha' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'file_sha': %w", err)
		}

		params.FileSha = v
	}

	return params, nil
}

func decodeGitCreateCommitParams(r *http.Request) (GitCreateCommitParams, error) {
	var params GitCreateCommitParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeGitGetCommitParams(r *http.Request) (GitGetCommitParams, error) {
	var params GitGetCommitParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "commit_sha")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'commit_sha' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'commit_sha': %w", err)
		}

		params.CommitSha = v
	}

	return params, nil
}

func decodeGitListMatchingRefsParams(r *http.Request) (GitListMatchingRefsParams, error) {
	var params GitListMatchingRefsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGitGetRefParams(r *http.Request) (GitGetRefParams, error) {
	var params GitGetRefParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}

	return params, nil
}

func decodeGitCreateRefParams(r *http.Request) (GitCreateRefParams, error) {
	var params GitCreateRefParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeGitDeleteRefParams(r *http.Request) (GitDeleteRefParams, error) {
	var params GitDeleteRefParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}

	return params, nil
}

func decodeGitUpdateRefParams(r *http.Request) (GitUpdateRefParams, error) {
	var params GitUpdateRefParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}

	return params, nil
}

func decodeGitCreateTagParams(r *http.Request) (GitCreateTagParams, error) {
	var params GitCreateTagParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeGitGetTagParams(r *http.Request) (GitGetTagParams, error) {
	var params GitGetTagParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "tag_sha")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'tag_sha' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'tag_sha': %w", err)
		}

		params.TagSha = v
	}

	return params, nil
}

func decodeGitCreateTreeParams(r *http.Request) (GitCreateTreeParams, error) {
	var params GitCreateTreeParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeGitGetTreeParams(r *http.Request) (GitGetTreeParams, error) {
	var params GitGetTreeParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "tree_sha")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'tree_sha' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'tree_sha': %w", err)
		}

		params.TreeSha = v
	}
	{
		param := r.URL.Query().Get("recursive")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'recursive': %w", err)
			}

			params.Recursive = v
		}
	}

	return params, nil
}

func decodeReposListWebhooksParams(r *http.Request) (ReposListWebhooksParams, error) {
	var params ReposListWebhooksParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposCreateWebhookParams(r *http.Request) (ReposCreateWebhookParams, error) {
	var params ReposCreateWebhookParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetWebhookParams(r *http.Request) (ReposGetWebhookParams, error) {
	var params ReposGetWebhookParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeReposDeleteWebhookParams(r *http.Request) (ReposDeleteWebhookParams, error) {
	var params ReposDeleteWebhookParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeReposUpdateWebhookParams(r *http.Request) (ReposUpdateWebhookParams, error) {
	var params ReposUpdateWebhookParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeReposGetWebhookConfigForRepoParams(r *http.Request) (ReposGetWebhookConfigForRepoParams, error) {
	var params ReposGetWebhookConfigForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeReposUpdateWebhookConfigForRepoParams(r *http.Request) (ReposUpdateWebhookConfigForRepoParams, error) {
	var params ReposUpdateWebhookConfigForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeReposListWebhookDeliveriesParams(r *http.Request) (ReposListWebhookDeliveriesParams, error) {
	var params ReposListWebhookDeliveriesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("cursor")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'cursor': %w", err)
			}

			params.Cursor = v
		}
	}

	return params, nil
}

func decodeReposGetWebhookDeliveryParams(r *http.Request) (ReposGetWebhookDeliveryParams, error) {
	var params ReposGetWebhookDeliveryParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}
	{
		param := chi.URLParam(r, "delivery_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'delivery_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'delivery_id': %w", err)
		}

		params.DeliveryID = v
	}

	return params, nil
}

func decodeReposRedeliverWebhookDeliveryParams(r *http.Request) (ReposRedeliverWebhookDeliveryParams, error) {
	var params ReposRedeliverWebhookDeliveryParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}
	{
		param := chi.URLParam(r, "delivery_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'delivery_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'delivery_id': %w", err)
		}

		params.DeliveryID = v
	}

	return params, nil
}

func decodeReposPingWebhookParams(r *http.Request) (ReposPingWebhookParams, error) {
	var params ReposPingWebhookParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeReposTestPushWebhookParams(r *http.Request) (ReposTestPushWebhookParams, error) {
	var params ReposTestPushWebhookParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeMigrationsGetImportStatusParams(r *http.Request) (MigrationsGetImportStatusParams, error) {
	var params MigrationsGetImportStatusParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeMigrationsStartImportParams(r *http.Request) (MigrationsStartImportParams, error) {
	var params MigrationsStartImportParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeMigrationsCancelImportParams(r *http.Request) (MigrationsCancelImportParams, error) {
	var params MigrationsCancelImportParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeMigrationsUpdateImportParams(r *http.Request) (MigrationsUpdateImportParams, error) {
	var params MigrationsUpdateImportParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeMigrationsGetCommitAuthorsParams(r *http.Request) (MigrationsGetCommitAuthorsParams, error) {
	var params MigrationsGetCommitAuthorsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}

	return params, nil
}

func decodeMigrationsMapCommitAuthorParams(r *http.Request) (MigrationsMapCommitAuthorParams, error) {
	var params MigrationsMapCommitAuthorParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "author_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'author_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'author_id': %w", err)
		}

		params.AuthorID = v
	}

	return params, nil
}

func decodeMigrationsGetLargeFilesParams(r *http.Request) (MigrationsGetLargeFilesParams, error) {
	var params MigrationsGetLargeFilesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeMigrationsSetLfsPreferenceParams(r *http.Request) (MigrationsSetLfsPreferenceParams, error) {
	var params MigrationsSetLfsPreferenceParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeAppsGetRepoInstallationParams(r *http.Request) (AppsGetRepoInstallationParams, error) {
	var params AppsGetRepoInstallationParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeInteractionsGetRestrictionsForRepoParams(r *http.Request) (InteractionsGetRestrictionsForRepoParams, error) {
	var params InteractionsGetRestrictionsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeInteractionsSetRestrictionsForRepoParams(r *http.Request) (InteractionsSetRestrictionsForRepoParams, error) {
	var params InteractionsSetRestrictionsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeInteractionsRemoveRestrictionsForRepoParams(r *http.Request) (InteractionsRemoveRestrictionsForRepoParams, error) {
	var params InteractionsRemoveRestrictionsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposListInvitationsParams(r *http.Request) (ReposListInvitationsParams, error) {
	var params ReposListInvitationsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposDeleteInvitationParams(r *http.Request) (ReposDeleteInvitationParams, error) {
	var params ReposDeleteInvitationParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "invitation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'invitation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'invitation_id': %w", err)
		}

		params.InvitationID = v
	}

	return params, nil
}

func decodeReposUpdateInvitationParams(r *http.Request) (ReposUpdateInvitationParams, error) {
	var params ReposUpdateInvitationParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "invitation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'invitation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'invitation_id': %w", err)
		}

		params.InvitationID = v
	}

	return params, nil
}

func decodeIssuesListForRepoParams(r *http.Request) (IssuesListForRepoParams, error) {
	var params IssuesListForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("milestone")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'milestone': %w", err)
			}

			params.Milestone = v
		}
	}
	{
		param := r.URL.Query().Get("state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'state': %w", err)
			}

			params.State = v
		}
	}
	{
		param := r.URL.Query().Get("assignee")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'assignee': %w", err)
			}

			params.Assignee = v
		}
	}
	{
		param := r.URL.Query().Get("creator")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'creator': %w", err)
			}

			params.Creator = v
		}
	}
	{
		param := r.URL.Query().Get("mentioned")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'mentioned': %w", err)
			}

			params.Mentioned = v
		}
	}
	{
		param := r.URL.Query().Get("labels")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'labels': %w", err)
			}

			params.Labels = v
		}
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesCreateParams(r *http.Request) (IssuesCreateParams, error) {
	var params IssuesCreateParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeIssuesListCommentsForRepoParams(r *http.Request) (IssuesListCommentsForRepoParams, error) {
	var params IssuesListCommentsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesGetCommentParams(r *http.Request) (IssuesGetCommentParams, error) {
	var params IssuesGetCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeIssuesDeleteCommentParams(r *http.Request) (IssuesDeleteCommentParams, error) {
	var params IssuesDeleteCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeIssuesUpdateCommentParams(r *http.Request) (IssuesUpdateCommentParams, error) {
	var params IssuesUpdateCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeReactionsListForIssueCommentParams(r *http.Request) (ReactionsListForIssueCommentParams, error) {
	var params ReactionsListForIssueCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}
	{
		param := r.URL.Query().Get("content")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'content': %w", err)
			}

			params.Content = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReactionsCreateForIssueCommentParams(r *http.Request) (ReactionsCreateForIssueCommentParams, error) {
	var params ReactionsCreateForIssueCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeReactionsDeleteForIssueCommentParams(r *http.Request) (ReactionsDeleteForIssueCommentParams, error) {
	var params ReactionsDeleteForIssueCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}
	{
		param := chi.URLParam(r, "reaction_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'reaction_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'reaction_id': %w", err)
		}

		params.ReactionID = v
	}

	return params, nil
}

func decodeIssuesListEventsForRepoParams(r *http.Request) (IssuesListEventsForRepoParams, error) {
	var params IssuesListEventsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesGetEventParams(r *http.Request) (IssuesGetEventParams, error) {
	var params IssuesGetEventParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "event_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'event_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'event_id': %w", err)
		}

		params.EventID = v
	}

	return params, nil
}

func decodeIssuesGetParams(r *http.Request) (IssuesGetParams, error) {
	var params IssuesGetParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}

	return params, nil
}

func decodeIssuesUpdateParams(r *http.Request) (IssuesUpdateParams, error) {
	var params IssuesUpdateParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}

	return params, nil
}

func decodeIssuesAddAssigneesParams(r *http.Request) (IssuesAddAssigneesParams, error) {
	var params IssuesAddAssigneesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}

	return params, nil
}

func decodeIssuesRemoveAssigneesParams(r *http.Request) (IssuesRemoveAssigneesParams, error) {
	var params IssuesRemoveAssigneesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}

	return params, nil
}

func decodeIssuesListCommentsParams(r *http.Request) (IssuesListCommentsParams, error) {
	var params IssuesListCommentsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesCreateCommentParams(r *http.Request) (IssuesCreateCommentParams, error) {
	var params IssuesCreateCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}

	return params, nil
}

func decodeIssuesListEventsParams(r *http.Request) (IssuesListEventsParams, error) {
	var params IssuesListEventsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesListLabelsOnIssueParams(r *http.Request) (IssuesListLabelsOnIssueParams, error) {
	var params IssuesListLabelsOnIssueParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesSetLabelsParams(r *http.Request) (IssuesSetLabelsParams, error) {
	var params IssuesSetLabelsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}

	return params, nil
}

func decodeIssuesAddLabelsParams(r *http.Request) (IssuesAddLabelsParams, error) {
	var params IssuesAddLabelsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}

	return params, nil
}

func decodeIssuesRemoveAllLabelsParams(r *http.Request) (IssuesRemoveAllLabelsParams, error) {
	var params IssuesRemoveAllLabelsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}

	return params, nil
}

func decodeIssuesRemoveLabelParams(r *http.Request) (IssuesRemoveLabelParams, error) {
	var params IssuesRemoveLabelParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}
	{
		param := chi.URLParam(r, "name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'name': %w", err)
		}

		params.Name = v
	}

	return params, nil
}

func decodeIssuesLockParams(r *http.Request) (IssuesLockParams, error) {
	var params IssuesLockParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}

	return params, nil
}

func decodeIssuesUnlockParams(r *http.Request) (IssuesUnlockParams, error) {
	var params IssuesUnlockParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}

	return params, nil
}

func decodeReactionsListForIssueParams(r *http.Request) (ReactionsListForIssueParams, error) {
	var params ReactionsListForIssueParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}
	{
		param := r.URL.Query().Get("content")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'content': %w", err)
			}

			params.Content = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReactionsCreateForIssueParams(r *http.Request) (ReactionsCreateForIssueParams, error) {
	var params ReactionsCreateForIssueParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}

	return params, nil
}

func decodeReactionsDeleteForIssueParams(r *http.Request) (ReactionsDeleteForIssueParams, error) {
	var params ReactionsDeleteForIssueParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}
	{
		param := chi.URLParam(r, "reaction_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'reaction_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'reaction_id': %w", err)
		}

		params.ReactionID = v
	}

	return params, nil
}

func decodeIssuesListEventsForTimelineParams(r *http.Request) (IssuesListEventsForTimelineParams, error) {
	var params IssuesListEventsForTimelineParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposListDeployKeysParams(r *http.Request) (ReposListDeployKeysParams, error) {
	var params ReposListDeployKeysParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposCreateDeployKeyParams(r *http.Request) (ReposCreateDeployKeyParams, error) {
	var params ReposCreateDeployKeyParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetDeployKeyParams(r *http.Request) (ReposGetDeployKeyParams, error) {
	var params ReposGetDeployKeyParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "key_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'key_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'key_id': %w", err)
		}

		params.KeyID = v
	}

	return params, nil
}

func decodeReposDeleteDeployKeyParams(r *http.Request) (ReposDeleteDeployKeyParams, error) {
	var params ReposDeleteDeployKeyParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "key_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'key_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'key_id': %w", err)
		}

		params.KeyID = v
	}

	return params, nil
}

func decodeIssuesListLabelsForRepoParams(r *http.Request) (IssuesListLabelsForRepoParams, error) {
	var params IssuesListLabelsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesCreateLabelParams(r *http.Request) (IssuesCreateLabelParams, error) {
	var params IssuesCreateLabelParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeIssuesGetLabelParams(r *http.Request) (IssuesGetLabelParams, error) {
	var params IssuesGetLabelParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'name': %w", err)
		}

		params.Name = v
	}

	return params, nil
}

func decodeIssuesDeleteLabelParams(r *http.Request) (IssuesDeleteLabelParams, error) {
	var params IssuesDeleteLabelParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'name': %w", err)
		}

		params.Name = v
	}

	return params, nil
}

func decodeIssuesUpdateLabelParams(r *http.Request) (IssuesUpdateLabelParams, error) {
	var params IssuesUpdateLabelParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'name': %w", err)
		}

		params.Name = v
	}

	return params, nil
}

func decodeReposListLanguagesParams(r *http.Request) (ReposListLanguagesParams, error) {
	var params ReposListLanguagesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposEnableLfsForRepoParams(r *http.Request) (ReposEnableLfsForRepoParams, error) {
	var params ReposEnableLfsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposDisableLfsForRepoParams(r *http.Request) (ReposDisableLfsForRepoParams, error) {
	var params ReposDisableLfsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeLicensesGetForRepoParams(r *http.Request) (LicensesGetForRepoParams, error) {
	var params LicensesGetForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposMergeUpstreamParams(r *http.Request) (ReposMergeUpstreamParams, error) {
	var params ReposMergeUpstreamParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposMergeParams(r *http.Request) (ReposMergeParams, error) {
	var params ReposMergeParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeIssuesListMilestonesParams(r *http.Request) (IssuesListMilestonesParams, error) {
	var params IssuesListMilestonesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'state': %w", err)
			}

			params.State = v
		}
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesCreateMilestoneParams(r *http.Request) (IssuesCreateMilestoneParams, error) {
	var params IssuesCreateMilestoneParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeIssuesGetMilestoneParams(r *http.Request) (IssuesGetMilestoneParams, error) {
	var params IssuesGetMilestoneParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "milestone_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'milestone_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'milestone_number': %w", err)
		}

		params.MilestoneNumber = v
	}

	return params, nil
}

func decodeIssuesDeleteMilestoneParams(r *http.Request) (IssuesDeleteMilestoneParams, error) {
	var params IssuesDeleteMilestoneParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "milestone_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'milestone_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'milestone_number': %w", err)
		}

		params.MilestoneNumber = v
	}

	return params, nil
}

func decodeIssuesUpdateMilestoneParams(r *http.Request) (IssuesUpdateMilestoneParams, error) {
	var params IssuesUpdateMilestoneParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "milestone_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'milestone_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'milestone_number': %w", err)
		}

		params.MilestoneNumber = v
	}

	return params, nil
}

func decodeIssuesListLabelsForMilestoneParams(r *http.Request) (IssuesListLabelsForMilestoneParams, error) {
	var params IssuesListLabelsForMilestoneParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "milestone_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'milestone_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'milestone_number': %w", err)
		}

		params.MilestoneNumber = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityListRepoNotificationsForAuthenticatedUserParams(r *http.Request) (ActivityListRepoNotificationsForAuthenticatedUserParams, error) {
	var params ActivityListRepoNotificationsForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("all")
		if len(param) > 0 {
			v, err := conv.ToBool(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'all': %w", err)
			}

			params.All = v
		}
	}
	{
		param := r.URL.Query().Get("participating")
		if len(param) > 0 {
			v, err := conv.ToBool(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'participating': %w", err)
			}

			params.Participating = v
		}
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("before")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'before': %w", err)
			}

			params.Before = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityMarkRepoNotificationsAsReadParams(r *http.Request) (ActivityMarkRepoNotificationsAsReadParams, error) {
	var params ActivityMarkRepoNotificationsAsReadParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetPagesParams(r *http.Request) (ReposGetPagesParams, error) {
	var params ReposGetPagesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposUpdateInformationAboutPagesSiteParams(r *http.Request) (ReposUpdateInformationAboutPagesSiteParams, error) {
	var params ReposUpdateInformationAboutPagesSiteParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposCreatePagesSiteParams(r *http.Request) (ReposCreatePagesSiteParams, error) {
	var params ReposCreatePagesSiteParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposDeletePagesSiteParams(r *http.Request) (ReposDeletePagesSiteParams, error) {
	var params ReposDeletePagesSiteParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposListPagesBuildsParams(r *http.Request) (ReposListPagesBuildsParams, error) {
	var params ReposListPagesBuildsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposRequestPagesBuildParams(r *http.Request) (ReposRequestPagesBuildParams, error) {
	var params ReposRequestPagesBuildParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetLatestPagesBuildParams(r *http.Request) (ReposGetLatestPagesBuildParams, error) {
	var params ReposGetLatestPagesBuildParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetPagesBuildParams(r *http.Request) (ReposGetPagesBuildParams, error) {
	var params ReposGetPagesBuildParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "build_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'build_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'build_id': %w", err)
		}

		params.BuildID = v
	}

	return params, nil
}

func decodeReposGetPagesHealthCheckParams(r *http.Request) (ReposGetPagesHealthCheckParams, error) {
	var params ReposGetPagesHealthCheckParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeProjectsListForRepoParams(r *http.Request) (ProjectsListForRepoParams, error) {
	var params ProjectsListForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'state': %w", err)
			}

			params.State = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeProjectsCreateForRepoParams(r *http.Request) (ProjectsCreateForRepoParams, error) {
	var params ProjectsCreateForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodePullsListParams(r *http.Request) (PullsListParams, error) {
	var params PullsListParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'state': %w", err)
			}

			params.State = v
		}
	}
	{
		param := r.URL.Query().Get("head")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'head': %w", err)
			}

			params.Head = v
		}
	}
	{
		param := r.URL.Query().Get("base")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'base': %w", err)
			}

			params.Base = v
		}
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodePullsCreateParams(r *http.Request) (PullsCreateParams, error) {
	var params PullsCreateParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodePullsListReviewCommentsForRepoParams(r *http.Request) (PullsListReviewCommentsForRepoParams, error) {
	var params PullsListReviewCommentsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodePullsGetReviewCommentParams(r *http.Request) (PullsGetReviewCommentParams, error) {
	var params PullsGetReviewCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodePullsDeleteReviewCommentParams(r *http.Request) (PullsDeleteReviewCommentParams, error) {
	var params PullsDeleteReviewCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodePullsUpdateReviewCommentParams(r *http.Request) (PullsUpdateReviewCommentParams, error) {
	var params PullsUpdateReviewCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeReactionsListForPullRequestReviewCommentParams(r *http.Request) (ReactionsListForPullRequestReviewCommentParams, error) {
	var params ReactionsListForPullRequestReviewCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}
	{
		param := r.URL.Query().Get("content")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'content': %w", err)
			}

			params.Content = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReactionsCreateForPullRequestReviewCommentParams(r *http.Request) (ReactionsCreateForPullRequestReviewCommentParams, error) {
	var params ReactionsCreateForPullRequestReviewCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeReactionsDeleteForPullRequestCommentParams(r *http.Request) (ReactionsDeleteForPullRequestCommentParams, error) {
	var params ReactionsDeleteForPullRequestCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}
	{
		param := chi.URLParam(r, "reaction_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'reaction_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'reaction_id': %w", err)
		}

		params.ReactionID = v
	}

	return params, nil
}

func decodePullsGetParams(r *http.Request) (PullsGetParams, error) {
	var params PullsGetParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}

	return params, nil
}

func decodePullsUpdateParams(r *http.Request) (PullsUpdateParams, error) {
	var params PullsUpdateParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}

	return params, nil
}

func decodePullsListReviewCommentsParams(r *http.Request) (PullsListReviewCommentsParams, error) {
	var params PullsListReviewCommentsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodePullsCreateReviewCommentParams(r *http.Request) (PullsCreateReviewCommentParams, error) {
	var params PullsCreateReviewCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}

	return params, nil
}

func decodePullsCreateReplyForReviewCommentParams(r *http.Request) (PullsCreateReplyForReviewCommentParams, error) {
	var params PullsCreateReplyForReviewCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodePullsListCommitsParams(r *http.Request) (PullsListCommitsParams, error) {
	var params PullsListCommitsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodePullsListFilesParams(r *http.Request) (PullsListFilesParams, error) {
	var params PullsListFilesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodePullsCheckIfMergedParams(r *http.Request) (PullsCheckIfMergedParams, error) {
	var params PullsCheckIfMergedParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}

	return params, nil
}

func decodePullsMergeParams(r *http.Request) (PullsMergeParams, error) {
	var params PullsMergeParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}

	return params, nil
}

func decodePullsListRequestedReviewersParams(r *http.Request) (PullsListRequestedReviewersParams, error) {
	var params PullsListRequestedReviewersParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodePullsRequestReviewersParams(r *http.Request) (PullsRequestReviewersParams, error) {
	var params PullsRequestReviewersParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}

	return params, nil
}

func decodePullsRemoveRequestedReviewersParams(r *http.Request) (PullsRemoveRequestedReviewersParams, error) {
	var params PullsRemoveRequestedReviewersParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}

	return params, nil
}

func decodePullsListReviewsParams(r *http.Request) (PullsListReviewsParams, error) {
	var params PullsListReviewsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodePullsCreateReviewParams(r *http.Request) (PullsCreateReviewParams, error) {
	var params PullsCreateReviewParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}

	return params, nil
}

func decodePullsGetReviewParams(r *http.Request) (PullsGetReviewParams, error) {
	var params PullsGetReviewParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := chi.URLParam(r, "review_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'review_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'review_id': %w", err)
		}

		params.ReviewID = v
	}

	return params, nil
}

func decodePullsUpdateReviewParams(r *http.Request) (PullsUpdateReviewParams, error) {
	var params PullsUpdateReviewParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := chi.URLParam(r, "review_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'review_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'review_id': %w", err)
		}

		params.ReviewID = v
	}

	return params, nil
}

func decodePullsDeletePendingReviewParams(r *http.Request) (PullsDeletePendingReviewParams, error) {
	var params PullsDeletePendingReviewParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := chi.URLParam(r, "review_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'review_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'review_id': %w", err)
		}

		params.ReviewID = v
	}

	return params, nil
}

func decodePullsListCommentsForReviewParams(r *http.Request) (PullsListCommentsForReviewParams, error) {
	var params PullsListCommentsForReviewParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := chi.URLParam(r, "review_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'review_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'review_id': %w", err)
		}

		params.ReviewID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodePullsDismissReviewParams(r *http.Request) (PullsDismissReviewParams, error) {
	var params PullsDismissReviewParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := chi.URLParam(r, "review_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'review_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'review_id': %w", err)
		}

		params.ReviewID = v
	}

	return params, nil
}

func decodePullsSubmitReviewParams(r *http.Request) (PullsSubmitReviewParams, error) {
	var params PullsSubmitReviewParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := chi.URLParam(r, "review_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'review_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'review_id': %w", err)
		}

		params.ReviewID = v
	}

	return params, nil
}

func decodePullsUpdateBranchParams(r *http.Request) (PullsUpdateBranchParams, error) {
	var params PullsUpdateBranchParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}

	return params, nil
}

func decodeReposGetReadmeParams(r *http.Request) (ReposGetReadmeParams, error) {
	var params ReposGetReadmeParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("ref")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'ref': %w", err)
			}

			params.Ref = v
		}
	}

	return params, nil
}

func decodeReposGetReadmeInDirectoryParams(r *http.Request) (ReposGetReadmeInDirectoryParams, error) {
	var params ReposGetReadmeInDirectoryParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "dir")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'dir' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'dir': %w", err)
		}

		params.Dir = v
	}
	{
		param := r.URL.Query().Get("ref")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'ref': %w", err)
			}

			params.Ref = v
		}
	}

	return params, nil
}

func decodeReposListReleasesParams(r *http.Request) (ReposListReleasesParams, error) {
	var params ReposListReleasesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposCreateReleaseParams(r *http.Request) (ReposCreateReleaseParams, error) {
	var params ReposCreateReleaseParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetReleaseAssetParams(r *http.Request) (ReposGetReleaseAssetParams, error) {
	var params ReposGetReleaseAssetParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "asset_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'asset_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'asset_id': %w", err)
		}

		params.AssetID = v
	}

	return params, nil
}

func decodeReposDeleteReleaseAssetParams(r *http.Request) (ReposDeleteReleaseAssetParams, error) {
	var params ReposDeleteReleaseAssetParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "asset_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'asset_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'asset_id': %w", err)
		}

		params.AssetID = v
	}

	return params, nil
}

func decodeReposUpdateReleaseAssetParams(r *http.Request) (ReposUpdateReleaseAssetParams, error) {
	var params ReposUpdateReleaseAssetParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "asset_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'asset_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'asset_id': %w", err)
		}

		params.AssetID = v
	}

	return params, nil
}

func decodeReposGetLatestReleaseParams(r *http.Request) (ReposGetLatestReleaseParams, error) {
	var params ReposGetLatestReleaseParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetReleaseByTagParams(r *http.Request) (ReposGetReleaseByTagParams, error) {
	var params ReposGetReleaseByTagParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "tag")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'tag' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'tag': %w", err)
		}

		params.Tag = v
	}

	return params, nil
}

func decodeReposGetReleaseParams(r *http.Request) (ReposGetReleaseParams, error) {
	var params ReposGetReleaseParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "release_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'release_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'release_id': %w", err)
		}

		params.ReleaseID = v
	}

	return params, nil
}

func decodeReposDeleteReleaseParams(r *http.Request) (ReposDeleteReleaseParams, error) {
	var params ReposDeleteReleaseParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "release_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'release_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'release_id': %w", err)
		}

		params.ReleaseID = v
	}

	return params, nil
}

func decodeReposUpdateReleaseParams(r *http.Request) (ReposUpdateReleaseParams, error) {
	var params ReposUpdateReleaseParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "release_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'release_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'release_id': %w", err)
		}

		params.ReleaseID = v
	}

	return params, nil
}

func decodeReposListReleaseAssetsParams(r *http.Request) (ReposListReleaseAssetsParams, error) {
	var params ReposListReleaseAssetsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "release_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'release_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'release_id': %w", err)
		}

		params.ReleaseID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposUploadReleaseAssetParams(r *http.Request) (ReposUploadReleaseAssetParams, error) {
	var params ReposUploadReleaseAssetParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "release_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'release_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'release_id': %w", err)
		}

		params.ReleaseID = v
	}
	{
		param := r.URL.Query().Get("name")
		if len(param) == 0 {
			return params, fmt.Errorf("query param 'name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse query param 'name': %w", err)
		}

		params.Name = v
	}
	{
		param := r.URL.Query().Get("label")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'label': %w", err)
			}

			params.Label = v
		}
	}

	return params, nil
}

func decodeReactionsCreateForReleaseParams(r *http.Request) (ReactionsCreateForReleaseParams, error) {
	var params ReactionsCreateForReleaseParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "release_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'release_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'release_id': %w", err)
		}

		params.ReleaseID = v
	}

	return params, nil
}

func decodeSecretScanningListAlertsForRepoParams(r *http.Request) (SecretScanningListAlertsForRepoParams, error) {
	var params SecretScanningListAlertsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'state': %w", err)
			}

			params.State = v
		}
	}
	{
		param := r.URL.Query().Get("secret_type")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'secret_type': %w", err)
			}

			params.SecretType = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}

	return params, nil
}

func decodeSecretScanningGetAlertParams(r *http.Request) (SecretScanningGetAlertParams, error) {
	var params SecretScanningGetAlertParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "alert_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'alert_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'alert_number': %w", err)
		}

		params.AlertNumber = v
	}

	return params, nil
}

func decodeSecretScanningUpdateAlertParams(r *http.Request) (SecretScanningUpdateAlertParams, error) {
	var params SecretScanningUpdateAlertParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "alert_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'alert_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'alert_number': %w", err)
		}

		params.AlertNumber = v
	}

	return params, nil
}

func decodeActivityListStargazersForRepoParams(r *http.Request) (ActivityListStargazersForRepoParams, error) {
	var params ActivityListStargazersForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetCodeFrequencyStatsParams(r *http.Request) (ReposGetCodeFrequencyStatsParams, error) {
	var params ReposGetCodeFrequencyStatsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetCommitActivityStatsParams(r *http.Request) (ReposGetCommitActivityStatsParams, error) {
	var params ReposGetCommitActivityStatsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetContributorsStatsParams(r *http.Request) (ReposGetContributorsStatsParams, error) {
	var params ReposGetContributorsStatsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetParticipationStatsParams(r *http.Request) (ReposGetParticipationStatsParams, error) {
	var params ReposGetParticipationStatsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetPunchCardStatsParams(r *http.Request) (ReposGetPunchCardStatsParams, error) {
	var params ReposGetPunchCardStatsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposCreateCommitStatusParams(r *http.Request) (ReposCreateCommitStatusParams, error) {
	var params ReposCreateCommitStatusParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "sha")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'sha' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'sha': %w", err)
		}

		params.Sha = v
	}

	return params, nil
}

func decodeActivityListWatchersForRepoParams(r *http.Request) (ActivityListWatchersForRepoParams, error) {
	var params ActivityListWatchersForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityGetRepoSubscriptionParams(r *http.Request) (ActivityGetRepoSubscriptionParams, error) {
	var params ActivityGetRepoSubscriptionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActivitySetRepoSubscriptionParams(r *http.Request) (ActivitySetRepoSubscriptionParams, error) {
	var params ActivitySetRepoSubscriptionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActivityDeleteRepoSubscriptionParams(r *http.Request) (ActivityDeleteRepoSubscriptionParams, error) {
	var params ActivityDeleteRepoSubscriptionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposListTagsParams(r *http.Request) (ReposListTagsParams, error) {
	var params ReposListTagsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposDownloadTarballArchiveParams(r *http.Request) (ReposDownloadTarballArchiveParams, error) {
	var params ReposDownloadTarballArchiveParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}

	return params, nil
}

func decodeReposListTeamsParams(r *http.Request) (ReposListTeamsParams, error) {
	var params ReposListTeamsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetAllTopicsParams(r *http.Request) (ReposGetAllTopicsParams, error) {
	var params ReposGetAllTopicsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}

	return params, nil
}

func decodeReposReplaceAllTopicsParams(r *http.Request) (ReposReplaceAllTopicsParams, error) {
	var params ReposReplaceAllTopicsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetClonesParams(r *http.Request) (ReposGetClonesParams, error) {
	var params ReposGetClonesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per': %w", err)
			}

			params.Per = v
		}
	}

	return params, nil
}

func decodeReposGetTopPathsParams(r *http.Request) (ReposGetTopPathsParams, error) {
	var params ReposGetTopPathsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetTopReferrersParams(r *http.Request) (ReposGetTopReferrersParams, error) {
	var params ReposGetTopReferrersParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetViewsParams(r *http.Request) (ReposGetViewsParams, error) {
	var params ReposGetViewsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per': %w", err)
			}

			params.Per = v
		}
	}

	return params, nil
}

func decodeReposTransferParams(r *http.Request) (ReposTransferParams, error) {
	var params ReposTransferParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposCheckVulnerabilityAlertsParams(r *http.Request) (ReposCheckVulnerabilityAlertsParams, error) {
	var params ReposCheckVulnerabilityAlertsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposEnableVulnerabilityAlertsParams(r *http.Request) (ReposEnableVulnerabilityAlertsParams, error) {
	var params ReposEnableVulnerabilityAlertsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposDisableVulnerabilityAlertsParams(r *http.Request) (ReposDisableVulnerabilityAlertsParams, error) {
	var params ReposDisableVulnerabilityAlertsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposDownloadZipballArchiveParams(r *http.Request) (ReposDownloadZipballArchiveParams, error) {
	var params ReposDownloadZipballArchiveParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}

	return params, nil
}

func decodeReposCreateUsingTemplateParams(r *http.Request) (ReposCreateUsingTemplateParams, error) {
	var params ReposCreateUsingTemplateParams
	{
		param := chi.URLParam(r, "template_owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'template_owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'template_owner': %w", err)
		}

		params.TemplateOwner = v
	}
	{
		param := chi.URLParam(r, "template_repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'template_repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'template_repo': %w", err)
		}

		params.TemplateRepo = v
	}

	return params, nil
}

func decodeReposListPublicParams(r *http.Request) (ReposListPublicParams, error) {
	var params ReposListPublicParams
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}

	return params, nil
}

func decodeActionsListEnvironmentSecretsParams(r *http.Request) (ActionsListEnvironmentSecretsParams, error) {
	var params ActionsListEnvironmentSecretsParams
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}
	{
		param := chi.URLParam(r, "environment_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'environment_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'environment_name': %w", err)
		}

		params.EnvironmentName = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsGetEnvironmentPublicKeyParams(r *http.Request) (ActionsGetEnvironmentPublicKeyParams, error) {
	var params ActionsGetEnvironmentPublicKeyParams
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}
	{
		param := chi.URLParam(r, "environment_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'environment_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'environment_name': %w", err)
		}

		params.EnvironmentName = v
	}

	return params, nil
}

func decodeActionsGetEnvironmentSecretParams(r *http.Request) (ActionsGetEnvironmentSecretParams, error) {
	var params ActionsGetEnvironmentSecretParams
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}
	{
		param := chi.URLParam(r, "environment_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'environment_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'environment_name': %w", err)
		}

		params.EnvironmentName = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsCreateOrUpdateEnvironmentSecretParams(r *http.Request) (ActionsCreateOrUpdateEnvironmentSecretParams, error) {
	var params ActionsCreateOrUpdateEnvironmentSecretParams
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}
	{
		param := chi.URLParam(r, "environment_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'environment_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'environment_name': %w", err)
		}

		params.EnvironmentName = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsDeleteEnvironmentSecretParams(r *http.Request) (ActionsDeleteEnvironmentSecretParams, error) {
	var params ActionsDeleteEnvironmentSecretParams
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}
	{
		param := chi.URLParam(r, "environment_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'environment_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'environment_name': %w", err)
		}

		params.EnvironmentName = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeEnterpriseAdminListProvisionedGroupsEnterpriseParams(r *http.Request) (EnterpriseAdminListProvisionedGroupsEnterpriseParams, error) {
	var params EnterpriseAdminListProvisionedGroupsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := r.URL.Query().Get("startIndex")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'startIndex': %w", err)
			}

			params.StartIndex = v
		}
	}
	{
		param := r.URL.Query().Get("count")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'count': %w", err)
			}

			params.Count = v
		}
	}
	{
		param := r.URL.Query().Get("filter")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'filter': %w", err)
			}

			params.Filter = v
		}
	}
	{
		param := r.URL.Query().Get("excludedAttributes")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'excludedAttributes': %w", err)
			}

			params.ExcludedAttributes = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupParams(r *http.Request) (EnterpriseAdminProvisionAndInviteEnterpriseGroupParams, error) {
	var params EnterpriseAdminProvisionAndInviteEnterpriseGroupParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams(r *http.Request) (EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams, error) {
	var params EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "scim_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_group_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_group_id': %w", err)
		}

		params.ScimGroupID = v
	}
	{
		param := r.URL.Query().Get("excludedAttributes")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'excludedAttributes': %w", err)
			}

			params.ExcludedAttributes = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams(r *http.Request) (EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams, error) {
	var params EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "scim_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_group_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_group_id': %w", err)
		}

		params.ScimGroupID = v
	}

	return params, nil
}

func decodeEnterpriseAdminDeleteScimGroupFromEnterpriseParams(r *http.Request) (EnterpriseAdminDeleteScimGroupFromEnterpriseParams, error) {
	var params EnterpriseAdminDeleteScimGroupFromEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "scim_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_group_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_group_id': %w", err)
		}

		params.ScimGroupID = v
	}

	return params, nil
}

func decodeEnterpriseAdminUpdateAttributeForEnterpriseGroupParams(r *http.Request) (EnterpriseAdminUpdateAttributeForEnterpriseGroupParams, error) {
	var params EnterpriseAdminUpdateAttributeForEnterpriseGroupParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "scim_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_group_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_group_id': %w", err)
		}

		params.ScimGroupID = v
	}

	return params, nil
}

func decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseParams(r *http.Request) (EnterpriseAdminListProvisionedIdentitiesEnterpriseParams, error) {
	var params EnterpriseAdminListProvisionedIdentitiesEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := r.URL.Query().Get("startIndex")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'startIndex': %w", err)
			}

			params.StartIndex = v
		}
	}
	{
		param := r.URL.Query().Get("count")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'count': %w", err)
			}

			params.Count = v
		}
	}
	{
		param := r.URL.Query().Get("filter")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'filter': %w", err)
			}

			params.Filter = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminProvisionAndInviteEnterpriseUserParams(r *http.Request) (EnterpriseAdminProvisionAndInviteEnterpriseUserParams, error) {
	var params EnterpriseAdminProvisionAndInviteEnterpriseUserParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams(r *http.Request) (EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams, error) {
	var params EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "scim_user_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_user_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_user_id': %w", err)
		}

		params.ScimUserID = v
	}

	return params, nil
}

func decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams(r *http.Request) (EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams, error) {
	var params EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "scim_user_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_user_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_user_id': %w", err)
		}

		params.ScimUserID = v
	}

	return params, nil
}

func decodeEnterpriseAdminDeleteUserFromEnterpriseParams(r *http.Request) (EnterpriseAdminDeleteUserFromEnterpriseParams, error) {
	var params EnterpriseAdminDeleteUserFromEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "scim_user_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_user_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_user_id': %w", err)
		}

		params.ScimUserID = v
	}

	return params, nil
}

func decodeEnterpriseAdminUpdateAttributeForEnterpriseUserParams(r *http.Request) (EnterpriseAdminUpdateAttributeForEnterpriseUserParams, error) {
	var params EnterpriseAdminUpdateAttributeForEnterpriseUserParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "scim_user_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_user_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_user_id': %w", err)
		}

		params.ScimUserID = v
	}

	return params, nil
}

func decodeScimListProvisionedIdentitiesParams(r *http.Request) (ScimListProvisionedIdentitiesParams, error) {
	var params ScimListProvisionedIdentitiesParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("startIndex")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'startIndex': %w", err)
			}

			params.StartIndex = v
		}
	}
	{
		param := r.URL.Query().Get("count")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'count': %w", err)
			}

			params.Count = v
		}
	}
	{
		param := r.URL.Query().Get("filter")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'filter': %w", err)
			}

			params.Filter = v
		}
	}

	return params, nil
}

func decodeScimProvisionAndInviteUserParams(r *http.Request) (ScimProvisionAndInviteUserParams, error) {
	var params ScimProvisionAndInviteUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeScimGetProvisioningInformationForUserParams(r *http.Request) (ScimGetProvisioningInformationForUserParams, error) {
	var params ScimGetProvisioningInformationForUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "scim_user_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_user_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_user_id': %w", err)
		}

		params.ScimUserID = v
	}

	return params, nil
}

func decodeScimSetInformationForProvisionedUserParams(r *http.Request) (ScimSetInformationForProvisionedUserParams, error) {
	var params ScimSetInformationForProvisionedUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "scim_user_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_user_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_user_id': %w", err)
		}

		params.ScimUserID = v
	}

	return params, nil
}

func decodeScimDeleteUserFromOrgParams(r *http.Request) (ScimDeleteUserFromOrgParams, error) {
	var params ScimDeleteUserFromOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "scim_user_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_user_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_user_id': %w", err)
		}

		params.ScimUserID = v
	}

	return params, nil
}

func decodeScimUpdateAttributeForUserParams(r *http.Request) (ScimUpdateAttributeForUserParams, error) {
	var params ScimUpdateAttributeForUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "scim_user_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_user_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_user_id': %w", err)
		}

		params.ScimUserID = v
	}

	return params, nil
}

func decodeSearchCodeParams(r *http.Request) (SearchCodeParams, error) {
	var params SearchCodeParams
	{
		param := r.URL.Query().Get("q")
		if len(param) == 0 {
			return params, fmt.Errorf("query param 'q' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse query param 'q': %w", err)
		}

		params.Q = v
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("order")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'order': %w", err)
			}

			params.Order = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeSearchCommitsParams(r *http.Request) (SearchCommitsParams, error) {
	var params SearchCommitsParams
	{
		param := r.URL.Query().Get("q")
		if len(param) == 0 {
			return params, fmt.Errorf("query param 'q' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse query param 'q': %w", err)
		}

		params.Q = v
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("order")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'order': %w", err)
			}

			params.Order = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeSearchIssuesAndPullRequestsParams(r *http.Request) (SearchIssuesAndPullRequestsParams, error) {
	var params SearchIssuesAndPullRequestsParams
	{
		param := r.URL.Query().Get("q")
		if len(param) == 0 {
			return params, fmt.Errorf("query param 'q' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse query param 'q': %w", err)
		}

		params.Q = v
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("order")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'order': %w", err)
			}

			params.Order = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeSearchLabelsParams(r *http.Request) (SearchLabelsParams, error) {
	var params SearchLabelsParams
	{
		param := r.URL.Query().Get("repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("query param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse query param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}
	{
		param := r.URL.Query().Get("q")
		if len(param) == 0 {
			return params, fmt.Errorf("query param 'q' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse query param 'q': %w", err)
		}

		params.Q = v
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("order")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'order': %w", err)
			}

			params.Order = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeSearchReposParams(r *http.Request) (SearchReposParams, error) {
	var params SearchReposParams
	{
		param := r.URL.Query().Get("q")
		if len(param) == 0 {
			return params, fmt.Errorf("query param 'q' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse query param 'q': %w", err)
		}

		params.Q = v
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("order")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'order': %w", err)
			}

			params.Order = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeSearchTopicsParams(r *http.Request) (SearchTopicsParams, error) {
	var params SearchTopicsParams
	{
		param := r.URL.Query().Get("q")
		if len(param) == 0 {
			return params, fmt.Errorf("query param 'q' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse query param 'q': %w", err)
		}

		params.Q = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeSearchUsersParams(r *http.Request) (SearchUsersParams, error) {
	var params SearchUsersParams
	{
		param := r.URL.Query().Get("q")
		if len(param) == 0 {
			return params, fmt.Errorf("query param 'q' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse query param 'q': %w", err)
		}

		params.Q = v
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("order")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'order': %w", err)
			}

			params.Order = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsGetLegacyParams(r *http.Request) (TeamsGetLegacyParams, error) {
	var params TeamsGetLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}

	return params, nil
}

func decodeTeamsDeleteLegacyParams(r *http.Request) (TeamsDeleteLegacyParams, error) {
	var params TeamsDeleteLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}

	return params, nil
}

func decodeTeamsUpdateLegacyParams(r *http.Request) (TeamsUpdateLegacyParams, error) {
	var params TeamsUpdateLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}

	return params, nil
}

func decodeTeamsListDiscussionsLegacyParams(r *http.Request) (TeamsListDiscussionsLegacyParams, error) {
	var params TeamsListDiscussionsLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsCreateDiscussionLegacyParams(r *http.Request) (TeamsCreateDiscussionLegacyParams, error) {
	var params TeamsCreateDiscussionLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}

	return params, nil
}

func decodeTeamsGetDiscussionLegacyParams(r *http.Request) (TeamsGetDiscussionLegacyParams, error) {
	var params TeamsGetDiscussionLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsDeleteDiscussionLegacyParams(r *http.Request) (TeamsDeleteDiscussionLegacyParams, error) {
	var params TeamsDeleteDiscussionLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsUpdateDiscussionLegacyParams(r *http.Request) (TeamsUpdateDiscussionLegacyParams, error) {
	var params TeamsUpdateDiscussionLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsListDiscussionCommentsLegacyParams(r *http.Request) (TeamsListDiscussionCommentsLegacyParams, error) {
	var params TeamsListDiscussionCommentsLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsCreateDiscussionCommentLegacyParams(r *http.Request) (TeamsCreateDiscussionCommentLegacyParams, error) {
	var params TeamsCreateDiscussionCommentLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsGetDiscussionCommentLegacyParams(r *http.Request) (TeamsGetDiscussionCommentLegacyParams, error) {
	var params TeamsGetDiscussionCommentLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeTeamsDeleteDiscussionCommentLegacyParams(r *http.Request) (TeamsDeleteDiscussionCommentLegacyParams, error) {
	var params TeamsDeleteDiscussionCommentLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeTeamsUpdateDiscussionCommentLegacyParams(r *http.Request) (TeamsUpdateDiscussionCommentLegacyParams, error) {
	var params TeamsUpdateDiscussionCommentLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeReactionsListForTeamDiscussionCommentLegacyParams(r *http.Request) (ReactionsListForTeamDiscussionCommentLegacyParams, error) {
	var params ReactionsListForTeamDiscussionCommentLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}
	{
		param := r.URL.Query().Get("content")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'content': %w", err)
			}

			params.Content = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReactionsCreateForTeamDiscussionCommentLegacyParams(r *http.Request) (ReactionsCreateForTeamDiscussionCommentLegacyParams, error) {
	var params ReactionsCreateForTeamDiscussionCommentLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeReactionsListForTeamDiscussionLegacyParams(r *http.Request) (ReactionsListForTeamDiscussionLegacyParams, error) {
	var params ReactionsListForTeamDiscussionLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := r.URL.Query().Get("content")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'content': %w", err)
			}

			params.Content = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReactionsCreateForTeamDiscussionLegacyParams(r *http.Request) (ReactionsCreateForTeamDiscussionLegacyParams, error) {
	var params ReactionsCreateForTeamDiscussionLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsListPendingInvitationsLegacyParams(r *http.Request) (TeamsListPendingInvitationsLegacyParams, error) {
	var params TeamsListPendingInvitationsLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsListMembersLegacyParams(r *http.Request) (TeamsListMembersLegacyParams, error) {
	var params TeamsListMembersLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := r.URL.Query().Get("role")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'role': %w", err)
			}

			params.Role = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsGetMemberLegacyParams(r *http.Request) (TeamsGetMemberLegacyParams, error) {
	var params TeamsGetMemberLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsAddMemberLegacyParams(r *http.Request) (TeamsAddMemberLegacyParams, error) {
	var params TeamsAddMemberLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsRemoveMemberLegacyParams(r *http.Request) (TeamsRemoveMemberLegacyParams, error) {
	var params TeamsRemoveMemberLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsGetMembershipForUserLegacyParams(r *http.Request) (TeamsGetMembershipForUserLegacyParams, error) {
	var params TeamsGetMembershipForUserLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsAddOrUpdateMembershipForUserLegacyParams(r *http.Request) (TeamsAddOrUpdateMembershipForUserLegacyParams, error) {
	var params TeamsAddOrUpdateMembershipForUserLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsRemoveMembershipForUserLegacyParams(r *http.Request) (TeamsRemoveMembershipForUserLegacyParams, error) {
	var params TeamsRemoveMembershipForUserLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsListProjectsLegacyParams(r *http.Request) (TeamsListProjectsLegacyParams, error) {
	var params TeamsListProjectsLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsCheckPermissionsForProjectLegacyParams(r *http.Request) (TeamsCheckPermissionsForProjectLegacyParams, error) {
	var params TeamsCheckPermissionsForProjectLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeTeamsAddOrUpdateProjectPermissionsLegacyParams(r *http.Request) (TeamsAddOrUpdateProjectPermissionsLegacyParams, error) {
	var params TeamsAddOrUpdateProjectPermissionsLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeTeamsRemoveProjectLegacyParams(r *http.Request) (TeamsRemoveProjectLegacyParams, error) {
	var params TeamsRemoveProjectLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeTeamsListReposLegacyParams(r *http.Request) (TeamsListReposLegacyParams, error) {
	var params TeamsListReposLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsCheckPermissionsForRepoLegacyParams(r *http.Request) (TeamsCheckPermissionsForRepoLegacyParams, error) {
	var params TeamsCheckPermissionsForRepoLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeTeamsAddOrUpdateRepoPermissionsLegacyParams(r *http.Request) (TeamsAddOrUpdateRepoPermissionsLegacyParams, error) {
	var params TeamsAddOrUpdateRepoPermissionsLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeTeamsRemoveRepoLegacyParams(r *http.Request) (TeamsRemoveRepoLegacyParams, error) {
	var params TeamsRemoveRepoLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeTeamsListIdpGroupsForLegacyParams(r *http.Request) (TeamsListIdpGroupsForLegacyParams, error) {
	var params TeamsListIdpGroupsForLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}

	return params, nil
}

func decodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyParams(r *http.Request) (TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams, error) {
	var params TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}

	return params, nil
}

func decodeTeamsListChildLegacyParams(r *http.Request) (TeamsListChildLegacyParams, error) {
	var params TeamsListChildLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersCheckBlockedParams(r *http.Request) (UsersCheckBlockedParams, error) {
	var params UsersCheckBlockedParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeUsersBlockParams(r *http.Request) (UsersBlockParams, error) {
	var params UsersBlockParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeUsersUnblockParams(r *http.Request) (UsersUnblockParams, error) {
	var params UsersUnblockParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeUsersListEmailsForAuthenticatedParams(r *http.Request) (UsersListEmailsForAuthenticatedParams, error) {
	var params UsersListEmailsForAuthenticatedParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersListFollowersForAuthenticatedUserParams(r *http.Request) (UsersListFollowersForAuthenticatedUserParams, error) {
	var params UsersListFollowersForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersListFollowedByAuthenticatedParams(r *http.Request) (UsersListFollowedByAuthenticatedParams, error) {
	var params UsersListFollowedByAuthenticatedParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersCheckPersonIsFollowedByAuthenticatedParams(r *http.Request) (UsersCheckPersonIsFollowedByAuthenticatedParams, error) {
	var params UsersCheckPersonIsFollowedByAuthenticatedParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeUsersFollowParams(r *http.Request) (UsersFollowParams, error) {
	var params UsersFollowParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeUsersUnfollowParams(r *http.Request) (UsersUnfollowParams, error) {
	var params UsersUnfollowParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeUsersListGpgKeysForAuthenticatedParams(r *http.Request) (UsersListGpgKeysForAuthenticatedParams, error) {
	var params UsersListGpgKeysForAuthenticatedParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersGetGpgKeyForAuthenticatedParams(r *http.Request) (UsersGetGpgKeyForAuthenticatedParams, error) {
	var params UsersGetGpgKeyForAuthenticatedParams
	{
		param := chi.URLParam(r, "gpg_key_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gpg_key_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gpg_key_id': %w", err)
		}

		params.GpgKeyID = v
	}

	return params, nil
}

func decodeUsersDeleteGpgKeyForAuthenticatedParams(r *http.Request) (UsersDeleteGpgKeyForAuthenticatedParams, error) {
	var params UsersDeleteGpgKeyForAuthenticatedParams
	{
		param := chi.URLParam(r, "gpg_key_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gpg_key_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gpg_key_id': %w", err)
		}

		params.GpgKeyID = v
	}

	return params, nil
}

func decodeAppsListInstallationsForAuthenticatedUserParams(r *http.Request) (AppsListInstallationsForAuthenticatedUserParams, error) {
	var params AppsListInstallationsForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeAppsListInstallationReposForAuthenticatedUserParams(r *http.Request) (AppsListInstallationReposForAuthenticatedUserParams, error) {
	var params AppsListInstallationReposForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "installation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'installation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'installation_id': %w", err)
		}

		params.InstallationID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeAppsAddRepoToInstallationParams(r *http.Request) (AppsAddRepoToInstallationParams, error) {
	var params AppsAddRepoToInstallationParams
	{
		param := chi.URLParam(r, "installation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'installation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'installation_id': %w", err)
		}

		params.InstallationID = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeAppsRemoveRepoFromInstallationParams(r *http.Request) (AppsRemoveRepoFromInstallationParams, error) {
	var params AppsRemoveRepoFromInstallationParams
	{
		param := chi.URLParam(r, "installation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'installation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'installation_id': %w", err)
		}

		params.InstallationID = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeIssuesListForAuthenticatedUserParams(r *http.Request) (IssuesListForAuthenticatedUserParams, error) {
	var params IssuesListForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("filter")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'filter': %w", err)
			}

			params.Filter = v
		}
	}
	{
		param := r.URL.Query().Get("state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'state': %w", err)
			}

			params.State = v
		}
	}
	{
		param := r.URL.Query().Get("labels")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'labels': %w", err)
			}

			params.Labels = v
		}
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersListPublicSSHKeysForAuthenticatedParams(r *http.Request) (UsersListPublicSSHKeysForAuthenticatedParams, error) {
	var params UsersListPublicSSHKeysForAuthenticatedParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersGetPublicSSHKeyForAuthenticatedParams(r *http.Request) (UsersGetPublicSSHKeyForAuthenticatedParams, error) {
	var params UsersGetPublicSSHKeyForAuthenticatedParams
	{
		param := chi.URLParam(r, "key_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'key_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'key_id': %w", err)
		}

		params.KeyID = v
	}

	return params, nil
}

func decodeUsersDeletePublicSSHKeyForAuthenticatedParams(r *http.Request) (UsersDeletePublicSSHKeyForAuthenticatedParams, error) {
	var params UsersDeletePublicSSHKeyForAuthenticatedParams
	{
		param := chi.URLParam(r, "key_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'key_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'key_id': %w", err)
		}

		params.KeyID = v
	}

	return params, nil
}

func decodeAppsListSubscriptionsForAuthenticatedUserParams(r *http.Request) (AppsListSubscriptionsForAuthenticatedUserParams, error) {
	var params AppsListSubscriptionsForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeAppsListSubscriptionsForAuthenticatedUserStubbedParams(r *http.Request) (AppsListSubscriptionsForAuthenticatedUserStubbedParams, error) {
	var params AppsListSubscriptionsForAuthenticatedUserStubbedParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsListMembershipsForAuthenticatedUserParams(r *http.Request) (OrgsListMembershipsForAuthenticatedUserParams, error) {
	var params OrgsListMembershipsForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'state': %w", err)
			}

			params.State = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsGetMembershipForAuthenticatedUserParams(r *http.Request) (OrgsGetMembershipForAuthenticatedUserParams, error) {
	var params OrgsGetMembershipForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeOrgsUpdateMembershipForAuthenticatedUserParams(r *http.Request) (OrgsUpdateMembershipForAuthenticatedUserParams, error) {
	var params OrgsUpdateMembershipForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeMigrationsListForAuthenticatedUserParams(r *http.Request) (MigrationsListForAuthenticatedUserParams, error) {
	var params MigrationsListForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeMigrationsGetStatusForAuthenticatedUserParams(r *http.Request) (MigrationsGetStatusForAuthenticatedUserParams, error) {
	var params MigrationsGetStatusForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}
	{
		param := r.URL.Query().Get("exclude")
		if len(param) > 0 {
			v, err := conv.ToStringArray(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'exclude': %w", err)
			}

			params.Exclude = v
		}
	}

	return params, nil
}

func decodeMigrationsGetArchiveForAuthenticatedUserParams(r *http.Request) (MigrationsGetArchiveForAuthenticatedUserParams, error) {
	var params MigrationsGetArchiveForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}

	return params, nil
}

func decodeMigrationsDeleteArchiveForAuthenticatedUserParams(r *http.Request) (MigrationsDeleteArchiveForAuthenticatedUserParams, error) {
	var params MigrationsDeleteArchiveForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}

	return params, nil
}

func decodeMigrationsUnlockRepoForAuthenticatedUserParams(r *http.Request) (MigrationsUnlockRepoForAuthenticatedUserParams, error) {
	var params MigrationsUnlockRepoForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}
	{
		param := chi.URLParam(r, "repo_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo_name': %w", err)
		}

		params.RepoName = v
	}

	return params, nil
}

func decodeMigrationsListReposForUserParams(r *http.Request) (MigrationsListReposForUserParams, error) {
	var params MigrationsListReposForUserParams
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsListForAuthenticatedUserParams(r *http.Request) (OrgsListForAuthenticatedUserParams, error) {
	var params OrgsListForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodePackagesListPackagesForAuthenticatedUserParams(r *http.Request) (PackagesListPackagesForAuthenticatedUserParams, error) {
	var params PackagesListPackagesForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("query param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse query param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := r.URL.Query().Get("visibility")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'visibility': %w", err)
			}

			params.Visibility = v
		}
	}

	return params, nil
}

func decodePackagesGetPackageForAuthenticatedUserParams(r *http.Request) (PackagesGetPackageForAuthenticatedUserParams, error) {
	var params PackagesGetPackageForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}

	return params, nil
}

func decodePackagesDeletePackageForAuthenticatedUserParams(r *http.Request) (PackagesDeletePackageForAuthenticatedUserParams, error) {
	var params PackagesDeletePackageForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}

	return params, nil
}

func decodePackagesRestorePackageForAuthenticatedUserParams(r *http.Request) (PackagesRestorePackageForAuthenticatedUserParams, error) {
	var params PackagesRestorePackageForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := r.URL.Query().Get("token")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'token': %w", err)
			}

			params.Token = v
		}
	}

	return params, nil
}

func decodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams(r *http.Request) (PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams, error) {
	var params PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'state': %w", err)
			}

			params.State = v
		}
	}

	return params, nil
}

func decodePackagesGetPackageVersionForAuthenticatedUserParams(r *http.Request) (PackagesGetPackageVersionForAuthenticatedUserParams, error) {
	var params PackagesGetPackageVersionForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "package_version_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_version_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_version_id': %w", err)
		}

		params.PackageVersionID = v
	}

	return params, nil
}

func decodePackagesDeletePackageVersionForAuthenticatedUserParams(r *http.Request) (PackagesDeletePackageVersionForAuthenticatedUserParams, error) {
	var params PackagesDeletePackageVersionForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "package_version_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_version_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_version_id': %w", err)
		}

		params.PackageVersionID = v
	}

	return params, nil
}

func decodePackagesRestorePackageVersionForAuthenticatedUserParams(r *http.Request) (PackagesRestorePackageVersionForAuthenticatedUserParams, error) {
	var params PackagesRestorePackageVersionForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "package_version_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_version_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_version_id': %w", err)
		}

		params.PackageVersionID = v
	}

	return params, nil
}

func decodeUsersListPublicEmailsForAuthenticatedParams(r *http.Request) (UsersListPublicEmailsForAuthenticatedParams, error) {
	var params UsersListPublicEmailsForAuthenticatedParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposListForAuthenticatedUserParams(r *http.Request) (ReposListForAuthenticatedUserParams, error) {
	var params ReposListForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("visibility")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'visibility': %w", err)
			}

			params.Visibility = v
		}
	}
	{
		param := r.URL.Query().Get("affiliation")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'affiliation': %w", err)
			}

			params.Affiliation = v
		}
	}
	{
		param := r.URL.Query().Get("type")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'type': %w", err)
			}

			params.Type = v
		}
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("before")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'before': %w", err)
			}

			params.Before = v
		}
	}

	return params, nil
}

func decodeReposListInvitationsForAuthenticatedUserParams(r *http.Request) (ReposListInvitationsForAuthenticatedUserParams, error) {
	var params ReposListInvitationsForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposDeclineInvitationParams(r *http.Request) (ReposDeclineInvitationParams, error) {
	var params ReposDeclineInvitationParams
	{
		param := chi.URLParam(r, "invitation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'invitation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'invitation_id': %w", err)
		}

		params.InvitationID = v
	}

	return params, nil
}

func decodeReposAcceptInvitationParams(r *http.Request) (ReposAcceptInvitationParams, error) {
	var params ReposAcceptInvitationParams
	{
		param := chi.URLParam(r, "invitation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'invitation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'invitation_id': %w", err)
		}

		params.InvitationID = v
	}

	return params, nil
}

func decodeActivityListReposStarredByAuthenticatedUserParams(r *http.Request) (ActivityListReposStarredByAuthenticatedUserParams, error) {
	var params ActivityListReposStarredByAuthenticatedUserParams
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityCheckRepoIsStarredByAuthenticatedUserParams(r *http.Request) (ActivityCheckRepoIsStarredByAuthenticatedUserParams, error) {
	var params ActivityCheckRepoIsStarredByAuthenticatedUserParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActivityStarRepoForAuthenticatedUserParams(r *http.Request) (ActivityStarRepoForAuthenticatedUserParams, error) {
	var params ActivityStarRepoForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActivityUnstarRepoForAuthenticatedUserParams(r *http.Request) (ActivityUnstarRepoForAuthenticatedUserParams, error) {
	var params ActivityUnstarRepoForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActivityListWatchedReposForAuthenticatedUserParams(r *http.Request) (ActivityListWatchedReposForAuthenticatedUserParams, error) {
	var params ActivityListWatchedReposForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsListForAuthenticatedUserParams(r *http.Request) (TeamsListForAuthenticatedUserParams, error) {
	var params TeamsListForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersListParams(r *http.Request) (UsersListParams, error) {
	var params UsersListParams
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}

	return params, nil
}

func decodeUsersGetByUsernameParams(r *http.Request) (UsersGetByUsernameParams, error) {
	var params UsersGetByUsernameParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeActivityListEventsForAuthenticatedUserParams(r *http.Request) (ActivityListEventsForAuthenticatedUserParams, error) {
	var params ActivityListEventsForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityListOrgEventsForAuthenticatedUserParams(r *http.Request) (ActivityListOrgEventsForAuthenticatedUserParams, error) {
	var params ActivityListOrgEventsForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityListPublicEventsForUserParams(r *http.Request) (ActivityListPublicEventsForUserParams, error) {
	var params ActivityListPublicEventsForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersListFollowersForUserParams(r *http.Request) (UsersListFollowersForUserParams, error) {
	var params UsersListFollowersForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersListFollowingForUserParams(r *http.Request) (UsersListFollowingForUserParams, error) {
	var params UsersListFollowingForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersCheckFollowingForUserParams(r *http.Request) (UsersCheckFollowingForUserParams, error) {
	var params UsersCheckFollowingForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := chi.URLParam(r, "target_user")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'target_user' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'target_user': %w", err)
		}

		params.TargetUser = v
	}

	return params, nil
}

func decodeGistsListForUserParams(r *http.Request) (GistsListForUserParams, error) {
	var params GistsListForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersListGpgKeysForUserParams(r *http.Request) (UsersListGpgKeysForUserParams, error) {
	var params UsersListGpgKeysForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersGetContextForUserParams(r *http.Request) (UsersGetContextForUserParams, error) {
	var params UsersGetContextForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("subject_type")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'subject_type': %w", err)
			}

			params.SubjectType = v
		}
	}
	{
		param := r.URL.Query().Get("subject_id")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'subject_id': %w", err)
			}

			params.SubjectID = v
		}
	}

	return params, nil
}

func decodeAppsGetUserInstallationParams(r *http.Request) (AppsGetUserInstallationParams, error) {
	var params AppsGetUserInstallationParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeUsersListPublicKeysForUserParams(r *http.Request) (UsersListPublicKeysForUserParams, error) {
	var params UsersListPublicKeysForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsListForUserParams(r *http.Request) (OrgsListForUserParams, error) {
	var params OrgsListForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodePackagesListPackagesForUserParams(r *http.Request) (PackagesListPackagesForUserParams, error) {
	var params PackagesListPackagesForUserParams
	{
		param := r.URL.Query().Get("package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("query param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse query param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := r.URL.Query().Get("visibility")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'visibility': %w", err)
			}

			params.Visibility = v
		}
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodePackagesGetPackageForUserParams(r *http.Request) (PackagesGetPackageForUserParams, error) {
	var params PackagesGetPackageForUserParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodePackagesDeletePackageForUserParams(r *http.Request) (PackagesDeletePackageForUserParams, error) {
	var params PackagesDeletePackageForUserParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodePackagesRestorePackageForUserParams(r *http.Request) (PackagesRestorePackageForUserParams, error) {
	var params PackagesRestorePackageForUserParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("token")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'token': %w", err)
			}

			params.Token = v
		}
	}

	return params, nil
}

func decodePackagesGetAllPackageVersionsForPackageOwnedByUserParams(r *http.Request) (PackagesGetAllPackageVersionsForPackageOwnedByUserParams, error) {
	var params PackagesGetAllPackageVersionsForPackageOwnedByUserParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodePackagesGetPackageVersionForUserParams(r *http.Request) (PackagesGetPackageVersionForUserParams, error) {
	var params PackagesGetPackageVersionForUserParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "package_version_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_version_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_version_id': %w", err)
		}

		params.PackageVersionID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodePackagesDeletePackageVersionForUserParams(r *http.Request) (PackagesDeletePackageVersionForUserParams, error) {
	var params PackagesDeletePackageVersionForUserParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := chi.URLParam(r, "package_version_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_version_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_version_id': %w", err)
		}

		params.PackageVersionID = v
	}

	return params, nil
}

func decodePackagesRestorePackageVersionForUserParams(r *http.Request) (PackagesRestorePackageVersionForUserParams, error) {
	var params PackagesRestorePackageVersionForUserParams
	{
		param := chi.URLParam(r, "package_type")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_type' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_type': %w", err)
		}

		params.PackageType = v
	}
	{
		param := chi.URLParam(r, "package_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_name': %w", err)
		}

		params.PackageName = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := chi.URLParam(r, "package_version_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'package_version_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'package_version_id': %w", err)
		}

		params.PackageVersionID = v
	}

	return params, nil
}

func decodeProjectsListForUserParams(r *http.Request) (ProjectsListForUserParams, error) {
	var params ProjectsListForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("state")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'state': %w", err)
			}

			params.State = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityListReceivedEventsForUserParams(r *http.Request) (ActivityListReceivedEventsForUserParams, error) {
	var params ActivityListReceivedEventsForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityListReceivedPublicEventsForUserParams(r *http.Request) (ActivityListReceivedPublicEventsForUserParams, error) {
	var params ActivityListReceivedPublicEventsForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposListForUserParams(r *http.Request) (ReposListForUserParams, error) {
	var params ReposListForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("type")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'type': %w", err)
			}

			params.Type = v
		}
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeBillingGetGithubActionsBillingUserParams(r *http.Request) (BillingGetGithubActionsBillingUserParams, error) {
	var params BillingGetGithubActionsBillingUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeBillingGetGithubPackagesBillingUserParams(r *http.Request) (BillingGetGithubPackagesBillingUserParams, error) {
	var params BillingGetGithubPackagesBillingUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeBillingGetSharedStorageBillingUserParams(r *http.Request) (BillingGetSharedStorageBillingUserParams, error) {
	var params BillingGetSharedStorageBillingUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeActivityListReposStarredByUserParams(r *http.Request) (ActivityListReposStarredByUserParams, error) {
	var params ActivityListReposStarredByUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("sort")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sort': %w", err)
			}

			params.Sort = v
		}
	}
	{
		param := r.URL.Query().Get("direction")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'direction': %w", err)
			}

			params.Direction = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityListReposWatchedByUserParams(r *http.Request) (ActivityListReposWatchedByUserParams, error) {
	var params ActivityListReposWatchedByUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}
