// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/json"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = chi.Context{}
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
)

func decodeAppsDeleteInstallationParams(r *http.Request) (AppsDeleteInstallationParams, error) {
	var params AppsDeleteInstallationParams
	{
		param := chi.URLParam(r, "installation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'installation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'installation_id': %w", err)
		}

		params.InstallationID = v
	}

	return params, nil
}

func decodeAppsSuspendInstallationParams(r *http.Request) (AppsSuspendInstallationParams, error) {
	var params AppsSuspendInstallationParams
	{
		param := chi.URLParam(r, "installation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'installation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'installation_id': %w", err)
		}

		params.InstallationID = v
	}

	return params, nil
}

func decodeAppsUnsuspendInstallationParams(r *http.Request) (AppsUnsuspendInstallationParams, error) {
	var params AppsUnsuspendInstallationParams
	{
		param := chi.URLParam(r, "installation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'installation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'installation_id': %w", err)
		}

		params.InstallationID = v
	}

	return params, nil
}

func decodeOAuthAuthorizationsListGrantsParams(r *http.Request) (OAuthAuthorizationsListGrantsParams, error) {
	var params OAuthAuthorizationsListGrantsParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("client_id")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'client_id': %w", err)
			}

			params.ClientID = v
		}
	}

	return params, nil
}

func decodeOAuthAuthorizationsGetGrantParams(r *http.Request) (OAuthAuthorizationsGetGrantParams, error) {
	var params OAuthAuthorizationsGetGrantParams
	{
		param := chi.URLParam(r, "grant_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'grant_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'grant_id': %w", err)
		}

		params.GrantID = v
	}

	return params, nil
}

func decodeOAuthAuthorizationsDeleteGrantParams(r *http.Request) (OAuthAuthorizationsDeleteGrantParams, error) {
	var params OAuthAuthorizationsDeleteGrantParams
	{
		param := chi.URLParam(r, "grant_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'grant_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'grant_id': %w", err)
		}

		params.GrantID = v
	}

	return params, nil
}

func decodeAppsGetBySlugParams(r *http.Request) (AppsGetBySlugParams, error) {
	var params AppsGetBySlugParams
	{
		param := chi.URLParam(r, "app_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'app_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'app_slug': %w", err)
		}

		params.AppSlug = v
	}

	return params, nil
}

func decodeOAuthAuthorizationsListAuthorizationsParams(r *http.Request) (OAuthAuthorizationsListAuthorizationsParams, error) {
	var params OAuthAuthorizationsListAuthorizationsParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("client_id")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'client_id': %w", err)
			}

			params.ClientID = v
		}
	}

	return params, nil
}

func decodeOAuthAuthorizationsGetAuthorizationParams(r *http.Request) (OAuthAuthorizationsGetAuthorizationParams, error) {
	var params OAuthAuthorizationsGetAuthorizationParams
	{
		param := chi.URLParam(r, "authorization_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'authorization_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'authorization_id': %w", err)
		}

		params.AuthorizationID = v
	}

	return params, nil
}

func decodeOAuthAuthorizationsDeleteAuthorizationParams(r *http.Request) (OAuthAuthorizationsDeleteAuthorizationParams, error) {
	var params OAuthAuthorizationsDeleteAuthorizationParams
	{
		param := chi.URLParam(r, "authorization_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'authorization_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'authorization_id': %w", err)
		}

		params.AuthorizationID = v
	}

	return params, nil
}

func decodeCodesOfConductGetConductCodeParams(r *http.Request) (CodesOfConductGetConductCodeParams, error) {
	var params CodesOfConductGetConductCodeParams
	{
		param := chi.URLParam(r, "key")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'key' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'key': %w", err)
		}

		params.Key = v
	}

	return params, nil
}

func decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams(r *http.Request) (EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams, error) {
	var params EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams(r *http.Request) (EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams, error) {
	var params EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams(r *http.Request) (EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams, error) {
	var params EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams(r *http.Request) (EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams, error) {
	var params EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams(r *http.Request) (EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams, error) {
	var params EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "org_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org_id': %w", err)
		}

		params.OrgID = v
	}

	return params, nil
}

func decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams(r *http.Request) (EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams, error) {
	var params EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "org_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org_id': %w", err)
		}

		params.OrgID = v
	}

	return params, nil
}

func decodeEnterpriseAdminGetAllowedActionsEnterpriseParams(r *http.Request) (EnterpriseAdminGetAllowedActionsEnterpriseParams, error) {
	var params EnterpriseAdminGetAllowedActionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminSetAllowedActionsEnterpriseParams(r *http.Request) (EnterpriseAdminSetAllowedActionsEnterpriseParams, error) {
	var params EnterpriseAdminSetAllowedActionsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams(r *http.Request) (EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams, error) {
	var params EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams(r *http.Request) (EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams, error) {
	var params EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams(r *http.Request) (EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams, error) {
	var params EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams(r *http.Request) (EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams, error) {
	var params EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams(r *http.Request) (EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams, error) {
	var params EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r *http.Request) (EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var params EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r *http.Request) (EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var params EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r *http.Request) (EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var params EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "org_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org_id': %w", err)
		}

		params.OrgID = v
	}

	return params, nil
}

func decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(r *http.Request) (EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, error) {
	var params EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "org_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org_id': %w", err)
		}

		params.OrgID = v
	}

	return params, nil
}

func decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams(r *http.Request) (EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams, error) {
	var params EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams(r *http.Request) (EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams, error) {
	var params EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams(r *http.Request) (EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams, error) {
	var params EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams(r *http.Request) (EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams, error) {
	var params EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseParams(r *http.Request) (EnterpriseAdminListSelfHostedRunnersForEnterpriseParams, error) {
	var params EnterpriseAdminListSelfHostedRunnersForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminListRunnerApplicationsForEnterpriseParams(r *http.Request) (EnterpriseAdminListRunnerApplicationsForEnterpriseParams, error) {
	var params EnterpriseAdminListRunnerApplicationsForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseParams(r *http.Request) (EnterpriseAdminCreateRegistrationTokenForEnterpriseParams, error) {
	var params EnterpriseAdminCreateRegistrationTokenForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminCreateRemoveTokenForEnterpriseParams(r *http.Request) (EnterpriseAdminCreateRemoveTokenForEnterpriseParams, error) {
	var params EnterpriseAdminCreateRemoveTokenForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams(r *http.Request) (EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams, error) {
	var params EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams(r *http.Request) (EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams, error) {
	var params EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeBillingGetGithubActionsBillingGheParams(r *http.Request) (BillingGetGithubActionsBillingGheParams, error) {
	var params BillingGetGithubActionsBillingGheParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeBillingGetGithubPackagesBillingGheParams(r *http.Request) (BillingGetGithubPackagesBillingGheParams, error) {
	var params BillingGetGithubPackagesBillingGheParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeBillingGetSharedStorageBillingGheParams(r *http.Request) (BillingGetSharedStorageBillingGheParams, error) {
	var params BillingGetSharedStorageBillingGheParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeActivityListPublicEventsParams(r *http.Request) (ActivityListPublicEventsParams, error) {
	var params ActivityListPublicEventsParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGistsListParams(r *http.Request) (GistsListParams, error) {
	var params GistsListParams
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGistsListStarredParams(r *http.Request) (GistsListStarredParams, error) {
	var params GistsListStarredParams
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGistsGetParams(r *http.Request) (GistsGetParams, error) {
	var params GistsGetParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}

	return params, nil
}

func decodeGistsDeleteParams(r *http.Request) (GistsDeleteParams, error) {
	var params GistsDeleteParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}

	return params, nil
}

func decodeGistsListCommentsParams(r *http.Request) (GistsListCommentsParams, error) {
	var params GistsListCommentsParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGistsCreateCommentParams(r *http.Request) (GistsCreateCommentParams, error) {
	var params GistsCreateCommentParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}

	return params, nil
}

func decodeGistsGetCommentParams(r *http.Request) (GistsGetCommentParams, error) {
	var params GistsGetCommentParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeGistsDeleteCommentParams(r *http.Request) (GistsDeleteCommentParams, error) {
	var params GistsDeleteCommentParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeGistsUpdateCommentParams(r *http.Request) (GistsUpdateCommentParams, error) {
	var params GistsUpdateCommentParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeGistsListCommitsParams(r *http.Request) (GistsListCommitsParams, error) {
	var params GistsListCommitsParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGistsListForksParams(r *http.Request) (GistsListForksParams, error) {
	var params GistsListForksParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGistsCheckIsStarredParams(r *http.Request) (GistsCheckIsStarredParams, error) {
	var params GistsCheckIsStarredParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}

	return params, nil
}

func decodeGistsStarParams(r *http.Request) (GistsStarParams, error) {
	var params GistsStarParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}

	return params, nil
}

func decodeGistsUnstarParams(r *http.Request) (GistsUnstarParams, error) {
	var params GistsUnstarParams
	{
		param := chi.URLParam(r, "gist_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gist_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gist_id': %w", err)
		}

		params.GistID = v
	}

	return params, nil
}

func decodeGitignoreGetTemplateParams(r *http.Request) (GitignoreGetTemplateParams, error) {
	var params GitignoreGetTemplateParams
	{
		param := chi.URLParam(r, "name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'name': %w", err)
		}

		params.Name = v
	}

	return params, nil
}

func decodeAppsListReposAccessibleToInstallationParams(r *http.Request) (AppsListReposAccessibleToInstallationParams, error) {
	var params AppsListReposAccessibleToInstallationParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeLicensesGetAllCommonlyUsedParams(r *http.Request) (LicensesGetAllCommonlyUsedParams, error) {
	var params LicensesGetAllCommonlyUsedParams
	{
		param := r.URL.Query().Get("featured")
		if len(param) > 0 {
			v, err := conv.ToBool(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'featured': %w", err)
			}

			params.Featured = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeLicensesGetParams(r *http.Request) (LicensesGetParams, error) {
	var params LicensesGetParams
	{
		param := chi.URLParam(r, "license")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'license' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'license': %w", err)
		}

		params.License = v
	}

	return params, nil
}

func decodeAppsGetSubscriptionPlanForAccountParams(r *http.Request) (AppsGetSubscriptionPlanForAccountParams, error) {
	var params AppsGetSubscriptionPlanForAccountParams
	{
		param := chi.URLParam(r, "account_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'account_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'account_id': %w", err)
		}

		params.AccountID = v
	}

	return params, nil
}

func decodeAppsListPlansParams(r *http.Request) (AppsListPlansParams, error) {
	var params AppsListPlansParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeAppsGetSubscriptionPlanForAccountStubbedParams(r *http.Request) (AppsGetSubscriptionPlanForAccountStubbedParams, error) {
	var params AppsGetSubscriptionPlanForAccountStubbedParams
	{
		param := chi.URLParam(r, "account_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'account_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'account_id': %w", err)
		}

		params.AccountID = v
	}

	return params, nil
}

func decodeAppsListPlansStubbedParams(r *http.Request) (AppsListPlansStubbedParams, error) {
	var params AppsListPlansStubbedParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityListPublicEventsForRepoNetworkParams(r *http.Request) (ActivityListPublicEventsForRepoNetworkParams, error) {
	var params ActivityListPublicEventsForRepoNetworkParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityGetThreadParams(r *http.Request) (ActivityGetThreadParams, error) {
	var params ActivityGetThreadParams
	{
		param := chi.URLParam(r, "thread_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'thread_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'thread_id': %w", err)
		}

		params.ThreadID = v
	}

	return params, nil
}

func decodeActivityMarkThreadAsReadParams(r *http.Request) (ActivityMarkThreadAsReadParams, error) {
	var params ActivityMarkThreadAsReadParams
	{
		param := chi.URLParam(r, "thread_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'thread_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'thread_id': %w", err)
		}

		params.ThreadID = v
	}

	return params, nil
}

func decodeActivityGetThreadSubscriptionForAuthenticatedUserParams(r *http.Request) (ActivityGetThreadSubscriptionForAuthenticatedUserParams, error) {
	var params ActivityGetThreadSubscriptionForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "thread_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'thread_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'thread_id': %w", err)
		}

		params.ThreadID = v
	}

	return params, nil
}

func decodeActivitySetThreadSubscriptionParams(r *http.Request) (ActivitySetThreadSubscriptionParams, error) {
	var params ActivitySetThreadSubscriptionParams
	{
		param := chi.URLParam(r, "thread_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'thread_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'thread_id': %w", err)
		}

		params.ThreadID = v
	}

	return params, nil
}

func decodeActivityDeleteThreadSubscriptionParams(r *http.Request) (ActivityDeleteThreadSubscriptionParams, error) {
	var params ActivityDeleteThreadSubscriptionParams
	{
		param := chi.URLParam(r, "thread_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'thread_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'thread_id': %w", err)
		}

		params.ThreadID = v
	}

	return params, nil
}

func decodeMetaGetOctocatParams(r *http.Request) (MetaGetOctocatParams, error) {
	var params MetaGetOctocatParams
	{
		param := r.URL.Query().Get("s")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 's': %w", err)
			}

			params.S = v
		}
	}

	return params, nil
}

func decodeOrgsListParams(r *http.Request) (OrgsListParams, error) {
	var params OrgsListParams
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}

	return params, nil
}

func decodeOrgsGetParams(r *http.Request) (OrgsGetParams, error) {
	var params OrgsGetParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsGetGithubActionsPermissionsOrganizationParams(r *http.Request) (ActionsGetGithubActionsPermissionsOrganizationParams, error) {
	var params ActionsGetGithubActionsPermissionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsSetGithubActionsPermissionsOrganizationParams(r *http.Request) (ActionsSetGithubActionsPermissionsOrganizationParams, error) {
	var params ActionsSetGithubActionsPermissionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams(r *http.Request) (ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams, error) {
	var params ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams(r *http.Request) (ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams, error) {
	var params ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsEnableSelectedRepositoryGithubActionsOrganizationParams(r *http.Request) (ActionsEnableSelectedRepositoryGithubActionsOrganizationParams, error) {
	var params ActionsEnableSelectedRepositoryGithubActionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeActionsDisableSelectedRepositoryGithubActionsOrganizationParams(r *http.Request) (ActionsDisableSelectedRepositoryGithubActionsOrganizationParams, error) {
	var params ActionsDisableSelectedRepositoryGithubActionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeActionsGetAllowedActionsOrganizationParams(r *http.Request) (ActionsGetAllowedActionsOrganizationParams, error) {
	var params ActionsGetAllowedActionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsSetAllowedActionsOrganizationParams(r *http.Request) (ActionsSetAllowedActionsOrganizationParams, error) {
	var params ActionsSetAllowedActionsOrganizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsListSelfHostedRunnerGroupsForOrgParams(r *http.Request) (ActionsListSelfHostedRunnerGroupsForOrgParams, error) {
	var params ActionsListSelfHostedRunnerGroupsForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsCreateSelfHostedRunnerGroupForOrgParams(r *http.Request) (ActionsCreateSelfHostedRunnerGroupForOrgParams, error) {
	var params ActionsCreateSelfHostedRunnerGroupForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsGetSelfHostedRunnerGroupForOrgParams(r *http.Request) (ActionsGetSelfHostedRunnerGroupForOrgParams, error) {
	var params ActionsGetSelfHostedRunnerGroupForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeActionsDeleteSelfHostedRunnerGroupFromOrgParams(r *http.Request) (ActionsDeleteSelfHostedRunnerGroupFromOrgParams, error) {
	var params ActionsDeleteSelfHostedRunnerGroupFromOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeActionsUpdateSelfHostedRunnerGroupForOrgParams(r *http.Request) (ActionsUpdateSelfHostedRunnerGroupForOrgParams, error) {
	var params ActionsUpdateSelfHostedRunnerGroupForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams(r *http.Request) (ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var params ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}

	return params, nil
}

func decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams(r *http.Request) (ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var params ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams(r *http.Request) (ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var params ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams(r *http.Request) (ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams, error) {
	var params ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeActionsListSelfHostedRunnersInGroupForOrgParams(r *http.Request) (ActionsListSelfHostedRunnersInGroupForOrgParams, error) {
	var params ActionsListSelfHostedRunnersInGroupForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsSetSelfHostedRunnersInGroupForOrgParams(r *http.Request) (ActionsSetSelfHostedRunnersInGroupForOrgParams, error) {
	var params ActionsSetSelfHostedRunnersInGroupForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}

	return params, nil
}

func decodeActionsAddSelfHostedRunnerToGroupForOrgParams(r *http.Request) (ActionsAddSelfHostedRunnerToGroupForOrgParams, error) {
	var params ActionsAddSelfHostedRunnerToGroupForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeActionsRemoveSelfHostedRunnerFromGroupForOrgParams(r *http.Request) (ActionsRemoveSelfHostedRunnerFromGroupForOrgParams, error) {
	var params ActionsRemoveSelfHostedRunnerFromGroupForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_group_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_group_id': %w", err)
		}

		params.RunnerGroupID = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeActionsListSelfHostedRunnersForOrgParams(r *http.Request) (ActionsListSelfHostedRunnersForOrgParams, error) {
	var params ActionsListSelfHostedRunnersForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsListRunnerApplicationsForOrgParams(r *http.Request) (ActionsListRunnerApplicationsForOrgParams, error) {
	var params ActionsListRunnerApplicationsForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsCreateRegistrationTokenForOrgParams(r *http.Request) (ActionsCreateRegistrationTokenForOrgParams, error) {
	var params ActionsCreateRegistrationTokenForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsCreateRemoveTokenForOrgParams(r *http.Request) (ActionsCreateRemoveTokenForOrgParams, error) {
	var params ActionsCreateRemoveTokenForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsGetSelfHostedRunnerForOrgParams(r *http.Request) (ActionsGetSelfHostedRunnerForOrgParams, error) {
	var params ActionsGetSelfHostedRunnerForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeActionsDeleteSelfHostedRunnerFromOrgParams(r *http.Request) (ActionsDeleteSelfHostedRunnerFromOrgParams, error) {
	var params ActionsDeleteSelfHostedRunnerFromOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeActionsListOrgSecretsParams(r *http.Request) (ActionsListOrgSecretsParams, error) {
	var params ActionsListOrgSecretsParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsGetOrgPublicKeyParams(r *http.Request) (ActionsGetOrgPublicKeyParams, error) {
	var params ActionsGetOrgPublicKeyParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeActionsGetOrgSecretParams(r *http.Request) (ActionsGetOrgSecretParams, error) {
	var params ActionsGetOrgSecretParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsCreateOrUpdateOrgSecretParams(r *http.Request) (ActionsCreateOrUpdateOrgSecretParams, error) {
	var params ActionsCreateOrUpdateOrgSecretParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsDeleteOrgSecretParams(r *http.Request) (ActionsDeleteOrgSecretParams, error) {
	var params ActionsDeleteOrgSecretParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsListSelectedReposForOrgSecretParams(r *http.Request) (ActionsListSelectedReposForOrgSecretParams, error) {
	var params ActionsListSelectedReposForOrgSecretParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}

	return params, nil
}

func decodeActionsSetSelectedReposForOrgSecretParams(r *http.Request) (ActionsSetSelectedReposForOrgSecretParams, error) {
	var params ActionsSetSelectedReposForOrgSecretParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsAddSelectedRepoToOrgSecretParams(r *http.Request) (ActionsAddSelectedRepoToOrgSecretParams, error) {
	var params ActionsAddSelectedRepoToOrgSecretParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeActionsRemoveSelectedRepoFromOrgSecretParams(r *http.Request) (ActionsRemoveSelectedRepoFromOrgSecretParams, error) {
	var params ActionsRemoveSelectedRepoFromOrgSecretParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeOrgsListBlockedUsersParams(r *http.Request) (OrgsListBlockedUsersParams, error) {
	var params OrgsListBlockedUsersParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeOrgsCheckBlockedUserParams(r *http.Request) (OrgsCheckBlockedUserParams, error) {
	var params OrgsCheckBlockedUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsUnblockUserParams(r *http.Request) (OrgsUnblockUserParams, error) {
	var params OrgsUnblockUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsListSamlSSOAuthorizationsParams(r *http.Request) (OrgsListSamlSSOAuthorizationsParams, error) {
	var params OrgsListSamlSSOAuthorizationsParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeOrgsRemoveSamlSSOAuthorizationParams(r *http.Request) (OrgsRemoveSamlSSOAuthorizationParams, error) {
	var params OrgsRemoveSamlSSOAuthorizationParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "credential_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'credential_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'credential_id': %w", err)
		}

		params.CredentialID = v
	}

	return params, nil
}

func decodeActivityListPublicOrgEventsParams(r *http.Request) (ActivityListPublicOrgEventsParams, error) {
	var params ActivityListPublicOrgEventsParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsListFailedInvitationsParams(r *http.Request) (OrgsListFailedInvitationsParams, error) {
	var params OrgsListFailedInvitationsParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsListWebhooksParams(r *http.Request) (OrgsListWebhooksParams, error) {
	var params OrgsListWebhooksParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsGetWebhookParams(r *http.Request) (OrgsGetWebhookParams, error) {
	var params OrgsGetWebhookParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeOrgsDeleteWebhookParams(r *http.Request) (OrgsDeleteWebhookParams, error) {
	var params OrgsDeleteWebhookParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeOrgsPingWebhookParams(r *http.Request) (OrgsPingWebhookParams, error) {
	var params OrgsPingWebhookParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeInteractionsRemoveRestrictionsForOrgParams(r *http.Request) (InteractionsRemoveRestrictionsForOrgParams, error) {
	var params InteractionsRemoveRestrictionsForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeOrgsListPendingInvitationsParams(r *http.Request) (OrgsListPendingInvitationsParams, error) {
	var params OrgsListPendingInvitationsParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsListInvitationTeamsParams(r *http.Request) (OrgsListInvitationTeamsParams, error) {
	var params OrgsListInvitationTeamsParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "invitation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'invitation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'invitation_id': %w", err)
		}

		params.InvitationID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsCheckMembershipForUserParams(r *http.Request) (OrgsCheckMembershipForUserParams, error) {
	var params OrgsCheckMembershipForUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsRemoveMemberParams(r *http.Request) (OrgsRemoveMemberParams, error) {
	var params OrgsRemoveMemberParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsGetMembershipForUserParams(r *http.Request) (OrgsGetMembershipForUserParams, error) {
	var params OrgsGetMembershipForUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsRemoveMembershipForUserParams(r *http.Request) (OrgsRemoveMembershipForUserParams, error) {
	var params OrgsRemoveMembershipForUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeMigrationsDownloadArchiveForOrgParams(r *http.Request) (MigrationsDownloadArchiveForOrgParams, error) {
	var params MigrationsDownloadArchiveForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}

	return params, nil
}

func decodeMigrationsDeleteArchiveForOrgParams(r *http.Request) (MigrationsDeleteArchiveForOrgParams, error) {
	var params MigrationsDeleteArchiveForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}

	return params, nil
}

func decodeMigrationsUnlockRepoForOrgParams(r *http.Request) (MigrationsUnlockRepoForOrgParams, error) {
	var params MigrationsUnlockRepoForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}
	{
		param := chi.URLParam(r, "repo_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo_name': %w", err)
		}

		params.RepoName = v
	}

	return params, nil
}

func decodeMigrationsListReposForOrgParams(r *http.Request) (MigrationsListReposForOrgParams, error) {
	var params MigrationsListReposForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsConvertMemberToOutsideCollaboratorParams(r *http.Request) (OrgsConvertMemberToOutsideCollaboratorParams, error) {
	var params OrgsConvertMemberToOutsideCollaboratorParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsRemoveOutsideCollaboratorParams(r *http.Request) (OrgsRemoveOutsideCollaboratorParams, error) {
	var params OrgsRemoveOutsideCollaboratorParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeProjectsCreateForOrgParams(r *http.Request) (ProjectsCreateForOrgParams, error) {
	var params ProjectsCreateForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeOrgsListPublicMembersParams(r *http.Request) (OrgsListPublicMembersParams, error) {
	var params OrgsListPublicMembersParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsCheckPublicMembershipForUserParams(r *http.Request) (OrgsCheckPublicMembershipForUserParams, error) {
	var params OrgsCheckPublicMembershipForUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsSetPublicMembershipForAuthenticatedUserParams(r *http.Request) (OrgsSetPublicMembershipForAuthenticatedUserParams, error) {
	var params OrgsSetPublicMembershipForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeOrgsRemovePublicMembershipForAuthenticatedUserParams(r *http.Request) (OrgsRemovePublicMembershipForAuthenticatedUserParams, error) {
	var params OrgsRemovePublicMembershipForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeBillingGetGithubActionsBillingOrgParams(r *http.Request) (BillingGetGithubActionsBillingOrgParams, error) {
	var params BillingGetGithubActionsBillingOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeBillingGetGithubPackagesBillingOrgParams(r *http.Request) (BillingGetGithubPackagesBillingOrgParams, error) {
	var params BillingGetGithubPackagesBillingOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeBillingGetSharedStorageBillingOrgParams(r *http.Request) (BillingGetSharedStorageBillingOrgParams, error) {
	var params BillingGetSharedStorageBillingOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeTeamsListIdpGroupsForOrgParams(r *http.Request) (TeamsListIdpGroupsForOrgParams, error) {
	var params TeamsListIdpGroupsForOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsListParams(r *http.Request) (TeamsListParams, error) {
	var params TeamsListParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsGetByNameParams(r *http.Request) (TeamsGetByNameParams, error) {
	var params TeamsGetByNameParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}

	return params, nil
}

func decodeTeamsDeleteInOrgParams(r *http.Request) (TeamsDeleteInOrgParams, error) {
	var params TeamsDeleteInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}

	return params, nil
}

func decodeTeamsUpdateInOrgParams(r *http.Request) (TeamsUpdateInOrgParams, error) {
	var params TeamsUpdateInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}

	return params, nil
}

func decodeTeamsCreateDiscussionInOrgParams(r *http.Request) (TeamsCreateDiscussionInOrgParams, error) {
	var params TeamsCreateDiscussionInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}

	return params, nil
}

func decodeTeamsGetDiscussionInOrgParams(r *http.Request) (TeamsGetDiscussionInOrgParams, error) {
	var params TeamsGetDiscussionInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsDeleteDiscussionInOrgParams(r *http.Request) (TeamsDeleteDiscussionInOrgParams, error) {
	var params TeamsDeleteDiscussionInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsUpdateDiscussionInOrgParams(r *http.Request) (TeamsUpdateDiscussionInOrgParams, error) {
	var params TeamsUpdateDiscussionInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsCreateDiscussionCommentInOrgParams(r *http.Request) (TeamsCreateDiscussionCommentInOrgParams, error) {
	var params TeamsCreateDiscussionCommentInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsGetDiscussionCommentInOrgParams(r *http.Request) (TeamsGetDiscussionCommentInOrgParams, error) {
	var params TeamsGetDiscussionCommentInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeTeamsDeleteDiscussionCommentInOrgParams(r *http.Request) (TeamsDeleteDiscussionCommentInOrgParams, error) {
	var params TeamsDeleteDiscussionCommentInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeTeamsUpdateDiscussionCommentInOrgParams(r *http.Request) (TeamsUpdateDiscussionCommentInOrgParams, error) {
	var params TeamsUpdateDiscussionCommentInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeReactionsCreateForTeamDiscussionCommentInOrgParams(r *http.Request) (ReactionsCreateForTeamDiscussionCommentInOrgParams, error) {
	var params ReactionsCreateForTeamDiscussionCommentInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeReactionsDeleteForTeamDiscussionCommentParams(r *http.Request) (ReactionsDeleteForTeamDiscussionCommentParams, error) {
	var params ReactionsDeleteForTeamDiscussionCommentParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}
	{
		param := chi.URLParam(r, "reaction_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'reaction_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'reaction_id': %w", err)
		}

		params.ReactionID = v
	}

	return params, nil
}

func decodeReactionsCreateForTeamDiscussionInOrgParams(r *http.Request) (ReactionsCreateForTeamDiscussionInOrgParams, error) {
	var params ReactionsCreateForTeamDiscussionInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeReactionsDeleteForTeamDiscussionParams(r *http.Request) (ReactionsDeleteForTeamDiscussionParams, error) {
	var params ReactionsDeleteForTeamDiscussionParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "reaction_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'reaction_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'reaction_id': %w", err)
		}

		params.ReactionID = v
	}

	return params, nil
}

func decodeTeamsListPendingInvitationsInOrgParams(r *http.Request) (TeamsListPendingInvitationsInOrgParams, error) {
	var params TeamsListPendingInvitationsInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsGetMembershipForUserInOrgParams(r *http.Request) (TeamsGetMembershipForUserInOrgParams, error) {
	var params TeamsGetMembershipForUserInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsAddOrUpdateMembershipForUserInOrgParams(r *http.Request) (TeamsAddOrUpdateMembershipForUserInOrgParams, error) {
	var params TeamsAddOrUpdateMembershipForUserInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsRemoveMembershipForUserInOrgParams(r *http.Request) (TeamsRemoveMembershipForUserInOrgParams, error) {
	var params TeamsRemoveMembershipForUserInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsListProjectsInOrgParams(r *http.Request) (TeamsListProjectsInOrgParams, error) {
	var params TeamsListProjectsInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsCheckPermissionsForProjectInOrgParams(r *http.Request) (TeamsCheckPermissionsForProjectInOrgParams, error) {
	var params TeamsCheckPermissionsForProjectInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeTeamsAddOrUpdateProjectPermissionsInOrgParams(r *http.Request) (TeamsAddOrUpdateProjectPermissionsInOrgParams, error) {
	var params TeamsAddOrUpdateProjectPermissionsInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeTeamsRemoveProjectInOrgParams(r *http.Request) (TeamsRemoveProjectInOrgParams, error) {
	var params TeamsRemoveProjectInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeTeamsListReposInOrgParams(r *http.Request) (TeamsListReposInOrgParams, error) {
	var params TeamsListReposInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsCheckPermissionsForRepoInOrgParams(r *http.Request) (TeamsCheckPermissionsForRepoInOrgParams, error) {
	var params TeamsCheckPermissionsForRepoInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeTeamsAddOrUpdateRepoPermissionsInOrgParams(r *http.Request) (TeamsAddOrUpdateRepoPermissionsInOrgParams, error) {
	var params TeamsAddOrUpdateRepoPermissionsInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeTeamsRemoveRepoInOrgParams(r *http.Request) (TeamsRemoveRepoInOrgParams, error) {
	var params TeamsRemoveRepoInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeTeamsListIdpGroupsInOrgParams(r *http.Request) (TeamsListIdpGroupsInOrgParams, error) {
	var params TeamsListIdpGroupsInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}

	return params, nil
}

func decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams(r *http.Request) (TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams, error) {
	var params TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}

	return params, nil
}

func decodeTeamsListChildInOrgParams(r *http.Request) (TeamsListChildInOrgParams, error) {
	var params TeamsListChildInOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "team_slug")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_slug' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_slug': %w", err)
		}

		params.TeamSlug = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeProjectsGetCardParams(r *http.Request) (ProjectsGetCardParams, error) {
	var params ProjectsGetCardParams
	{
		param := chi.URLParam(r, "card_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'card_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'card_id': %w", err)
		}

		params.CardID = v
	}

	return params, nil
}

func decodeProjectsDeleteCardParams(r *http.Request) (ProjectsDeleteCardParams, error) {
	var params ProjectsDeleteCardParams
	{
		param := chi.URLParam(r, "card_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'card_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'card_id': %w", err)
		}

		params.CardID = v
	}

	return params, nil
}

func decodeProjectsUpdateCardParams(r *http.Request) (ProjectsUpdateCardParams, error) {
	var params ProjectsUpdateCardParams
	{
		param := chi.URLParam(r, "card_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'card_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'card_id': %w", err)
		}

		params.CardID = v
	}

	return params, nil
}

func decodeProjectsGetColumnParams(r *http.Request) (ProjectsGetColumnParams, error) {
	var params ProjectsGetColumnParams
	{
		param := chi.URLParam(r, "column_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'column_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'column_id': %w", err)
		}

		params.ColumnID = v
	}

	return params, nil
}

func decodeProjectsDeleteColumnParams(r *http.Request) (ProjectsDeleteColumnParams, error) {
	var params ProjectsDeleteColumnParams
	{
		param := chi.URLParam(r, "column_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'column_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'column_id': %w", err)
		}

		params.ColumnID = v
	}

	return params, nil
}

func decodeProjectsUpdateColumnParams(r *http.Request) (ProjectsUpdateColumnParams, error) {
	var params ProjectsUpdateColumnParams
	{
		param := chi.URLParam(r, "column_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'column_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'column_id': %w", err)
		}

		params.ColumnID = v
	}

	return params, nil
}

func decodeProjectsMoveColumnParams(r *http.Request) (ProjectsMoveColumnParams, error) {
	var params ProjectsMoveColumnParams
	{
		param := chi.URLParam(r, "column_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'column_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'column_id': %w", err)
		}

		params.ColumnID = v
	}

	return params, nil
}

func decodeProjectsGetParams(r *http.Request) (ProjectsGetParams, error) {
	var params ProjectsGetParams
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeProjectsDeleteParams(r *http.Request) (ProjectsDeleteParams, error) {
	var params ProjectsDeleteParams
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeProjectsUpdateParams(r *http.Request) (ProjectsUpdateParams, error) {
	var params ProjectsUpdateParams
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeProjectsListColumnsParams(r *http.Request) (ProjectsListColumnsParams, error) {
	var params ProjectsListColumnsParams
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeProjectsCreateColumnParams(r *http.Request) (ProjectsCreateColumnParams, error) {
	var params ProjectsCreateColumnParams
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeReactionsDeleteLegacyParams(r *http.Request) (ReactionsDeleteLegacyParams, error) {
	var params ReactionsDeleteLegacyParams
	{
		param := chi.URLParam(r, "reaction_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'reaction_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'reaction_id': %w", err)
		}

		params.ReactionID = v
	}

	return params, nil
}

func decodeReposGetParams(r *http.Request) (ReposGetParams, error) {
	var params ReposGetParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposDeleteParams(r *http.Request) (ReposDeleteParams, error) {
	var params ReposDeleteParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsListArtifactsForRepoParams(r *http.Request) (ActionsListArtifactsForRepoParams, error) {
	var params ActionsListArtifactsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsGetArtifactParams(r *http.Request) (ActionsGetArtifactParams, error) {
	var params ActionsGetArtifactParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "artifact_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'artifact_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'artifact_id': %w", err)
		}

		params.ArtifactID = v
	}

	return params, nil
}

func decodeActionsDeleteArtifactParams(r *http.Request) (ActionsDeleteArtifactParams, error) {
	var params ActionsDeleteArtifactParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "artifact_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'artifact_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'artifact_id': %w", err)
		}

		params.ArtifactID = v
	}

	return params, nil
}

func decodeActionsDownloadArtifactParams(r *http.Request) (ActionsDownloadArtifactParams, error) {
	var params ActionsDownloadArtifactParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "artifact_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'artifact_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'artifact_id': %w", err)
		}

		params.ArtifactID = v
	}
	{
		param := chi.URLParam(r, "archive_format")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'archive_format' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'archive_format': %w", err)
		}

		params.ArchiveFormat = v
	}

	return params, nil
}

func decodeActionsGetJobForWorkflowRunParams(r *http.Request) (ActionsGetJobForWorkflowRunParams, error) {
	var params ActionsGetJobForWorkflowRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "job_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'job_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'job_id': %w", err)
		}

		params.JobID = v
	}

	return params, nil
}

func decodeActionsDownloadJobLogsForWorkflowRunParams(r *http.Request) (ActionsDownloadJobLogsForWorkflowRunParams, error) {
	var params ActionsDownloadJobLogsForWorkflowRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "job_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'job_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'job_id': %w", err)
		}

		params.JobID = v
	}

	return params, nil
}

func decodeActionsGetGithubActionsPermissionsRepositoryParams(r *http.Request) (ActionsGetGithubActionsPermissionsRepositoryParams, error) {
	var params ActionsGetGithubActionsPermissionsRepositoryParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsSetGithubActionsPermissionsRepositoryParams(r *http.Request) (ActionsSetGithubActionsPermissionsRepositoryParams, error) {
	var params ActionsSetGithubActionsPermissionsRepositoryParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsGetAllowedActionsRepositoryParams(r *http.Request) (ActionsGetAllowedActionsRepositoryParams, error) {
	var params ActionsGetAllowedActionsRepositoryParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsSetAllowedActionsRepositoryParams(r *http.Request) (ActionsSetAllowedActionsRepositoryParams, error) {
	var params ActionsSetAllowedActionsRepositoryParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsListSelfHostedRunnersForRepoParams(r *http.Request) (ActionsListSelfHostedRunnersForRepoParams, error) {
	var params ActionsListSelfHostedRunnersForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsListRunnerApplicationsForRepoParams(r *http.Request) (ActionsListRunnerApplicationsForRepoParams, error) {
	var params ActionsListRunnerApplicationsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsCreateRegistrationTokenForRepoParams(r *http.Request) (ActionsCreateRegistrationTokenForRepoParams, error) {
	var params ActionsCreateRegistrationTokenForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsCreateRemoveTokenForRepoParams(r *http.Request) (ActionsCreateRemoveTokenForRepoParams, error) {
	var params ActionsCreateRemoveTokenForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsGetSelfHostedRunnerForRepoParams(r *http.Request) (ActionsGetSelfHostedRunnerForRepoParams, error) {
	var params ActionsGetSelfHostedRunnerForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeActionsDeleteSelfHostedRunnerFromRepoParams(r *http.Request) (ActionsDeleteSelfHostedRunnerFromRepoParams, error) {
	var params ActionsDeleteSelfHostedRunnerFromRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "runner_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'runner_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'runner_id': %w", err)
		}

		params.RunnerID = v
	}

	return params, nil
}

func decodeActionsGetWorkflowRunParams(r *http.Request) (ActionsGetWorkflowRunParams, error) {
	var params ActionsGetWorkflowRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsDeleteWorkflowRunParams(r *http.Request) (ActionsDeleteWorkflowRunParams, error) {
	var params ActionsDeleteWorkflowRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsGetReviewsForRunParams(r *http.Request) (ActionsGetReviewsForRunParams, error) {
	var params ActionsGetReviewsForRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsApproveWorkflowRunParams(r *http.Request) (ActionsApproveWorkflowRunParams, error) {
	var params ActionsApproveWorkflowRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsListWorkflowRunArtifactsParams(r *http.Request) (ActionsListWorkflowRunArtifactsParams, error) {
	var params ActionsListWorkflowRunArtifactsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsCancelWorkflowRunParams(r *http.Request) (ActionsCancelWorkflowRunParams, error) {
	var params ActionsCancelWorkflowRunParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsDownloadWorkflowRunLogsParams(r *http.Request) (ActionsDownloadWorkflowRunLogsParams, error) {
	var params ActionsDownloadWorkflowRunLogsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsDeleteWorkflowRunLogsParams(r *http.Request) (ActionsDeleteWorkflowRunLogsParams, error) {
	var params ActionsDeleteWorkflowRunLogsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsReRunWorkflowParams(r *http.Request) (ActionsReRunWorkflowParams, error) {
	var params ActionsReRunWorkflowParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsRetryWorkflowParams(r *http.Request) (ActionsRetryWorkflowParams, error) {
	var params ActionsRetryWorkflowParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsGetWorkflowRunUsageParams(r *http.Request) (ActionsGetWorkflowRunUsageParams, error) {
	var params ActionsGetWorkflowRunUsageParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'run_id': %w", err)
		}

		params.RunID = v
	}

	return params, nil
}

func decodeActionsListRepoSecretsParams(r *http.Request) (ActionsListRepoSecretsParams, error) {
	var params ActionsListRepoSecretsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsGetRepoPublicKeyParams(r *http.Request) (ActionsGetRepoPublicKeyParams, error) {
	var params ActionsGetRepoPublicKeyParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActionsGetRepoSecretParams(r *http.Request) (ActionsGetRepoSecretParams, error) {
	var params ActionsGetRepoSecretParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsCreateOrUpdateRepoSecretParams(r *http.Request) (ActionsCreateOrUpdateRepoSecretParams, error) {
	var params ActionsCreateOrUpdateRepoSecretParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsDeleteRepoSecretParams(r *http.Request) (ActionsDeleteRepoSecretParams, error) {
	var params ActionsDeleteRepoSecretParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsListRepoWorkflowsParams(r *http.Request) (ActionsListRepoWorkflowsParams, error) {
	var params ActionsListRepoWorkflowsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesListAssigneesParams(r *http.Request) (IssuesListAssigneesParams, error) {
	var params IssuesListAssigneesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesCheckUserCanBeAssignedParams(r *http.Request) (IssuesCheckUserCanBeAssignedParams, error) {
	var params IssuesCheckUserCanBeAssignedParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "assignee")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'assignee' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'assignee': %w", err)
		}

		params.Assignee = v
	}

	return params, nil
}

func decodeReposListAutolinksParams(r *http.Request) (ReposListAutolinksParams, error) {
	var params ReposListAutolinksParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetAutolinkParams(r *http.Request) (ReposGetAutolinkParams, error) {
	var params ReposGetAutolinkParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "autolink_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'autolink_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'autolink_id': %w", err)
		}

		params.AutolinkID = v
	}

	return params, nil
}

func decodeReposDeleteAutolinkParams(r *http.Request) (ReposDeleteAutolinkParams, error) {
	var params ReposDeleteAutolinkParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "autolink_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'autolink_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'autolink_id': %w", err)
		}

		params.AutolinkID = v
	}

	return params, nil
}

func decodeReposEnableAutomatedSecurityFixesParams(r *http.Request) (ReposEnableAutomatedSecurityFixesParams, error) {
	var params ReposEnableAutomatedSecurityFixesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposDisableAutomatedSecurityFixesParams(r *http.Request) (ReposDisableAutomatedSecurityFixesParams, error) {
	var params ReposDisableAutomatedSecurityFixesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposListBranchesParams(r *http.Request) (ReposListBranchesParams, error) {
	var params ReposListBranchesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("protected")
		if len(param) > 0 {
			v, err := conv.ToBool(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'protected': %w", err)
			}

			params.Protected = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetBranchParams(r *http.Request) (ReposGetBranchParams, error) {
	var params ReposGetBranchParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetBranchProtectionParams(r *http.Request) (ReposGetBranchProtectionParams, error) {
	var params ReposGetBranchProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposUpdateBranchProtectionParams(r *http.Request) (ReposUpdateBranchProtectionParams, error) {
	var params ReposUpdateBranchProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposDeleteBranchProtectionParams(r *http.Request) (ReposDeleteBranchProtectionParams, error) {
	var params ReposDeleteBranchProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetAdminBranchProtectionParams(r *http.Request) (ReposGetAdminBranchProtectionParams, error) {
	var params ReposGetAdminBranchProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposSetAdminBranchProtectionParams(r *http.Request) (ReposSetAdminBranchProtectionParams, error) {
	var params ReposSetAdminBranchProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposDeleteAdminBranchProtectionParams(r *http.Request) (ReposDeleteAdminBranchProtectionParams, error) {
	var params ReposDeleteAdminBranchProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetPullRequestReviewProtectionParams(r *http.Request) (ReposGetPullRequestReviewProtectionParams, error) {
	var params ReposGetPullRequestReviewProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposDeletePullRequestReviewProtectionParams(r *http.Request) (ReposDeletePullRequestReviewProtectionParams, error) {
	var params ReposDeletePullRequestReviewProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetCommitSignatureProtectionParams(r *http.Request) (ReposGetCommitSignatureProtectionParams, error) {
	var params ReposGetCommitSignatureProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposCreateCommitSignatureProtectionParams(r *http.Request) (ReposCreateCommitSignatureProtectionParams, error) {
	var params ReposCreateCommitSignatureProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposDeleteCommitSignatureProtectionParams(r *http.Request) (ReposDeleteCommitSignatureProtectionParams, error) {
	var params ReposDeleteCommitSignatureProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetStatusChecksProtectionParams(r *http.Request) (ReposGetStatusChecksProtectionParams, error) {
	var params ReposGetStatusChecksProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposRemoveStatusCheckProtectionParams(r *http.Request) (ReposRemoveStatusCheckProtectionParams, error) {
	var params ReposRemoveStatusCheckProtectionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetAllStatusCheckContextsParams(r *http.Request) (ReposGetAllStatusCheckContextsParams, error) {
	var params ReposGetAllStatusCheckContextsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetAccessRestrictionsParams(r *http.Request) (ReposGetAccessRestrictionsParams, error) {
	var params ReposGetAccessRestrictionsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposDeleteAccessRestrictionsParams(r *http.Request) (ReposDeleteAccessRestrictionsParams, error) {
	var params ReposDeleteAccessRestrictionsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetAppsWithAccessToProtectedBranchParams(r *http.Request) (ReposGetAppsWithAccessToProtectedBranchParams, error) {
	var params ReposGetAppsWithAccessToProtectedBranchParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetTeamsWithAccessToProtectedBranchParams(r *http.Request) (ReposGetTeamsWithAccessToProtectedBranchParams, error) {
	var params ReposGetTeamsWithAccessToProtectedBranchParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeReposGetUsersWithAccessToProtectedBranchParams(r *http.Request) (ReposGetUsersWithAccessToProtectedBranchParams, error) {
	var params ReposGetUsersWithAccessToProtectedBranchParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "branch")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'branch' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'branch': %w", err)
		}

		params.Branch = v
	}

	return params, nil
}

func decodeChecksGetParams(r *http.Request) (ChecksGetParams, error) {
	var params ChecksGetParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "check_run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'check_run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'check_run_id': %w", err)
		}

		params.CheckRunID = v
	}

	return params, nil
}

func decodeChecksListAnnotationsParams(r *http.Request) (ChecksListAnnotationsParams, error) {
	var params ChecksListAnnotationsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "check_run_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'check_run_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'check_run_id': %w", err)
		}

		params.CheckRunID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeChecksCreateSuiteParams(r *http.Request) (ChecksCreateSuiteParams, error) {
	var params ChecksCreateSuiteParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeChecksSetSuitesPreferencesParams(r *http.Request) (ChecksSetSuitesPreferencesParams, error) {
	var params ChecksSetSuitesPreferencesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeChecksGetSuiteParams(r *http.Request) (ChecksGetSuiteParams, error) {
	var params ChecksGetSuiteParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "check_suite_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'check_suite_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'check_suite_id': %w", err)
		}

		params.CheckSuiteID = v
	}

	return params, nil
}

func decodeChecksRerequestSuiteParams(r *http.Request) (ChecksRerequestSuiteParams, error) {
	var params ChecksRerequestSuiteParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "check_suite_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'check_suite_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'check_suite_id': %w", err)
		}

		params.CheckSuiteID = v
	}

	return params, nil
}

func decodeCodeScanningGetAlertParams(r *http.Request) (CodeScanningGetAlertParams, error) {
	var params CodeScanningGetAlertParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "alert_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'alert_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'alert_number': %w", err)
		}

		params.AlertNumber = v
	}

	return params, nil
}

func decodeCodeScanningUpdateAlertParams(r *http.Request) (CodeScanningUpdateAlertParams, error) {
	var params CodeScanningUpdateAlertParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "alert_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'alert_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'alert_number': %w", err)
		}

		params.AlertNumber = v
	}

	return params, nil
}

func decodeCodeScanningListAlertInstancesParams(r *http.Request) (CodeScanningListAlertInstancesParams, error) {
	var params CodeScanningListAlertInstancesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "alert_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'alert_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'alert_number': %w", err)
		}

		params.AlertNumber = v
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("ref")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'ref': %w", err)
			}

			params.Ref = v
		}
	}

	return params, nil
}

func decodeCodeScanningListRecentAnalysesParams(r *http.Request) (CodeScanningListRecentAnalysesParams, error) {
	var params CodeScanningListRecentAnalysesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("tool_name")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'tool_name': %w", err)
			}

			params.ToolName = v
		}
	}
	{
		param := r.URL.Query().Get("tool_guid")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'tool_guid': %w", err)
			}

			params.ToolGUID = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("ref")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'ref': %w", err)
			}

			params.Ref = v
		}
	}
	{
		param := r.URL.Query().Get("sarif_id")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sarif_id': %w", err)
			}

			params.SarifID = v
		}
	}

	return params, nil
}

func decodeCodeScanningGetAnalysisParams(r *http.Request) (CodeScanningGetAnalysisParams, error) {
	var params CodeScanningGetAnalysisParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "analysis_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'analysis_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'analysis_id': %w", err)
		}

		params.AnalysisID = v
	}

	return params, nil
}

func decodeCodeScanningDeleteAnalysisParams(r *http.Request) (CodeScanningDeleteAnalysisParams, error) {
	var params CodeScanningDeleteAnalysisParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "analysis_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'analysis_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'analysis_id': %w", err)
		}

		params.AnalysisID = v
	}
	{
		param := r.URL.Query().Get("confirm_delete")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'confirm_delete': %w", err)
			}

			params.ConfirmDelete = v
		}
	}

	return params, nil
}

func decodeCodeScanningUploadSarifParams(r *http.Request) (CodeScanningUploadSarifParams, error) {
	var params CodeScanningUploadSarifParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeCodeScanningGetSarifParams(r *http.Request) (CodeScanningGetSarifParams, error) {
	var params CodeScanningGetSarifParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "sarif_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'sarif_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'sarif_id': %w", err)
		}

		params.SarifID = v
	}

	return params, nil
}

func decodeReposCheckCollaboratorParams(r *http.Request) (ReposCheckCollaboratorParams, error) {
	var params ReposCheckCollaboratorParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeReposRemoveCollaboratorParams(r *http.Request) (ReposRemoveCollaboratorParams, error) {
	var params ReposRemoveCollaboratorParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeReposGetCollaboratorPermissionLevelParams(r *http.Request) (ReposGetCollaboratorPermissionLevelParams, error) {
	var params ReposGetCollaboratorPermissionLevelParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeReposListCommitCommentsForRepoParams(r *http.Request) (ReposListCommitCommentsForRepoParams, error) {
	var params ReposListCommitCommentsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetCommitCommentParams(r *http.Request) (ReposGetCommitCommentParams, error) {
	var params ReposGetCommitCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeReposDeleteCommitCommentParams(r *http.Request) (ReposDeleteCommitCommentParams, error) {
	var params ReposDeleteCommitCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeReposUpdateCommitCommentParams(r *http.Request) (ReposUpdateCommitCommentParams, error) {
	var params ReposUpdateCommitCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeReactionsDeleteForCommitCommentParams(r *http.Request) (ReactionsDeleteForCommitCommentParams, error) {
	var params ReactionsDeleteForCommitCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}
	{
		param := chi.URLParam(r, "reaction_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'reaction_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'reaction_id': %w", err)
		}

		params.ReactionID = v
	}

	return params, nil
}

func decodeReposListCommitsParams(r *http.Request) (ReposListCommitsParams, error) {
	var params ReposListCommitsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("sha")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'sha': %w", err)
			}

			params.Sha = v
		}
	}
	{
		param := r.URL.Query().Get("path")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'path': %w", err)
			}

			params.Path = v
		}
	}
	{
		param := r.URL.Query().Get("author")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'author': %w", err)
			}

			params.Author = v
		}
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("until")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'until': %w", err)
			}

			params.Until = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposListCommentsForCommitParams(r *http.Request) (ReposListCommentsForCommitParams, error) {
	var params ReposListCommentsForCommitParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "commit_sha")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'commit_sha' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'commit_sha': %w", err)
		}

		params.CommitSha = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposListPullRequestsAssociatedWithCommitParams(r *http.Request) (ReposListPullRequestsAssociatedWithCommitParams, error) {
	var params ReposListPullRequestsAssociatedWithCommitParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "commit_sha")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'commit_sha' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'commit_sha': %w", err)
		}

		params.CommitSha = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeChecksListSuitesForRefParams(r *http.Request) (ChecksListSuitesForRefParams, error) {
	var params ChecksListSuitesForRefParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}
	{
		param := r.URL.Query().Get("app_id")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'app_id': %w", err)
			}

			params.AppID = v
		}
	}
	{
		param := r.URL.Query().Get("check_name")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'check_name': %w", err)
			}

			params.CheckName = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetCombinedStatusForRefParams(r *http.Request) (ReposGetCombinedStatusForRefParams, error) {
	var params ReposGetCombinedStatusForRefParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposListCommitStatusesForRefParams(r *http.Request) (ReposListCommitStatusesForRefParams, error) {
	var params ReposListCommitStatusesForRefParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetCommunityProfileMetricsParams(r *http.Request) (ReposGetCommunityProfileMetricsParams, error) {
	var params ReposGetCommunityProfileMetricsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposCompareCommitsParams(r *http.Request) (ReposCompareCommitsParams, error) {
	var params ReposCompareCommitsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := chi.URLParam(r, "basehead")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'basehead' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'basehead': %w", err)
		}

		params.Basehead = v
	}

	return params, nil
}

func decodeReposListContributorsParams(r *http.Request) (ReposListContributorsParams, error) {
	var params ReposListContributorsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("anon")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'anon': %w", err)
			}

			params.Anon = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposDeleteDeploymentParams(r *http.Request) (ReposDeleteDeploymentParams, error) {
	var params ReposDeleteDeploymentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "deployment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'deployment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'deployment_id': %w", err)
		}

		params.DeploymentID = v
	}

	return params, nil
}

func decodeReposListDeploymentStatusesParams(r *http.Request) (ReposListDeploymentStatusesParams, error) {
	var params ReposListDeploymentStatusesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "deployment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'deployment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'deployment_id': %w", err)
		}

		params.DeploymentID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetDeploymentStatusParams(r *http.Request) (ReposGetDeploymentStatusParams, error) {
	var params ReposGetDeploymentStatusParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "deployment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'deployment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'deployment_id': %w", err)
		}

		params.DeploymentID = v
	}
	{
		param := chi.URLParam(r, "status_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'status_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'status_id': %w", err)
		}

		params.StatusID = v
	}

	return params, nil
}

func decodeReposDeleteAnEnvironmentParams(r *http.Request) (ReposDeleteAnEnvironmentParams, error) {
	var params ReposDeleteAnEnvironmentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "environment_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'environment_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'environment_name': %w", err)
		}

		params.EnvironmentName = v
	}

	return params, nil
}

func decodeActivityListRepoEventsParams(r *http.Request) (ActivityListRepoEventsParams, error) {
	var params ActivityListRepoEventsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGitGetCommitParams(r *http.Request) (GitGetCommitParams, error) {
	var params GitGetCommitParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "commit_sha")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'commit_sha' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'commit_sha': %w", err)
		}

		params.CommitSha = v
	}

	return params, nil
}

func decodeGitListMatchingRefsParams(r *http.Request) (GitListMatchingRefsParams, error) {
	var params GitListMatchingRefsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeGitGetRefParams(r *http.Request) (GitGetRefParams, error) {
	var params GitGetRefParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}

	return params, nil
}

func decodeGitGetTagParams(r *http.Request) (GitGetTagParams, error) {
	var params GitGetTagParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "tag_sha")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'tag_sha' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'tag_sha': %w", err)
		}

		params.TagSha = v
	}

	return params, nil
}

func decodeReposDeleteWebhookParams(r *http.Request) (ReposDeleteWebhookParams, error) {
	var params ReposDeleteWebhookParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeReposPingWebhookParams(r *http.Request) (ReposPingWebhookParams, error) {
	var params ReposPingWebhookParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeReposTestPushWebhookParams(r *http.Request) (ReposTestPushWebhookParams, error) {
	var params ReposTestPushWebhookParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "hook_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'hook_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'hook_id': %w", err)
		}

		params.HookID = v
	}

	return params, nil
}

func decodeMigrationsGetImportStatusParams(r *http.Request) (MigrationsGetImportStatusParams, error) {
	var params MigrationsGetImportStatusParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeMigrationsCancelImportParams(r *http.Request) (MigrationsCancelImportParams, error) {
	var params MigrationsCancelImportParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeMigrationsUpdateImportParams(r *http.Request) (MigrationsUpdateImportParams, error) {
	var params MigrationsUpdateImportParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeMigrationsGetCommitAuthorsParams(r *http.Request) (MigrationsGetCommitAuthorsParams, error) {
	var params MigrationsGetCommitAuthorsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}

	return params, nil
}

func decodeMigrationsGetLargeFilesParams(r *http.Request) (MigrationsGetLargeFilesParams, error) {
	var params MigrationsGetLargeFilesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeInteractionsSetRestrictionsForRepoParams(r *http.Request) (InteractionsSetRestrictionsForRepoParams, error) {
	var params InteractionsSetRestrictionsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeInteractionsRemoveRestrictionsForRepoParams(r *http.Request) (InteractionsRemoveRestrictionsForRepoParams, error) {
	var params InteractionsRemoveRestrictionsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposListInvitationsParams(r *http.Request) (ReposListInvitationsParams, error) {
	var params ReposListInvitationsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposDeleteInvitationParams(r *http.Request) (ReposDeleteInvitationParams, error) {
	var params ReposDeleteInvitationParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "invitation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'invitation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'invitation_id': %w", err)
		}

		params.InvitationID = v
	}

	return params, nil
}

func decodeReposUpdateInvitationParams(r *http.Request) (ReposUpdateInvitationParams, error) {
	var params ReposUpdateInvitationParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "invitation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'invitation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'invitation_id': %w", err)
		}

		params.InvitationID = v
	}

	return params, nil
}

func decodeIssuesGetCommentParams(r *http.Request) (IssuesGetCommentParams, error) {
	var params IssuesGetCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeIssuesDeleteCommentParams(r *http.Request) (IssuesDeleteCommentParams, error) {
	var params IssuesDeleteCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeReactionsDeleteForIssueCommentParams(r *http.Request) (ReactionsDeleteForIssueCommentParams, error) {
	var params ReactionsDeleteForIssueCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}
	{
		param := chi.URLParam(r, "reaction_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'reaction_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'reaction_id': %w", err)
		}

		params.ReactionID = v
	}

	return params, nil
}

func decodeIssuesGetEventParams(r *http.Request) (IssuesGetEventParams, error) {
	var params IssuesGetEventParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "event_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'event_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'event_id': %w", err)
		}

		params.EventID = v
	}

	return params, nil
}

func decodeIssuesAddAssigneesParams(r *http.Request) (IssuesAddAssigneesParams, error) {
	var params IssuesAddAssigneesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}

	return params, nil
}

func decodeIssuesRemoveAssigneesParams(r *http.Request) (IssuesRemoveAssigneesParams, error) {
	var params IssuesRemoveAssigneesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}

	return params, nil
}

func decodeIssuesListCommentsParams(r *http.Request) (IssuesListCommentsParams, error) {
	var params IssuesListCommentsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesListLabelsOnIssueParams(r *http.Request) (IssuesListLabelsOnIssueParams, error) {
	var params IssuesListLabelsOnIssueParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesRemoveAllLabelsParams(r *http.Request) (IssuesRemoveAllLabelsParams, error) {
	var params IssuesRemoveAllLabelsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}

	return params, nil
}

func decodeIssuesRemoveLabelParams(r *http.Request) (IssuesRemoveLabelParams, error) {
	var params IssuesRemoveLabelParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}
	{
		param := chi.URLParam(r, "name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'name': %w", err)
		}

		params.Name = v
	}

	return params, nil
}

func decodeIssuesUnlockParams(r *http.Request) (IssuesUnlockParams, error) {
	var params IssuesUnlockParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}

	return params, nil
}

func decodeReactionsDeleteForIssueParams(r *http.Request) (ReactionsDeleteForIssueParams, error) {
	var params ReactionsDeleteForIssueParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "issue_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'issue_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'issue_number': %w", err)
		}

		params.IssueNumber = v
	}
	{
		param := chi.URLParam(r, "reaction_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'reaction_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'reaction_id': %w", err)
		}

		params.ReactionID = v
	}

	return params, nil
}

func decodeReposListDeployKeysParams(r *http.Request) (ReposListDeployKeysParams, error) {
	var params ReposListDeployKeysParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetDeployKeyParams(r *http.Request) (ReposGetDeployKeyParams, error) {
	var params ReposGetDeployKeyParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "key_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'key_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'key_id': %w", err)
		}

		params.KeyID = v
	}

	return params, nil
}

func decodeReposDeleteDeployKeyParams(r *http.Request) (ReposDeleteDeployKeyParams, error) {
	var params ReposDeleteDeployKeyParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "key_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'key_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'key_id': %w", err)
		}

		params.KeyID = v
	}

	return params, nil
}

func decodeIssuesListLabelsForRepoParams(r *http.Request) (IssuesListLabelsForRepoParams, error) {
	var params IssuesListLabelsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeIssuesGetLabelParams(r *http.Request) (IssuesGetLabelParams, error) {
	var params IssuesGetLabelParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'name': %w", err)
		}

		params.Name = v
	}

	return params, nil
}

func decodeIssuesDeleteLabelParams(r *http.Request) (IssuesDeleteLabelParams, error) {
	var params IssuesDeleteLabelParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'name': %w", err)
		}

		params.Name = v
	}

	return params, nil
}

func decodeIssuesUpdateLabelParams(r *http.Request) (IssuesUpdateLabelParams, error) {
	var params IssuesUpdateLabelParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'name': %w", err)
		}

		params.Name = v
	}

	return params, nil
}

func decodeReposListLanguagesParams(r *http.Request) (ReposListLanguagesParams, error) {
	var params ReposListLanguagesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposEnableLfsForRepoParams(r *http.Request) (ReposEnableLfsForRepoParams, error) {
	var params ReposEnableLfsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposDisableLfsForRepoParams(r *http.Request) (ReposDisableLfsForRepoParams, error) {
	var params ReposDisableLfsForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeLicensesGetForRepoParams(r *http.Request) (LicensesGetForRepoParams, error) {
	var params LicensesGetForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposMergeUpstreamParams(r *http.Request) (ReposMergeUpstreamParams, error) {
	var params ReposMergeUpstreamParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeIssuesGetMilestoneParams(r *http.Request) (IssuesGetMilestoneParams, error) {
	var params IssuesGetMilestoneParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "milestone_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'milestone_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'milestone_number': %w", err)
		}

		params.MilestoneNumber = v
	}

	return params, nil
}

func decodeIssuesDeleteMilestoneParams(r *http.Request) (IssuesDeleteMilestoneParams, error) {
	var params IssuesDeleteMilestoneParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "milestone_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'milestone_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'milestone_number': %w", err)
		}

		params.MilestoneNumber = v
	}

	return params, nil
}

func decodeIssuesUpdateMilestoneParams(r *http.Request) (IssuesUpdateMilestoneParams, error) {
	var params IssuesUpdateMilestoneParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "milestone_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'milestone_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'milestone_number': %w", err)
		}

		params.MilestoneNumber = v
	}

	return params, nil
}

func decodeIssuesListLabelsForMilestoneParams(r *http.Request) (IssuesListLabelsForMilestoneParams, error) {
	var params IssuesListLabelsForMilestoneParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "milestone_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'milestone_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'milestone_number': %w", err)
		}

		params.MilestoneNumber = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityListRepoNotificationsForAuthenticatedUserParams(r *http.Request) (ActivityListRepoNotificationsForAuthenticatedUserParams, error) {
	var params ActivityListRepoNotificationsForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("all")
		if len(param) > 0 {
			v, err := conv.ToBool(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'all': %w", err)
			}

			params.All = v
		}
	}
	{
		param := r.URL.Query().Get("participating")
		if len(param) > 0 {
			v, err := conv.ToBool(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'participating': %w", err)
			}

			params.Participating = v
		}
	}
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("before")
		if len(param) > 0 {
			v, err := conv.ToTime(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'before': %w", err)
			}

			params.Before = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityMarkRepoNotificationsAsReadParams(r *http.Request) (ActivityMarkRepoNotificationsAsReadParams, error) {
	var params ActivityMarkRepoNotificationsAsReadParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetPagesParams(r *http.Request) (ReposGetPagesParams, error) {
	var params ReposGetPagesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposListPagesBuildsParams(r *http.Request) (ReposListPagesBuildsParams, error) {
	var params ReposListPagesBuildsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposRequestPagesBuildParams(r *http.Request) (ReposRequestPagesBuildParams, error) {
	var params ReposRequestPagesBuildParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetLatestPagesBuildParams(r *http.Request) (ReposGetLatestPagesBuildParams, error) {
	var params ReposGetLatestPagesBuildParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetPagesBuildParams(r *http.Request) (ReposGetPagesBuildParams, error) {
	var params ReposGetPagesBuildParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "build_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'build_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'build_id': %w", err)
		}

		params.BuildID = v
	}

	return params, nil
}

func decodeReposGetPagesHealthCheckParams(r *http.Request) (ReposGetPagesHealthCheckParams, error) {
	var params ReposGetPagesHealthCheckParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeProjectsCreateForRepoParams(r *http.Request) (ProjectsCreateForRepoParams, error) {
	var params ProjectsCreateForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodePullsGetReviewCommentParams(r *http.Request) (PullsGetReviewCommentParams, error) {
	var params PullsGetReviewCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodePullsDeleteReviewCommentParams(r *http.Request) (PullsDeleteReviewCommentParams, error) {
	var params PullsDeleteReviewCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodePullsUpdateReviewCommentParams(r *http.Request) (PullsUpdateReviewCommentParams, error) {
	var params PullsUpdateReviewCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodeReactionsDeleteForPullRequestCommentParams(r *http.Request) (ReactionsDeleteForPullRequestCommentParams, error) {
	var params ReactionsDeleteForPullRequestCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}
	{
		param := chi.URLParam(r, "reaction_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'reaction_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'reaction_id': %w", err)
		}

		params.ReactionID = v
	}

	return params, nil
}

func decodePullsGetParams(r *http.Request) (PullsGetParams, error) {
	var params PullsGetParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}

	return params, nil
}

func decodePullsCreateReplyForReviewCommentParams(r *http.Request) (PullsCreateReplyForReviewCommentParams, error) {
	var params PullsCreateReplyForReviewCommentParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := chi.URLParam(r, "comment_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_id': %w", err)
		}

		params.CommentID = v
	}

	return params, nil
}

func decodePullsListCommitsParams(r *http.Request) (PullsListCommitsParams, error) {
	var params PullsListCommitsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodePullsCheckIfMergedParams(r *http.Request) (PullsCheckIfMergedParams, error) {
	var params PullsCheckIfMergedParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}

	return params, nil
}

func decodePullsListRequestedReviewersParams(r *http.Request) (PullsListRequestedReviewersParams, error) {
	var params PullsListRequestedReviewersParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodePullsListReviewsParams(r *http.Request) (PullsListReviewsParams, error) {
	var params PullsListReviewsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodePullsCreateReviewParams(r *http.Request) (PullsCreateReviewParams, error) {
	var params PullsCreateReviewParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}

	return params, nil
}

func decodePullsGetReviewParams(r *http.Request) (PullsGetReviewParams, error) {
	var params PullsGetReviewParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := chi.URLParam(r, "review_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'review_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'review_id': %w", err)
		}

		params.ReviewID = v
	}

	return params, nil
}

func decodePullsUpdateReviewParams(r *http.Request) (PullsUpdateReviewParams, error) {
	var params PullsUpdateReviewParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := chi.URLParam(r, "review_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'review_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'review_id': %w", err)
		}

		params.ReviewID = v
	}

	return params, nil
}

func decodePullsDeletePendingReviewParams(r *http.Request) (PullsDeletePendingReviewParams, error) {
	var params PullsDeletePendingReviewParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := chi.URLParam(r, "review_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'review_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'review_id': %w", err)
		}

		params.ReviewID = v
	}

	return params, nil
}

func decodePullsListCommentsForReviewParams(r *http.Request) (PullsListCommentsForReviewParams, error) {
	var params PullsListCommentsForReviewParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := chi.URLParam(r, "review_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'review_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'review_id': %w", err)
		}

		params.ReviewID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodePullsDismissReviewParams(r *http.Request) (PullsDismissReviewParams, error) {
	var params PullsDismissReviewParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := chi.URLParam(r, "review_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'review_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'review_id': %w", err)
		}

		params.ReviewID = v
	}

	return params, nil
}

func decodePullsSubmitReviewParams(r *http.Request) (PullsSubmitReviewParams, error) {
	var params PullsSubmitReviewParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "pull_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'pull_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'pull_number': %w", err)
		}

		params.PullNumber = v
	}
	{
		param := chi.URLParam(r, "review_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'review_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'review_id': %w", err)
		}

		params.ReviewID = v
	}

	return params, nil
}

func decodeReposListReleasesParams(r *http.Request) (ReposListReleasesParams, error) {
	var params ReposListReleasesParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetReleaseAssetParams(r *http.Request) (ReposGetReleaseAssetParams, error) {
	var params ReposGetReleaseAssetParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "asset_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'asset_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'asset_id': %w", err)
		}

		params.AssetID = v
	}

	return params, nil
}

func decodeReposDeleteReleaseAssetParams(r *http.Request) (ReposDeleteReleaseAssetParams, error) {
	var params ReposDeleteReleaseAssetParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "asset_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'asset_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'asset_id': %w", err)
		}

		params.AssetID = v
	}

	return params, nil
}

func decodeReposUpdateReleaseAssetParams(r *http.Request) (ReposUpdateReleaseAssetParams, error) {
	var params ReposUpdateReleaseAssetParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "asset_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'asset_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'asset_id': %w", err)
		}

		params.AssetID = v
	}

	return params, nil
}

func decodeReposGetLatestReleaseParams(r *http.Request) (ReposGetLatestReleaseParams, error) {
	var params ReposGetLatestReleaseParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetReleaseByTagParams(r *http.Request) (ReposGetReleaseByTagParams, error) {
	var params ReposGetReleaseByTagParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "tag")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'tag' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'tag': %w", err)
		}

		params.Tag = v
	}

	return params, nil
}

func decodeReposGetReleaseParams(r *http.Request) (ReposGetReleaseParams, error) {
	var params ReposGetReleaseParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "release_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'release_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'release_id': %w", err)
		}

		params.ReleaseID = v
	}

	return params, nil
}

func decodeReposDeleteReleaseParams(r *http.Request) (ReposDeleteReleaseParams, error) {
	var params ReposDeleteReleaseParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "release_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'release_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'release_id': %w", err)
		}

		params.ReleaseID = v
	}

	return params, nil
}

func decodeReposUpdateReleaseParams(r *http.Request) (ReposUpdateReleaseParams, error) {
	var params ReposUpdateReleaseParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "release_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'release_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'release_id': %w", err)
		}

		params.ReleaseID = v
	}

	return params, nil
}

func decodeReposListReleaseAssetsParams(r *http.Request) (ReposListReleaseAssetsParams, error) {
	var params ReposListReleaseAssetsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "release_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'release_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'release_id': %w", err)
		}

		params.ReleaseID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposUploadReleaseAssetParams(r *http.Request) (ReposUploadReleaseAssetParams, error) {
	var params ReposUploadReleaseAssetParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "release_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'release_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'release_id': %w", err)
		}

		params.ReleaseID = v
	}
	{
		param := r.URL.Query().Get("name")
		if len(param) == 0 {
			return params, fmt.Errorf("query param 'name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse query param 'name': %w", err)
		}

		params.Name = v
	}
	{
		param := r.URL.Query().Get("label")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'label': %w", err)
			}

			params.Label = v
		}
	}

	return params, nil
}

func decodeSecretScanningGetAlertParams(r *http.Request) (SecretScanningGetAlertParams, error) {
	var params SecretScanningGetAlertParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "alert_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'alert_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'alert_number': %w", err)
		}

		params.AlertNumber = v
	}

	return params, nil
}

func decodeSecretScanningUpdateAlertParams(r *http.Request) (SecretScanningUpdateAlertParams, error) {
	var params SecretScanningUpdateAlertParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "alert_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'alert_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'alert_number': %w", err)
		}

		params.AlertNumber = v
	}

	return params, nil
}

func decodeReposGetCodeFrequencyStatsParams(r *http.Request) (ReposGetCodeFrequencyStatsParams, error) {
	var params ReposGetCodeFrequencyStatsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetCommitActivityStatsParams(r *http.Request) (ReposGetCommitActivityStatsParams, error) {
	var params ReposGetCommitActivityStatsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetContributorsStatsParams(r *http.Request) (ReposGetContributorsStatsParams, error) {
	var params ReposGetContributorsStatsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetParticipationStatsParams(r *http.Request) (ReposGetParticipationStatsParams, error) {
	var params ReposGetParticipationStatsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetPunchCardStatsParams(r *http.Request) (ReposGetPunchCardStatsParams, error) {
	var params ReposGetPunchCardStatsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposCreateCommitStatusParams(r *http.Request) (ReposCreateCommitStatusParams, error) {
	var params ReposCreateCommitStatusParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "sha")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'sha' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'sha': %w", err)
		}

		params.Sha = v
	}

	return params, nil
}

func decodeActivityListWatchersForRepoParams(r *http.Request) (ActivityListWatchersForRepoParams, error) {
	var params ActivityListWatchersForRepoParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityGetRepoSubscriptionParams(r *http.Request) (ActivityGetRepoSubscriptionParams, error) {
	var params ActivityGetRepoSubscriptionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActivitySetRepoSubscriptionParams(r *http.Request) (ActivitySetRepoSubscriptionParams, error) {
	var params ActivitySetRepoSubscriptionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActivityDeleteRepoSubscriptionParams(r *http.Request) (ActivityDeleteRepoSubscriptionParams, error) {
	var params ActivityDeleteRepoSubscriptionParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposListTagsParams(r *http.Request) (ReposListTagsParams, error) {
	var params ReposListTagsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposDownloadTarballArchiveParams(r *http.Request) (ReposDownloadTarballArchiveParams, error) {
	var params ReposDownloadTarballArchiveParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}

	return params, nil
}

func decodeReposListTeamsParams(r *http.Request) (ReposListTeamsParams, error) {
	var params ReposListTeamsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposGetAllTopicsParams(r *http.Request) (ReposGetAllTopicsParams, error) {
	var params ReposGetAllTopicsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}

	return params, nil
}

func decodeReposReplaceAllTopicsParams(r *http.Request) (ReposReplaceAllTopicsParams, error) {
	var params ReposReplaceAllTopicsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetTopPathsParams(r *http.Request) (ReposGetTopPathsParams, error) {
	var params ReposGetTopPathsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposGetTopReferrersParams(r *http.Request) (ReposGetTopReferrersParams, error) {
	var params ReposGetTopReferrersParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposTransferParams(r *http.Request) (ReposTransferParams, error) {
	var params ReposTransferParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposCheckVulnerabilityAlertsParams(r *http.Request) (ReposCheckVulnerabilityAlertsParams, error) {
	var params ReposCheckVulnerabilityAlertsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposEnableVulnerabilityAlertsParams(r *http.Request) (ReposEnableVulnerabilityAlertsParams, error) {
	var params ReposEnableVulnerabilityAlertsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposDisableVulnerabilityAlertsParams(r *http.Request) (ReposDisableVulnerabilityAlertsParams, error) {
	var params ReposDisableVulnerabilityAlertsParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeReposDownloadZipballArchiveParams(r *http.Request) (ReposDownloadZipballArchiveParams, error) {
	var params ReposDownloadZipballArchiveParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}
	{
		param := chi.URLParam(r, "ref")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'ref' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'ref': %w", err)
		}

		params.Ref = v
	}

	return params, nil
}

func decodeReposCreateUsingTemplateParams(r *http.Request) (ReposCreateUsingTemplateParams, error) {
	var params ReposCreateUsingTemplateParams
	{
		param := chi.URLParam(r, "template_owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'template_owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'template_owner': %w", err)
		}

		params.TemplateOwner = v
	}
	{
		param := chi.URLParam(r, "template_repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'template_repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'template_repo': %w", err)
		}

		params.TemplateRepo = v
	}

	return params, nil
}

func decodeActionsListEnvironmentSecretsParams(r *http.Request) (ActionsListEnvironmentSecretsParams, error) {
	var params ActionsListEnvironmentSecretsParams
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}
	{
		param := chi.URLParam(r, "environment_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'environment_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'environment_name': %w", err)
		}

		params.EnvironmentName = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActionsGetEnvironmentPublicKeyParams(r *http.Request) (ActionsGetEnvironmentPublicKeyParams, error) {
	var params ActionsGetEnvironmentPublicKeyParams
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}
	{
		param := chi.URLParam(r, "environment_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'environment_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'environment_name': %w", err)
		}

		params.EnvironmentName = v
	}

	return params, nil
}

func decodeActionsGetEnvironmentSecretParams(r *http.Request) (ActionsGetEnvironmentSecretParams, error) {
	var params ActionsGetEnvironmentSecretParams
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}
	{
		param := chi.URLParam(r, "environment_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'environment_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'environment_name': %w", err)
		}

		params.EnvironmentName = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsCreateOrUpdateEnvironmentSecretParams(r *http.Request) (ActionsCreateOrUpdateEnvironmentSecretParams, error) {
	var params ActionsCreateOrUpdateEnvironmentSecretParams
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}
	{
		param := chi.URLParam(r, "environment_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'environment_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'environment_name': %w", err)
		}

		params.EnvironmentName = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeActionsDeleteEnvironmentSecretParams(r *http.Request) (ActionsDeleteEnvironmentSecretParams, error) {
	var params ActionsDeleteEnvironmentSecretParams
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}
	{
		param := chi.URLParam(r, "environment_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'environment_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'environment_name': %w", err)
		}

		params.EnvironmentName = v
	}
	{
		param := chi.URLParam(r, "secret_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'secret_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'secret_name': %w", err)
		}

		params.SecretName = v
	}

	return params, nil
}

func decodeEnterpriseAdminListProvisionedGroupsEnterpriseParams(r *http.Request) (EnterpriseAdminListProvisionedGroupsEnterpriseParams, error) {
	var params EnterpriseAdminListProvisionedGroupsEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := r.URL.Query().Get("startIndex")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'startIndex': %w", err)
			}

			params.StartIndex = v
		}
	}
	{
		param := r.URL.Query().Get("count")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'count': %w", err)
			}

			params.Count = v
		}
	}
	{
		param := r.URL.Query().Get("filter")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'filter': %w", err)
			}

			params.Filter = v
		}
	}
	{
		param := r.URL.Query().Get("excludedAttributes")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'excludedAttributes': %w", err)
			}

			params.ExcludedAttributes = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupParams(r *http.Request) (EnterpriseAdminProvisionAndInviteEnterpriseGroupParams, error) {
	var params EnterpriseAdminProvisionAndInviteEnterpriseGroupParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams(r *http.Request) (EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams, error) {
	var params EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "scim_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_group_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_group_id': %w", err)
		}

		params.ScimGroupID = v
	}
	{
		param := r.URL.Query().Get("excludedAttributes")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'excludedAttributes': %w", err)
			}

			params.ExcludedAttributes = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams(r *http.Request) (EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams, error) {
	var params EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "scim_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_group_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_group_id': %w", err)
		}

		params.ScimGroupID = v
	}

	return params, nil
}

func decodeEnterpriseAdminDeleteScimGroupFromEnterpriseParams(r *http.Request) (EnterpriseAdminDeleteScimGroupFromEnterpriseParams, error) {
	var params EnterpriseAdminDeleteScimGroupFromEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "scim_group_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_group_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_group_id': %w", err)
		}

		params.ScimGroupID = v
	}

	return params, nil
}

func decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseParams(r *http.Request) (EnterpriseAdminListProvisionedIdentitiesEnterpriseParams, error) {
	var params EnterpriseAdminListProvisionedIdentitiesEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := r.URL.Query().Get("startIndex")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'startIndex': %w", err)
			}

			params.StartIndex = v
		}
	}
	{
		param := r.URL.Query().Get("count")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'count': %w", err)
			}

			params.Count = v
		}
	}
	{
		param := r.URL.Query().Get("filter")
		if len(param) > 0 {
			v, err := conv.ToString(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'filter': %w", err)
			}

			params.Filter = v
		}
	}

	return params, nil
}

func decodeEnterpriseAdminProvisionAndInviteEnterpriseUserParams(r *http.Request) (EnterpriseAdminProvisionAndInviteEnterpriseUserParams, error) {
	var params EnterpriseAdminProvisionAndInviteEnterpriseUserParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}

	return params, nil
}

func decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams(r *http.Request) (EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams, error) {
	var params EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "scim_user_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_user_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_user_id': %w", err)
		}

		params.ScimUserID = v
	}

	return params, nil
}

func decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams(r *http.Request) (EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams, error) {
	var params EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "scim_user_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_user_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_user_id': %w", err)
		}

		params.ScimUserID = v
	}

	return params, nil
}

func decodeEnterpriseAdminDeleteUserFromEnterpriseParams(r *http.Request) (EnterpriseAdminDeleteUserFromEnterpriseParams, error) {
	var params EnterpriseAdminDeleteUserFromEnterpriseParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "scim_user_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_user_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_user_id': %w", err)
		}

		params.ScimUserID = v
	}

	return params, nil
}

func decodeEnterpriseAdminUpdateAttributeForEnterpriseUserParams(r *http.Request) (EnterpriseAdminUpdateAttributeForEnterpriseUserParams, error) {
	var params EnterpriseAdminUpdateAttributeForEnterpriseUserParams
	{
		param := chi.URLParam(r, "enterprise")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'enterprise' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'enterprise': %w", err)
		}

		params.Enterprise = v
	}
	{
		param := chi.URLParam(r, "scim_user_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_user_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_user_id': %w", err)
		}

		params.ScimUserID = v
	}

	return params, nil
}

func decodeScimDeleteUserFromOrgParams(r *http.Request) (ScimDeleteUserFromOrgParams, error) {
	var params ScimDeleteUserFromOrgParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := chi.URLParam(r, "scim_user_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'scim_user_id' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'scim_user_id': %w", err)
		}

		params.ScimUserID = v
	}

	return params, nil
}

func decodeSearchTopicsParams(r *http.Request) (SearchTopicsParams, error) {
	var params SearchTopicsParams
	{
		param := r.URL.Query().Get("q")
		if len(param) == 0 {
			return params, fmt.Errorf("query param 'q' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse query param 'q': %w", err)
		}

		params.Q = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsGetLegacyParams(r *http.Request) (TeamsGetLegacyParams, error) {
	var params TeamsGetLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}

	return params, nil
}

func decodeTeamsCreateDiscussionLegacyParams(r *http.Request) (TeamsCreateDiscussionLegacyParams, error) {
	var params TeamsCreateDiscussionLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}

	return params, nil
}

func decodeTeamsGetDiscussionLegacyParams(r *http.Request) (TeamsGetDiscussionLegacyParams, error) {
	var params TeamsGetDiscussionLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsDeleteDiscussionLegacyParams(r *http.Request) (TeamsDeleteDiscussionLegacyParams, error) {
	var params TeamsDeleteDiscussionLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsUpdateDiscussionLegacyParams(r *http.Request) (TeamsUpdateDiscussionLegacyParams, error) {
	var params TeamsUpdateDiscussionLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsCreateDiscussionCommentLegacyParams(r *http.Request) (TeamsCreateDiscussionCommentLegacyParams, error) {
	var params TeamsCreateDiscussionCommentLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsGetDiscussionCommentLegacyParams(r *http.Request) (TeamsGetDiscussionCommentLegacyParams, error) {
	var params TeamsGetDiscussionCommentLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeTeamsDeleteDiscussionCommentLegacyParams(r *http.Request) (TeamsDeleteDiscussionCommentLegacyParams, error) {
	var params TeamsDeleteDiscussionCommentLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeTeamsUpdateDiscussionCommentLegacyParams(r *http.Request) (TeamsUpdateDiscussionCommentLegacyParams, error) {
	var params TeamsUpdateDiscussionCommentLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeReactionsCreateForTeamDiscussionCommentLegacyParams(r *http.Request) (ReactionsCreateForTeamDiscussionCommentLegacyParams, error) {
	var params ReactionsCreateForTeamDiscussionCommentLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}
	{
		param := chi.URLParam(r, "comment_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'comment_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'comment_number': %w", err)
		}

		params.CommentNumber = v
	}

	return params, nil
}

func decodeReactionsCreateForTeamDiscussionLegacyParams(r *http.Request) (ReactionsCreateForTeamDiscussionLegacyParams, error) {
	var params ReactionsCreateForTeamDiscussionLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "discussion_number")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'discussion_number' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'discussion_number': %w", err)
		}

		params.DiscussionNumber = v
	}

	return params, nil
}

func decodeTeamsListPendingInvitationsLegacyParams(r *http.Request) (TeamsListPendingInvitationsLegacyParams, error) {
	var params TeamsListPendingInvitationsLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsGetMemberLegacyParams(r *http.Request) (TeamsGetMemberLegacyParams, error) {
	var params TeamsGetMemberLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsAddMemberLegacyParams(r *http.Request) (TeamsAddMemberLegacyParams, error) {
	var params TeamsAddMemberLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsRemoveMemberLegacyParams(r *http.Request) (TeamsRemoveMemberLegacyParams, error) {
	var params TeamsRemoveMemberLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsGetMembershipForUserLegacyParams(r *http.Request) (TeamsGetMembershipForUserLegacyParams, error) {
	var params TeamsGetMembershipForUserLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsAddOrUpdateMembershipForUserLegacyParams(r *http.Request) (TeamsAddOrUpdateMembershipForUserLegacyParams, error) {
	var params TeamsAddOrUpdateMembershipForUserLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsRemoveMembershipForUserLegacyParams(r *http.Request) (TeamsRemoveMembershipForUserLegacyParams, error) {
	var params TeamsRemoveMembershipForUserLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeTeamsListProjectsLegacyParams(r *http.Request) (TeamsListProjectsLegacyParams, error) {
	var params TeamsListProjectsLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsCheckPermissionsForProjectLegacyParams(r *http.Request) (TeamsCheckPermissionsForProjectLegacyParams, error) {
	var params TeamsCheckPermissionsForProjectLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "project_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'project_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'project_id': %w", err)
		}

		params.ProjectID = v
	}

	return params, nil
}

func decodeTeamsListReposLegacyParams(r *http.Request) (TeamsListReposLegacyParams, error) {
	var params TeamsListReposLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsCheckPermissionsForRepoLegacyParams(r *http.Request) (TeamsCheckPermissionsForRepoLegacyParams, error) {
	var params TeamsCheckPermissionsForRepoLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeTeamsRemoveRepoLegacyParams(r *http.Request) (TeamsRemoveRepoLegacyParams, error) {
	var params TeamsRemoveRepoLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeTeamsListIdpGroupsForLegacyParams(r *http.Request) (TeamsListIdpGroupsForLegacyParams, error) {
	var params TeamsListIdpGroupsForLegacyParams
	{
		param := chi.URLParam(r, "team_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'team_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'team_id': %w", err)
		}

		params.TeamID = v
	}

	return params, nil
}

func decodeUsersCheckBlockedParams(r *http.Request) (UsersCheckBlockedParams, error) {
	var params UsersCheckBlockedParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeUsersUnblockParams(r *http.Request) (UsersUnblockParams, error) {
	var params UsersUnblockParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeUsersListEmailsForAuthenticatedParams(r *http.Request) (UsersListEmailsForAuthenticatedParams, error) {
	var params UsersListEmailsForAuthenticatedParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersListFollowersForAuthenticatedUserParams(r *http.Request) (UsersListFollowersForAuthenticatedUserParams, error) {
	var params UsersListFollowersForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersListFollowedByAuthenticatedParams(r *http.Request) (UsersListFollowedByAuthenticatedParams, error) {
	var params UsersListFollowedByAuthenticatedParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersCheckPersonIsFollowedByAuthenticatedParams(r *http.Request) (UsersCheckPersonIsFollowedByAuthenticatedParams, error) {
	var params UsersCheckPersonIsFollowedByAuthenticatedParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeUsersFollowParams(r *http.Request) (UsersFollowParams, error) {
	var params UsersFollowParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeUsersUnfollowParams(r *http.Request) (UsersUnfollowParams, error) {
	var params UsersUnfollowParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeUsersListGpgKeysForAuthenticatedParams(r *http.Request) (UsersListGpgKeysForAuthenticatedParams, error) {
	var params UsersListGpgKeysForAuthenticatedParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersGetGpgKeyForAuthenticatedParams(r *http.Request) (UsersGetGpgKeyForAuthenticatedParams, error) {
	var params UsersGetGpgKeyForAuthenticatedParams
	{
		param := chi.URLParam(r, "gpg_key_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'gpg_key_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'gpg_key_id': %w", err)
		}

		params.GpgKeyID = v
	}

	return params, nil
}

func decodeAppsListInstallationReposForAuthenticatedUserParams(r *http.Request) (AppsListInstallationReposForAuthenticatedUserParams, error) {
	var params AppsListInstallationReposForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "installation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'installation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'installation_id': %w", err)
		}

		params.InstallationID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeAppsAddRepoToInstallationParams(r *http.Request) (AppsAddRepoToInstallationParams, error) {
	var params AppsAddRepoToInstallationParams
	{
		param := chi.URLParam(r, "installation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'installation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'installation_id': %w", err)
		}

		params.InstallationID = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeAppsRemoveRepoFromInstallationParams(r *http.Request) (AppsRemoveRepoFromInstallationParams, error) {
	var params AppsRemoveRepoFromInstallationParams
	{
		param := chi.URLParam(r, "installation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'installation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'installation_id': %w", err)
		}

		params.InstallationID = v
	}
	{
		param := chi.URLParam(r, "repository_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repository_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repository_id': %w", err)
		}

		params.RepositoryID = v
	}

	return params, nil
}

func decodeUsersListPublicSSHKeysForAuthenticatedParams(r *http.Request) (UsersListPublicSSHKeysForAuthenticatedParams, error) {
	var params UsersListPublicSSHKeysForAuthenticatedParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersGetPublicSSHKeyForAuthenticatedParams(r *http.Request) (UsersGetPublicSSHKeyForAuthenticatedParams, error) {
	var params UsersGetPublicSSHKeyForAuthenticatedParams
	{
		param := chi.URLParam(r, "key_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'key_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'key_id': %w", err)
		}

		params.KeyID = v
	}

	return params, nil
}

func decodeUsersDeletePublicSSHKeyForAuthenticatedParams(r *http.Request) (UsersDeletePublicSSHKeyForAuthenticatedParams, error) {
	var params UsersDeletePublicSSHKeyForAuthenticatedParams
	{
		param := chi.URLParam(r, "key_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'key_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'key_id': %w", err)
		}

		params.KeyID = v
	}

	return params, nil
}

func decodeAppsListSubscriptionsForAuthenticatedUserParams(r *http.Request) (AppsListSubscriptionsForAuthenticatedUserParams, error) {
	var params AppsListSubscriptionsForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeAppsListSubscriptionsForAuthenticatedUserStubbedParams(r *http.Request) (AppsListSubscriptionsForAuthenticatedUserStubbedParams, error) {
	var params AppsListSubscriptionsForAuthenticatedUserStubbedParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsGetMembershipForAuthenticatedUserParams(r *http.Request) (OrgsGetMembershipForAuthenticatedUserParams, error) {
	var params OrgsGetMembershipForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}

	return params, nil
}

func decodeMigrationsListForAuthenticatedUserParams(r *http.Request) (MigrationsListForAuthenticatedUserParams, error) {
	var params MigrationsListForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeMigrationsGetStatusForAuthenticatedUserParams(r *http.Request) (MigrationsGetStatusForAuthenticatedUserParams, error) {
	var params MigrationsGetStatusForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}
	{
		param := r.URL.Query().Get("exclude")
		if len(param) > 0 {
			v, err := conv.ToStringArray(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'exclude': %w", err)
			}

			params.Exclude = v
		}
	}

	return params, nil
}

func decodeMigrationsGetArchiveForAuthenticatedUserParams(r *http.Request) (MigrationsGetArchiveForAuthenticatedUserParams, error) {
	var params MigrationsGetArchiveForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}

	return params, nil
}

func decodeMigrationsDeleteArchiveForAuthenticatedUserParams(r *http.Request) (MigrationsDeleteArchiveForAuthenticatedUserParams, error) {
	var params MigrationsDeleteArchiveForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}

	return params, nil
}

func decodeMigrationsUnlockRepoForAuthenticatedUserParams(r *http.Request) (MigrationsUnlockRepoForAuthenticatedUserParams, error) {
	var params MigrationsUnlockRepoForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}
	{
		param := chi.URLParam(r, "repo_name")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo_name' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo_name': %w", err)
		}

		params.RepoName = v
	}

	return params, nil
}

func decodeMigrationsListReposForUserParams(r *http.Request) (MigrationsListReposForUserParams, error) {
	var params MigrationsListReposForUserParams
	{
		param := chi.URLParam(r, "migration_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'migration_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'migration_id': %w", err)
		}

		params.MigrationID = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsListForAuthenticatedUserParams(r *http.Request) (OrgsListForAuthenticatedUserParams, error) {
	var params OrgsListForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersListPublicEmailsForAuthenticatedParams(r *http.Request) (UsersListPublicEmailsForAuthenticatedParams, error) {
	var params UsersListPublicEmailsForAuthenticatedParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposListInvitationsForAuthenticatedUserParams(r *http.Request) (ReposListInvitationsForAuthenticatedUserParams, error) {
	var params ReposListInvitationsForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeReposDeclineInvitationParams(r *http.Request) (ReposDeclineInvitationParams, error) {
	var params ReposDeclineInvitationParams
	{
		param := chi.URLParam(r, "invitation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'invitation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'invitation_id': %w", err)
		}

		params.InvitationID = v
	}

	return params, nil
}

func decodeReposAcceptInvitationParams(r *http.Request) (ReposAcceptInvitationParams, error) {
	var params ReposAcceptInvitationParams
	{
		param := chi.URLParam(r, "invitation_id")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'invitation_id' is empty")
		}

		v, err := conv.ToInt(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'invitation_id': %w", err)
		}

		params.InvitationID = v
	}

	return params, nil
}

func decodeActivityCheckRepoIsStarredByAuthenticatedUserParams(r *http.Request) (ActivityCheckRepoIsStarredByAuthenticatedUserParams, error) {
	var params ActivityCheckRepoIsStarredByAuthenticatedUserParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActivityStarRepoForAuthenticatedUserParams(r *http.Request) (ActivityStarRepoForAuthenticatedUserParams, error) {
	var params ActivityStarRepoForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActivityUnstarRepoForAuthenticatedUserParams(r *http.Request) (ActivityUnstarRepoForAuthenticatedUserParams, error) {
	var params ActivityUnstarRepoForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "owner")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'owner' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'owner': %w", err)
		}

		params.Owner = v
	}
	{
		param := chi.URLParam(r, "repo")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'repo' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'repo': %w", err)
		}

		params.Repo = v
	}

	return params, nil
}

func decodeActivityListWatchedReposForAuthenticatedUserParams(r *http.Request) (ActivityListWatchedReposForAuthenticatedUserParams, error) {
	var params ActivityListWatchedReposForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeTeamsListForAuthenticatedUserParams(r *http.Request) (TeamsListForAuthenticatedUserParams, error) {
	var params TeamsListForAuthenticatedUserParams
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersListParams(r *http.Request) (UsersListParams, error) {
	var params UsersListParams
	{
		param := r.URL.Query().Get("since")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'since': %w", err)
			}

			params.Since = v
		}
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}

	return params, nil
}

func decodeActivityListEventsForAuthenticatedUserParams(r *http.Request) (ActivityListEventsForAuthenticatedUserParams, error) {
	var params ActivityListEventsForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityListOrgEventsForAuthenticatedUserParams(r *http.Request) (ActivityListOrgEventsForAuthenticatedUserParams, error) {
	var params ActivityListOrgEventsForAuthenticatedUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := chi.URLParam(r, "org")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'org' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'org': %w", err)
		}

		params.Org = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityListPublicEventsForUserParams(r *http.Request) (ActivityListPublicEventsForUserParams, error) {
	var params ActivityListPublicEventsForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersListFollowersForUserParams(r *http.Request) (UsersListFollowersForUserParams, error) {
	var params UsersListFollowersForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersListFollowingForUserParams(r *http.Request) (UsersListFollowingForUserParams, error) {
	var params UsersListFollowingForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersCheckFollowingForUserParams(r *http.Request) (UsersCheckFollowingForUserParams, error) {
	var params UsersCheckFollowingForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := chi.URLParam(r, "target_user")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'target_user' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'target_user': %w", err)
		}

		params.TargetUser = v
	}

	return params, nil
}

func decodeUsersListGpgKeysForUserParams(r *http.Request) (UsersListGpgKeysForUserParams, error) {
	var params UsersListGpgKeysForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeUsersListPublicKeysForUserParams(r *http.Request) (UsersListPublicKeysForUserParams, error) {
	var params UsersListPublicKeysForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeOrgsListForUserParams(r *http.Request) (OrgsListForUserParams, error) {
	var params OrgsListForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityListReceivedEventsForUserParams(r *http.Request) (ActivityListReceivedEventsForUserParams, error) {
	var params ActivityListReceivedEventsForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeActivityListReceivedPublicEventsForUserParams(r *http.Request) (ActivityListReceivedPublicEventsForUserParams, error) {
	var params ActivityListReceivedPublicEventsForUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}

func decodeBillingGetGithubActionsBillingUserParams(r *http.Request) (BillingGetGithubActionsBillingUserParams, error) {
	var params BillingGetGithubActionsBillingUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeBillingGetGithubPackagesBillingUserParams(r *http.Request) (BillingGetGithubPackagesBillingUserParams, error) {
	var params BillingGetGithubPackagesBillingUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeBillingGetSharedStorageBillingUserParams(r *http.Request) (BillingGetSharedStorageBillingUserParams, error) {
	var params BillingGetSharedStorageBillingUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}

	return params, nil
}

func decodeActivityListReposWatchedByUserParams(r *http.Request) (ActivityListReposWatchedByUserParams, error) {
	var params ActivityListReposWatchedByUserParams
	{
		param := chi.URLParam(r, "username")
		if len(param) == 0 {
			return params, fmt.Errorf("path param 'username' is empty")
		}

		v, err := conv.ToString(param)
		if err != nil {
			return params, fmt.Errorf("parse path param 'username': %w", err)
		}

		params.Username = v
	}
	{
		param := r.URL.Query().Get("per_page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'per_page': %w", err)
			}

			params.PerPage = v
		}
	}
	{
		param := r.URL.Query().Get("page")
		if len(param) > 0 {
			v, err := conv.ToInt(param)
			if err != nil {
				return params, fmt.Errorf("parse query param 'page': %w", err)
			}

			params.Page = v
		}
	}

	return params, nil
}
