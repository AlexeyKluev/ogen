// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/big"
	"math/bits"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = bits.LeadingZeros64
	_ = big.Rat{}
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
	_ = codes.Unset
)

// Encode implements json.Marshaler.
func (s Balloon) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"amount_mib\"" + ":")
		e.Int(s.AmountMib)
	}
	{
		e.Comma()

		e.RawStr("\"deflate_on_oom\"" + ":")
		e.Bool(s.DeflateOnOom)
	}
	{
		if s.StatsPollingIntervalS.Set {
			e.Comma()
		}
		if s.StatsPollingIntervalS.Set {
			e.RawStr("\"stats_polling_interval_s\"" + ":")
			s.StatsPollingIntervalS.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBalloon = [3]string{
	0: "amount_mib",
	1: "deflate_on_oom",
	2: "stats_polling_interval_s",
}

// Decode decodes Balloon from json.
func (s *Balloon) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Balloon to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "amount_mib":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AmountMib = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount_mib\"")
			}
		case "deflate_on_oom":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.DeflateOnOom = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deflate_on_oom\"")
			}
		case "stats_polling_interval_s":
			if err := func() error {
				s.StatsPollingIntervalS.Reset()
				if err := s.StatsPollingIntervalS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats_polling_interval_s\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Balloon")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBalloon) {
					name = jsonFieldsNameOfBalloon[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BalloonStats) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"target_pages\"" + ":")
		e.Int(s.TargetPages)
	}
	{
		e.Comma()

		e.RawStr("\"actual_pages\"" + ":")
		e.Int(s.ActualPages)
	}
	{
		e.Comma()

		e.RawStr("\"target_mib\"" + ":")
		e.Int(s.TargetMib)
	}
	{
		e.Comma()

		e.RawStr("\"actual_mib\"" + ":")
		e.Int(s.ActualMib)
	}
	{
		if s.SwapIn.Set {
			e.Comma()
		}
		if s.SwapIn.Set {
			e.RawStr("\"swap_in\"" + ":")
			s.SwapIn.Encode(e)
		}
	}
	{
		if s.SwapOut.Set {
			e.Comma()
		}
		if s.SwapOut.Set {
			e.RawStr("\"swap_out\"" + ":")
			s.SwapOut.Encode(e)
		}
	}
	{
		if s.MajorFaults.Set {
			e.Comma()
		}
		if s.MajorFaults.Set {
			e.RawStr("\"major_faults\"" + ":")
			s.MajorFaults.Encode(e)
		}
	}
	{
		if s.MinorFaults.Set {
			e.Comma()
		}
		if s.MinorFaults.Set {
			e.RawStr("\"minor_faults\"" + ":")
			s.MinorFaults.Encode(e)
		}
	}
	{
		if s.FreeMemory.Set {
			e.Comma()
		}
		if s.FreeMemory.Set {
			e.RawStr("\"free_memory\"" + ":")
			s.FreeMemory.Encode(e)
		}
	}
	{
		if s.TotalMemory.Set {
			e.Comma()
		}
		if s.TotalMemory.Set {
			e.RawStr("\"total_memory\"" + ":")
			s.TotalMemory.Encode(e)
		}
	}
	{
		if s.AvailableMemory.Set {
			e.Comma()
		}
		if s.AvailableMemory.Set {
			e.RawStr("\"available_memory\"" + ":")
			s.AvailableMemory.Encode(e)
		}
	}
	{
		if s.DiskCaches.Set {
			e.Comma()
		}
		if s.DiskCaches.Set {
			e.RawStr("\"disk_caches\"" + ":")
			s.DiskCaches.Encode(e)
		}
	}
	{
		if s.HugetlbAllocations.Set {
			e.Comma()
		}
		if s.HugetlbAllocations.Set {
			e.RawStr("\"hugetlb_allocations\"" + ":")
			s.HugetlbAllocations.Encode(e)
		}
	}
	{
		if s.HugetlbFailures.Set {
			e.Comma()
		}
		if s.HugetlbFailures.Set {
			e.RawStr("\"hugetlb_failures\"" + ":")
			s.HugetlbFailures.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBalloonStats = [14]string{
	0:  "target_pages",
	1:  "actual_pages",
	2:  "target_mib",
	3:  "actual_mib",
	4:  "swap_in",
	5:  "swap_out",
	6:  "major_faults",
	7:  "minor_faults",
	8:  "free_memory",
	9:  "total_memory",
	10: "available_memory",
	11: "disk_caches",
	12: "hugetlb_allocations",
	13: "hugetlb_failures",
}

// Decode decodes BalloonStats from json.
func (s *BalloonStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BalloonStats to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "target_pages":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TargetPages = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_pages\"")
			}
		case "actual_pages":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ActualPages = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actual_pages\"")
			}
		case "target_mib":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.TargetMib = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_mib\"")
			}
		case "actual_mib":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ActualMib = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actual_mib\"")
			}
		case "swap_in":
			if err := func() error {
				s.SwapIn.Reset()
				if err := s.SwapIn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"swap_in\"")
			}
		case "swap_out":
			if err := func() error {
				s.SwapOut.Reset()
				if err := s.SwapOut.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"swap_out\"")
			}
		case "major_faults":
			if err := func() error {
				s.MajorFaults.Reset()
				if err := s.MajorFaults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"major_faults\"")
			}
		case "minor_faults":
			if err := func() error {
				s.MinorFaults.Reset()
				if err := s.MinorFaults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minor_faults\"")
			}
		case "free_memory":
			if err := func() error {
				s.FreeMemory.Reset()
				if err := s.FreeMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"free_memory\"")
			}
		case "total_memory":
			if err := func() error {
				s.TotalMemory.Reset()
				if err := s.TotalMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_memory\"")
			}
		case "available_memory":
			if err := func() error {
				s.AvailableMemory.Reset()
				if err := s.AvailableMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available_memory\"")
			}
		case "disk_caches":
			if err := func() error {
				s.DiskCaches.Reset()
				if err := s.DiskCaches.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk_caches\"")
			}
		case "hugetlb_allocations":
			if err := func() error {
				s.HugetlbAllocations.Reset()
				if err := s.HugetlbAllocations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hugetlb_allocations\"")
			}
		case "hugetlb_failures":
			if err := func() error {
				s.HugetlbFailures.Reset()
				if err := s.HugetlbFailures.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hugetlb_failures\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BalloonStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBalloonStats) {
					name = jsonFieldsNameOfBalloonStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BalloonStatsUpdate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"stats_polling_interval_s\"" + ":")
		e.Int(s.StatsPollingIntervalS)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBalloonStatsUpdate = [1]string{
	0: "stats_polling_interval_s",
}

// Decode decodes BalloonStatsUpdate from json.
func (s *BalloonStatsUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BalloonStatsUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stats_polling_interval_s":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.StatsPollingIntervalS = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats_polling_interval_s\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BalloonStatsUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBalloonStatsUpdate) {
					name = jsonFieldsNameOfBalloonStatsUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BalloonUpdate) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"amount_mib\"" + ":")
		e.Int(s.AmountMib)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBalloonUpdate = [1]string{
	0: "amount_mib",
}

// Decode decodes BalloonUpdate from json.
func (s *BalloonUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BalloonUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "amount_mib":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.AmountMib = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount_mib\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BalloonUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBalloonUpdate) {
					name = jsonFieldsNameOfBalloonUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s BootSource) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.BootArgs.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BootArgs.Set {
			e.RawStr("\"boot_args\"" + ":")
			s.BootArgs.Encode(e)
		}
	}
	{
		if s.InitrdPath.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.InitrdPath.Set {
			e.RawStr("\"initrd_path\"" + ":")
			s.InitrdPath.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"kernel_image_path\"" + ":")
		e.Str(s.KernelImagePath)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfBootSource = [3]string{
	0: "boot_args",
	1: "initrd_path",
	2: "kernel_image_path",
}

// Decode decodes BootSource from json.
func (s *BootSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BootSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "boot_args":
			if err := func() error {
				s.BootArgs.Reset()
				if err := s.BootArgs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boot_args\"")
			}
		case "initrd_path":
			if err := func() error {
				s.InitrdPath.Reset()
				if err := s.InitrdPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initrd_path\"")
			}
		case "kernel_image_path":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.KernelImagePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kernel_image_path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BootSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBootSource) {
					name = jsonFieldsNameOfBootSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes CpuTemplate as json.
func (s CpuTemplate) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CpuTemplate from json.
func (s *CpuTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CpuTemplate to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CpuTemplate(v) {
	case CpuTemplateC3:
		*s = CpuTemplateC3
	case CpuTemplateT2:
		*s = CpuTemplateT2
	default:
		*s = CpuTemplate(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Drive) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"drive_id\"" + ":")
		e.Str(s.DriveID)
	}
	{
		if s.CacheType.Set {
			e.Comma()
		}
		if s.CacheType.Set {
			e.RawStr("\"cache_type\"" + ":")
			s.CacheType.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"is_read_only\"" + ":")
		e.Bool(s.IsReadOnly)
	}
	{
		e.Comma()

		e.RawStr("\"is_root_device\"" + ":")
		e.Bool(s.IsRootDevice)
	}
	{
		if s.Partuuid.Set {
			e.Comma()
		}
		if s.Partuuid.Set {
			e.RawStr("\"partuuid\"" + ":")
			s.Partuuid.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"path_on_host\"" + ":")
		e.Str(s.PathOnHost)
	}
	{
		if s.RateLimiter.Set {
			e.Comma()
		}
		if s.RateLimiter.Set {
			e.RawStr("\"rate_limiter\"" + ":")
			s.RateLimiter.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfDrive = [7]string{
	0: "drive_id",
	1: "cache_type",
	2: "is_read_only",
	3: "is_root_device",
	4: "partuuid",
	5: "path_on_host",
	6: "rate_limiter",
}

// Decode decodes Drive from json.
func (s *Drive) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Drive to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "drive_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DriveID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drive_id\"")
			}
		case "cache_type":
			if err := func() error {
				s.CacheType.Reset()
				if err := s.CacheType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cache_type\"")
			}
		case "is_read_only":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsReadOnly = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_read_only\"")
			}
		case "is_root_device":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsRootDevice = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_root_device\"")
			}
		case "partuuid":
			if err := func() error {
				s.Partuuid.Reset()
				if err := s.Partuuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partuuid\"")
			}
		case "path_on_host":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PathOnHost = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path_on_host\"")
			}
		case "rate_limiter":
			if err := func() error {
				s.RateLimiter.Reset()
				if err := s.RateLimiter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limiter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Drive")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDrive) {
					name = jsonFieldsNameOfDrive[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Error) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.FaultMessage.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.FaultMessage.Set {
			e.RawStr("\"fault_message\"" + ":")
			s.FaultMessage.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfError = [1]string{
	0: "fault_message",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fault_message":
			if err := func() error {
				s.FaultMessage.Reset()
				if err := s.FaultMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fault_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s FullVmConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.BalloonDevice.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BalloonDevice.Set {
			e.RawStr("\"balloon_device\"" + ":")
			s.BalloonDevice.Encode(e)
		}
	}
	{
		if s.BlockDevices != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BlockDevices != nil {
			e.RawStr("\"block_devices\"" + ":")
			e.ArrStart()
			if len(s.BlockDevices) >= 1 {
				// Encode first element without comma.
				{
					elem := s.BlockDevices[0]
					elem.Encode(e)
				}
				for _, elem := range s.BlockDevices[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.BootSource.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BootSource.Set {
			e.RawStr("\"boot_source\"" + ":")
			s.BootSource.Encode(e)
		}
	}
	{
		if s.Logger.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Logger.Set {
			e.RawStr("\"logger\"" + ":")
			s.Logger.Encode(e)
		}
	}
	{
		if s.MachineConfig.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MachineConfig.Set {
			e.RawStr("\"machine_config\"" + ":")
			s.MachineConfig.Encode(e)
		}
	}
	{
		if s.Metrics.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Metrics.Set {
			e.RawStr("\"metrics\"" + ":")
			s.Metrics.Encode(e)
		}
	}
	{
		if s.MmdsConfig.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.MmdsConfig.Set {
			e.RawStr("\"mmds_config\"" + ":")
			s.MmdsConfig.Encode(e)
		}
	}
	{
		if s.NetDevices != nil {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.NetDevices != nil {
			e.RawStr("\"net_devices\"" + ":")
			e.ArrStart()
			if len(s.NetDevices) >= 1 {
				// Encode first element without comma.
				{
					elem := s.NetDevices[0]
					elem.Encode(e)
				}
				for _, elem := range s.NetDevices[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.VsockDevice.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.VsockDevice.Set {
			e.RawStr("\"vsock_device\"" + ":")
			s.VsockDevice.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfFullVmConfiguration = [9]string{
	0: "balloon_device",
	1: "block_devices",
	2: "boot_source",
	3: "logger",
	4: "machine_config",
	5: "metrics",
	6: "mmds_config",
	7: "net_devices",
	8: "vsock_device",
}

// Decode decodes FullVmConfiguration from json.
func (s *FullVmConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FullVmConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "balloon_device":
			if err := func() error {
				s.BalloonDevice.Reset()
				if err := s.BalloonDevice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balloon_device\"")
			}
		case "block_devices":
			if err := func() error {
				s.BlockDevices = make([]Drive, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Drive
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BlockDevices = append(s.BlockDevices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"block_devices\"")
			}
		case "boot_source":
			if err := func() error {
				s.BootSource.Reset()
				if err := s.BootSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boot_source\"")
			}
		case "logger":
			if err := func() error {
				s.Logger.Reset()
				if err := s.Logger.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logger\"")
			}
		case "machine_config":
			if err := func() error {
				s.MachineConfig.Reset()
				if err := s.MachineConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"machine_config\"")
			}
		case "metrics":
			if err := func() error {
				s.Metrics.Reset()
				if err := s.Metrics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics\"")
			}
		case "mmds_config":
			if err := func() error {
				s.MmdsConfig.Reset()
				if err := s.MmdsConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mmds_config\"")
			}
		case "net_devices":
			if err := func() error {
				s.NetDevices = make([]NetworkInterface, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NetworkInterface
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NetDevices = append(s.NetDevices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"net_devices\"")
			}
		case "vsock_device":
			if err := func() error {
				s.VsockDevice.Reset()
				if err := s.VsockDevice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsock_device\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FullVmConfiguration")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InstanceActionInfo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"action_type\"" + ":")
		s.ActionType.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInstanceActionInfo = [1]string{
	0: "action_type",
}

// Decode decodes InstanceActionInfo from json.
func (s *InstanceActionInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceActionInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstanceActionInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInstanceActionInfo) {
					name = jsonFieldsNameOfInstanceActionInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes InstanceActionInfoActionType as json.
func (s InstanceActionInfoActionType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes InstanceActionInfoActionType from json.
func (s *InstanceActionInfoActionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceActionInfoActionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InstanceActionInfoActionType(v) {
	case InstanceActionInfoActionTypeFlushMetrics:
		*s = InstanceActionInfoActionTypeFlushMetrics
	case InstanceActionInfoActionTypeInstanceStart:
		*s = InstanceActionInfoActionTypeInstanceStart
	case InstanceActionInfoActionTypeSendCtrlAltDel:
		*s = InstanceActionInfoActionTypeSendCtrlAltDel
	default:
		*s = InstanceActionInfoActionType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s InstanceInfo) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"app_name\"" + ":")
		e.Str(s.AppName)
	}
	{
		e.Comma()

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"vmm_version\"" + ":")
		e.Str(s.VmmVersion)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfInstanceInfo = [4]string{
	0: "app_name",
	1: "id",
	2: "state",
	3: "vmm_version",
}

// Decode decodes InstanceInfo from json.
func (s *InstanceInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "app_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AppName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app_name\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "vmm_version":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VmmVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmm_version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstanceInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInstanceInfo) {
					name = jsonFieldsNameOfInstanceInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes InstanceInfoState as json.
func (s InstanceInfoState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes InstanceInfoState from json.
func (s *InstanceInfoState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceInfoState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InstanceInfoState(v) {
	case InstanceInfoStateNotStarted:
		*s = InstanceInfoStateNotStarted
	case InstanceInfoStateRunning:
		*s = InstanceInfoStateRunning
	case InstanceInfoStatePaused:
		*s = InstanceInfoStatePaused
	default:
		*s = InstanceInfoState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Logger) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Level.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Level.Set {
			e.RawStr("\"level\"" + ":")
			s.Level.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"log_path\"" + ":")
		e.Str(s.LogPath)
	}
	{
		if s.ShowLevel.Set {
			e.Comma()
		}
		if s.ShowLevel.Set {
			e.RawStr("\"show_level\"" + ":")
			s.ShowLevel.Encode(e)
		}
	}
	{
		if s.ShowLogOrigin.Set {
			e.Comma()
		}
		if s.ShowLogOrigin.Set {
			e.RawStr("\"show_log_origin\"" + ":")
			s.ShowLogOrigin.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLogger = [4]string{
	0: "level",
	1: "log_path",
	2: "show_level",
	3: "show_log_origin",
}

// Decode decodes Logger from json.
func (s *Logger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Logger to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "log_path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LogPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"log_path\"")
			}
		case "show_level":
			if err := func() error {
				s.ShowLevel.Reset()
				if err := s.ShowLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_level\"")
			}
		case "show_log_origin":
			if err := func() error {
				s.ShowLogOrigin.Reset()
				if err := s.ShowLogOrigin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"show_log_origin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Logger")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLogger) {
					name = jsonFieldsNameOfLogger[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes LoggerLevel as json.
func (s LoggerLevel) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes LoggerLevel from json.
func (s *LoggerLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoggerLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LoggerLevel(v) {
	case LoggerLevelError:
		*s = LoggerLevelError
	case LoggerLevelWarning:
		*s = LoggerLevelWarning
	case LoggerLevelInfo:
		*s = LoggerLevelInfo
	case LoggerLevelDebug:
		*s = LoggerLevelDebug
	default:
		*s = LoggerLevel(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MachineConfiguration) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.CPUTemplate.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.CPUTemplate.Set {
			e.RawStr("\"cpu_template\"" + ":")
			s.CPUTemplate.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"ht_enabled\"" + ":")
		e.Bool(s.HtEnabled)
	}
	{
		e.Comma()

		e.RawStr("\"mem_size_mib\"" + ":")
		e.Int(s.MemSizeMib)
	}
	{
		if s.TrackDirtyPages.Set {
			e.Comma()
		}
		if s.TrackDirtyPages.Set {
			e.RawStr("\"track_dirty_pages\"" + ":")
			s.TrackDirtyPages.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"vcpu_count\"" + ":")
		e.Int(s.VcpuCount)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMachineConfiguration = [5]string{
	0: "cpu_template",
	1: "ht_enabled",
	2: "mem_size_mib",
	3: "track_dirty_pages",
	4: "vcpu_count",
}

// Decode decodes MachineConfiguration from json.
func (s *MachineConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MachineConfiguration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cpu_template":
			if err := func() error {
				s.CPUTemplate.Reset()
				if err := s.CPUTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu_template\"")
			}
		case "ht_enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HtEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ht_enabled\"")
			}
		case "mem_size_mib":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MemSizeMib = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mem_size_mib\"")
			}
		case "track_dirty_pages":
			if err := func() error {
				s.TrackDirtyPages.Reset()
				if err := s.TrackDirtyPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"track_dirty_pages\"")
			}
		case "vcpu_count":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.VcpuCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vcpu_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MachineConfiguration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMachineConfiguration) {
					name = jsonFieldsNameOfMachineConfiguration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Metrics) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"metrics_path\"" + ":")
		e.Str(s.MetricsPath)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMetrics = [1]string{
	0: "metrics_path",
}

// Decode decodes Metrics from json.
func (s *Metrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Metrics to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metrics_path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MetricsPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics_path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Metrics")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMetrics) {
					name = jsonFieldsNameOfMetrics[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MmdsConfig) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Ipv4Address.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ipv4Address.Set {
			e.RawStr("\"ipv4_address\"" + ":")
			s.Ipv4Address.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMmdsConfig = [1]string{
	0: "ipv4_address",
}

// Decode decodes MmdsConfig from json.
func (s *MmdsConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MmdsConfig to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipv4_address":
			if err := func() error {
				s.Ipv4Address.Reset()
				if err := s.Ipv4Address.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipv4_address\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MmdsConfig")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MmdsGetOK) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfMmdsGetOK = [0]string{}

// Decode decodes MmdsGetOK from json.
func (s *MmdsGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MmdsGetOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MmdsGetOK")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MmdsPatchReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfMmdsPatchReq = [0]string{}

// Decode decodes MmdsPatchReq from json.
func (s *MmdsPatchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MmdsPatchReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MmdsPatchReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MmdsPutReq) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfMmdsPutReq = [0]string{}

// Decode decodes MmdsPutReq from json.
func (s *MmdsPutReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MmdsPutReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MmdsPutReq")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s NetworkInterface) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.AllowMmdsRequests.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.AllowMmdsRequests.Set {
			e.RawStr("\"allow_mmds_requests\"" + ":")
			s.AllowMmdsRequests.Encode(e)
		}
	}
	{
		if s.GuestMAC.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.GuestMAC.Set {
			e.RawStr("\"guest_mac\"" + ":")
			s.GuestMAC.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"host_dev_name\"" + ":")
		e.Str(s.HostDevName)
	}
	{
		e.Comma()

		e.RawStr("\"iface_id\"" + ":")
		e.Str(s.IfaceID)
	}
	{
		if s.RxRateLimiter.Set {
			e.Comma()
		}
		if s.RxRateLimiter.Set {
			e.RawStr("\"rx_rate_limiter\"" + ":")
			s.RxRateLimiter.Encode(e)
		}
	}
	{
		if s.TxRateLimiter.Set {
			e.Comma()
		}
		if s.TxRateLimiter.Set {
			e.RawStr("\"tx_rate_limiter\"" + ":")
			s.TxRateLimiter.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfNetworkInterface = [6]string{
	0: "allow_mmds_requests",
	1: "guest_mac",
	2: "host_dev_name",
	3: "iface_id",
	4: "rx_rate_limiter",
	5: "tx_rate_limiter",
}

// Decode decodes NetworkInterface from json.
func (s *NetworkInterface) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkInterface to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allow_mmds_requests":
			if err := func() error {
				s.AllowMmdsRequests.Reset()
				if err := s.AllowMmdsRequests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_mmds_requests\"")
			}
		case "guest_mac":
			if err := func() error {
				s.GuestMAC.Reset()
				if err := s.GuestMAC.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guest_mac\"")
			}
		case "host_dev_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.HostDevName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_dev_name\"")
			}
		case "iface_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.IfaceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iface_id\"")
			}
		case "rx_rate_limiter":
			if err := func() error {
				s.RxRateLimiter.Reset()
				if err := s.RxRateLimiter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rx_rate_limiter\"")
			}
		case "tx_rate_limiter":
			if err := func() error {
				s.TxRateLimiter.Reset()
				if err := s.TxRateLimiter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tx_rate_limiter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkInterface")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNetworkInterface) {
					name = jsonFieldsNameOfNetworkInterface[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes Balloon as json.
func (o OptBalloon) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Balloon from json.
func (o *OptBalloon) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBalloon to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBalloon", d.Next())
	}
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	switch d.Next() {
	case jx.Bool:
		o.Set = true
		v, err := d.Bool()
		if err != nil {
			return err
		}
		o.Value = bool(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBool", d.Next())
	}
}

// Encode encodes BootSource as json.
func (o OptBootSource) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BootSource from json.
func (o *OptBootSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBootSource to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBootSource", d.Next())
	}
}

// Encode encodes CpuTemplate as json.
func (o OptCpuTemplate) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CpuTemplate from json.
func (o *OptCpuTemplate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCpuTemplate to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCpuTemplate", d.Next())
	}
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int()
		if err != nil {
			return err
		}
		o.Value = int(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptInt", d.Next())
	}
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int64()
		if err != nil {
			return err
		}
		o.Value = int64(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptInt64", d.Next())
	}
}

// Encode encodes Logger as json.
func (o OptLogger) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Logger from json.
func (o *OptLogger) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLogger to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptLogger", d.Next())
	}
}

// Encode encodes LoggerLevel as json.
func (o OptLoggerLevel) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LoggerLevel from json.
func (o *OptLoggerLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLoggerLevel to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptLoggerLevel", d.Next())
	}
}

// Encode encodes MachineConfiguration as json.
func (o OptMachineConfiguration) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MachineConfiguration from json.
func (o *OptMachineConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMachineConfiguration to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptMachineConfiguration", d.Next())
	}
}

// Encode encodes Metrics as json.
func (o OptMetrics) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Metrics from json.
func (o *OptMetrics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMetrics to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptMetrics", d.Next())
	}
}

// Encode encodes MmdsConfig as json.
func (o OptMmdsConfig) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MmdsConfig from json.
func (o *OptMmdsConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMmdsConfig to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptMmdsConfig", d.Next())
	}
}

// Encode encodes RateLimiter as json.
func (o OptRateLimiter) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RateLimiter from json.
func (o *OptRateLimiter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRateLimiter to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptRateLimiter", d.Next())
	}
}

// Encode encodes SnapshotCreateParamsSnapshotType as json.
func (o OptSnapshotCreateParamsSnapshotType) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SnapshotCreateParamsSnapshotType from json.
func (o *OptSnapshotCreateParamsSnapshotType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSnapshotCreateParamsSnapshotType to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptSnapshotCreateParamsSnapshotType", d.Next())
	}
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptString", d.Next())
	}
}

// Encode encodes TokenBucket as json.
func (o OptTokenBucket) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TokenBucket from json.
func (o *OptTokenBucket) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTokenBucket to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptTokenBucket", d.Next())
	}
}

// Encode encodes Vsock as json.
func (o OptVsock) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Vsock from json.
func (o *OptVsock) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVsock to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptVsock", d.Next())
	}
}

// Encode implements json.Marshaler.
func (s PartialDrive) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"drive_id\"" + ":")
		e.Str(s.DriveID)
	}
	{
		if s.PathOnHost.Set {
			e.Comma()
		}
		if s.PathOnHost.Set {
			e.RawStr("\"path_on_host\"" + ":")
			s.PathOnHost.Encode(e)
		}
	}
	{
		if s.RateLimiter.Set {
			e.Comma()
		}
		if s.RateLimiter.Set {
			e.RawStr("\"rate_limiter\"" + ":")
			s.RateLimiter.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPartialDrive = [3]string{
	0: "drive_id",
	1: "path_on_host",
	2: "rate_limiter",
}

// Decode decodes PartialDrive from json.
func (s *PartialDrive) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PartialDrive to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "drive_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DriveID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drive_id\"")
			}
		case "path_on_host":
			if err := func() error {
				s.PathOnHost.Reset()
				if err := s.PathOnHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path_on_host\"")
			}
		case "rate_limiter":
			if err := func() error {
				s.RateLimiter.Reset()
				if err := s.RateLimiter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate_limiter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PartialDrive")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPartialDrive) {
					name = jsonFieldsNameOfPartialDrive[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PartialNetworkInterface) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"iface_id\"" + ":")
		e.Str(s.IfaceID)
	}
	{
		if s.RxRateLimiter.Set {
			e.Comma()
		}
		if s.RxRateLimiter.Set {
			e.RawStr("\"rx_rate_limiter\"" + ":")
			s.RxRateLimiter.Encode(e)
		}
	}
	{
		if s.TxRateLimiter.Set {
			e.Comma()
		}
		if s.TxRateLimiter.Set {
			e.RawStr("\"tx_rate_limiter\"" + ":")
			s.TxRateLimiter.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPartialNetworkInterface = [3]string{
	0: "iface_id",
	1: "rx_rate_limiter",
	2: "tx_rate_limiter",
}

// Decode decodes PartialNetworkInterface from json.
func (s *PartialNetworkInterface) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PartialNetworkInterface to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "iface_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IfaceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iface_id\"")
			}
		case "rx_rate_limiter":
			if err := func() error {
				s.RxRateLimiter.Reset()
				if err := s.RxRateLimiter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rx_rate_limiter\"")
			}
		case "tx_rate_limiter":
			if err := func() error {
				s.TxRateLimiter.Reset()
				if err := s.TxRateLimiter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tx_rate_limiter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PartialNetworkInterface")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPartialNetworkInterface) {
					name = jsonFieldsNameOfPartialNetworkInterface[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s RateLimiter) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Bandwidth.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Bandwidth.Set {
			e.RawStr("\"bandwidth\"" + ":")
			s.Bandwidth.Encode(e)
		}
	}
	{
		if s.Ops.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Ops.Set {
			e.RawStr("\"ops\"" + ":")
			s.Ops.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfRateLimiter = [2]string{
	0: "bandwidth",
	1: "ops",
}

// Decode decodes RateLimiter from json.
func (s *RateLimiter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RateLimiter to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bandwidth":
			if err := func() error {
				s.Bandwidth.Reset()
				if err := s.Bandwidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidth\"")
			}
		case "ops":
			if err := func() error {
				s.Ops.Reset()
				if err := s.Ops.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ops\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RateLimiter")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SnapshotCreateParams) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"mem_file_path\"" + ":")
		e.Str(s.MemFilePath)
	}
	{
		e.Comma()

		e.RawStr("\"snapshot_path\"" + ":")
		e.Str(s.SnapshotPath)
	}
	{
		if s.SnapshotType.Set {
			e.Comma()
		}
		if s.SnapshotType.Set {
			e.RawStr("\"snapshot_type\"" + ":")
			s.SnapshotType.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.Comma()
		}
		if s.Version.Set {
			e.RawStr("\"version\"" + ":")
			s.Version.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSnapshotCreateParams = [4]string{
	0: "mem_file_path",
	1: "snapshot_path",
	2: "snapshot_type",
	3: "version",
}

// Decode decodes SnapshotCreateParams from json.
func (s *SnapshotCreateParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnapshotCreateParams to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mem_file_path":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MemFilePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mem_file_path\"")
			}
		case "snapshot_path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SnapshotPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snapshot_path\"")
			}
		case "snapshot_type":
			if err := func() error {
				s.SnapshotType.Reset()
				if err := s.SnapshotType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snapshot_type\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnapshotCreateParams")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSnapshotCreateParams) {
					name = jsonFieldsNameOfSnapshotCreateParams[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes SnapshotCreateParamsSnapshotType as json.
func (s SnapshotCreateParamsSnapshotType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SnapshotCreateParamsSnapshotType from json.
func (s *SnapshotCreateParamsSnapshotType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnapshotCreateParamsSnapshotType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SnapshotCreateParamsSnapshotType(v) {
	case SnapshotCreateParamsSnapshotTypeFull:
		*s = SnapshotCreateParamsSnapshotTypeFull
	case SnapshotCreateParamsSnapshotTypeDiff:
		*s = SnapshotCreateParamsSnapshotTypeDiff
	default:
		*s = SnapshotCreateParamsSnapshotType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SnapshotLoadParams) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.EnableDiffSnapshots.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.EnableDiffSnapshots.Set {
			e.RawStr("\"enable_diff_snapshots\"" + ":")
			s.EnableDiffSnapshots.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"mem_file_path\"" + ":")
		e.Str(s.MemFilePath)
	}
	{
		e.Comma()

		e.RawStr("\"snapshot_path\"" + ":")
		e.Str(s.SnapshotPath)
	}
	{
		if s.ResumeVM.Set {
			e.Comma()
		}
		if s.ResumeVM.Set {
			e.RawStr("\"resume_vm\"" + ":")
			s.ResumeVM.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSnapshotLoadParams = [4]string{
	0: "enable_diff_snapshots",
	1: "mem_file_path",
	2: "snapshot_path",
	3: "resume_vm",
}

// Decode decodes SnapshotLoadParams from json.
func (s *SnapshotLoadParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnapshotLoadParams to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enable_diff_snapshots":
			if err := func() error {
				s.EnableDiffSnapshots.Reset()
				if err := s.EnableDiffSnapshots.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_diff_snapshots\"")
			}
		case "mem_file_path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MemFilePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mem_file_path\"")
			}
		case "snapshot_path":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SnapshotPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snapshot_path\"")
			}
		case "resume_vm":
			if err := func() error {
				s.ResumeVM.Reset()
				if err := s.ResumeVM.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resume_vm\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnapshotLoadParams")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSnapshotLoadParams) {
					name = jsonFieldsNameOfSnapshotLoadParams[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s TokenBucket) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.OneTimeBurst.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.OneTimeBurst.Set {
			e.RawStr("\"one_time_burst\"" + ":")
			s.OneTimeBurst.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"refill_time\"" + ":")
		e.Int64(s.RefillTime)
	}
	{
		e.Comma()

		e.RawStr("\"size\"" + ":")
		e.Int64(s.Size)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfTokenBucket = [3]string{
	0: "one_time_burst",
	1: "refill_time",
	2: "size",
}

// Decode decodes TokenBucket from json.
func (s *TokenBucket) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TokenBucket to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "one_time_burst":
			if err := func() error {
				s.OneTimeBurst.Reset()
				if err := s.OneTimeBurst.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"one_time_burst\"")
			}
		case "refill_time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.RefillTime = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refill_time\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Size = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TokenBucket")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTokenBucket) {
					name = jsonFieldsNameOfTokenBucket[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s VM) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"state\"" + ":")
		s.State.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVM = [1]string{
	0: "state",
}

// Decode decodes VM from json.
func (s *VM) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VM to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VM")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVM) {
					name = jsonFieldsNameOfVM[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes VMState as json.
func (s VMState) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes VMState from json.
func (s *VMState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VMState(v) {
	case VMStatePaused:
		*s = VMStatePaused
	case VMStateResumed:
		*s = VMStateResumed
	default:
		*s = VMState(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Vsock) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"guest_cid\"" + ":")
		e.Int(s.GuestCid)
	}
	{
		e.Comma()

		e.RawStr("\"uds_path\"" + ":")
		e.Str(s.UdsPath)
	}
	{
		e.Comma()

		e.RawStr("\"vsock_id\"" + ":")
		e.Str(s.VsockID)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfVsock = [3]string{
	0: "guest_cid",
	1: "uds_path",
	2: "vsock_id",
}

// Decode decodes Vsock from json.
func (s *Vsock) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Vsock to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "guest_cid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.GuestCid = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guest_cid\"")
			}
		case "uds_path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UdsPath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uds_path\"")
			}
		case "vsock_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VsockID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vsock_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Vsock")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVsock) {
					name = jsonFieldsNameOfVsock[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}
