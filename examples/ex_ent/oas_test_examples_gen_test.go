// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/big"
	"math/bits"
	"net"
	"net/http"
	"net/netip"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/instrument/syncint64"
	"go.opentelemetry.io/otel/metric/nonrecording"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

import (
	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

// No-op definition for keeping imports.
var (
	_ = bytes.NewReader
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = io.Copy
	_ = math.Mod
	_ = big.Rat{}
	_ = bits.LeadingZeros64
	_ = net.IP{}
	_ = http.MethodGet
	_ = netip.Addr{}
	_ = url.URL{}
	_ = regexp.MustCompile
	_ = sort.Ints
	_ = strconv.ParseInt
	_ = strings.Builder{}
	_ = sync.Pool{}
	_ = time.Time{}

	_ = errors.Is
	_ = jx.Null
	_ = uuid.UUID{}
	_ = otel.GetTracerProvider
	_ = attribute.KeyValue{}
	_ = codes.Unset
	_ = metric.MeterConfig{}
	_ = syncint64.Counter(nil)
	_ = nonrecording.NewNoopMeterProvider
	_ = trace.TraceIDFromHex

	_ = conv.ToInt32
	_ = ht.NewRequest
	_ = json.Marshal
	_ = otelogen.Version
	_ = uri.PathEncoder{}
	_ = validate.Int{}
)

var (
	_ = std.Marshal
	_ = testing.TB(nil)
	_ = require.NoError
)

func TestCreatePetCategoriesReq_EncodeDecode(t *testing.T) {
	var typ CreatePetCategoriesReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreatePetCategoriesReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreatePetFriendsReq_EncodeDecode(t *testing.T) {
	var typ CreatePetFriendsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreatePetFriendsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreatePetOwnerReq_EncodeDecode(t *testing.T) {
	var typ CreatePetOwnerReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreatePetOwnerReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreatePetReq_EncodeDecode(t *testing.T) {
	var typ CreatePetReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreatePetReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListPetCategoriesOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ListPetCategoriesOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPetCategoriesOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListPetFriendsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ListPetFriendsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPetFriendsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListPetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ListPetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetCategoriesCreate_EncodeDecode(t *testing.T) {
	var typ PetCategoriesCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetCategoriesCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetCategoriesList_EncodeDecode(t *testing.T) {
	var typ PetCategoriesList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetCategoriesList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetCreate_EncodeDecode(t *testing.T) {
	var typ PetCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetCreateCategories_EncodeDecode(t *testing.T) {
	var typ PetCreateCategories
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetCreateCategories
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetCreateOwner_EncodeDecode(t *testing.T) {
	var typ PetCreateOwner
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetCreateOwner
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetFriendsCreate_EncodeDecode(t *testing.T) {
	var typ PetFriendsCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetFriendsCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetFriendsList_EncodeDecode(t *testing.T) {
	var typ PetFriendsList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetFriendsList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetList_EncodeDecode(t *testing.T) {
	var typ PetList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetOwnerCreate_EncodeDecode(t *testing.T) {
	var typ PetOwnerCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetOwnerCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetOwnerRead_EncodeDecode(t *testing.T) {
	var typ PetOwnerRead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetOwnerRead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetRead_EncodeDecode(t *testing.T) {
	var typ PetRead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetRead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetUpdate_EncodeDecode(t *testing.T) {
	var typ PetUpdate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetUpdate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestR400_EncodeDecode(t *testing.T) {
	var typ R400
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 R400
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestR404_EncodeDecode(t *testing.T) {
	var typ R404
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 R404
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestR409_EncodeDecode(t *testing.T) {
	var typ R409
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 R409
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestR500_EncodeDecode(t *testing.T) {
	var typ R500
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 R500
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdatePetReq_EncodeDecode(t *testing.T) {
	var typ UpdatePetReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdatePetReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
