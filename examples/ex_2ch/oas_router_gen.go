// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"strings"
)

func (s *Server) notFound(w http.ResponseWriter, r *http.Request) {
	s.cfg.NotFound(w, r)
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	if len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [3]string{}
	// Static code generated router with unwrapped path search.
	switch r.Method {
	case "GET":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/api/"
			if l := len("/api/"); len(elem) >= l && elem[0:l] == "/api/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'c': // Prefix: "captcha/"
				if l := len("captcha/"); len(elem) >= l && elem[0:l] == "captcha/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '2': // Prefix: "2chcaptcha/"
					if l := len("2chcaptcha/"); len(elem) >= l && elem[0:l] == "2chcaptcha/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'i': // Prefix: "id"
						if l := len("id"); len(elem) >= l && elem[0:l] == "id" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: APICaptcha2chcaptchaIDGet
							s.handleAPICaptcha2chcaptchaIDGetRequest([0]string{}, w, r)

							return
						}
					case 's': // Prefix: "show"
						if l := len("show"); len(elem) >= l && elem[0:l] == "show" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: APICaptcha2chcaptchaShowGet
							s.handleAPICaptcha2chcaptchaShowGetRequest([0]string{}, w, r)

							return
						}
					}
				case 'a': // Prefix: "app/id/"
					if l := len("app/id/"); len(elem) >= l && elem[0:l] == "app/id/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "public_key"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: APICaptchaAppIDPublicKeyGet
						s.handleAPICaptchaAppIDPublicKeyGetRequest([1]string{
							args[0],
						}, w, r)

						return
					}
				case 'i': // Prefix: "invisible_recaptcha/"
					if l := len("invisible_recaptcha/"); len(elem) >= l && elem[0:l] == "invisible_recaptcha/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'i': // Prefix: "id"
						if l := len("id"); len(elem) >= l && elem[0:l] == "id" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: APICaptchaInvisibleRecaptchaIDGet
							s.handleAPICaptchaInvisibleRecaptchaIDGetRequest([0]string{}, w, r)

							return
						}
					case 'm': // Prefix: "mobile"
						if l := len("mobile"); len(elem) >= l && elem[0:l] == "mobile" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: APICaptchaInvisibleRecaptchaMobileGet
							s.handleAPICaptchaInvisibleRecaptchaMobileGetRequest([0]string{}, w, r)

							return
						}
					}
				case 'r': // Prefix: "recaptcha/"
					if l := len("recaptcha/"); len(elem) >= l && elem[0:l] == "recaptcha/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'i': // Prefix: "id"
						if l := len("id"); len(elem) >= l && elem[0:l] == "id" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: APICaptchaRecaptchaIDGet
							s.handleAPICaptchaRecaptchaIDGetRequest([0]string{}, w, r)

							return
						}
					case 'm': // Prefix: "mobile"
						if l := len("mobile"); len(elem) >= l && elem[0:l] == "mobile" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: APICaptchaRecaptchaMobileGet
							s.handleAPICaptchaRecaptchaMobileGetRequest([0]string{}, w, r)

							return
						}
					}
				}
			case 'd': // Prefix: "dislike"
				if l := len("dislike"); len(elem) >= l && elem[0:l] == "dislike" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf: APIDislikeGet
					s.handleAPIDislikeGetRequest([0]string{}, w, r)

					return
				}
			case 'l': // Prefix: "like"
				if l := len("like"); len(elem) >= l && elem[0:l] == "like" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf: APILikeGet
					s.handleAPILikeGetRequest([0]string{}, w, r)

					return
				}
			case 'm': // Prefix: "mobile/v2/"
				if l := len("mobile/v2/"); len(elem) >= l && elem[0:l] == "mobile/v2/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "after/"
					if l := len("after/"); len(elem) >= l && elem[0:l] == "after/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "board"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "thread"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "num"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: APIMobileV2AfterBoardThreadNumGet
								s.handleAPIMobileV2AfterBoardThreadNumGetRequest([3]string{
									args[0],
									args[1],
									args[2],
								}, w, r)

								return
							}
						}
					}
				case 'b': // Prefix: "boards"
					if l := len("boards"); len(elem) >= l && elem[0:l] == "boards" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: APIMobileV2BoardsGet
						s.handleAPIMobileV2BoardsGetRequest([0]string{}, w, r)

						return
					}
				case 'i': // Prefix: "info/"
					if l := len("info/"); len(elem) >= l && elem[0:l] == "info/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "board"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "thread"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: APIMobileV2InfoBoardThreadGet
							s.handleAPIMobileV2InfoBoardThreadGetRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					}
				case 'p': // Prefix: "post/"
					if l := len("post/"); len(elem) >= l && elem[0:l] == "post/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "board"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "num"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: APIMobileV2PostBoardNumGet
							s.handleAPIMobileV2PostBoardNumGetRequest([2]string{
								args[0],
								args[1],
							}, w, r)

							return
						}
					}
				}
			}
		}
	case "POST":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/user/"
			if l := len("/user/"); len(elem) >= l && elem[0:l] == "/user/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'p': // Prefix: "p"
				if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "asslogin"
					if l := len("asslogin"); len(elem) >= l && elem[0:l] == "asslogin" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: UserPassloginPost
						s.handleUserPassloginPostRequest([0]string{}, w, r)

						return
					}
				case 'o': // Prefix: "osting"
					if l := len("osting"); len(elem) >= l && elem[0:l] == "osting" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: UserPostingPost
						s.handleUserPostingPostRequest([0]string{}, w, r)

						return
					}
				}
			case 'r': // Prefix: "report"
				if l := len("report"); len(elem) >= l && elem[0:l] == "report" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf: UserReportPost
					s.handleUserReportPostRequest([0]string{}, w, r)

					return
				}
			}
		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name  string
	count int
	args  [3]string
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.name
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
func (s *Server) FindRoute(method, path string) (r Route, _ bool) {
	var (
		args = [3]string{}
		elem = path
	)
	r.args = args
	if elem == "" {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch method {
	case "GET":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/api/"
			if l := len("/api/"); len(elem) >= l && elem[0:l] == "/api/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'c': // Prefix: "captcha/"
				if l := len("captcha/"); len(elem) >= l && elem[0:l] == "captcha/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '2': // Prefix: "2chcaptcha/"
					if l := len("2chcaptcha/"); len(elem) >= l && elem[0:l] == "2chcaptcha/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'i': // Prefix: "id"
						if l := len("id"); len(elem) >= l && elem[0:l] == "id" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: APICaptcha2chcaptchaIDGet
							r.name = "APICaptcha2chcaptchaIDGet"
							r.args = args
							r.count = 0
							return r, true
						}
					case 's': // Prefix: "show"
						if l := len("show"); len(elem) >= l && elem[0:l] == "show" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: APICaptcha2chcaptchaShowGet
							r.name = "APICaptcha2chcaptchaShowGet"
							r.args = args
							r.count = 0
							return r, true
						}
					}
				case 'a': // Prefix: "app/id/"
					if l := len("app/id/"); len(elem) >= l && elem[0:l] == "app/id/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "public_key"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf: APICaptchaAppIDPublicKeyGet
						r.name = "APICaptchaAppIDPublicKeyGet"
						r.args = args
						r.count = 1
						return r, true
					}
				case 'i': // Prefix: "invisible_recaptcha/"
					if l := len("invisible_recaptcha/"); len(elem) >= l && elem[0:l] == "invisible_recaptcha/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'i': // Prefix: "id"
						if l := len("id"); len(elem) >= l && elem[0:l] == "id" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: APICaptchaInvisibleRecaptchaIDGet
							r.name = "APICaptchaInvisibleRecaptchaIDGet"
							r.args = args
							r.count = 0
							return r, true
						}
					case 'm': // Prefix: "mobile"
						if l := len("mobile"); len(elem) >= l && elem[0:l] == "mobile" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: APICaptchaInvisibleRecaptchaMobileGet
							r.name = "APICaptchaInvisibleRecaptchaMobileGet"
							r.args = args
							r.count = 0
							return r, true
						}
					}
				case 'r': // Prefix: "recaptcha/"
					if l := len("recaptcha/"); len(elem) >= l && elem[0:l] == "recaptcha/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'i': // Prefix: "id"
						if l := len("id"); len(elem) >= l && elem[0:l] == "id" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: APICaptchaRecaptchaIDGet
							r.name = "APICaptchaRecaptchaIDGet"
							r.args = args
							r.count = 0
							return r, true
						}
					case 'm': // Prefix: "mobile"
						if l := len("mobile"); len(elem) >= l && elem[0:l] == "mobile" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf: APICaptchaRecaptchaMobileGet
							r.name = "APICaptchaRecaptchaMobileGet"
							r.args = args
							r.count = 0
							return r, true
						}
					}
				}
			case 'd': // Prefix: "dislike"
				if l := len("dislike"); len(elem) >= l && elem[0:l] == "dislike" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf: APIDislikeGet
					r.name = "APIDislikeGet"
					r.args = args
					r.count = 0
					return r, true
				}
			case 'l': // Prefix: "like"
				if l := len("like"); len(elem) >= l && elem[0:l] == "like" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf: APILikeGet
					r.name = "APILikeGet"
					r.args = args
					r.count = 0
					return r, true
				}
			case 'm': // Prefix: "mobile/v2/"
				if l := len("mobile/v2/"); len(elem) >= l && elem[0:l] == "mobile/v2/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "after/"
					if l := len("after/"); len(elem) >= l && elem[0:l] == "after/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "board"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "thread"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[1] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "num"
							// Leaf parameter
							args[2] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf: APIMobileV2AfterBoardThreadNumGet
								r.name = "APIMobileV2AfterBoardThreadNumGet"
								r.args = args
								r.count = 3
								return r, true
							}
						}
					}
				case 'b': // Prefix: "boards"
					if l := len("boards"); len(elem) >= l && elem[0:l] == "boards" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: APIMobileV2BoardsGet
						r.name = "APIMobileV2BoardsGet"
						r.args = args
						r.count = 0
						return r, true
					}
				case 'i': // Prefix: "info/"
					if l := len("info/"); len(elem) >= l && elem[0:l] == "info/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "board"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "thread"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: APIMobileV2InfoBoardThreadGet
							r.name = "APIMobileV2InfoBoardThreadGet"
							r.args = args
							r.count = 2
							return r, true
						}
					}
				case 'p': // Prefix: "post/"
					if l := len("post/"); len(elem) >= l && elem[0:l] == "post/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "board"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "num"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf: APIMobileV2PostBoardNumGet
							r.name = "APIMobileV2PostBoardNumGet"
							r.args = args
							r.count = 2
							return r, true
						}
					}
				}
			}
		}
	case "POST":
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/user/"
			if l := len("/user/"); len(elem) >= l && elem[0:l] == "/user/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'p': // Prefix: "p"
				if l := len("p"); len(elem) >= l && elem[0:l] == "p" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "asslogin"
					if l := len("asslogin"); len(elem) >= l && elem[0:l] == "asslogin" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: UserPassloginPost
						r.name = "UserPassloginPost"
						r.args = args
						r.count = 0
						return r, true
					}
				case 'o': // Prefix: "osting"
					if l := len("osting"); len(elem) >= l && elem[0:l] == "osting" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf: UserPostingPost
						r.name = "UserPostingPost"
						r.args = args
						r.count = 0
						return r, true
					}
				}
			case 'r': // Prefix: "report"
				if l := len("report"); len(elem) >= l && elem[0:l] == "report" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf: UserReportPost
					r.name = "UserReportPost"
					r.args = args
					r.count = 0
					return r, true
				}
			}
		}
	}
	return r, false
}
