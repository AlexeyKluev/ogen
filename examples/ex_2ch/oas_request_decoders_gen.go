// Code generated by ogen, DO NOT EDIT.

package api

import (
	"io"
	"mime"
	"net/http"
	"net/url"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/trace"
	"go.uber.org/multierr"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

func (s *Server) decodeUserPassloginPostRequest(r *http.Request, span trace.Span) (
	req OptUserPassloginPostReq,
	close func() error,
	rerr error,
) {
	var closers []io.Closer
	close = func() error {
		var merr error
		for _, c := range closers {
			merr = multierr.Append(merr, c.Close())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	if _, ok := r.Header["Content-Type"]; !ok && r.ContentLength == 0 {
		return req, close, nil
	}

	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch ct {
	case "multipart/form-data":
		var request UserPassloginPostReq

		if r.ContentLength == 0 {
			return req, close, nil
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		form := url.Values(r.MultipartForm.Value)

		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "passcode",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.Passcode = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"passcode\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		return OptUserPassloginPostReq{
			Value: request,
			Set:   true,
		}, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeUserPostingPostRequest(r *http.Request, span trace.Span) (
	req OptUserPostingPostReqForm,
	close func() error,
	rerr error,
) {
	var closers []io.Closer
	close = func() error {
		var merr error
		for _, c := range closers {
			merr = multierr.Append(merr, c.Close())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	if _, ok := r.Header["Content-Type"]; !ok && r.ContentLength == 0 {
		return req, close, nil
	}

	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch ct {
	case "multipart/form-data":
		var request UserPostingPostReq

		if r.ContentLength == 0 {
			return req, close, nil
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		form := url.Values(r.MultipartForm.Value)

		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "board",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.Board = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"board\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "captcha_type",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.CaptchaType = CaptchaType(c)
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"captcha_type\"")
				}
				if err := func() error {
					if err := request.CaptchaType.Validate(); err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return req, close, errors.Wrap(err, "validate")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "comment",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					var requestDotCommentVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						requestDotCommentVal = c
						return nil
					}(); err != nil {
						return err
					}
					request.Comment.SetTo(requestDotCommentVal)
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"comment\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "email",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					var requestDotEmailVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						requestDotEmailVal = c
						return nil
					}(); err != nil {
						return err
					}
					request.Email.SetTo(requestDotEmailVal)
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"email\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "file[]",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var requestDotFileVal string
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToString(val)
							if err != nil {
								return err
							}

							requestDotFileVal = c
							return nil
						}(); err != nil {
							return err
						}
						request.File = append(request.File, requestDotFileVal)
						return nil
					})
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"file[]\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "icon",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					var requestDotIconVal int
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToInt(val)
						if err != nil {
							return err
						}

						requestDotIconVal = c
						return nil
					}(); err != nil {
						return err
					}
					request.Icon.SetTo(requestDotIconVal)
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"icon\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "name",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					var requestDotNameVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						requestDotNameVal = c
						return nil
					}(); err != nil {
						return err
					}
					request.Name.SetTo(requestDotNameVal)
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"name\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "op_mark",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					var requestDotOpMarkVal int
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToInt(val)
						if err != nil {
							return err
						}

						requestDotOpMarkVal = c
						return nil
					}(); err != nil {
						return err
					}
					request.OpMark.SetTo(requestDotOpMarkVal)
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"op_mark\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "subject",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					var requestDotSubjectVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						requestDotSubjectVal = c
						return nil
					}(); err != nil {
						return err
					}
					request.Subject.SetTo(requestDotSubjectVal)
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"subject\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "tags",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					var requestDotTagsVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						requestDotTagsVal = c
						return nil
					}(); err != nil {
						return err
					}
					request.Tags.SetTo(requestDotTagsVal)
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"tags\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "thread",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					var requestDotThreadVal int
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToInt(val)
						if err != nil {
							return err
						}

						requestDotThreadVal = c
						return nil
					}(); err != nil {
						return err
					}
					request.Thread.SetTo(requestDotThreadVal)
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"thread\"")
				}
			}
		}
		return OptUserPostingPostReqForm{
			Value: request,
			Set:   true,
		}, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}

func (s *Server) decodeUserReportPostRequest(r *http.Request, span trace.Span) (
	req OptUserReportPostReq,
	close func() error,
	rerr error,
) {
	var closers []io.Closer
	close = func() error {
		var merr error
		for _, c := range closers {
			merr = multierr.Append(merr, c.Close())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()
	if _, ok := r.Header["Content-Type"]; !ok && r.ContentLength == 0 {
		return req, close, nil
	}

	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch ct {
	case "multipart/form-data":
		var request UserReportPostReq

		if r.ContentLength == 0 {
			return req, close, nil
		}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		form := url.Values(r.MultipartForm.Value)

		q := uri.NewQueryDecoder(form)
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "board",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.Board = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"board\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "comment",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					request.Comment = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"comment\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "post",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					return d.DecodeArray(func(d uri.Decoder) error {
						var requestDotPostVal int
						if err := func() error {
							val, err := d.DecodeValue()
							if err != nil {
								return err
							}

							c, err := conv.ToInt(val)
							if err != nil {
								return err
							}

							requestDotPostVal = c
							return nil
						}(); err != nil {
							return err
						}
						request.Post = append(request.Post, requestDotPostVal)
						return nil
					})
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"post\"")
				}
			}
		}
		{
			cfg := uri.QueryParameterDecodingConfig{
				Name:    "thread",
				Style:   uri.QueryStyleForm,
				Explode: true,
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					request.Thread = c
					return nil
				}); err != nil {
					return req, close, errors.Wrap(err, "decode \"thread\"")
				}
			} else {
				return req, close, errors.Wrap(err, "query")
			}
		}
		return OptUserReportPostReq{
			Value: request,
			Set:   true,
		}, close, nil
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}
