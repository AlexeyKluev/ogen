// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s Board) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Board) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("bump_limit")
		e.Int(s.BumpLimit)
	}
	{

		e.FieldStart("category")
		e.Str(s.Category)
	}
	{

		e.FieldStart("default_name")
		e.Str(s.DefaultName)
	}
	{

		e.FieldStart("enable_dices")
		e.Bool(s.EnableDices)
	}
	{

		e.FieldStart("enable_flags")
		e.Bool(s.EnableFlags)
	}
	{

		e.FieldStart("enable_icons")
		e.Bool(s.EnableIcons)
	}
	{

		e.FieldStart("enable_likes")
		e.Bool(s.EnableLikes)
	}
	{

		e.FieldStart("enable_names")
		e.Bool(s.EnableNames)
	}
	{

		e.FieldStart("enable_oekaki")
		e.Bool(s.EnableOekaki)
	}
	{

		e.FieldStart("enable_posting")
		e.Bool(s.EnablePosting)
	}
	{

		e.FieldStart("enable_sage")
		e.Bool(s.EnableSage)
	}
	{

		e.FieldStart("enable_shield")
		e.Bool(s.EnableShield)
	}
	{

		e.FieldStart("enable_subject")
		e.Bool(s.EnableSubject)
	}
	{

		e.FieldStart("enable_thread_tags")
		e.Bool(s.EnableThreadTags)
	}
	{

		e.FieldStart("enable_trips")
		e.Bool(s.EnableTrips)
	}
	{

		e.FieldStart("file_types")
		e.ArrStart()
		for _, elem := range s.FileTypes {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Icons != nil {
			e.FieldStart("icons")
			e.ArrStart()
			for _, elem := range s.Icons {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("info")
		e.Str(s.Info)
	}
	{

		e.FieldStart("info_outer")
		e.Str(s.InfoOuter)
	}
	{

		e.FieldStart("max_comment")
		e.Int(s.MaxComment)
	}
	{

		e.FieldStart("max_files_size")
		e.Int(s.MaxFilesSize)
	}
	{

		e.FieldStart("max_pages")
		e.Int(s.MaxPages)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{

		e.FieldStart("threads_per_page")
		e.Int(s.ThreadsPerPage)
	}
}

var jsonFieldsNameOfBoard = [26]string{
	0:  "bump_limit",
	1:  "category",
	2:  "default_name",
	3:  "enable_dices",
	4:  "enable_flags",
	5:  "enable_icons",
	6:  "enable_likes",
	7:  "enable_names",
	8:  "enable_oekaki",
	9:  "enable_posting",
	10: "enable_sage",
	11: "enable_shield",
	12: "enable_subject",
	13: "enable_thread_tags",
	14: "enable_trips",
	15: "file_types",
	16: "icons",
	17: "id",
	18: "info",
	19: "info_outer",
	20: "max_comment",
	21: "max_files_size",
	22: "max_pages",
	23: "name",
	24: "tags",
	25: "threads_per_page",
}

// Decode decodes Board from json.
func (s *Board) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Board to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bump_limit":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.BumpLimit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bump_limit\"")
			}
		case "category":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Category = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "default_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DefaultName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_name\"")
			}
		case "enable_dices":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.EnableDices = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_dices\"")
			}
		case "enable_flags":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.EnableFlags = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_flags\"")
			}
		case "enable_icons":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.EnableIcons = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_icons\"")
			}
		case "enable_likes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.EnableLikes = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_likes\"")
			}
		case "enable_names":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.EnableNames = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_names\"")
			}
		case "enable_oekaki":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EnableOekaki = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_oekaki\"")
			}
		case "enable_posting":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.EnablePosting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_posting\"")
			}
		case "enable_sage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.EnableSage = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_sage\"")
			}
		case "enable_shield":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.EnableShield = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_shield\"")
			}
		case "enable_subject":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.EnableSubject = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_subject\"")
			}
		case "enable_thread_tags":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.EnableThreadTags = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_thread_tags\"")
			}
		case "enable_trips":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.EnableTrips = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_trips\"")
			}
		case "file_types":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				s.FileTypes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FileTypes = append(s.FileTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_types\"")
			}
		case "icons":
			if err := func() error {
				s.Icons = make([]BoardIconsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BoardIconsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Icons = append(s.Icons, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icons\"")
			}
		case "id":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "info":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Info = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "info_outer":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.InfoOuter = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info_outer\"")
			}
		case "max_comment":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxComment = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_comment\"")
			}
		case "max_files_size":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.MaxFilesSize = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_files_size\"")
			}
		case "max_pages":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.MaxPages = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_pages\"")
			}
		case "name":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "threads_per_page":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ThreadsPerPage = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"threads_per_page\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Board")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111110,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBoard) {
					name = jsonFieldsNameOfBoard[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Board) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Board) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s BoardIconsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s BoardIconsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Num.Set {
			e.FieldStart("num")
			s.Num.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfBoardIconsItem = [3]string{
	0: "name",
	1: "num",
	2: "url",
}

// Decode decodes BoardIconsItem from json.
func (s *BoardIconsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BoardIconsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "num":
			if err := func() error {
				s.Num.Reset()
				if err := s.Num.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BoardIconsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BoardIconsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BoardIconsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Boards as json.
func (s Boards) Encode(e *jx.Encoder) {
	unwrapped := []Board(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes Boards from json.
func (s *Boards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Boards to nil")
	}
	var unwrapped []Board
	if err := func() error {
		unwrapped = make([]Board, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Board
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Boards(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Boards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Boards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Captcha) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Captcha) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Expires.Set {
			e.FieldStart("expires")
			s.Expires.Encode(e)
		}
	}
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Input.Set {
			e.FieldStart("input")
			s.Input.Encode(e)
		}
	}
	{

		e.FieldStart("result")
		e.Int(s.Result)
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfCaptcha = [6]string{
	0: "error",
	1: "expires",
	2: "id",
	3: "input",
	4: "result",
	5: "type",
}

// Decode decodes Captcha from json.
func (s *Captcha) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Captcha to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "expires":
			if err := func() error {
				s.Expires.Reset()
				if err := s.Expires.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "input":
			if err := func() error {
				s.Input.Reset()
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Result = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Captcha")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCaptcha) {
					name = jsonFieldsNameOfCaptcha[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Captcha) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Captcha) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptchaType as json.
func (s CaptchaType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CaptchaType from json.
func (s *CaptchaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptchaType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CaptchaType(v) {
	case CaptchaTypeRecaptcha:
		*s = CaptchaTypeRecaptcha
	case CaptchaTypeInvisibleRecaptcha:
		*s = CaptchaTypeInvisibleRecaptcha
	case CaptchaTypeRecaptcha3:
		*s = CaptchaTypeRecaptcha3
	case CaptchaType2chcaptcha:
		*s = CaptchaType2chcaptcha
	case CaptchaTypeAppid:
		*s = CaptchaTypeAppid
	case CaptchaTypePasscode:
		*s = CaptchaTypePasscode
	case CaptchaTypeNocaptcha:
		*s = CaptchaTypeNocaptcha
	default:
		*s = CaptchaType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CaptchaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptchaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Error) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [2]string{
	0: "code",
	1: "message",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorCode as json.
func (s ErrorCode) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes ErrorCode from json.
func (s *ErrorCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorCode to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = ErrorCode(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ErrorCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s File) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s File) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("displayname")
		e.Str(s.Displayname)
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.DurationSecs.Set {
			e.FieldStart("duration_secs")
			s.DurationSecs.Encode(e)
		}
	}
	{

		e.FieldStart("fullname")
		e.Str(s.Fullname)
	}
	{

		e.FieldStart("height")
		e.Int(s.Height)
	}
	{
		if s.Install.Set {
			e.FieldStart("install")
			s.Install.Encode(e)
		}
	}
	{
		if s.MD5.Set {
			e.FieldStart("md5")
			s.MD5.Encode(e)
		}
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Nsfw.Set {
			e.FieldStart("nsfw")
			s.Nsfw.Encode(e)
		}
	}
	{
		if s.Pack.Set {
			e.FieldStart("pack")
			s.Pack.Encode(e)
		}
	}
	{

		e.FieldStart("path")
		e.Str(s.Path)
	}
	{

		e.FieldStart("size")
		e.Int(s.Size)
	}
	{
		if s.Sticker.Set {
			e.FieldStart("sticker")
			s.Sticker.Encode(e)
		}
	}
	{

		e.FieldStart("thumbnail")
		e.Str(s.Thumbnail)
	}
	{

		e.FieldStart("tn_height")
		e.Int(s.TnHeight)
	}
	{

		e.FieldStart("tn_width")
		e.Int(s.TnWidth)
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{

		e.FieldStart("width")
		e.Int(s.Width)
	}
}

var jsonFieldsNameOfFile = [18]string{
	0:  "displayname",
	1:  "duration",
	2:  "duration_secs",
	3:  "fullname",
	4:  "height",
	5:  "install",
	6:  "md5",
	7:  "name",
	8:  "nsfw",
	9:  "pack",
	10: "path",
	11: "size",
	12: "sticker",
	13: "thumbnail",
	14: "tn_height",
	15: "tn_width",
	16: "type",
	17: "width",
}

// Decode decodes File from json.
func (s *File) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode File to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "displayname":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Displayname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayname\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "duration_secs":
			if err := func() error {
				s.DurationSecs.Reset()
				if err := s.DurationSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_secs\"")
			}
		case "fullname":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Fullname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullname\"")
			}
		case "height":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Height = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "install":
			if err := func() error {
				s.Install.Reset()
				if err := s.Install.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"install\"")
			}
		case "md5":
			if err := func() error {
				s.MD5.Reset()
				if err := s.MD5.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"md5\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "nsfw":
			if err := func() error {
				s.Nsfw.Reset()
				if err := s.Nsfw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nsfw\"")
			}
		case "pack":
			if err := func() error {
				s.Pack.Reset()
				if err := s.Pack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pack\"")
			}
		case "path":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "size":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "sticker":
			if err := func() error {
				s.Sticker.Reset()
				if err := s.Sticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticker\"")
			}
		case "thumbnail":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Thumbnail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbnail\"")
			}
		case "tn_height":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.TnHeight = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tn_height\"")
			}
		case "tn_width":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.TnWidth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tn_width\"")
			}
		case "type":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "width":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Width = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode File")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b10011001,
		0b11101100,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFile) {
					name = jsonFieldsNameOfFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s File) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *File) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FileType as json.
func (s FileType) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes FileType from json.
func (s *FileType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileType to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = FileType(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Like) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Like) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
}

var jsonFieldsNameOfLike = [2]string{
	0: "error",
	1: "result",
}

// Decode decodes Like from json.
func (s *Like) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Like to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Like")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Like) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Like) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s MobilePost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s MobilePost) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Post.Set {
			e.FieldStart("post")
			s.Post.Encode(e)
		}
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
}

var jsonFieldsNameOfMobilePost = [3]string{
	0: "error",
	1: "post",
	2: "result",
}

// Decode decodes MobilePost from json.
func (s *MobilePost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MobilePost to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "post":
			if err := func() error {
				s.Post.Reset()
				if err := s.Post.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"post\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MobilePost")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MobilePost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MobilePost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s MobileThreadLastInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s MobileThreadLastInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		if s.Thread.Set {
			e.FieldStart("thread")
			s.Thread.Encode(e)
		}
	}
}

var jsonFieldsNameOfMobileThreadLastInfo = [3]string{
	0: "error",
	1: "result",
	2: "thread",
}

// Decode decodes MobileThreadLastInfo from json.
func (s *MobileThreadLastInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MobileThreadLastInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "thread":
			if err := func() error {
				s.Thread.Reset()
				if err := s.Thread.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MobileThreadLastInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MobileThreadLastInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MobileThreadLastInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s MobileThreadLastInfoThread) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s MobileThreadLastInfoThread) encodeFields(e *jx.Encoder) {
	{
		if s.Num.Set {
			e.FieldStart("num")
			s.Num.Encode(e)
		}
	}
	{
		if s.Posts.Set {
			e.FieldStart("posts")
			s.Posts.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
}

var jsonFieldsNameOfMobileThreadLastInfoThread = [3]string{
	0: "num",
	1: "posts",
	2: "timestamp",
}

// Decode decodes MobileThreadLastInfoThread from json.
func (s *MobileThreadLastInfoThread) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MobileThreadLastInfoThread to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "num":
			if err := func() error {
				s.Num.Reset()
				if err := s.Num.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num\"")
			}
		case "posts":
			if err := func() error {
				s.Posts.Reset()
				if err := s.Posts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"posts\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MobileThreadLastInfoThread")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MobileThreadLastInfoThread) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MobileThreadLastInfoThread) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s MobileThreadPostsAfter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s MobileThreadPostsAfter) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Posts != nil {
			e.FieldStart("posts")
			e.ArrStart()
			for _, elem := range s.Posts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		if s.UniquePosters.Set {
			e.FieldStart("unique_posters")
			s.UniquePosters.Encode(e)
		}
	}
}

var jsonFieldsNameOfMobileThreadPostsAfter = [4]string{
	0: "error",
	1: "posts",
	2: "result",
	3: "unique_posters",
}

// Decode decodes MobileThreadPostsAfter from json.
func (s *MobileThreadPostsAfter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MobileThreadPostsAfter to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "posts":
			if err := func() error {
				s.Posts = make([]Post, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Post
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Posts = append(s.Posts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"posts\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "unique_posters":
			if err := func() error {
				s.UniquePosters.Reset()
				if err := s.UniquePosters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unique_posters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MobileThreadPostsAfter")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MobileThreadPostsAfter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MobileThreadPostsAfter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Error as json.
func (o OptError) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Error from json.
func (o *OptError) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptError to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorCode as json.
func (o OptErrorCode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes ErrorCode from json.
func (o *OptErrorCode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrorCode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrorCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrorCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MobileThreadLastInfoThread as json.
func (o OptMobileThreadLastInfoThread) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MobileThreadLastInfoThread from json.
func (o *OptMobileThreadLastInfoThread) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMobileThreadLastInfoThread to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMobileThreadLastInfoThread) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMobileThreadLastInfoThread) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Post as json.
func (o OptPost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Post from json.
func (o *OptPost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPost to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Post) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Post) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("banned")
		e.Int(s.Banned)
	}
	{

		e.FieldStart("board")
		e.Str(s.Board)
	}
	{

		e.FieldStart("closed")
		e.Int(s.Closed)
	}
	{

		e.FieldStart("comment")
		e.Str(s.Comment)
	}
	{

		e.FieldStart("date")
		e.Str(s.Date)
	}
	{
		if s.Dislikes.Set {
			e.FieldStart("dislikes")
			s.Dislikes.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{

		e.FieldStart("endless")
		e.Int(s.Endless)
	}
	{
		if s.Files != nil {
			e.FieldStart("files")
			e.ArrStart()
			for _, elem := range s.Files {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Icon.Set {
			e.FieldStart("icon")
			s.Icon.Encode(e)
		}
	}
	{

		e.FieldStart("lasthit")
		e.Int(s.Lasthit)
	}
	{
		if s.Likes.Set {
			e.FieldStart("likes")
			s.Likes.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{

		e.FieldStart("num")
		e.Int(s.Num)
	}
	{

		e.FieldStart("op")
		e.Int(s.Op)
	}
	{

		e.FieldStart("parent")
		e.Int(s.Parent)
	}
	{

		e.FieldStart("sticky")
		e.Int(s.Sticky)
	}
	{
		if s.Subject.Set {
			e.FieldStart("subject")
			s.Subject.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{

		e.FieldStart("timestamp")
		e.Int(s.Timestamp)
	}
	{
		if s.Trip.Set {
			e.FieldStart("trip")
			s.Trip.Encode(e)
		}
	}
	{
		if s.TripStyle.Set {
			e.FieldStart("trip_style")
			s.TripStyle.Encode(e)
		}
	}
	{

		e.FieldStart("views")
		e.Int(s.Views)
	}
}

var jsonFieldsNameOfPost = [23]string{
	0:  "banned",
	1:  "board",
	2:  "closed",
	3:  "comment",
	4:  "date",
	5:  "dislikes",
	6:  "email",
	7:  "endless",
	8:  "files",
	9:  "icon",
	10: "lasthit",
	11: "likes",
	12: "name",
	13: "num",
	14: "op",
	15: "parent",
	16: "sticky",
	17: "subject",
	18: "tags",
	19: "timestamp",
	20: "trip",
	21: "trip_style",
	22: "views",
}

// Decode decodes Post from json.
func (s *Post) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Post to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "banned":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Banned = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"banned\"")
			}
		case "board":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Board = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"board\"")
			}
		case "closed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Closed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed\"")
			}
		case "comment":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Comment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "dislikes":
			if err := func() error {
				s.Dislikes.Reset()
				if err := s.Dislikes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dislikes\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "endless":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Endless = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endless\"")
			}
		case "files":
			if err := func() error {
				s.Files = make([]File, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem File
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Files = append(s.Files, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "icon":
			if err := func() error {
				s.Icon.Reset()
				if err := s.Icon.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon\"")
			}
		case "lasthit":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Lasthit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lasthit\"")
			}
		case "likes":
			if err := func() error {
				s.Likes.Reset()
				if err := s.Likes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"likes\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "num":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Num = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num\"")
			}
		case "op":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Op = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"op\"")
			}
		case "parent":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Parent = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent\"")
			}
		case "sticky":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Sticky = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sticky\"")
			}
		case "subject":
			if err := func() error {
				s.Subject.Reset()
				if err := s.Subject.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subject\"")
			}
		case "tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "timestamp":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Timestamp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "trip":
			if err := func() error {
				s.Trip.Reset()
				if err := s.Trip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trip\"")
			}
		case "trip_style":
			if err := func() error {
				s.TripStyle.Reset()
				if err := s.TripStyle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trip_style\"")
			}
		case "views":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Views = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"views\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Post")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b10011111,
		0b11100100,
		0b01001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPost) {
					name = jsonFieldsNameOfPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Post) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Post) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
