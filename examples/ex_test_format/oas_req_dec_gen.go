// Code generated by ogen, DO NOT EDIT.

package api

import (
	"fmt"
	"io"
	"net/http"
	"net/netip"
	"net/url"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

func decodeTestRequestAnyRequest(r *http.Request, span trace.Span) (req jx.Raw, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request jx.Raw
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.RawAppend(nil)
			request = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanRequest(r *http.Request, span trace.Span) (req OptBool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptBool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanArrayRequest(r *http.Request, span trace.Span) (req []bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem bool
				v, err := d.Bool()
				elem = bool(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanArrayArrayRequest(r *http.Request, span trace.Span) (req [][]bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []bool
				elem = make([]bool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem bool
					v, err := d.Bool()
					elemElem = bool(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanNullableRequest(r *http.Request, span trace.Span) (req OptNilBool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilBool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanNullableArrayRequest(r *http.Request, span trace.Span) (req []bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem bool
				v, err := d.Bool()
				elem = bool(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []bool
				elem = make([]bool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem bool
					v, err := d.Bool()
					elemElem = bool(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestEmptyStructRequest(r *http.Request, span trace.Span) (req *TestRequestEmptyStructReq, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request *TestRequestEmptyStructReq
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = nil
			var elem TestRequestEmptyStructReq
			if err := elem.Decode(d); err != nil {
				return err
			}
			request = &elem
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestFormatTestRequest(r *http.Request, span trace.Span) (req OptTestRequestFormatTestReq, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTestRequestFormatTestReq
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := request.Value.Validate(); err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerRequest(r *http.Request, span trace.Span) (req OptInt, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerArrayRequest(r *http.Request, span trace.Span) (req []int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int
				elem = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int
					v, err := d.Int()
					elemElem = int(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32Request(r *http.Request, span trace.Span) (req OptInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32ArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32NullableRequest(r *http.Request, span trace.Span) (req OptNilInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32NullableArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64Request(r *http.Request, span trace.Span) (req OptInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64ArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64NullableRequest(r *http.Request, span trace.Span) (req OptNilInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64NullableArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerNullableRequest(r *http.Request, span trace.Span) (req OptNilInt, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilInt
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerNullableArrayRequest(r *http.Request, span trace.Span) (req []int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int
				elem = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int
					v, err := d.Int()
					elemElem = int(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNullRequest(r *http.Request, span trace.Span) (req OptNull, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNull
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNullArrayRequest(r *http.Request, span trace.Span) (req []struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem struct{}
				if err := d.Null(); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNullArrayArrayRequest(r *http.Request, span trace.Span) (req [][]struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []struct{}
				elem = make([]struct{}, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem struct{}
					if err := d.Null(); err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNullNullableRequest(r *http.Request, span trace.Span) (req OptNull, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNull
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNullNullableArrayRequest(r *http.Request, span trace.Span) (req []struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem struct{}
				if err := d.Null(); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNullNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []struct{}
				elem = make([]struct{}, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem struct{}
					if err := d.Null(); err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberRequest(r *http.Request, span trace.Span) (req OptFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleRequest(r *http.Request, span trace.Span) (req OptFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleNullableRequest(r *http.Request, span trace.Span) (req OptNilFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleNullableArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatRequest(r *http.Request, span trace.Span) (req OptFloat32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatArrayRequest(r *http.Request, span trace.Span) (req []float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float32
				v, err := d.Float32()
				elem = float32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float32
				elem = make([]float32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float32
					v, err := d.Float32()
					elemElem = float32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatNullableRequest(r *http.Request, span trace.Span) (req OptNilFloat32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilFloat32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatNullableArrayRequest(r *http.Request, span trace.Span) (req []float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float32
				v, err := d.Float32()
				elem = float32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float32
				elem = make([]float32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float32
					v, err := d.Float32()
					elemElem = float32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32Request(r *http.Request, span trace.Span) (req OptInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32ArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32NullableRequest(r *http.Request, span trace.Span) (req OptNilInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32NullableArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64Request(r *http.Request, span trace.Span) (req OptInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64ArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64NullableRequest(r *http.Request, span trace.Span) (req OptNilInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64NullableArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberNullableRequest(r *http.Request, span trace.Span) (req OptNilFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberNullableArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredAnyRequest(r *http.Request, span trace.Span) (req jx.Raw, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request jx.Raw
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.RawAppend(nil)
			request = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredBooleanRequest(r *http.Request, span trace.Span) (req bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Bool()
			request = bool(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredBooleanArrayRequest(r *http.Request, span trace.Span) (req []bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem bool
				v, err := d.Bool()
				elem = bool(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredBooleanArrayArrayRequest(r *http.Request, span trace.Span) (req [][]bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []bool
				elem = make([]bool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem bool
					v, err := d.Bool()
					elemElem = bool(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredBooleanNullableRequest(r *http.Request, span trace.Span) (req NilBool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilBool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredBooleanNullableArrayRequest(r *http.Request, span trace.Span) (req []bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem bool
				v, err := d.Bool()
				elem = bool(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredBooleanNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]bool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]bool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]bool, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []bool
				elem = make([]bool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem bool
					v, err := d.Bool()
					elemElem = bool(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredEmptyStructRequest(r *http.Request, span trace.Span) (req TestRequestRequiredEmptyStructReq, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request TestRequestRequiredEmptyStructReq
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredFormatTestRequest(r *http.Request, span trace.Span) (req TestRequestRequiredFormatTestReq, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request TestRequestRequiredFormatTestReq
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if err := request.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerRequest(r *http.Request, span trace.Span) (req int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Int()
			request = int(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerArrayRequest(r *http.Request, span trace.Span) (req []int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int
				elem = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int
					v, err := d.Int()
					elemElem = int(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt32Request(r *http.Request, span trace.Span) (req int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Int32()
			request = int32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt32ArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt32NullableRequest(r *http.Request, span trace.Span) (req NilInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt32NullableArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt64Request(r *http.Request, span trace.Span) (req int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Int64()
			request = int64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt64ArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt64NullableRequest(r *http.Request, span trace.Span) (req NilInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt64NullableArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerNullableRequest(r *http.Request, span trace.Span) (req NilInt, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilInt
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerNullableArrayRequest(r *http.Request, span trace.Span) (req []int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredIntegerNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int
				elem = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int
					v, err := d.Int()
					elemElem = int(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNullRequest(r *http.Request, span trace.Span) (req struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := d.Null(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNullArrayRequest(r *http.Request, span trace.Span) (req []struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem struct{}
				if err := d.Null(); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNullArrayArrayRequest(r *http.Request, span trace.Span) (req [][]struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []struct{}
				elem = make([]struct{}, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem struct{}
					if err := d.Null(); err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNullNullableRequest(r *http.Request, span trace.Span) (req struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := d.Null(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNullNullableArrayRequest(r *http.Request, span trace.Span) (req []struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem struct{}
				if err := d.Null(); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNullNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]struct{}, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]struct{}
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]struct{}, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []struct{}
				elem = make([]struct{}, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem struct{}
					if err := d.Null(); err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberRequest(r *http.Request, span trace.Span) (req float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Float64()
			request = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if err := (validate.Float{}).Validate(float64(request)); err != nil {
				return errors.Wrap(err, "float")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberDoubleRequest(r *http.Request, span trace.Span) (req float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Float64()
			request = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if err := (validate.Float{}).Validate(float64(request)); err != nil {
				return errors.Wrap(err, "float")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberDoubleArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberDoubleArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberDoubleNullableRequest(r *http.Request, span trace.Span) (req NilFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
				return errors.Wrap(err, "float")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberDoubleNullableArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberDoubleNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberFloatRequest(r *http.Request, span trace.Span) (req float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Float32()
			request = float32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if err := (validate.Float{}).Validate(float64(request)); err != nil {
				return errors.Wrap(err, "float")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberFloatArrayRequest(r *http.Request, span trace.Span) (req []float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float32
				v, err := d.Float32()
				elem = float32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberFloatArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float32
				elem = make([]float32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float32
					v, err := d.Float32()
					elemElem = float32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberFloatNullableRequest(r *http.Request, span trace.Span) (req NilFloat32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilFloat32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
				return errors.Wrap(err, "float")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberFloatNullableArrayRequest(r *http.Request, span trace.Span) (req []float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float32
				v, err := d.Float32()
				elem = float32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberFloatNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]float32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float32
				elem = make([]float32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float32
					v, err := d.Float32()
					elemElem = float32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt32Request(r *http.Request, span trace.Span) (req int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Int32()
			request = int32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt32ArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt32NullableRequest(r *http.Request, span trace.Span) (req NilInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt32NullableArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := d.Int32()
				elem = int32(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := d.Int32()
					elemElem = int32(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt64Request(r *http.Request, span trace.Span) (req int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Int64()
			request = int64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt64ArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt64NullableRequest(r *http.Request, span trace.Span) (req NilInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt64NullableArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := d.Int64()
				elem = int64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := d.Int64()
					elemElem = int64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberNullableRequest(r *http.Request, span trace.Span) (req NilFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if err := (validate.Float{}).Validate(float64(request.Value)); err != nil {
				return errors.Wrap(err, "float")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberNullableArrayRequest(r *http.Request, span trace.Span) (req []float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem float64
				v, err := d.Float64()
				elem = float64(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.Float{}).Validate(float64(elem)); err != nil {
						return errors.Wrap(err, "float")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredNumberNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]float64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]float64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []float64
				elem = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem float64
					v, err := d.Float64()
					elemElem = float64(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.Float{}).Validate(float64(elem)); err != nil {
								return errors.Wrap(err, "float")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringBinaryRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringBinaryArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringBinaryArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringBinaryNullableRequest(r *http.Request, span trace.Span) (req NilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringBinaryNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringBinaryNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringByteRequest(r *http.Request, span trace.Span) (req []byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Base64()
			request = []byte(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringByteArrayRequest(r *http.Request, span trace.Span) (req [][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []byte
				v, err := d.Base64()
				elem = []byte(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringByteArrayArrayRequest(r *http.Request, span trace.Span) (req [][][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem [][]byte
				elem = make([][]byte, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem []byte
					v, err := d.Base64()
					elemElem = []byte(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringByteNullableRequest(r *http.Request, span trace.Span) (req []byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Base64()
			request = []byte(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringByteNullableArrayRequest(r *http.Request, span trace.Span) (req [][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []byte
				v, err := d.Base64()
				elem = []byte(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringByteNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem [][]byte
				elem = make([][]byte, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem []byte
					v, err := d.Base64()
					elemElem = []byte(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateRequest(r *http.Request, span trace.Span) (req time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeDate(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDate(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDate(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateNullableRequest(r *http.Request, span trace.Span) (req NilDate, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilDate
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d, json.DecodeDate); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDate(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDate(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateTimeRequest(r *http.Request, span trace.Span) (req time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeDateTime(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateTimeArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDateTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateTimeArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDateTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateTimeNullableRequest(r *http.Request, span trace.Span) (req NilDateTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilDateTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateTimeNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDateTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDateTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDateTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDurationRequest(r *http.Request, span trace.Span) (req time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeDuration(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDurationArrayRequest(r *http.Request, span trace.Span) (req []time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Duration
				v, err := json.DecodeDuration(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDurationArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Duration
				elem = make([]time.Duration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Duration
					v, err := json.DecodeDuration(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDurationNullableRequest(r *http.Request, span trace.Span) (req NilDuration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilDuration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDurationNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Duration
				v, err := json.DecodeDuration(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringDurationNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Duration
				elem = make([]time.Duration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Duration
					v, err := json.DecodeDuration(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringEmailRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if err := (validate.String{
				MinLength:    0,
				MinLengthSet: false,
				MaxLength:    0,
				MaxLengthSet: false,
				Email:        true,
				Hostname:     false,
				Regex:        nil,
			}).Validate(string(request)); err != nil {
				return errors.Wrap(err, "string")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringEmailArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        true,
						Hostname:     false,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringEmailArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        true,
								Hostname:     false,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringEmailNullableRequest(r *http.Request, span trace.Span) (req NilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if err := (validate.String{
				MinLength:    0,
				MinLengthSet: false,
				MaxLength:    0,
				MaxLengthSet: false,
				Email:        true,
				Hostname:     false,
				Regex:        nil,
			}).Validate(string(request.Value)); err != nil {
				return errors.Wrap(err, "string")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringEmailNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        true,
						Hostname:     false,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringEmailNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        true,
								Hostname:     false,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringHostnameRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if err := (validate.String{
				MinLength:    0,
				MinLengthSet: false,
				MaxLength:    0,
				MaxLengthSet: false,
				Email:        false,
				Hostname:     true,
				Regex:        nil,
			}).Validate(string(request)); err != nil {
				return errors.Wrap(err, "string")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringHostnameArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        false,
						Hostname:     true,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringHostnameArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        false,
								Hostname:     true,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringHostnameNullableRequest(r *http.Request, span trace.Span) (req NilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if err := (validate.String{
				MinLength:    0,
				MinLengthSet: false,
				MaxLength:    0,
				MaxLengthSet: false,
				Email:        false,
				Hostname:     true,
				Regex:        nil,
			}).Validate(string(request.Value)); err != nil {
				return errors.Wrap(err, "string")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringHostnameNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        false,
						Hostname:     true,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringHostnameNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        false,
								Hostname:     true,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIPRequest(r *http.Request, span trace.Span) (req netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeIP(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIPArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIPArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIPNullableRequest(r *http.Request, span trace.Span) (req NilIP, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilIP
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIPNullableArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIPNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt32Request(r *http.Request, span trace.Span) (req int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeStringInt32(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt32ArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := json.DecodeStringInt32(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := json.DecodeStringInt32(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt32NullableRequest(r *http.Request, span trace.Span) (req NilStringInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilStringInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt32NullableArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := json.DecodeStringInt32(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := json.DecodeStringInt32(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt64Request(r *http.Request, span trace.Span) (req int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeStringInt64(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt64ArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := json.DecodeStringInt64(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := json.DecodeStringInt64(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt64NullableRequest(r *http.Request, span trace.Span) (req NilStringInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilStringInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt64NullableArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := json.DecodeStringInt64(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := json.DecodeStringInt64(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv4Request(r *http.Request, span trace.Span) (req netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeIP(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv4ArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv4ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv4NullableRequest(r *http.Request, span trace.Span) (req NilIPv4, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilIPv4
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv4NullableArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv4NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv6Request(r *http.Request, span trace.Span) (req netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeIP(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv6ArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv6ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv6NullableRequest(r *http.Request, span trace.Span) (req NilIPv6, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilIPv6
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv6NullableArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringIpv6NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringNullableRequest(r *http.Request, span trace.Span) (req NilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringPasswordRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringPasswordArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringPasswordArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringPasswordNullableRequest(r *http.Request, span trace.Span) (req NilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringPasswordNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringPasswordNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringTimeRequest(r *http.Request, span trace.Span) (req time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeTime(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringTimeArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringTimeArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringTimeNullableRequest(r *http.Request, span trace.Span) (req NilTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d, json.DecodeTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringTimeNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringURIRequest(r *http.Request, span trace.Span) (req url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeURI(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringURIArrayRequest(r *http.Request, span trace.Span) (req []url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem url.URL
				v, err := json.DecodeURI(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringURIArrayArrayRequest(r *http.Request, span trace.Span) (req [][]url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []url.URL
				elem = make([]url.URL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem url.URL
					v, err := json.DecodeURI(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringURINullableRequest(r *http.Request, span trace.Span) (req NilURI, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilURI
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringURINullableArrayRequest(r *http.Request, span trace.Span) (req []url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem url.URL
				v, err := json.DecodeURI(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringURINullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []url.URL
				elem = make([]url.URL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem url.URL
					v, err := json.DecodeURI(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUUIDRequest(r *http.Request, span trace.Span) (req uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeUUID(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUUIDArrayRequest(r *http.Request, span trace.Span) (req []uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem uuid.UUID
				v, err := json.DecodeUUID(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUUIDArrayArrayRequest(r *http.Request, span trace.Span) (req [][]uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []uuid.UUID
				elem = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem uuid.UUID
					v, err := json.DecodeUUID(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUUIDNullableRequest(r *http.Request, span trace.Span) (req NilUUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilUUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUUIDNullableArrayRequest(r *http.Request, span trace.Span) (req []uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem uuid.UUID
				v, err := json.DecodeUUID(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUUIDNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []uuid.UUID
				elem = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem uuid.UUID
					v, err := json.DecodeUUID(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixRequest(r *http.Request, span trace.Span) (req time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeUnixSeconds(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixSeconds(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixSeconds(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixMicroRequest(r *http.Request, span trace.Span) (req time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeUnixMicro(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixMicroArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixMicro(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixMicroArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixMicro(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixMicroNullableRequest(r *http.Request, span trace.Span) (req NilUnixMicro, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilUnixMicro
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d, json.DecodeUnixMicro); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixMicroNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixMicro(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixMicroNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixMicro(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixMilliRequest(r *http.Request, span trace.Span) (req time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeUnixMilli(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixMilliArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixMilli(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixMilliArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixMilli(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixMilliNullableRequest(r *http.Request, span trace.Span) (req NilUnixMilli, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilUnixMilli
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d, json.DecodeUnixMilli); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixMilliNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixMilli(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixMilliNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixMilli(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixNanoRequest(r *http.Request, span trace.Span) (req time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeUnixNano(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixNanoArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixNano(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixNanoArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixNano(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixNanoNullableRequest(r *http.Request, span trace.Span) (req NilUnixNano, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilUnixNano
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d, json.DecodeUnixNano); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixNanoNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixNano(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixNanoNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixNano(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixNullableRequest(r *http.Request, span trace.Span) (req NilUnixSeconds, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilUnixSeconds
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d, json.DecodeUnixSeconds); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixSeconds(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixSeconds(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixSecondsRequest(r *http.Request, span trace.Span) (req time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := json.DecodeUnixSeconds(d)
			request = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixSecondsArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixSeconds(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixSecondsArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixSeconds(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixSecondsNullableRequest(r *http.Request, span trace.Span) (req NilUnixSeconds, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request NilUnixSeconds
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			if err := request.Decode(d, json.DecodeUnixSeconds); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixSecondsNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixSeconds(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestRequiredStringUnixSecondsNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixSeconds(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request == nil {
				return errors.New("nil is invalid value")
			}
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringRequest(r *http.Request, span trace.Span) (req OptString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringBinaryRequest(r *http.Request, span trace.Span) (req OptString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringBinaryArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringBinaryArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringBinaryNullableRequest(r *http.Request, span trace.Span) (req OptNilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringBinaryNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringBinaryNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteRequest(r *http.Request, span trace.Span) (req []byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Base64()
			request = []byte(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteArrayRequest(r *http.Request, span trace.Span) (req [][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []byte
				v, err := d.Base64()
				elem = []byte(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteArrayArrayRequest(r *http.Request, span trace.Span) (req [][][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem [][]byte
				elem = make([][]byte, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem []byte
					v, err := d.Base64()
					elemElem = []byte(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteNullableRequest(r *http.Request, span trace.Span) (req OptNilByte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilByte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteNullableArrayRequest(r *http.Request, span trace.Span) (req [][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []byte
				v, err := d.Base64()
				elem = []byte(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][][]byte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][][]byte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][][]byte, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem [][]byte
				elem = make([][]byte, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem []byte
					v, err := d.Base64()
					elemElem = []byte(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateRequest(r *http.Request, span trace.Span) (req OptDate, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptDate
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeDate); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDate(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDate(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateNullableRequest(r *http.Request, span trace.Span) (req OptNilDate, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilDate
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeDate); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDate(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDate(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeRequest(r *http.Request, span trace.Span) (req OptDateTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptDateTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDateTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDateTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeNullableRequest(r *http.Request, span trace.Span) (req OptNilDateTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilDateTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeDateTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeDateTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationRequest(r *http.Request, span trace.Span) (req OptDuration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptDuration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationArrayRequest(r *http.Request, span trace.Span) (req []time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Duration
				v, err := json.DecodeDuration(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Duration
				elem = make([]time.Duration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Duration
					v, err := json.DecodeDuration(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationNullableRequest(r *http.Request, span trace.Span) (req OptNilDuration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilDuration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Duration
				v, err := json.DecodeDuration(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Duration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Duration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Duration, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Duration
				elem = make([]time.Duration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Duration
					v, err := json.DecodeDuration(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringEmailRequest(r *http.Request, span trace.Span) (req OptString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        true,
						Hostname:     false,
						Regex:        nil,
					}).Validate(string(request.Value)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringEmailArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        true,
						Hostname:     false,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringEmailArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        true,
								Hostname:     false,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringEmailNullableRequest(r *http.Request, span trace.Span) (req OptNilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        true,
						Hostname:     false,
						Regex:        nil,
					}).Validate(string(request.Value)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringEmailNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        true,
						Hostname:     false,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringEmailNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        true,
								Hostname:     false,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringHostnameRequest(r *http.Request, span trace.Span) (req OptString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        false,
						Hostname:     true,
						Regex:        nil,
					}).Validate(string(request.Value)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringHostnameArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        false,
						Hostname:     true,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringHostnameArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        false,
								Hostname:     true,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringHostnameNullableRequest(r *http.Request, span trace.Span) (req OptNilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        false,
						Hostname:     true,
						Regex:        nil,
					}).Validate(string(request.Value)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringHostnameNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if err := (validate.String{
						MinLength:    0,
						MinLengthSet: false,
						MaxLength:    0,
						MaxLengthSet: false,
						Email:        false,
						Hostname:     true,
						Regex:        nil,
					}).Validate(string(elem)); err != nil {
						return errors.Wrap(err, "string")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringHostnameNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range elem {
						if err := func() error {
							if err := (validate.String{
								MinLength:    0,
								MinLengthSet: false,
								MaxLength:    0,
								MaxLengthSet: false,
								Email:        false,
								Hostname:     true,
								Regex:        nil,
							}).Validate(string(elem)); err != nil {
								return errors.Wrap(err, "string")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPRequest(r *http.Request, span trace.Span) (req OptIP, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIP
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPNullableRequest(r *http.Request, span trace.Span) (req OptNilIP, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilIP
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPNullableArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt32Request(r *http.Request, span trace.Span) (req OptStringInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptStringInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt32ArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := json.DecodeStringInt32(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := json.DecodeStringInt32(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt32NullableRequest(r *http.Request, span trace.Span) (req OptNilStringInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilStringInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt32NullableArrayRequest(r *http.Request, span trace.Span) (req []int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int32
				v, err := json.DecodeStringInt32(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int32, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int32
				elem = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int32
					v, err := json.DecodeStringInt32(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt64Request(r *http.Request, span trace.Span) (req OptStringInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptStringInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt64ArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := json.DecodeStringInt64(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := json.DecodeStringInt64(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt64NullableRequest(r *http.Request, span trace.Span) (req OptNilStringInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilStringInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt64NullableArrayRequest(r *http.Request, span trace.Span) (req []int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int64
				v, err := json.DecodeStringInt64(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]int64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]int64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]int64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []int64
				elem = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem int64
					v, err := json.DecodeStringInt64(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4Request(r *http.Request, span trace.Span) (req OptIPv4, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPv4
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4ArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4NullableRequest(r *http.Request, span trace.Span) (req OptNilIPv4, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilIPv4
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4NullableArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6Request(r *http.Request, span trace.Span) (req OptIPv6, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPv6
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6ArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6ArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6NullableRequest(r *http.Request, span trace.Span) (req OptNilIPv6, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilIPv6
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6NullableArrayRequest(r *http.Request, span trace.Span) (req []netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem netip.Addr
				v, err := json.DecodeIP(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6NullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]netip.Addr, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]netip.Addr
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]netip.Addr, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []netip.Addr
				elem = make([]netip.Addr, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem netip.Addr
					v, err := json.DecodeIP(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringNullableRequest(r *http.Request, span trace.Span) (req OptNilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordRequest(r *http.Request, span trace.Span) (req OptString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordNullableRequest(r *http.Request, span trace.Span) (req OptNilString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordNullableArrayRequest(r *http.Request, span trace.Span) (req []string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []string
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeRequest(r *http.Request, span trace.Span) (req OptTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeNullableRequest(r *http.Request, span trace.Span) (req OptNilTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeTime(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeTime(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURIRequest(r *http.Request, span trace.Span) (req OptURI, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptURI
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURIArrayRequest(r *http.Request, span trace.Span) (req []url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem url.URL
				v, err := json.DecodeURI(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURIArrayArrayRequest(r *http.Request, span trace.Span) (req [][]url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []url.URL
				elem = make([]url.URL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem url.URL
					v, err := json.DecodeURI(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURINullableRequest(r *http.Request, span trace.Span) (req OptNilURI, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilURI
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURINullableArrayRequest(r *http.Request, span trace.Span) (req []url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem url.URL
				v, err := json.DecodeURI(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURINullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]url.URL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]url.URL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]url.URL, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []url.URL
				elem = make([]url.URL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem url.URL
					v, err := json.DecodeURI(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDRequest(r *http.Request, span trace.Span) (req OptUUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptUUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDArrayRequest(r *http.Request, span trace.Span) (req []uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem uuid.UUID
				v, err := json.DecodeUUID(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDArrayArrayRequest(r *http.Request, span trace.Span) (req [][]uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []uuid.UUID
				elem = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem uuid.UUID
					v, err := json.DecodeUUID(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDNullableRequest(r *http.Request, span trace.Span) (req OptNilUUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilUUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDNullableArrayRequest(r *http.Request, span trace.Span) (req []uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem uuid.UUID
				v, err := json.DecodeUUID(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]uuid.UUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]uuid.UUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]uuid.UUID, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []uuid.UUID
				elem = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem uuid.UUID
					v, err := json.DecodeUUID(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixRequest(r *http.Request, span trace.Span) (req OptUnixSeconds, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptUnixSeconds
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeUnixSeconds); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixSeconds(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixSeconds(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixMicroRequest(r *http.Request, span trace.Span) (req OptUnixMicro, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptUnixMicro
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeUnixMicro); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixMicroArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixMicro(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixMicroArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixMicro(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixMicroNullableRequest(r *http.Request, span trace.Span) (req OptNilUnixMicro, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilUnixMicro
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeUnixMicro); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixMicroNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixMicro(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixMicroNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixMicro(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixMilliRequest(r *http.Request, span trace.Span) (req OptUnixMilli, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptUnixMilli
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeUnixMilli); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixMilliArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixMilli(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixMilliArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixMilli(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixMilliNullableRequest(r *http.Request, span trace.Span) (req OptNilUnixMilli, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilUnixMilli
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeUnixMilli); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixMilliNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixMilli(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixMilliNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixMilli(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixNanoRequest(r *http.Request, span trace.Span) (req OptUnixNano, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptUnixNano
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeUnixNano); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixNanoArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixNano(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixNanoArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixNano(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixNanoNullableRequest(r *http.Request, span trace.Span) (req OptNilUnixNano, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilUnixNano
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeUnixNano); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixNanoNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixNano(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixNanoNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixNano(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixNullableRequest(r *http.Request, span trace.Span) (req OptNilUnixSeconds, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilUnixSeconds
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeUnixSeconds); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixSeconds(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixSeconds(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixSecondsRequest(r *http.Request, span trace.Span) (req OptUnixSeconds, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptUnixSeconds
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeUnixSeconds); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixSecondsArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixSeconds(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixSecondsArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixSeconds(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixSecondsNullableRequest(r *http.Request, span trace.Span) (req OptNilUnixSeconds, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptNilUnixSeconds
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeUnixSeconds); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixSecondsNullableArrayRequest(r *http.Request, span trace.Span) (req []time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request []time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem time.Time
				v, err := json.DecodeUnixSeconds(d)
				elem = v
				if err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUnixSecondsNullableArrayArrayRequest(r *http.Request, span trace.Span) (req [][]time.Time, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request [][]time.Time
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request = make([][]time.Time, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem []time.Time
				elem = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem time.Time
					v, err := json.DecodeUnixSeconds(d)
					elemElem = v
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
				request = append(request, elem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		if err := func() error {
			var failures []validate.FieldError
			for i, elem := range request {
				if err := func() error {
					if elem == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					failures = append(failures, validate.FieldError{
						Name:  fmt.Sprintf("[%d]", i),
						Error: err,
					})
				}
			}
			if len(failures) > 0 {
				return &validate.Error{Fields: failures}
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseAnyRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseEmptyStructRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseFormatTestRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNullRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNullArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNullArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNullNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNullNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNullNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringBinaryRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringBinaryArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringBinaryArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringBinaryNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringBinaryNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringBinaryNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringEmailRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringEmailArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringEmailArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringEmailNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringEmailNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringEmailNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringHostnameRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringHostnameArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringHostnameArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringHostnameNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringHostnameNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringHostnameNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt32Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt32ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt32NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt32NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt64Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt64ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt64NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt64NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURIRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURIArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURIArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURINullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURINullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURINullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixMicroRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixMicroArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixMicroArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixMicroNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixMicroNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixMicroNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixMilliRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixMilliArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixMilliArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixMilliNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixMilliNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixMilliNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixNanoRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixNanoArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixNanoArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixNanoNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixNanoNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixNanoNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixSecondsRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixSecondsArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixSecondsArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixSecondsNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixSecondsNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUnixSecondsNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode \"application/json\"")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}
