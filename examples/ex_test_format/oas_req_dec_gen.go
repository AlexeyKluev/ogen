// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/bits"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = bits.LeadingZeros64
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
	_ = codes.Unset
)

func decodeTestRequestAnyRequest(r *http.Request, span trace.Span) (req OptRaw, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptRaw
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestAny:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanRequest(r *http.Request, span trace.Span) (req OptBool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptBool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestBoolean:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanArrayRequest(r *http.Request, span trace.Span) (req OptBoolArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptBoolArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestBooleanArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestBooleanArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanArrayArrayRequest(r *http.Request, span trace.Span) (req OptBoolArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptBoolArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestBooleanArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestBooleanArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanNullableRequest(r *http.Request, span trace.Span) (req OptBool, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptBool
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestBooleanNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanNullableArrayRequest(r *http.Request, span trace.Span) (req OptBoolArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptBoolArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestBooleanNullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestBooleanNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestBooleanNullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptBoolArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptBoolArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestBooleanNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestBooleanNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestFormatTestRequest(r *http.Request, span trace.Span) (req OptTestRequestFormatTestReq, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTestRequestFormatTestReq
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestFormatTest:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if err := request.Value.Validate(); err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestFormatTest request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerRequest(r *http.Request, span trace.Span) (req OptInt, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestInteger:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerArrayRequest(r *http.Request, span trace.Span) (req OptIntArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIntArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerArrayArrayRequest(r *http.Request, span trace.Span) (req OptIntArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIntArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32Request(r *http.Request, span trace.Span) (req OptInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt32:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32ArrayRequest(r *http.Request, span trace.Span) (req OptInt32Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt32Array:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerInt32Array request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req OptInt32Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt32ArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerInt32ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32NullableRequest(r *http.Request, span trace.Span) (req OptInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt32Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32NullableArrayRequest(r *http.Request, span trace.Span) (req OptInt32Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt32NullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerInt32NullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptInt32Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt32NullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerInt32NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64Request(r *http.Request, span trace.Span) (req OptInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt64:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64ArrayRequest(r *http.Request, span trace.Span) (req OptInt64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt64Array:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerInt64Array request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req OptInt64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt64ArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerInt64ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64NullableRequest(r *http.Request, span trace.Span) (req OptInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt64Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64NullableArrayRequest(r *http.Request, span trace.Span) (req OptInt64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt64NullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerInt64NullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptInt64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerInt64NullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerInt64NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerNullableRequest(r *http.Request, span trace.Span) (req OptInt, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerNullableArrayRequest(r *http.Request, span trace.Span) (req OptIntArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIntArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerNullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestIntegerNullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptIntArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIntArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestIntegerNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestIntegerNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberRequest(r *http.Request, span trace.Span) (req OptFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumber:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if f := float64(request.Value); math.IsInf(f, 0) || math.IsNaN(f) {
						return errors.Errorf("%f float value is invalid", f)
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumber request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberArrayRequest(r *http.Request, span trace.Span) (req OptFloat64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if f := float64(elem); math.IsInf(f, 0) || math.IsNaN(f) {
								return errors.Errorf("%f float value is invalid", f)
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberArrayArrayRequest(r *http.Request, span trace.Span) (req OptFloat64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							var failures []validate.FieldError
							for i, elem := range elem {
								if err := func() error {
									if f := float64(elem); math.IsInf(f, 0) || math.IsNaN(f) {
										return errors.Errorf("%f float value is invalid", f)
									}
									return nil
								}(); err != nil {
									failures = append(failures, validate.FieldError{
										Name:  fmt.Sprintf("[%d]", i),
										Error: err,
									})
								}
							}
							if len(failures) > 0 {
								return &validate.Error{Fields: failures}
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleRequest(r *http.Request, span trace.Span) (req OptFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberDouble:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if f := float64(request.Value); math.IsInf(f, 0) || math.IsNaN(f) {
						return errors.Errorf("%f float value is invalid", f)
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberDouble request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleArrayRequest(r *http.Request, span trace.Span) (req OptFloat64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberDoubleArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if f := float64(elem); math.IsInf(f, 0) || math.IsNaN(f) {
								return errors.Errorf("%f float value is invalid", f)
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberDoubleArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleArrayArrayRequest(r *http.Request, span trace.Span) (req OptFloat64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberDoubleArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							var failures []validate.FieldError
							for i, elem := range elem {
								if err := func() error {
									if f := float64(elem); math.IsInf(f, 0) || math.IsNaN(f) {
										return errors.Errorf("%f float value is invalid", f)
									}
									return nil
								}(); err != nil {
									failures = append(failures, validate.FieldError{
										Name:  fmt.Sprintf("[%d]", i),
										Error: err,
									})
								}
							}
							if len(failures) > 0 {
								return &validate.Error{Fields: failures}
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberDoubleArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleNullableRequest(r *http.Request, span trace.Span) (req OptFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberDoubleNullable:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if f := float64(request.Value); math.IsInf(f, 0) || math.IsNaN(f) {
						return errors.Errorf("%f float value is invalid", f)
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberDoubleNullable request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleNullableArrayRequest(r *http.Request, span trace.Span) (req OptFloat64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberDoubleNullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if f := float64(elem); math.IsInf(f, 0) || math.IsNaN(f) {
								return errors.Errorf("%f float value is invalid", f)
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberDoubleNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberDoubleNullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptFloat64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberDoubleNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							var failures []validate.FieldError
							for i, elem := range elem {
								if err := func() error {
									if f := float64(elem); math.IsInf(f, 0) || math.IsNaN(f) {
										return errors.Errorf("%f float value is invalid", f)
									}
									return nil
								}(); err != nil {
									failures = append(failures, validate.FieldError{
										Name:  fmt.Sprintf("[%d]", i),
										Error: err,
									})
								}
							}
							if len(failures) > 0 {
								return &validate.Error{Fields: failures}
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberDoubleNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatRequest(r *http.Request, span trace.Span) (req OptFloat32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberFloat:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if f := float64(request.Value); math.IsInf(f, 0) || math.IsNaN(f) {
						return errors.Errorf("%f float value is invalid", f)
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberFloat request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatArrayRequest(r *http.Request, span trace.Span) (req OptFloat32Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat32Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberFloatArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if f := float64(elem); math.IsInf(f, 0) || math.IsNaN(f) {
								return errors.Errorf("%f float value is invalid", f)
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberFloatArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatArrayArrayRequest(r *http.Request, span trace.Span) (req OptFloat32Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat32Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberFloatArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							var failures []validate.FieldError
							for i, elem := range elem {
								if err := func() error {
									if f := float64(elem); math.IsInf(f, 0) || math.IsNaN(f) {
										return errors.Errorf("%f float value is invalid", f)
									}
									return nil
								}(); err != nil {
									failures = append(failures, validate.FieldError{
										Name:  fmt.Sprintf("[%d]", i),
										Error: err,
									})
								}
							}
							if len(failures) > 0 {
								return &validate.Error{Fields: failures}
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberFloatArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatNullableRequest(r *http.Request, span trace.Span) (req OptFloat32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberFloatNullable:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if f := float64(request.Value); math.IsInf(f, 0) || math.IsNaN(f) {
						return errors.Errorf("%f float value is invalid", f)
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberFloatNullable request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatNullableArrayRequest(r *http.Request, span trace.Span) (req OptFloat32Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat32Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberFloatNullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if f := float64(elem); math.IsInf(f, 0) || math.IsNaN(f) {
								return errors.Errorf("%f float value is invalid", f)
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberFloatNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberFloatNullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptFloat32Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat32Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberFloatNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							var failures []validate.FieldError
							for i, elem := range elem {
								if err := func() error {
									if f := float64(elem); math.IsInf(f, 0) || math.IsNaN(f) {
										return errors.Errorf("%f float value is invalid", f)
									}
									return nil
								}(); err != nil {
									failures = append(failures, validate.FieldError{
										Name:  fmt.Sprintf("[%d]", i),
										Error: err,
									})
								}
							}
							if len(failures) > 0 {
								return &validate.Error{Fields: failures}
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberFloatNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32Request(r *http.Request, span trace.Span) (req OptInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt32:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32ArrayRequest(r *http.Request, span trace.Span) (req OptInt32Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt32Array:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberInt32Array request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req OptInt32Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt32ArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberInt32ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32NullableRequest(r *http.Request, span trace.Span) (req OptInt32, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt32Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32NullableArrayRequest(r *http.Request, span trace.Span) (req OptInt32Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt32NullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberInt32NullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptInt32Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt32Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt32NullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberInt32NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64Request(r *http.Request, span trace.Span) (req OptInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt64:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64ArrayRequest(r *http.Request, span trace.Span) (req OptInt64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt64Array:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberInt64Array request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req OptInt64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt64ArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberInt64ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64NullableRequest(r *http.Request, span trace.Span) (req OptInt64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt64Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64NullableArrayRequest(r *http.Request, span trace.Span) (req OptInt64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt64NullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberInt64NullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptInt64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptInt64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberInt64NullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberInt64NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberNullableRequest(r *http.Request, span trace.Span) (req OptFloat64, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberNullable:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if f := float64(request.Value); math.IsInf(f, 0) || math.IsNaN(f) {
						return errors.Errorf("%f float value is invalid", f)
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberNullable request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberNullableArrayRequest(r *http.Request, span trace.Span) (req OptFloat64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberNullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if f := float64(elem); math.IsInf(f, 0) || math.IsNaN(f) {
								return errors.Errorf("%f float value is invalid", f)
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestNumberNullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptFloat64Array, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptFloat64Array
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestNumberNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							var failures []validate.FieldError
							for i, elem := range elem {
								if err := func() error {
									if f := float64(elem); math.IsInf(f, 0) || math.IsNaN(f) {
										return errors.Errorf("%f float value is invalid", f)
									}
									return nil
								}(); err != nil {
									failures = append(failures, validate.FieldError{
										Name:  fmt.Sprintf("[%d]", i),
										Error: err,
									})
								}
							}
							if len(failures) > 0 {
								return &validate.Error{Fields: failures}
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestNumberNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringRequest(r *http.Request, span trace.Span) (req OptString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestString:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringArrayRequest(r *http.Request, span trace.Span) (req OptStringArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptStringArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringArrayArrayRequest(r *http.Request, span trace.Span) (req OptStringArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptStringArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteRequest(r *http.Request, span trace.Span) (req OptByte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptByte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringByte:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteArrayRequest(r *http.Request, span trace.Span) (req OptByteArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptByteArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringByteArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringByteArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteArrayArrayRequest(r *http.Request, span trace.Span) (req OptByteArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptByteArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringByteArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringByteArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteNullableRequest(r *http.Request, span trace.Span) (req OptByte, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptByte
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringByteNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteNullableArrayRequest(r *http.Request, span trace.Span) (req OptByteArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptByteArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringByteNullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringByteNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringByteNullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptByteArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptByteArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringByteNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringByteNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateRequest(r *http.Request, span trace.Span) (req OptTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeDate); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDate:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateArrayRequest(r *http.Request, span trace.Span) (req OptTimeArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTimeArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDateArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateArrayArrayRequest(r *http.Request, span trace.Span) (req OptTimeArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTimeArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDateArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateNullableRequest(r *http.Request, span trace.Span) (req OptTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeDate); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateNullableArrayRequest(r *http.Request, span trace.Span) (req OptTimeArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTimeArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateNullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDateNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateNullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptTimeArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTimeArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDateNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeRequest(r *http.Request, span trace.Span) (req OptTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateTime:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeArrayRequest(r *http.Request, span trace.Span) (req OptTimeArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTimeArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateTimeArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDateTimeArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeArrayArrayRequest(r *http.Request, span trace.Span) (req OptTimeArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTimeArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateTimeArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDateTimeArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeNullableRequest(r *http.Request, span trace.Span) (req OptTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateTimeNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeNullableArrayRequest(r *http.Request, span trace.Span) (req OptTimeArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTimeArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateTimeNullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDateTimeNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDateTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptTimeArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTimeArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDateTimeNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDateTimeNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationRequest(r *http.Request, span trace.Span) (req OptDuration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptDuration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDuration:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationArrayRequest(r *http.Request, span trace.Span) (req OptDurationArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptDurationArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDurationArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDurationArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationArrayArrayRequest(r *http.Request, span trace.Span) (req OptDurationArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptDurationArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDurationArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDurationArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationNullableRequest(r *http.Request, span trace.Span) (req OptDuration, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptDuration
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDurationNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationNullableArrayRequest(r *http.Request, span trace.Span) (req OptDurationArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptDurationArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDurationNullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDurationNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringDurationNullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptDurationArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptDurationArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringDurationNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringDurationNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPRequest(r *http.Request, span trace.Span) (req OptIP, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIP
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIP:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPArrayRequest(r *http.Request, span trace.Span) (req OptIPArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIPArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIPArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPArrayArrayRequest(r *http.Request, span trace.Span) (req OptIPArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIPArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIPArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPNullableRequest(r *http.Request, span trace.Span) (req OptIP, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIP
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIPNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPNullableArrayRequest(r *http.Request, span trace.Span) (req OptIPArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIPNullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIPNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIPNullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptIPArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIPNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIPNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4Request(r *http.Request, span trace.Span) (req OptIP, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIP
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv4:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4ArrayRequest(r *http.Request, span trace.Span) (req OptIPArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv4Array:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIpv4Array request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4ArrayArrayRequest(r *http.Request, span trace.Span) (req OptIPArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv4ArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIpv4ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4NullableRequest(r *http.Request, span trace.Span) (req OptIP, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIP
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv4Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4NullableArrayRequest(r *http.Request, span trace.Span) (req OptIPArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv4NullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIpv4NullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv4NullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptIPArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv4NullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIpv4NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6Request(r *http.Request, span trace.Span) (req OptIP, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIP
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv6:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6ArrayRequest(r *http.Request, span trace.Span) (req OptIPArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv6Array:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIpv6Array request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6ArrayArrayRequest(r *http.Request, span trace.Span) (req OptIPArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv6ArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIpv6ArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6NullableRequest(r *http.Request, span trace.Span) (req OptIP, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIP
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv6Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6NullableArrayRequest(r *http.Request, span trace.Span) (req OptIPArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv6NullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIpv6NullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringIpv6NullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptIPArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptIPArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringIpv6NullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringIpv6NullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringNullableRequest(r *http.Request, span trace.Span) (req OptString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringNullableArrayRequest(r *http.Request, span trace.Span) (req OptStringArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptStringArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringNullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringNullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptStringArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptStringArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordRequest(r *http.Request, span trace.Span) (req OptString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringPassword:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordArrayRequest(r *http.Request, span trace.Span) (req OptStringArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptStringArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringPasswordArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringPasswordArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordArrayArrayRequest(r *http.Request, span trace.Span) (req OptStringArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptStringArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringPasswordArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringPasswordArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordNullableRequest(r *http.Request, span trace.Span) (req OptString, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptString
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringPasswordNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordNullableArrayRequest(r *http.Request, span trace.Span) (req OptStringArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptStringArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringPasswordNullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringPasswordNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringPasswordNullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptStringArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptStringArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringPasswordNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringPasswordNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeRequest(r *http.Request, span trace.Span) (req OptTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringTime:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeArrayRequest(r *http.Request, span trace.Span) (req OptTimeArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTimeArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringTimeArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringTimeArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeArrayArrayRequest(r *http.Request, span trace.Span) (req OptTimeArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTimeArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringTimeArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringTimeArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeNullableRequest(r *http.Request, span trace.Span) (req OptTime, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTime
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d, json.DecodeTime); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringTimeNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeNullableArrayRequest(r *http.Request, span trace.Span) (req OptTimeArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTimeArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringTimeNullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringTimeNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptTimeArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptTimeArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringTimeNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringTimeNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURIRequest(r *http.Request, span trace.Span) (req OptURL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptURL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringURI:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURIArrayRequest(r *http.Request, span trace.Span) (req OptURLArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptURLArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringURIArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringURIArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURIArrayArrayRequest(r *http.Request, span trace.Span) (req OptURLArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptURLArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringURIArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringURIArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURINullableRequest(r *http.Request, span trace.Span) (req OptURL, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptURL
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringURINullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURINullableArrayRequest(r *http.Request, span trace.Span) (req OptURLArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptURLArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringURINullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringURINullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringURINullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptURLArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptURLArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringURINullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringURINullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDRequest(r *http.Request, span trace.Span) (req OptUUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptUUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringUUID:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDArrayRequest(r *http.Request, span trace.Span) (req OptUUIDArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptUUIDArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringUUIDArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringUUIDArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDArrayArrayRequest(r *http.Request, span trace.Span) (req OptUUIDArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptUUIDArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringUUIDArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringUUIDArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDNullableRequest(r *http.Request, span trace.Span) (req OptUUID, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptUUID
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringUUIDNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDNullableArrayRequest(r *http.Request, span trace.Span) (req OptUUIDArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptUUIDArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringUUIDNullableArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringUUIDNullableArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestRequestStringUUIDNullableArrayArrayRequest(r *http.Request, span trace.Span) (req OptUUIDArray, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, nil
		}

		var request OptUUIDArray
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, nil
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			request.Reset()
			if err := request.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestRequestStringUUIDNullableArrayArray:application/json request")
		}
		if err := func() error {
			if request.Set {
				if err := func() error {
					if request.Value == nil {
						return errors.New("nil is invalid value")
					}
					var failures []validate.FieldError
					for i, elem := range request.Value {
						if err := func() error {
							if elem == nil {
								return errors.New("nil is invalid value")
							}
							return nil
						}(); err != nil {
							failures = append(failures, validate.FieldError{
								Name:  fmt.Sprintf("[%d]", i),
								Error: err,
							})
						}
					}
					if len(failures) > 0 {
						return &validate.Error{Fields: failures}
					}
					return nil
				}(); err != nil {
					return err
				}
			}
			return nil
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "validate TestRequestStringUUIDNullableArrayArray request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseAnyRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseAny:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseBoolean:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseBooleanArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseBooleanArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseBooleanNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseBooleanNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseBooleanNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseBooleanNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseFormatTestRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseFormatTest:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseInteger:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt32:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt32Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt32ArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt32Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt32NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt32NullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt64:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt64Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt64ArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt64Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt64NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerInt64NullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseIntegerNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseIntegerNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumber:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberDouble:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberDoubleArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberDoubleArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberDoubleNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberDoubleNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberDoubleNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberDoubleNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberFloat:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberFloatArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberFloatArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberFloatNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberFloatNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberFloatNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberFloatNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt32:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt32Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt32ArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt32Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt32NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt32NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt32NullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt64:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt64Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt64ArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt64Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt64NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberInt64NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberInt64NullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseNumberNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseNumberNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseString:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringByte:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringByteArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringByteArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringByteNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringByteNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringByteNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringByteNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDate:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateTime:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateTimeArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateTimeArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateTimeNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateTimeNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDateTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDateTimeNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDuration:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDurationArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDurationArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDurationNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDurationNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringDurationNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringDurationNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIP:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIPArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIPArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIPNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIPNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIPNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIPNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv4:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv4Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv4ArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv4Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv4NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv4NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv4NullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6Request(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv6:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6ArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv6Array:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6ArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv6ArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6NullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv6Nullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6NullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv6NullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringIpv6NullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringIpv6NullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringPassword:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringPasswordArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringPasswordArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringPasswordNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringPasswordNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringPasswordNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringPasswordNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringTime:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringTimeArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringTimeArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringTimeNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringTimeNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringTimeNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringTimeNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURIRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringURI:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURIArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringURIArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURIArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringURIArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURINullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringURINullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURINullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringURINullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringURINullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringURINullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringUUID:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringUUIDArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringUUIDArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDNullableRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringUUIDNullable:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDNullableArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringUUIDNullableArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}

func decodeTestResponseStringUUIDNullableArrayArrayRequest(r *http.Request, span trace.Span) (req string, err error) {
	switch ct := r.Header.Get("Content-Type"); ct {
	case "application/json":
		if r.ContentLength == 0 {
			return req, validate.ErrBodyRequired
		}

		var request string
		buf := getBuf()
		defer putBuf(buf)
		written, err := io.Copy(buf, r.Body)
		if err != nil {
			return req, err
		}

		if written == 0 {
			return req, validate.ErrBodyRequired
		}

		d := jx.GetDecoder()
		defer jx.PutDecoder(d)
		d.ResetBytes(buf.Bytes())
		if err := func() error {
			v, err := d.Str()
			request = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return req, errors.Wrap(err, "decode TestResponseStringUUIDNullableArrayArray:application/json request")
		}
		return request, nil
	default:
		return req, validate.InvalidContentType(ct)
	}
}
