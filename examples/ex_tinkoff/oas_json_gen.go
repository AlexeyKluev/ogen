// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/big"
	"math/bits"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = bits.LeadingZeros64
	_ = big.Rat{}
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
	_ = codes.Unset
)

// Encode encodes BrokerAccountType as json.
func (s BrokerAccountType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes BrokerAccountType from json.
func (s *BrokerAccountType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BrokerAccountType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BrokerAccountType(v) {
	case BrokerAccountTypeTinkoff:
		*s = BrokerAccountTypeTinkoff
	case BrokerAccountTypeTinkoffIis:
		*s = BrokerAccountTypeTinkoffIis
	default:
		*s = BrokerAccountType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Candle) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"figi\"" + ":")
		e.Str(s.Figi)
	}
	{
		e.Comma()

		e.RawStr("\"interval\"" + ":")
		s.Interval.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"o\"" + ":")
		e.Float64(s.O)
	}
	{
		e.Comma()

		e.RawStr("\"c\"" + ":")
		e.Float64(s.C)
	}
	{
		e.Comma()

		e.RawStr("\"h\"" + ":")
		e.Float64(s.H)
	}
	{
		e.Comma()

		e.RawStr("\"l\"" + ":")
		e.Float64(s.L)
	}
	{
		e.Comma()

		e.RawStr("\"v\"" + ":")
		e.Int32(s.V)
	}
	{
		e.Comma()

		e.RawStr("\"time\"" + ":")
		json.EncodeDateTime(e, s.Time)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCandle = [8]string{
	0: "figi",
	1: "interval",
	2: "o",
	3: "c",
	4: "h",
	5: "l",
	6: "v",
	7: "time",
}

// Decode decodes Candle from json.
func (s *Candle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Candle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Figi = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "interval":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Interval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interval\"")
			}
		case "o":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.O = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"o\"")
			}
		case "c":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.C = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"c\"")
			}
		case "h":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.H = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"h\"")
			}
		case "l":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.L = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"l\"")
			}
		case "v":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.V = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"v\"")
			}
		case "time":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Candle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCandle) {
					name = jsonFieldsNameOfCandle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes CandleResolution as json.
func (s CandleResolution) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CandleResolution from json.
func (s *CandleResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CandleResolution to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CandleResolution(v) {
	case CandleResolution1min:
		*s = CandleResolution1min
	case CandleResolution2min:
		*s = CandleResolution2min
	case CandleResolution3min:
		*s = CandleResolution3min
	case CandleResolution5min:
		*s = CandleResolution5min
	case CandleResolution10min:
		*s = CandleResolution10min
	case CandleResolution15min:
		*s = CandleResolution15min
	case CandleResolution30min:
		*s = CandleResolution30min
	case CandleResolutionHour:
		*s = CandleResolutionHour
	case CandleResolutionDay:
		*s = CandleResolutionDay
	case CandleResolutionWeek:
		*s = CandleResolutionWeek
	case CandleResolutionMonth:
		*s = CandleResolutionMonth
	default:
		*s = CandleResolution(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Candles) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"figi\"" + ":")
		e.Str(s.Figi)
	}
	{
		e.Comma()

		e.RawStr("\"interval\"" + ":")
		s.Interval.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"candles\"" + ":")
		e.ArrStart()
		if len(s.Candles) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Candles[0]
				elem.Encode(e)
			}
			for _, elem := range s.Candles[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCandles = [3]string{
	0: "figi",
	1: "interval",
	2: "candles",
}

// Decode decodes Candles from json.
func (s *Candles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Candles to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Figi = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "interval":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Interval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interval\"")
			}
		case "candles":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Candles = make([]Candle, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Candle
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Candles = append(s.Candles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"candles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Candles")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCandles) {
					name = jsonFieldsNameOfCandles[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CandlesResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCandlesResponse = [3]string{
	0: "trackingId",
	1: "status",
	2: "payload",
}

// Decode decodes CandlesResponse from json.
func (s *CandlesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CandlesResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrackingId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackingId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CandlesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCandlesResponse) {
					name = jsonFieldsNameOfCandlesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Currencies) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currencies\"" + ":")
		e.ArrStart()
		if len(s.Currencies) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Currencies[0]
				elem.Encode(e)
			}
			for _, elem := range s.Currencies[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCurrencies = [1]string{
	0: "currencies",
}

// Decode decodes Currencies from json.
func (s *Currencies) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Currencies to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currencies":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Currencies = make([]CurrencyPosition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CurrencyPosition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Currencies = append(s.Currencies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currencies\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Currencies")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCurrencies) {
					name = jsonFieldsNameOfCurrencies[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes Currency as json.
func (s Currency) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes Currency from json.
func (s *Currency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Currency to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch Currency(v) {
	case CurrencyRUB:
		*s = CurrencyRUB
	case CurrencyUSD:
		*s = CurrencyUSD
	case CurrencyEUR:
		*s = CurrencyEUR
	case CurrencyGBP:
		*s = CurrencyGBP
	case CurrencyHKD:
		*s = CurrencyHKD
	case CurrencyCHF:
		*s = CurrencyCHF
	case CurrencyJPY:
		*s = CurrencyJPY
	case CurrencyCNY:
		*s = CurrencyCNY
	case CurrencyTRY:
		*s = CurrencyTRY
	default:
		*s = Currency(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CurrencyPosition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currency\"" + ":")
		s.Currency.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"balance\"" + ":")
		e.Float64(s.Balance)
	}
	{
		if s.Blocked.Set {
			e.Comma()
		}
		if s.Blocked.Set {
			e.RawStr("\"blocked\"" + ":")
			s.Blocked.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfCurrencyPosition = [3]string{
	0: "currency",
	1: "balance",
	2: "blocked",
}

// Decode decodes CurrencyPosition from json.
func (s *CurrencyPosition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CurrencyPosition to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "balance":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Balance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance\"")
			}
		case "blocked":
			if err := func() error {
				s.Blocked.Reset()
				if err := s.Blocked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CurrencyPosition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCurrencyPosition) {
					name = jsonFieldsNameOfCurrencyPosition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Empty) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfEmpty = [3]string{
	0: "trackingId",
	1: "payload",
	2: "status",
}

// Decode decodes Empty from json.
func (s *Empty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Empty to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrackingId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackingId\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Empty")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEmpty) {
					name = jsonFieldsNameOfEmpty[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s EmptyPayload) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

var jsonFieldsNameOfEmptyPayload = [0]string{}

// Decode decodes EmptyPayload from json.
func (s *EmptyPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EmptyPayload to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EmptyPayload")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Error) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfError = [3]string{
	0: "trackingId",
	1: "status",
	2: "payload",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrackingId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackingId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s ErrorPayload) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Code.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Code.Set {
			e.RawStr("\"code\"" + ":")
			s.Code.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfErrorPayload = [2]string{
	0: "message",
	1: "code",
}

// Decode decodes ErrorPayload from json.
func (s *ErrorPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorPayload to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorPayload")
	}

	return nil
}

// Encode encodes InstrumentType as json.
func (s InstrumentType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes InstrumentType from json.
func (s *InstrumentType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstrumentType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InstrumentType(v) {
	case InstrumentTypeStock:
		*s = InstrumentTypeStock
	case InstrumentTypeCurrency:
		*s = InstrumentTypeCurrency
	case InstrumentTypeBond:
		*s = InstrumentTypeBond
	case InstrumentTypeEtf:
		*s = InstrumentTypeEtf
	default:
		*s = InstrumentType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s LimitOrderRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"lots\"" + ":")
		e.Int32(s.Lots)
	}
	{
		e.Comma()

		e.RawStr("\"operation\"" + ":")
		s.Operation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"price\"" + ":")
		e.Float64(s.Price)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLimitOrderRequest = [3]string{
	0: "lots",
	1: "operation",
	2: "price",
}

// Decode decodes LimitOrderRequest from json.
func (s *LimitOrderRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LimitOrderRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lots":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Lots = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lots\"")
			}
		case "operation":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Operation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		case "price":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Price = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LimitOrderRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLimitOrderRequest) {
					name = jsonFieldsNameOfLimitOrderRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s LimitOrderResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfLimitOrderResponse = [3]string{
	0: "trackingId",
	1: "status",
	2: "payload",
}

// Decode decodes LimitOrderResponse from json.
func (s *LimitOrderResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LimitOrderResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrackingId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackingId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LimitOrderResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLimitOrderResponse) {
					name = jsonFieldsNameOfLimitOrderResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MarketInstrument) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"figi\"" + ":")
		e.Str(s.Figi)
	}
	{
		e.Comma()

		e.RawStr("\"ticker\"" + ":")
		e.Str(s.Ticker)
	}
	{
		if s.Isin.Set {
			e.Comma()
		}
		if s.Isin.Set {
			e.RawStr("\"isin\"" + ":")
			s.Isin.Encode(e)
		}
	}
	{
		if s.MinPriceIncrement.Set {
			e.Comma()
		}
		if s.MinPriceIncrement.Set {
			e.RawStr("\"minPriceIncrement\"" + ":")
			s.MinPriceIncrement.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"lot\"" + ":")
		e.Int32(s.Lot)
	}
	{
		if s.MinQuantity.Set {
			e.Comma()
		}
		if s.MinQuantity.Set {
			e.RawStr("\"minQuantity\"" + ":")
			s.MinQuantity.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.Comma()
		}
		if s.Currency.Set {
			e.RawStr("\"currency\"" + ":")
			s.Currency.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMarketInstrument = [9]string{
	0: "figi",
	1: "ticker",
	2: "isin",
	3: "minPriceIncrement",
	4: "lot",
	5: "minQuantity",
	6: "currency",
	7: "name",
	8: "type",
}

// Decode decodes MarketInstrument from json.
func (s *MarketInstrument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarketInstrument to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Figi = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "ticker":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ticker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ticker\"")
			}
		case "isin":
			if err := func() error {
				s.Isin.Reset()
				if err := s.Isin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isin\"")
			}
		case "minPriceIncrement":
			if err := func() error {
				s.MinPriceIncrement.Reset()
				if err := s.MinPriceIncrement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minPriceIncrement\"")
			}
		case "lot":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Lot = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lot\"")
			}
		case "minQuantity":
			if err := func() error {
				s.MinQuantity.Reset()
				if err := s.MinQuantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minQuantity\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarketInstrument")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10010011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMarketInstrument) {
					name = jsonFieldsNameOfMarketInstrument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MarketInstrumentList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total\"" + ":")
		e.Int32(s.Total)
	}
	{
		e.Comma()

		e.RawStr("\"instruments\"" + ":")
		e.ArrStart()
		if len(s.Instruments) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Instruments[0]
				elem.Encode(e)
			}
			for _, elem := range s.Instruments[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMarketInstrumentList = [2]string{
	0: "total",
	1: "instruments",
}

// Decode decodes MarketInstrumentList from json.
func (s *MarketInstrumentList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarketInstrumentList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Total = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "instruments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Instruments = make([]MarketInstrument, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MarketInstrument
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Instruments = append(s.Instruments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instruments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarketInstrumentList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMarketInstrumentList) {
					name = jsonFieldsNameOfMarketInstrumentList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MarketInstrumentListResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMarketInstrumentListResponse = [3]string{
	0: "trackingId",
	1: "status",
	2: "payload",
}

// Decode decodes MarketInstrumentListResponse from json.
func (s *MarketInstrumentListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarketInstrumentListResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrackingId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackingId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarketInstrumentListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMarketInstrumentListResponse) {
					name = jsonFieldsNameOfMarketInstrumentListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MarketOrderRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"lots\"" + ":")
		e.Int32(s.Lots)
	}
	{
		e.Comma()

		e.RawStr("\"operation\"" + ":")
		s.Operation.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMarketOrderRequest = [2]string{
	0: "lots",
	1: "operation",
}

// Decode decodes MarketOrderRequest from json.
func (s *MarketOrderRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarketOrderRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lots":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Lots = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lots\"")
			}
		case "operation":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Operation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarketOrderRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMarketOrderRequest) {
					name = jsonFieldsNameOfMarketOrderRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MarketOrderResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMarketOrderResponse = [3]string{
	0: "trackingId",
	1: "status",
	2: "payload",
}

// Decode decodes MarketOrderResponse from json.
func (s *MarketOrderResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MarketOrderResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrackingId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackingId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MarketOrderResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMarketOrderResponse) {
					name = jsonFieldsNameOfMarketOrderResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s MoneyAmount) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currency\"" + ":")
		s.Currency.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"value\"" + ":")
		e.Float64(s.Value)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfMoneyAmount = [2]string{
	0: "currency",
	1: "value",
}

// Decode decodes MoneyAmount from json.
func (s *MoneyAmount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MoneyAmount to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MoneyAmount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMoneyAmount) {
					name = jsonFieldsNameOfMoneyAmount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Operation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		if s.Trades != nil {
			e.Comma()
		}
		if s.Trades != nil {
			e.RawStr("\"trades\"" + ":")
			e.ArrStart()
			if len(s.Trades) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Trades[0]
					elem.Encode(e)
				}
				for _, elem := range s.Trades[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Commission.Set {
			e.Comma()
		}
		if s.Commission.Set {
			e.RawStr("\"commission\"" + ":")
			s.Commission.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"currency\"" + ":")
		s.Currency.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"payment\"" + ":")
		e.Float64(s.Payment)
	}
	{
		if s.Price.Set {
			e.Comma()
		}
		if s.Price.Set {
			e.RawStr("\"price\"" + ":")
			s.Price.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.Comma()
		}
		if s.Quantity.Set {
			e.RawStr("\"quantity\"" + ":")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.QuantityExecuted.Set {
			e.Comma()
		}
		if s.QuantityExecuted.Set {
			e.RawStr("\"quantityExecuted\"" + ":")
			s.QuantityExecuted.Encode(e)
		}
	}
	{
		if s.Figi.Set {
			e.Comma()
		}
		if s.Figi.Set {
			e.RawStr("\"figi\"" + ":")
			s.Figi.Encode(e)
		}
	}
	{
		if s.InstrumentType.Set {
			e.Comma()
		}
		if s.InstrumentType.Set {
			e.RawStr("\"instrumentType\"" + ":")
			s.InstrumentType.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"isMarginCall\"" + ":")
		e.Bool(s.IsMarginCall)
	}
	{
		e.Comma()

		e.RawStr("\"date\"" + ":")
		json.EncodeDateTime(e, s.Date)
	}
	{
		if s.OperationType.Set {
			e.Comma()
		}
		if s.OperationType.Set {
			e.RawStr("\"operationType\"" + ":")
			s.OperationType.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOperation = [14]string{
	0:  "id",
	1:  "status",
	2:  "trades",
	3:  "commission",
	4:  "currency",
	5:  "payment",
	6:  "price",
	7:  "quantity",
	8:  "quantityExecuted",
	9:  "figi",
	10: "instrumentType",
	11: "isMarginCall",
	12: "date",
	13: "operationType",
}

// Decode decodes Operation from json.
func (s *Operation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Operation to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "trades":
			if err := func() error {
				s.Trades = make([]OperationTrade, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem OperationTrade
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Trades = append(s.Trades, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trades\"")
			}
		case "commission":
			if err := func() error {
				s.Commission.Reset()
				if err := s.Commission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commission\"")
			}
		case "currency":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "payment":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.Payment = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payment\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "quantityExecuted":
			if err := func() error {
				s.QuantityExecuted.Reset()
				if err := s.QuantityExecuted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantityExecuted\"")
			}
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "instrumentType":
			if err := func() error {
				s.InstrumentType.Reset()
				if err := s.InstrumentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentType\"")
			}
		case "isMarginCall":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsMarginCall = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isMarginCall\"")
			}
		case "date":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Date = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "operationType":
			if err := func() error {
				s.OperationType.Reset()
				if err := s.OperationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Operation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110011,
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOperation) {
					name = jsonFieldsNameOfOperation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes OperationStatus as json.
func (s OperationStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OperationStatus from json.
func (s *OperationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OperationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OperationStatus(v) {
	case OperationStatusDone:
		*s = OperationStatusDone
	case OperationStatusDecline:
		*s = OperationStatusDecline
	case OperationStatusProgress:
		*s = OperationStatusProgress
	default:
		*s = OperationStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OperationTrade) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"tradeId\"" + ":")
		e.Str(s.TradeId)
	}
	{
		e.Comma()

		e.RawStr("\"date\"" + ":")
		json.EncodeDateTime(e, s.Date)
	}
	{
		e.Comma()

		e.RawStr("\"price\"" + ":")
		e.Float64(s.Price)
	}
	{
		e.Comma()

		e.RawStr("\"quantity\"" + ":")
		e.Int32(s.Quantity)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOperationTrade = [4]string{
	0: "tradeId",
	1: "date",
	2: "price",
	3: "quantity",
}

// Decode decodes OperationTrade from json.
func (s *OperationTrade) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OperationTrade to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tradeId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TradeId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradeId\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Date = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "price":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Price = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Quantity = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OperationTrade")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOperationTrade) {
					name = jsonFieldsNameOfOperationTrade[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes OperationType as json.
func (s OperationType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OperationType from json.
func (s *OperationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OperationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OperationType(v) {
	case OperationTypeBuy:
		*s = OperationTypeBuy
	case OperationTypeSell:
		*s = OperationTypeSell
	default:
		*s = OperationType(v)
	}

	return nil
}

// Encode encodes OperationTypeWithCommission as json.
func (s OperationTypeWithCommission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OperationTypeWithCommission from json.
func (s *OperationTypeWithCommission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OperationTypeWithCommission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OperationTypeWithCommission(v) {
	case OperationTypeWithCommissionBuy:
		*s = OperationTypeWithCommissionBuy
	case OperationTypeWithCommissionBuyCard:
		*s = OperationTypeWithCommissionBuyCard
	case OperationTypeWithCommissionSell:
		*s = OperationTypeWithCommissionSell
	case OperationTypeWithCommissionBrokerCommission:
		*s = OperationTypeWithCommissionBrokerCommission
	case OperationTypeWithCommissionExchangeCommission:
		*s = OperationTypeWithCommissionExchangeCommission
	case OperationTypeWithCommissionServiceCommission:
		*s = OperationTypeWithCommissionServiceCommission
	case OperationTypeWithCommissionMarginCommission:
		*s = OperationTypeWithCommissionMarginCommission
	case OperationTypeWithCommissionOtherCommission:
		*s = OperationTypeWithCommissionOtherCommission
	case OperationTypeWithCommissionPayIn:
		*s = OperationTypeWithCommissionPayIn
	case OperationTypeWithCommissionPayOut:
		*s = OperationTypeWithCommissionPayOut
	case OperationTypeWithCommissionTax:
		*s = OperationTypeWithCommissionTax
	case OperationTypeWithCommissionTaxLucre:
		*s = OperationTypeWithCommissionTaxLucre
	case OperationTypeWithCommissionTaxDividend:
		*s = OperationTypeWithCommissionTaxDividend
	case OperationTypeWithCommissionTaxCoupon:
		*s = OperationTypeWithCommissionTaxCoupon
	case OperationTypeWithCommissionTaxBack:
		*s = OperationTypeWithCommissionTaxBack
	case OperationTypeWithCommissionRepayment:
		*s = OperationTypeWithCommissionRepayment
	case OperationTypeWithCommissionPartRepayment:
		*s = OperationTypeWithCommissionPartRepayment
	case OperationTypeWithCommissionCoupon:
		*s = OperationTypeWithCommissionCoupon
	case OperationTypeWithCommissionDividend:
		*s = OperationTypeWithCommissionDividend
	case OperationTypeWithCommissionSecurityIn:
		*s = OperationTypeWithCommissionSecurityIn
	case OperationTypeWithCommissionSecurityOut:
		*s = OperationTypeWithCommissionSecurityOut
	default:
		*s = OperationTypeWithCommission(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Operations) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"operations\"" + ":")
		e.ArrStart()
		if len(s.Operations) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Operations[0]
				elem.Encode(e)
			}
			for _, elem := range s.Operations[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOperations = [1]string{
	0: "operations",
}

// Decode decodes Operations from json.
func (s *Operations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Operations to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operations":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Operations = make([]Operation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Operation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Operations = append(s.Operations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Operations")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOperations) {
					name = jsonFieldsNameOfOperations[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OperationsResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOperationsResponse = [3]string{
	0: "trackingId",
	1: "status",
	2: "payload",
}

// Decode decodes OperationsResponse from json.
func (s *OperationsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OperationsResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrackingId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackingId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OperationsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOperationsResponse) {
					name = jsonFieldsNameOfOperationsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes BrokerAccountType as json.
func (o OptBrokerAccountType) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BrokerAccountType from json.
func (o *OptBrokerAccountType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBrokerAccountType to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptBrokerAccountType", d.Next())
	}
}

// Encode encodes Currency as json.
func (o OptCurrency) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes Currency from json.
func (o *OptCurrency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCurrency to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptCurrency", d.Next())
	}
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Float64()
		if err != nil {
			return err
		}
		o.Value = float64(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptFloat64", d.Next())
	}
}

// Encode encodes InstrumentType as json.
func (o OptInstrumentType) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InstrumentType from json.
func (o *OptInstrumentType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInstrumentType to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptInstrumentType", d.Next())
	}
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int32()
		if err != nil {
			return err
		}
		o.Value = int32(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptInt32", d.Next())
	}
}

// Encode encodes MoneyAmount as json.
func (o OptMoneyAmount) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MoneyAmount from json.
func (o *OptMoneyAmount) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMoneyAmount to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptMoneyAmount", d.Next())
	}
}

// Encode encodes OperationTypeWithCommission as json.
func (o OptOperationTypeWithCommission) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes OperationTypeWithCommission from json.
func (o *OptOperationTypeWithCommission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOperationTypeWithCommission to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptOperationTypeWithCommission", d.Next())
	}
}

// Encode encodes SandboxRegisterRequest as json.
func (o OptSandboxRegisterRequest) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SandboxRegisterRequest from json.
func (o *OptSandboxRegisterRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSandboxRegisterRequest to nil")
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptSandboxRegisterRequest", d.Next())
	}
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	default:
		return errors.Errorf("unexpected type %q while reading OptString", d.Next())
	}
}

// Encode implements json.Marshaler.
func (s Order) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"orderId\"" + ":")
		e.Str(s.OrderId)
	}
	{
		e.Comma()

		e.RawStr("\"figi\"" + ":")
		e.Str(s.Figi)
	}
	{
		e.Comma()

		e.RawStr("\"operation\"" + ":")
		s.Operation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"requestedLots\"" + ":")
		e.Int32(s.RequestedLots)
	}
	{
		e.Comma()

		e.RawStr("\"executedLots\"" + ":")
		e.Int32(s.ExecutedLots)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"price\"" + ":")
		e.Float64(s.Price)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrder = [8]string{
	0: "orderId",
	1: "figi",
	2: "operation",
	3: "status",
	4: "requestedLots",
	5: "executedLots",
	6: "type",
	7: "price",
}

// Decode decodes Order from json.
func (s *Order) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Order to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "orderId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OrderId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderId\"")
			}
		case "figi":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Figi = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "operation":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Operation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "requestedLots":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.RequestedLots = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestedLots\"")
			}
		case "executedLots":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.ExecutedLots = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executedLots\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "price":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float64()
				s.Price = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Order")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrder) {
					name = jsonFieldsNameOfOrder[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrderResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"price\"" + ":")
		e.Float64(s.Price)
	}
	{
		e.Comma()

		e.RawStr("\"quantity\"" + ":")
		e.Int32(s.Quantity)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrderResponse = [2]string{
	0: "price",
	1: "quantity",
}

// Decode decodes OrderResponse from json.
func (s *OrderResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "price":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Price = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "quantity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Quantity = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrderResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrderResponse) {
					name = jsonFieldsNameOfOrderResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes OrderStatus as json.
func (s OrderStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrderStatus from json.
func (s *OrderStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrderStatus(v) {
	case OrderStatusNew:
		*s = OrderStatusNew
	case OrderStatusPartiallyFill:
		*s = OrderStatusPartiallyFill
	case OrderStatusFill:
		*s = OrderStatusFill
	case OrderStatusCancelled:
		*s = OrderStatusCancelled
	case OrderStatusReplaced:
		*s = OrderStatusReplaced
	case OrderStatusPendingCancel:
		*s = OrderStatusPendingCancel
	case OrderStatusRejected:
		*s = OrderStatusRejected
	case OrderStatusPendingReplace:
		*s = OrderStatusPendingReplace
	case OrderStatusPendingNew:
		*s = OrderStatusPendingNew
	default:
		*s = OrderStatus(v)
	}

	return nil
}

// Encode encodes OrderType as json.
func (s OrderType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrderType from json.
func (s *OrderType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrderType(v) {
	case OrderTypeLimit:
		*s = OrderTypeLimit
	case OrderTypeMarket:
		*s = OrderTypeMarket
	default:
		*s = OrderType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Orderbook) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"figi\"" + ":")
		e.Str(s.Figi)
	}
	{
		e.Comma()

		e.RawStr("\"depth\"" + ":")
		e.Int32(s.Depth)
	}
	{
		e.Comma()

		e.RawStr("\"bids\"" + ":")
		e.ArrStart()
		if len(s.Bids) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Bids[0]
				elem.Encode(e)
			}
			for _, elem := range s.Bids[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"asks\"" + ":")
		e.ArrStart()
		if len(s.Asks) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Asks[0]
				elem.Encode(e)
			}
			for _, elem := range s.Asks[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"tradeStatus\"" + ":")
		s.TradeStatus.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"minPriceIncrement\"" + ":")
		e.Float64(s.MinPriceIncrement)
	}
	{
		if s.FaceValue.Set {
			e.Comma()
		}
		if s.FaceValue.Set {
			e.RawStr("\"faceValue\"" + ":")
			s.FaceValue.Encode(e)
		}
	}
	{
		if s.LastPrice.Set {
			e.Comma()
		}
		if s.LastPrice.Set {
			e.RawStr("\"lastPrice\"" + ":")
			s.LastPrice.Encode(e)
		}
	}
	{
		if s.ClosePrice.Set {
			e.Comma()
		}
		if s.ClosePrice.Set {
			e.RawStr("\"closePrice\"" + ":")
			s.ClosePrice.Encode(e)
		}
	}
	{
		if s.LimitUp.Set {
			e.Comma()
		}
		if s.LimitUp.Set {
			e.RawStr("\"limitUp\"" + ":")
			s.LimitUp.Encode(e)
		}
	}
	{
		if s.LimitDown.Set {
			e.Comma()
		}
		if s.LimitDown.Set {
			e.RawStr("\"limitDown\"" + ":")
			s.LimitDown.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrderbook = [11]string{
	0:  "figi",
	1:  "depth",
	2:  "bids",
	3:  "asks",
	4:  "tradeStatus",
	5:  "minPriceIncrement",
	6:  "faceValue",
	7:  "lastPrice",
	8:  "closePrice",
	9:  "limitUp",
	10: "limitDown",
}

// Decode decodes Orderbook from json.
func (s *Orderbook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Orderbook to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Figi = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "depth":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Depth = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"depth\"")
			}
		case "bids":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Bids = make([]OrderResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem OrderResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Bids = append(s.Bids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bids\"")
			}
		case "asks":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Asks = make([]OrderResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem OrderResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Asks = append(s.Asks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asks\"")
			}
		case "tradeStatus":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.TradeStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradeStatus\"")
			}
		case "minPriceIncrement":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.MinPriceIncrement = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minPriceIncrement\"")
			}
		case "faceValue":
			if err := func() error {
				s.FaceValue.Reset()
				if err := s.FaceValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faceValue\"")
			}
		case "lastPrice":
			if err := func() error {
				s.LastPrice.Reset()
				if err := s.LastPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastPrice\"")
			}
		case "closePrice":
			if err := func() error {
				s.ClosePrice.Reset()
				if err := s.ClosePrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closePrice\"")
			}
		case "limitUp":
			if err := func() error {
				s.LimitUp.Reset()
				if err := s.LimitUp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitUp\"")
			}
		case "limitDown":
			if err := func() error {
				s.LimitDown.Reset()
				if err := s.LimitDown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitDown\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Orderbook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrderbook) {
					name = jsonFieldsNameOfOrderbook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrderbookResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrderbookResponse = [3]string{
	0: "trackingId",
	1: "status",
	2: "payload",
}

// Decode decodes OrderbookResponse from json.
func (s *OrderbookResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderbookResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrackingId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackingId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrderbookResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrderbookResponse) {
					name = jsonFieldsNameOfOrderbookResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OrdersResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		e.ArrStart()
		if len(s.Payload) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Payload[0]
				elem.Encode(e)
			}
			for _, elem := range s.Payload[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfOrdersResponse = [3]string{
	0: "trackingId",
	1: "status",
	2: "payload",
}

// Decode decodes OrdersResponse from json.
func (s *OrdersResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrdersResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrackingId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackingId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Payload = make([]Order, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Order
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Payload = append(s.Payload, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrdersResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrdersResponse) {
					name = jsonFieldsNameOfOrdersResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PlacedLimitOrder) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"orderId\"" + ":")
		e.Str(s.OrderId)
	}
	{
		e.Comma()

		e.RawStr("\"operation\"" + ":")
		s.Operation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		if s.RejectReason.Set {
			e.Comma()
		}
		if s.RejectReason.Set {
			e.RawStr("\"rejectReason\"" + ":")
			s.RejectReason.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.Comma()
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"requestedLots\"" + ":")
		e.Int(s.RequestedLots)
	}
	{
		e.Comma()

		e.RawStr("\"executedLots\"" + ":")
		e.Int(s.ExecutedLots)
	}
	{
		if s.Commission.Set {
			e.Comma()
		}
		if s.Commission.Set {
			e.RawStr("\"commission\"" + ":")
			s.Commission.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPlacedLimitOrder = [8]string{
	0: "orderId",
	1: "operation",
	2: "status",
	3: "rejectReason",
	4: "message",
	5: "requestedLots",
	6: "executedLots",
	7: "commission",
}

// Decode decodes PlacedLimitOrder from json.
func (s *PlacedLimitOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlacedLimitOrder to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "orderId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OrderId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderId\"")
			}
		case "operation":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Operation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "rejectReason":
			if err := func() error {
				s.RejectReason.Reset()
				if err := s.RejectReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rejectReason\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "requestedLots":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.RequestedLots = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestedLots\"")
			}
		case "executedLots":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ExecutedLots = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executedLots\"")
			}
		case "commission":
			if err := func() error {
				s.Commission.Reset()
				if err := s.Commission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlacedLimitOrder")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlacedLimitOrder) {
					name = jsonFieldsNameOfPlacedLimitOrder[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PlacedMarketOrder) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"orderId\"" + ":")
		e.Str(s.OrderId)
	}
	{
		e.Comma()

		e.RawStr("\"operation\"" + ":")
		s.Operation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		if s.RejectReason.Set {
			e.Comma()
		}
		if s.RejectReason.Set {
			e.RawStr("\"rejectReason\"" + ":")
			s.RejectReason.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.Comma()
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"requestedLots\"" + ":")
		e.Int(s.RequestedLots)
	}
	{
		e.Comma()

		e.RawStr("\"executedLots\"" + ":")
		e.Int(s.ExecutedLots)
	}
	{
		if s.Commission.Set {
			e.Comma()
		}
		if s.Commission.Set {
			e.RawStr("\"commission\"" + ":")
			s.Commission.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPlacedMarketOrder = [8]string{
	0: "orderId",
	1: "operation",
	2: "status",
	3: "rejectReason",
	4: "message",
	5: "requestedLots",
	6: "executedLots",
	7: "commission",
}

// Decode decodes PlacedMarketOrder from json.
func (s *PlacedMarketOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlacedMarketOrder to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "orderId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OrderId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderId\"")
			}
		case "operation":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Operation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "rejectReason":
			if err := func() error {
				s.RejectReason.Reset()
				if err := s.RejectReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rejectReason\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "requestedLots":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.RequestedLots = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestedLots\"")
			}
		case "executedLots":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ExecutedLots = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executedLots\"")
			}
		case "commission":
			if err := func() error {
				s.Commission.Reset()
				if err := s.Commission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlacedMarketOrder")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlacedMarketOrder) {
					name = jsonFieldsNameOfPlacedMarketOrder[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Portfolio) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"positions\"" + ":")
		e.ArrStart()
		if len(s.Positions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Positions[0]
				elem.Encode(e)
			}
			for _, elem := range s.Positions[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPortfolio = [1]string{
	0: "positions",
}

// Decode decodes Portfolio from json.
func (s *Portfolio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Portfolio to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "positions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Positions = make([]PortfolioPosition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PortfolioPosition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Positions = append(s.Positions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Portfolio")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPortfolio) {
					name = jsonFieldsNameOfPortfolio[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PortfolioCurrenciesResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPortfolioCurrenciesResponse = [3]string{
	0: "trackingId",
	1: "status",
	2: "payload",
}

// Decode decodes PortfolioCurrenciesResponse from json.
func (s *PortfolioCurrenciesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PortfolioCurrenciesResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrackingId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackingId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PortfolioCurrenciesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPortfolioCurrenciesResponse) {
					name = jsonFieldsNameOfPortfolioCurrenciesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PortfolioPosition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"figi\"" + ":")
		e.Str(s.Figi)
	}
	{
		if s.Ticker.Set {
			e.Comma()
		}
		if s.Ticker.Set {
			e.RawStr("\"ticker\"" + ":")
			s.Ticker.Encode(e)
		}
	}
	{
		if s.Isin.Set {
			e.Comma()
		}
		if s.Isin.Set {
			e.RawStr("\"isin\"" + ":")
			s.Isin.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"instrumentType\"" + ":")
		s.InstrumentType.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"balance\"" + ":")
		e.Float64(s.Balance)
	}
	{
		if s.Blocked.Set {
			e.Comma()
		}
		if s.Blocked.Set {
			e.RawStr("\"blocked\"" + ":")
			s.Blocked.Encode(e)
		}
	}
	{
		if s.ExpectedYield.Set {
			e.Comma()
		}
		if s.ExpectedYield.Set {
			e.RawStr("\"expectedYield\"" + ":")
			s.ExpectedYield.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"lots\"" + ":")
		e.Int32(s.Lots)
	}
	{
		if s.AveragePositionPrice.Set {
			e.Comma()
		}
		if s.AveragePositionPrice.Set {
			e.RawStr("\"averagePositionPrice\"" + ":")
			s.AveragePositionPrice.Encode(e)
		}
	}
	{
		if s.AveragePositionPriceNoNkd.Set {
			e.Comma()
		}
		if s.AveragePositionPriceNoNkd.Set {
			e.RawStr("\"averagePositionPriceNoNkd\"" + ":")
			s.AveragePositionPriceNoNkd.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPortfolioPosition = [11]string{
	0:  "figi",
	1:  "ticker",
	2:  "isin",
	3:  "instrumentType",
	4:  "balance",
	5:  "blocked",
	6:  "expectedYield",
	7:  "lots",
	8:  "averagePositionPrice",
	9:  "averagePositionPriceNoNkd",
	10: "name",
}

// Decode decodes PortfolioPosition from json.
func (s *PortfolioPosition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PortfolioPosition to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Figi = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "ticker":
			if err := func() error {
				s.Ticker.Reset()
				if err := s.Ticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ticker\"")
			}
		case "isin":
			if err := func() error {
				s.Isin.Reset()
				if err := s.Isin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isin\"")
			}
		case "instrumentType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.InstrumentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentType\"")
			}
		case "balance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Balance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance\"")
			}
		case "blocked":
			if err := func() error {
				s.Blocked.Reset()
				if err := s.Blocked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked\"")
			}
		case "expectedYield":
			if err := func() error {
				s.ExpectedYield.Reset()
				if err := s.ExpectedYield.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expectedYield\"")
			}
		case "lots":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Lots = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lots\"")
			}
		case "averagePositionPrice":
			if err := func() error {
				s.AveragePositionPrice.Reset()
				if err := s.AveragePositionPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averagePositionPrice\"")
			}
		case "averagePositionPriceNoNkd":
			if err := func() error {
				s.AveragePositionPriceNoNkd.Reset()
				if err := s.AveragePositionPriceNoNkd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averagePositionPriceNoNkd\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PortfolioPosition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10011001,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPortfolioPosition) {
					name = jsonFieldsNameOfPortfolioPosition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s PortfolioResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfPortfolioResponse = [3]string{
	0: "trackingId",
	1: "status",
	2: "payload",
}

// Decode decodes PortfolioResponse from json.
func (s *PortfolioResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PortfolioResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrackingId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackingId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PortfolioResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPortfolioResponse) {
					name = jsonFieldsNameOfPortfolioResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SandboxAccount) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"brokerAccountType\"" + ":")
		s.BrokerAccountType.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"brokerAccountId\"" + ":")
		e.Str(s.BrokerAccountId)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSandboxAccount = [2]string{
	0: "brokerAccountType",
	1: "brokerAccountId",
}

// Decode decodes SandboxAccount from json.
func (s *SandboxAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SandboxAccount to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "brokerAccountType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.BrokerAccountType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brokerAccountType\"")
			}
		case "brokerAccountId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BrokerAccountId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brokerAccountId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SandboxAccount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSandboxAccount) {
					name = jsonFieldsNameOfSandboxAccount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes SandboxCurrency as json.
func (s SandboxCurrency) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SandboxCurrency from json.
func (s *SandboxCurrency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SandboxCurrency to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SandboxCurrency(v) {
	case SandboxCurrencyRUB:
		*s = SandboxCurrencyRUB
	case SandboxCurrencyUSD:
		*s = SandboxCurrencyUSD
	case SandboxCurrencyEUR:
		*s = SandboxCurrencyEUR
	case SandboxCurrencyGBP:
		*s = SandboxCurrencyGBP
	case SandboxCurrencyHKD:
		*s = SandboxCurrencyHKD
	case SandboxCurrencyCHF:
		*s = SandboxCurrencyCHF
	case SandboxCurrencyJPY:
		*s = SandboxCurrencyJPY
	case SandboxCurrencyCNY:
		*s = SandboxCurrencyCNY
	case SandboxCurrencyTRY:
		*s = SandboxCurrencyTRY
	default:
		*s = SandboxCurrency(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SandboxRegisterRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.BrokerAccountType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BrokerAccountType.Set {
			e.RawStr("\"brokerAccountType\"" + ":")
			s.BrokerAccountType.Encode(e)
		}
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSandboxRegisterRequest = [1]string{
	0: "brokerAccountType",
}

// Decode decodes SandboxRegisterRequest from json.
func (s *SandboxRegisterRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SandboxRegisterRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "brokerAccountType":
			if err := func() error {
				s.BrokerAccountType.Reset()
				if err := s.BrokerAccountType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brokerAccountType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SandboxRegisterRequest")
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SandboxRegisterResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSandboxRegisterResponse = [3]string{
	0: "trackingId",
	1: "status",
	2: "payload",
}

// Decode decodes SandboxRegisterResponse from json.
func (s *SandboxRegisterResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SandboxRegisterResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrackingId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackingId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SandboxRegisterResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSandboxRegisterResponse) {
					name = jsonFieldsNameOfSandboxRegisterResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SandboxSetCurrencyBalanceRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currency\"" + ":")
		s.Currency.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"balance\"" + ":")
		e.Float64(s.Balance)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSandboxSetCurrencyBalanceRequest = [2]string{
	0: "currency",
	1: "balance",
}

// Decode decodes SandboxSetCurrencyBalanceRequest from json.
func (s *SandboxSetCurrencyBalanceRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SandboxSetCurrencyBalanceRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "balance":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Balance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SandboxSetCurrencyBalanceRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSandboxSetCurrencyBalanceRequest) {
					name = jsonFieldsNameOfSandboxSetCurrencyBalanceRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SandboxSetPositionBalanceRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Figi.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Figi.Set {
			e.RawStr("\"figi\"" + ":")
			s.Figi.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"balance\"" + ":")
		e.Float64(s.Balance)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSandboxSetPositionBalanceRequest = [2]string{
	0: "figi",
	1: "balance",
}

// Decode decodes SandboxSetPositionBalanceRequest from json.
func (s *SandboxSetPositionBalanceRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SandboxSetPositionBalanceRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "balance":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Balance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SandboxSetPositionBalanceRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSandboxSetPositionBalanceRequest) {
					name = jsonFieldsNameOfSandboxSetPositionBalanceRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SearchMarketInstrument) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"figi\"" + ":")
		e.Str(s.Figi)
	}
	{
		e.Comma()

		e.RawStr("\"ticker\"" + ":")
		e.Str(s.Ticker)
	}
	{
		if s.Isin.Set {
			e.Comma()
		}
		if s.Isin.Set {
			e.RawStr("\"isin\"" + ":")
			s.Isin.Encode(e)
		}
	}
	{
		if s.MinPriceIncrement.Set {
			e.Comma()
		}
		if s.MinPriceIncrement.Set {
			e.RawStr("\"minPriceIncrement\"" + ":")
			s.MinPriceIncrement.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"lot\"" + ":")
		e.Int32(s.Lot)
	}
	{
		if s.Currency.Set {
			e.Comma()
		}
		if s.Currency.Set {
			e.RawStr("\"currency\"" + ":")
			s.Currency.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSearchMarketInstrument = [8]string{
	0: "figi",
	1: "ticker",
	2: "isin",
	3: "minPriceIncrement",
	4: "lot",
	5: "currency",
	6: "name",
	7: "type",
}

// Decode decodes SearchMarketInstrument from json.
func (s *SearchMarketInstrument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchMarketInstrument to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Figi = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "ticker":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Ticker = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ticker\"")
			}
		case "isin":
			if err := func() error {
				s.Isin.Reset()
				if err := s.Isin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isin\"")
			}
		case "minPriceIncrement":
			if err := func() error {
				s.MinPriceIncrement.Reset()
				if err := s.MinPriceIncrement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minPriceIncrement\"")
			}
		case "lot":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Lot = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lot\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchMarketInstrument")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchMarketInstrument) {
					name = jsonFieldsNameOfSearchMarketInstrument[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SearchMarketInstrumentResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfSearchMarketInstrumentResponse = [3]string{
	0: "trackingId",
	1: "status",
	2: "payload",
}

// Decode decodes SearchMarketInstrumentResponse from json.
func (s *SearchMarketInstrumentResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchMarketInstrumentResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrackingId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackingId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchMarketInstrumentResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchMarketInstrumentResponse) {
					name = jsonFieldsNameOfSearchMarketInstrumentResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode encodes TradeStatus as json.
func (s TradeStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TradeStatus from json.
func (s *TradeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TradeStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TradeStatus(v) {
	case TradeStatusNormalTrading:
		*s = TradeStatusNormalTrading
	case TradeStatusNotAvailableForTrading:
		*s = TradeStatusNotAvailableForTrading
	default:
		*s = TradeStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserAccount) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"brokerAccountType\"" + ":")
		s.BrokerAccountType.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"brokerAccountId\"" + ":")
		e.Str(s.BrokerAccountId)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserAccount = [2]string{
	0: "brokerAccountType",
	1: "brokerAccountId",
}

// Decode decodes UserAccount from json.
func (s *UserAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAccount to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "brokerAccountType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.BrokerAccountType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brokerAccountType\"")
			}
		case "brokerAccountId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BrokerAccountId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brokerAccountId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAccount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserAccount) {
					name = jsonFieldsNameOfUserAccount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserAccounts) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"accounts\"" + ":")
		e.ArrStart()
		if len(s.Accounts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Accounts[0]
				elem.Encode(e)
			}
			for _, elem := range s.Accounts[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserAccounts = [1]string{
	0: "accounts",
}

// Decode decodes UserAccounts from json.
func (s *UserAccounts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAccounts to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accounts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Accounts = make([]UserAccount, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserAccount
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Accounts = append(s.Accounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accounts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAccounts")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserAccounts) {
					name = jsonFieldsNameOfUserAccounts[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserAccountsResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

var jsonFieldsNameOfUserAccountsResponse = [3]string{
	0: "trackingId",
	1: "status",
	2: "payload",
}

// Decode decodes UserAccountsResponse from json.
func (s *UserAccountsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAccountsResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TrackingId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trackingId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "payload":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Payload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAccountsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserAccountsResponse) {
					name = jsonFieldsNameOfUserAccountsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}
