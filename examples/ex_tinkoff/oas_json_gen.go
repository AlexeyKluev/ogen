// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
)

// Encode encodes BrokerAccountType as json.
func (s BrokerAccountType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes BrokerAccountType from json.
func (s *BrokerAccountType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BrokerAccountType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BrokerAccountType(v) {
	case BrokerAccountTypeTinkoff:
		*s = BrokerAccountTypeTinkoff
	case BrokerAccountTypeTinkoffIis:
		*s = BrokerAccountTypeTinkoffIis
	default:
		*s = BrokerAccountType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Candle) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"figi\"" + ":")
		e.Str(s.Figi)
	}
	{
		e.Comma()

		e.RawStr("\"interval\"" + ":")
		s.Interval.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"o\"" + ":")
		e.Float64(s.O)
	}
	{
		e.Comma()

		e.RawStr("\"c\"" + ":")
		e.Float64(s.C)
	}
	{
		e.Comma()

		e.RawStr("\"h\"" + ":")
		e.Float64(s.H)
	}
	{
		e.Comma()

		e.RawStr("\"l\"" + ":")
		e.Float64(s.L)
	}
	{
		e.Comma()

		e.RawStr("\"v\"" + ":")
		e.Int32(s.V)
	}
	{
		e.Comma()

		e.RawStr("\"time\"" + ":")
		json.EncodeDateTime(e, s.Time)
	}
	e.ObjEnd()
}

// Decode decodes Candle from json.
func (s *Candle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Candle to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			v, err := d.Str()
			s.Figi = string(v)
			if err != nil {
				return err
			}
		case "interval":
			if err := s.Interval.Decode(d); err != nil {
				return err
			}
		case "o":
			v, err := d.Float64()
			s.O = float64(v)
			if err != nil {
				return err
			}
		case "c":
			v, err := d.Float64()
			s.C = float64(v)
			if err != nil {
				return err
			}
		case "h":
			v, err := d.Float64()
			s.H = float64(v)
			if err != nil {
				return err
			}
		case "l":
			v, err := d.Float64()
			s.L = float64(v)
			if err != nil {
				return err
			}
		case "v":
			v, err := d.Int32()
			s.V = int32(v)
			if err != nil {
				return err
			}
		case "time":
			v, err := json.DecodeDateTime(d)
			s.Time = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CandleResolution as json.
func (s CandleResolution) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes CandleResolution from json.
func (s *CandleResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CandleResolution to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CandleResolution(v) {
	case CandleResolution1min:
		*s = CandleResolution1min
	case CandleResolution2min:
		*s = CandleResolution2min
	case CandleResolution3min:
		*s = CandleResolution3min
	case CandleResolution5min:
		*s = CandleResolution5min
	case CandleResolution10min:
		*s = CandleResolution10min
	case CandleResolution15min:
		*s = CandleResolution15min
	case CandleResolution30min:
		*s = CandleResolution30min
	case CandleResolutionHour:
		*s = CandleResolutionHour
	case CandleResolutionDay:
		*s = CandleResolutionDay
	case CandleResolutionWeek:
		*s = CandleResolutionWeek
	case CandleResolutionMonth:
		*s = CandleResolutionMonth
	default:
		*s = CandleResolution(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Candles) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"figi\"" + ":")
		e.Str(s.Figi)
	}
	{
		e.Comma()

		e.RawStr("\"interval\"" + ":")
		s.Interval.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"candles\"" + ":")
		e.ArrStart()
		if len(s.Candles) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Candles[0]
				elem.Encode(e)
			}
			for _, elem := range s.Candles[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes Candles from json.
func (s *Candles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Candles to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			v, err := d.Str()
			s.Figi = string(v)
			if err != nil {
				return err
			}
		case "interval":
			if err := s.Interval.Decode(d); err != nil {
				return err
			}
		case "candles":
			s.Candles = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Candle
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Candles = append(s.Candles, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CandlesResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CandlesResponse from json.
func (s *CandlesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CandlesResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			v, err := d.Str()
			s.TrackingId = string(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Currencies) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currencies\"" + ":")
		e.ArrStart()
		if len(s.Currencies) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Currencies[0]
				elem.Encode(e)
			}
			for _, elem := range s.Currencies[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes Currencies from json.
func (s *Currencies) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Currencies to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currencies":
			s.Currencies = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CurrencyPosition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Currencies = append(s.Currencies, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes Currency as json.
func (s Currency) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes Currency from json.
func (s *Currency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Currency to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch Currency(v) {
	case CurrencyRUB:
		*s = CurrencyRUB
	case CurrencyUSD:
		*s = CurrencyUSD
	case CurrencyEUR:
		*s = CurrencyEUR
	case CurrencyGBP:
		*s = CurrencyGBP
	case CurrencyHKD:
		*s = CurrencyHKD
	case CurrencyCHF:
		*s = CurrencyCHF
	case CurrencyJPY:
		*s = CurrencyJPY
	case CurrencyCNY:
		*s = CurrencyCNY
	case CurrencyTRY:
		*s = CurrencyTRY
	default:
		*s = Currency(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s CurrencyPosition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currency\"" + ":")
		s.Currency.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"balance\"" + ":")
		e.Float64(s.Balance)
	}
	{
		if s.Blocked.Set {
			e.Comma()
		}
		if s.Blocked.Set {
			e.RawStr("\"blocked\"" + ":")
			s.Blocked.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes CurrencyPosition from json.
func (s *CurrencyPosition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CurrencyPosition to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			if err := s.Currency.Decode(d); err != nil {
				return err
			}
		case "balance":
			v, err := d.Float64()
			s.Balance = float64(v)
			if err != nil {
				return err
			}
		case "blocked":
			s.Blocked.Reset()
			if err := s.Blocked.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Empty) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	e.ObjEnd()
}

// Decode decodes Empty from json.
func (s *Empty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Empty to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			v, err := d.Str()
			s.TrackingId = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EmptyPayload) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	e.ObjEnd()
}

// Decode decodes EmptyPayload from json.
func (s *EmptyPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EmptyPayload to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Error) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Error to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			v, err := d.Str()
			s.TrackingId = string(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ErrorPayload) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Message.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		if s.Code.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Code.Set {
			e.RawStr("\"code\"" + ":")
			s.Code.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes ErrorPayload from json.
func (s *ErrorPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ErrorPayload to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "code":
			s.Code.Reset()
			if err := s.Code.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes InstrumentType as json.
func (s InstrumentType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes InstrumentType from json.
func (s *InstrumentType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InstrumentType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InstrumentType(v) {
	case InstrumentTypeStock:
		*s = InstrumentTypeStock
	case InstrumentTypeCurrency:
		*s = InstrumentTypeCurrency
	case InstrumentTypeBond:
		*s = InstrumentTypeBond
	case InstrumentTypeEtf:
		*s = InstrumentTypeEtf
	default:
		*s = InstrumentType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s LimitOrderRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"lots\"" + ":")
		e.Int32(s.Lots)
	}
	{
		e.Comma()

		e.RawStr("\"operation\"" + ":")
		s.Operation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"price\"" + ":")
		e.Float64(s.Price)
	}
	e.ObjEnd()
}

// Decode decodes LimitOrderRequest from json.
func (s *LimitOrderRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LimitOrderRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lots":
			v, err := d.Int32()
			s.Lots = int32(v)
			if err != nil {
				return err
			}
		case "operation":
			if err := s.Operation.Decode(d); err != nil {
				return err
			}
		case "price":
			v, err := d.Float64()
			s.Price = float64(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s LimitOrderResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes LimitOrderResponse from json.
func (s *LimitOrderResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LimitOrderResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			v, err := d.Str()
			s.TrackingId = string(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MarketInstrument) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"figi\"" + ":")
		e.Str(s.Figi)
	}
	{
		e.Comma()

		e.RawStr("\"ticker\"" + ":")
		e.Str(s.Ticker)
	}
	{
		if s.Isin.Set {
			e.Comma()
		}
		if s.Isin.Set {
			e.RawStr("\"isin\"" + ":")
			s.Isin.Encode(e)
		}
	}
	{
		if s.MinPriceIncrement.Set {
			e.Comma()
		}
		if s.MinPriceIncrement.Set {
			e.RawStr("\"minPriceIncrement\"" + ":")
			s.MinPriceIncrement.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"lot\"" + ":")
		e.Int32(s.Lot)
	}
	{
		if s.MinQuantity.Set {
			e.Comma()
		}
		if s.MinQuantity.Set {
			e.RawStr("\"minQuantity\"" + ":")
			s.MinQuantity.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.Comma()
		}
		if s.Currency.Set {
			e.RawStr("\"currency\"" + ":")
			s.Currency.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MarketInstrument from json.
func (s *MarketInstrument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarketInstrument to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			v, err := d.Str()
			s.Figi = string(v)
			if err != nil {
				return err
			}
		case "ticker":
			v, err := d.Str()
			s.Ticker = string(v)
			if err != nil {
				return err
			}
		case "isin":
			s.Isin.Reset()
			if err := s.Isin.Decode(d); err != nil {
				return err
			}
		case "minPriceIncrement":
			s.MinPriceIncrement.Reset()
			if err := s.MinPriceIncrement.Decode(d); err != nil {
				return err
			}
		case "lot":
			v, err := d.Int32()
			s.Lot = int32(v)
			if err != nil {
				return err
			}
		case "minQuantity":
			s.MinQuantity.Reset()
			if err := s.MinQuantity.Decode(d); err != nil {
				return err
			}
		case "currency":
			s.Currency.Reset()
			if err := s.Currency.Decode(d); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "type":
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MarketInstrumentList) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"total\"" + ":")
		e.Int32(s.Total)
	}
	{
		e.Comma()

		e.RawStr("\"instruments\"" + ":")
		e.ArrStart()
		if len(s.Instruments) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Instruments[0]
				elem.Encode(e)
			}
			for _, elem := range s.Instruments[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes MarketInstrumentList from json.
func (s *MarketInstrumentList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarketInstrumentList to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			v, err := d.Int32()
			s.Total = int32(v)
			if err != nil {
				return err
			}
		case "instruments":
			s.Instruments = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MarketInstrument
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Instruments = append(s.Instruments, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MarketInstrumentListResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MarketInstrumentListResponse from json.
func (s *MarketInstrumentListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarketInstrumentListResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			v, err := d.Str()
			s.TrackingId = string(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MarketOrderRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"lots\"" + ":")
		e.Int32(s.Lots)
	}
	{
		e.Comma()

		e.RawStr("\"operation\"" + ":")
		s.Operation.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MarketOrderRequest from json.
func (s *MarketOrderRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarketOrderRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lots":
			v, err := d.Int32()
			s.Lots = int32(v)
			if err != nil {
				return err
			}
		case "operation":
			if err := s.Operation.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MarketOrderResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MarketOrderResponse from json.
func (s *MarketOrderResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarketOrderResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			v, err := d.Str()
			s.TrackingId = string(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MoneyAmount) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currency\"" + ":")
		s.Currency.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"value\"" + ":")
		e.Float64(s.Value)
	}
	e.ObjEnd()
}

// Decode decodes MoneyAmount from json.
func (s *MoneyAmount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MoneyAmount to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			if err := s.Currency.Decode(d); err != nil {
				return err
			}
		case "value":
			v, err := d.Float64()
			s.Value = float64(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Operation) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"id\"" + ":")
		e.Str(s.ID)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		if s.Trades != nil {
			e.Comma()
		}
		if s.Trades != nil {
			e.RawStr("\"trades\"" + ":")
			e.ArrStart()
			if len(s.Trades) >= 1 {
				// Encode first element without comma.
				{
					elem := s.Trades[0]
					elem.Encode(e)
				}
				for _, elem := range s.Trades[1:] {
					e.Comma()
					elem.Encode(e)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.Commission.Set {
			e.Comma()
		}
		if s.Commission.Set {
			e.RawStr("\"commission\"" + ":")
			s.Commission.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"currency\"" + ":")
		s.Currency.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"payment\"" + ":")
		e.Float64(s.Payment)
	}
	{
		if s.Price.Set {
			e.Comma()
		}
		if s.Price.Set {
			e.RawStr("\"price\"" + ":")
			s.Price.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.Comma()
		}
		if s.Quantity.Set {
			e.RawStr("\"quantity\"" + ":")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.QuantityExecuted.Set {
			e.Comma()
		}
		if s.QuantityExecuted.Set {
			e.RawStr("\"quantityExecuted\"" + ":")
			s.QuantityExecuted.Encode(e)
		}
	}
	{
		if s.Figi.Set {
			e.Comma()
		}
		if s.Figi.Set {
			e.RawStr("\"figi\"" + ":")
			s.Figi.Encode(e)
		}
	}
	{
		if s.InstrumentType.Set {
			e.Comma()
		}
		if s.InstrumentType.Set {
			e.RawStr("\"instrumentType\"" + ":")
			s.InstrumentType.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"isMarginCall\"" + ":")
		e.Bool(s.IsMarginCall)
	}
	{
		e.Comma()

		e.RawStr("\"date\"" + ":")
		json.EncodeDateTime(e, s.Date)
	}
	{
		if s.OperationType.Set {
			e.Comma()
		}
		if s.OperationType.Set {
			e.RawStr("\"operationType\"" + ":")
			s.OperationType.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes Operation from json.
func (s *Operation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Operation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "trades":
			s.Trades = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem OperationTrade
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Trades = append(s.Trades, elem)
				return nil
			}); err != nil {
				return err
			}
		case "commission":
			s.Commission.Reset()
			if err := s.Commission.Decode(d); err != nil {
				return err
			}
		case "currency":
			if err := s.Currency.Decode(d); err != nil {
				return err
			}
		case "payment":
			v, err := d.Float64()
			s.Payment = float64(v)
			if err != nil {
				return err
			}
		case "price":
			s.Price.Reset()
			if err := s.Price.Decode(d); err != nil {
				return err
			}
		case "quantity":
			s.Quantity.Reset()
			if err := s.Quantity.Decode(d); err != nil {
				return err
			}
		case "quantityExecuted":
			s.QuantityExecuted.Reset()
			if err := s.QuantityExecuted.Decode(d); err != nil {
				return err
			}
		case "figi":
			s.Figi.Reset()
			if err := s.Figi.Decode(d); err != nil {
				return err
			}
		case "instrumentType":
			s.InstrumentType.Reset()
			if err := s.InstrumentType.Decode(d); err != nil {
				return err
			}
		case "isMarginCall":
			v, err := d.Bool()
			s.IsMarginCall = bool(v)
			if err != nil {
				return err
			}
		case "date":
			v, err := json.DecodeDateTime(d)
			s.Date = v
			if err != nil {
				return err
			}
		case "operationType":
			s.OperationType.Reset()
			if err := s.OperationType.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OperationStatus as json.
func (s OperationStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OperationStatus from json.
func (s *OperationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OperationStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OperationStatus(v) {
	case OperationStatusDone:
		*s = OperationStatusDone
	case OperationStatusDecline:
		*s = OperationStatusDecline
	case OperationStatusProgress:
		*s = OperationStatusProgress
	default:
		*s = OperationStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s OperationTrade) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"tradeId\"" + ":")
		e.Str(s.TradeId)
	}
	{
		e.Comma()

		e.RawStr("\"date\"" + ":")
		json.EncodeDateTime(e, s.Date)
	}
	{
		e.Comma()

		e.RawStr("\"price\"" + ":")
		e.Float64(s.Price)
	}
	{
		e.Comma()

		e.RawStr("\"quantity\"" + ":")
		e.Int32(s.Quantity)
	}
	e.ObjEnd()
}

// Decode decodes OperationTrade from json.
func (s *OperationTrade) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OperationTrade to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tradeId":
			v, err := d.Str()
			s.TradeId = string(v)
			if err != nil {
				return err
			}
		case "date":
			v, err := json.DecodeDateTime(d)
			s.Date = v
			if err != nil {
				return err
			}
		case "price":
			v, err := d.Float64()
			s.Price = float64(v)
			if err != nil {
				return err
			}
		case "quantity":
			v, err := d.Int32()
			s.Quantity = int32(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OperationType as json.
func (s OperationType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OperationType from json.
func (s *OperationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OperationType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OperationType(v) {
	case OperationTypeBuy:
		*s = OperationTypeBuy
	case OperationTypeSell:
		*s = OperationTypeSell
	default:
		*s = OperationType(v)
	}

	return nil
}

// Encode encodes OperationTypeWithCommission as json.
func (s OperationTypeWithCommission) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OperationTypeWithCommission from json.
func (s *OperationTypeWithCommission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OperationTypeWithCommission to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OperationTypeWithCommission(v) {
	case OperationTypeWithCommissionBuy:
		*s = OperationTypeWithCommissionBuy
	case OperationTypeWithCommissionBuyCard:
		*s = OperationTypeWithCommissionBuyCard
	case OperationTypeWithCommissionSell:
		*s = OperationTypeWithCommissionSell
	case OperationTypeWithCommissionBrokerCommission:
		*s = OperationTypeWithCommissionBrokerCommission
	case OperationTypeWithCommissionExchangeCommission:
		*s = OperationTypeWithCommissionExchangeCommission
	case OperationTypeWithCommissionServiceCommission:
		*s = OperationTypeWithCommissionServiceCommission
	case OperationTypeWithCommissionMarginCommission:
		*s = OperationTypeWithCommissionMarginCommission
	case OperationTypeWithCommissionOtherCommission:
		*s = OperationTypeWithCommissionOtherCommission
	case OperationTypeWithCommissionPayIn:
		*s = OperationTypeWithCommissionPayIn
	case OperationTypeWithCommissionPayOut:
		*s = OperationTypeWithCommissionPayOut
	case OperationTypeWithCommissionTax:
		*s = OperationTypeWithCommissionTax
	case OperationTypeWithCommissionTaxLucre:
		*s = OperationTypeWithCommissionTaxLucre
	case OperationTypeWithCommissionTaxDividend:
		*s = OperationTypeWithCommissionTaxDividend
	case OperationTypeWithCommissionTaxCoupon:
		*s = OperationTypeWithCommissionTaxCoupon
	case OperationTypeWithCommissionTaxBack:
		*s = OperationTypeWithCommissionTaxBack
	case OperationTypeWithCommissionRepayment:
		*s = OperationTypeWithCommissionRepayment
	case OperationTypeWithCommissionPartRepayment:
		*s = OperationTypeWithCommissionPartRepayment
	case OperationTypeWithCommissionCoupon:
		*s = OperationTypeWithCommissionCoupon
	case OperationTypeWithCommissionDividend:
		*s = OperationTypeWithCommissionDividend
	case OperationTypeWithCommissionSecurityIn:
		*s = OperationTypeWithCommissionSecurityIn
	case OperationTypeWithCommissionSecurityOut:
		*s = OperationTypeWithCommissionSecurityOut
	default:
		*s = OperationTypeWithCommission(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Operations) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"operations\"" + ":")
		e.ArrStart()
		if len(s.Operations) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Operations[0]
				elem.Encode(e)
			}
			for _, elem := range s.Operations[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes Operations from json.
func (s *Operations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Operations to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operations":
			s.Operations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Operation
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Operations = append(s.Operations, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OperationsResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OperationsResponse from json.
func (s *OperationsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OperationsResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			v, err := d.Str()
			s.TrackingId = string(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes BrokerAccountType as json.
func (o OptBrokerAccountType) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BrokerAccountType from json.
func (o *OptBrokerAccountType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBrokerAccountType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBrokerAccountType`, d.Next())
	}
}

// Encode encodes Currency as json.
func (o OptCurrency) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes Currency from json.
func (o *OptCurrency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCurrency to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCurrency`, d.Next())
	}
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFloat64 to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Float64()
		if err != nil {
			return err
		}
		o.Value = float64(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFloat64`, d.Next())
	}
}

// Encode encodes InstrumentType as json.
func (o OptInstrumentType) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InstrumentType from json.
func (o *OptInstrumentType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInstrumentType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInstrumentType`, d.Next())
	}
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInt32 to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int32()
		if err != nil {
			return err
		}
		o.Value = int32(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInt32`, d.Next())
	}
}

// Encode encodes MoneyAmount as json.
func (o OptMoneyAmount) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MoneyAmount from json.
func (o *OptMoneyAmount) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMoneyAmount to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMoneyAmount`, d.Next())
	}
}

// Encode encodes OperationTypeWithCommission as json.
func (o OptOperationTypeWithCommission) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes OperationTypeWithCommission from json.
func (o *OptOperationTypeWithCommission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOperationTypeWithCommission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOperationTypeWithCommission`, d.Next())
	}
}

// Encode encodes SandboxRegisterRequest as json.
func (o OptSandboxRegisterRequest) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SandboxRegisterRequest from json.
func (o *OptSandboxRegisterRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSandboxRegisterRequest to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSandboxRegisterRequest`, d.Next())
	}
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Writer) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptString to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptString`, d.Next())
	}
}

// Encode implements json.Marshaler.
func (s Order) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"orderId\"" + ":")
		e.Str(s.OrderId)
	}
	{
		e.Comma()

		e.RawStr("\"figi\"" + ":")
		e.Str(s.Figi)
	}
	{
		e.Comma()

		e.RawStr("\"operation\"" + ":")
		s.Operation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"requestedLots\"" + ":")
		e.Int32(s.RequestedLots)
	}
	{
		e.Comma()

		e.RawStr("\"executedLots\"" + ":")
		e.Int32(s.ExecutedLots)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"price\"" + ":")
		e.Float64(s.Price)
	}
	e.ObjEnd()
}

// Decode decodes Order from json.
func (s *Order) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Order to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "orderId":
			v, err := d.Str()
			s.OrderId = string(v)
			if err != nil {
				return err
			}
		case "figi":
			v, err := d.Str()
			s.Figi = string(v)
			if err != nil {
				return err
			}
		case "operation":
			if err := s.Operation.Decode(d); err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "requestedLots":
			v, err := d.Int32()
			s.RequestedLots = int32(v)
			if err != nil {
				return err
			}
		case "executedLots":
			v, err := d.Int32()
			s.ExecutedLots = int32(v)
			if err != nil {
				return err
			}
		case "type":
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "price":
			v, err := d.Float64()
			s.Price = float64(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrderResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"price\"" + ":")
		e.Float64(s.Price)
	}
	{
		e.Comma()

		e.RawStr("\"quantity\"" + ":")
		e.Int32(s.Quantity)
	}
	e.ObjEnd()
}

// Decode decodes OrderResponse from json.
func (s *OrderResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrderResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "price":
			v, err := d.Float64()
			s.Price = float64(v)
			if err != nil {
				return err
			}
		case "quantity":
			v, err := d.Int32()
			s.Quantity = int32(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrderStatus as json.
func (s OrderStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrderStatus from json.
func (s *OrderStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrderStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrderStatus(v) {
	case OrderStatusNew:
		*s = OrderStatusNew
	case OrderStatusPartiallyFill:
		*s = OrderStatusPartiallyFill
	case OrderStatusFill:
		*s = OrderStatusFill
	case OrderStatusCancelled:
		*s = OrderStatusCancelled
	case OrderStatusReplaced:
		*s = OrderStatusReplaced
	case OrderStatusPendingCancel:
		*s = OrderStatusPendingCancel
	case OrderStatusRejected:
		*s = OrderStatusRejected
	case OrderStatusPendingReplace:
		*s = OrderStatusPendingReplace
	case OrderStatusPendingNew:
		*s = OrderStatusPendingNew
	default:
		*s = OrderStatus(v)
	}

	return nil
}

// Encode encodes OrderType as json.
func (s OrderType) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes OrderType from json.
func (s *OrderType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrderType to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrderType(v) {
	case OrderTypeLimit:
		*s = OrderTypeLimit
	case OrderTypeMarket:
		*s = OrderTypeMarket
	default:
		*s = OrderType(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s Orderbook) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"figi\"" + ":")
		e.Str(s.Figi)
	}
	{
		e.Comma()

		e.RawStr("\"depth\"" + ":")
		e.Int32(s.Depth)
	}
	{
		e.Comma()

		e.RawStr("\"bids\"" + ":")
		e.ArrStart()
		if len(s.Bids) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Bids[0]
				elem.Encode(e)
			}
			for _, elem := range s.Bids[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"asks\"" + ":")
		e.ArrStart()
		if len(s.Asks) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Asks[0]
				elem.Encode(e)
			}
			for _, elem := range s.Asks[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	{
		e.Comma()

		e.RawStr("\"tradeStatus\"" + ":")
		s.TradeStatus.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"minPriceIncrement\"" + ":")
		e.Float64(s.MinPriceIncrement)
	}
	{
		if s.FaceValue.Set {
			e.Comma()
		}
		if s.FaceValue.Set {
			e.RawStr("\"faceValue\"" + ":")
			s.FaceValue.Encode(e)
		}
	}
	{
		if s.LastPrice.Set {
			e.Comma()
		}
		if s.LastPrice.Set {
			e.RawStr("\"lastPrice\"" + ":")
			s.LastPrice.Encode(e)
		}
	}
	{
		if s.ClosePrice.Set {
			e.Comma()
		}
		if s.ClosePrice.Set {
			e.RawStr("\"closePrice\"" + ":")
			s.ClosePrice.Encode(e)
		}
	}
	{
		if s.LimitUp.Set {
			e.Comma()
		}
		if s.LimitUp.Set {
			e.RawStr("\"limitUp\"" + ":")
			s.LimitUp.Encode(e)
		}
	}
	{
		if s.LimitDown.Set {
			e.Comma()
		}
		if s.LimitDown.Set {
			e.RawStr("\"limitDown\"" + ":")
			s.LimitDown.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes Orderbook from json.
func (s *Orderbook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Orderbook to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			v, err := d.Str()
			s.Figi = string(v)
			if err != nil {
				return err
			}
		case "depth":
			v, err := d.Int32()
			s.Depth = int32(v)
			if err != nil {
				return err
			}
		case "bids":
			s.Bids = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem OrderResponse
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Bids = append(s.Bids, elem)
				return nil
			}); err != nil {
				return err
			}
		case "asks":
			s.Asks = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem OrderResponse
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Asks = append(s.Asks, elem)
				return nil
			}); err != nil {
				return err
			}
		case "tradeStatus":
			if err := s.TradeStatus.Decode(d); err != nil {
				return err
			}
		case "minPriceIncrement":
			v, err := d.Float64()
			s.MinPriceIncrement = float64(v)
			if err != nil {
				return err
			}
		case "faceValue":
			s.FaceValue.Reset()
			if err := s.FaceValue.Decode(d); err != nil {
				return err
			}
		case "lastPrice":
			s.LastPrice.Reset()
			if err := s.LastPrice.Decode(d); err != nil {
				return err
			}
		case "closePrice":
			s.ClosePrice.Reset()
			if err := s.ClosePrice.Decode(d); err != nil {
				return err
			}
		case "limitUp":
			s.LimitUp.Reset()
			if err := s.LimitUp.Decode(d); err != nil {
				return err
			}
		case "limitDown":
			s.LimitDown.Reset()
			if err := s.LimitDown.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrderbookResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrderbookResponse from json.
func (s *OrderbookResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrderbookResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			v, err := d.Str()
			s.TrackingId = string(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrdersResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		e.ArrStart()
		if len(s.Payload) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Payload[0]
				elem.Encode(e)
			}
			for _, elem := range s.Payload[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes OrdersResponse from json.
func (s *OrdersResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrdersResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			v, err := d.Str()
			s.TrackingId = string(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "payload":
			s.Payload = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Order
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Payload = append(s.Payload, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PlacedLimitOrder) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"orderId\"" + ":")
		e.Str(s.OrderId)
	}
	{
		e.Comma()

		e.RawStr("\"operation\"" + ":")
		s.Operation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		if s.RejectReason.Set {
			e.Comma()
		}
		if s.RejectReason.Set {
			e.RawStr("\"rejectReason\"" + ":")
			s.RejectReason.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.Comma()
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"requestedLots\"" + ":")
		e.Int(s.RequestedLots)
	}
	{
		e.Comma()

		e.RawStr("\"executedLots\"" + ":")
		e.Int(s.ExecutedLots)
	}
	{
		if s.Commission.Set {
			e.Comma()
		}
		if s.Commission.Set {
			e.RawStr("\"commission\"" + ":")
			s.Commission.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PlacedLimitOrder from json.
func (s *PlacedLimitOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PlacedLimitOrder to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "orderId":
			v, err := d.Str()
			s.OrderId = string(v)
			if err != nil {
				return err
			}
		case "operation":
			if err := s.Operation.Decode(d); err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "rejectReason":
			s.RejectReason.Reset()
			if err := s.RejectReason.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "requestedLots":
			v, err := d.Int()
			s.RequestedLots = int(v)
			if err != nil {
				return err
			}
		case "executedLots":
			v, err := d.Int()
			s.ExecutedLots = int(v)
			if err != nil {
				return err
			}
		case "commission":
			s.Commission.Reset()
			if err := s.Commission.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PlacedMarketOrder) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"orderId\"" + ":")
		e.Str(s.OrderId)
	}
	{
		e.Comma()

		e.RawStr("\"operation\"" + ":")
		s.Operation.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		s.Status.Encode(e)
	}
	{
		if s.RejectReason.Set {
			e.Comma()
		}
		if s.RejectReason.Set {
			e.RawStr("\"rejectReason\"" + ":")
			s.RejectReason.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.Comma()
		}
		if s.Message.Set {
			e.RawStr("\"message\"" + ":")
			s.Message.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"requestedLots\"" + ":")
		e.Int(s.RequestedLots)
	}
	{
		e.Comma()

		e.RawStr("\"executedLots\"" + ":")
		e.Int(s.ExecutedLots)
	}
	{
		if s.Commission.Set {
			e.Comma()
		}
		if s.Commission.Set {
			e.RawStr("\"commission\"" + ":")
			s.Commission.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes PlacedMarketOrder from json.
func (s *PlacedMarketOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PlacedMarketOrder to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "orderId":
			v, err := d.Str()
			s.OrderId = string(v)
			if err != nil {
				return err
			}
		case "operation":
			if err := s.Operation.Decode(d); err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "rejectReason":
			s.RejectReason.Reset()
			if err := s.RejectReason.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "requestedLots":
			v, err := d.Int()
			s.RequestedLots = int(v)
			if err != nil {
				return err
			}
		case "executedLots":
			v, err := d.Int()
			s.ExecutedLots = int(v)
			if err != nil {
				return err
			}
		case "commission":
			s.Commission.Reset()
			if err := s.Commission.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Portfolio) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"positions\"" + ":")
		e.ArrStart()
		if len(s.Positions) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Positions[0]
				elem.Encode(e)
			}
			for _, elem := range s.Positions[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes Portfolio from json.
func (s *Portfolio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Portfolio to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "positions":
			s.Positions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PortfolioPosition
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Positions = append(s.Positions, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PortfolioCurrenciesResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PortfolioCurrenciesResponse from json.
func (s *PortfolioCurrenciesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PortfolioCurrenciesResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			v, err := d.Str()
			s.TrackingId = string(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PortfolioPosition) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"figi\"" + ":")
		e.Str(s.Figi)
	}
	{
		if s.Ticker.Set {
			e.Comma()
		}
		if s.Ticker.Set {
			e.RawStr("\"ticker\"" + ":")
			s.Ticker.Encode(e)
		}
	}
	{
		if s.Isin.Set {
			e.Comma()
		}
		if s.Isin.Set {
			e.RawStr("\"isin\"" + ":")
			s.Isin.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"instrumentType\"" + ":")
		s.InstrumentType.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"balance\"" + ":")
		e.Float64(s.Balance)
	}
	{
		if s.Blocked.Set {
			e.Comma()
		}
		if s.Blocked.Set {
			e.RawStr("\"blocked\"" + ":")
			s.Blocked.Encode(e)
		}
	}
	{
		if s.ExpectedYield.Set {
			e.Comma()
		}
		if s.ExpectedYield.Set {
			e.RawStr("\"expectedYield\"" + ":")
			s.ExpectedYield.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"lots\"" + ":")
		e.Int32(s.Lots)
	}
	{
		if s.AveragePositionPrice.Set {
			e.Comma()
		}
		if s.AveragePositionPrice.Set {
			e.RawStr("\"averagePositionPrice\"" + ":")
			s.AveragePositionPrice.Encode(e)
		}
	}
	{
		if s.AveragePositionPriceNoNkd.Set {
			e.Comma()
		}
		if s.AveragePositionPriceNoNkd.Set {
			e.RawStr("\"averagePositionPriceNoNkd\"" + ":")
			s.AveragePositionPriceNoNkd.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	e.ObjEnd()
}

// Decode decodes PortfolioPosition from json.
func (s *PortfolioPosition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PortfolioPosition to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			v, err := d.Str()
			s.Figi = string(v)
			if err != nil {
				return err
			}
		case "ticker":
			s.Ticker.Reset()
			if err := s.Ticker.Decode(d); err != nil {
				return err
			}
		case "isin":
			s.Isin.Reset()
			if err := s.Isin.Decode(d); err != nil {
				return err
			}
		case "instrumentType":
			if err := s.InstrumentType.Decode(d); err != nil {
				return err
			}
		case "balance":
			v, err := d.Float64()
			s.Balance = float64(v)
			if err != nil {
				return err
			}
		case "blocked":
			s.Blocked.Reset()
			if err := s.Blocked.Decode(d); err != nil {
				return err
			}
		case "expectedYield":
			s.ExpectedYield.Reset()
			if err := s.ExpectedYield.Decode(d); err != nil {
				return err
			}
		case "lots":
			v, err := d.Int32()
			s.Lots = int32(v)
			if err != nil {
				return err
			}
		case "averagePositionPrice":
			s.AveragePositionPrice.Reset()
			if err := s.AveragePositionPrice.Decode(d); err != nil {
				return err
			}
		case "averagePositionPriceNoNkd":
			s.AveragePositionPriceNoNkd.Reset()
			if err := s.AveragePositionPriceNoNkd.Decode(d); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PortfolioResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PortfolioResponse from json.
func (s *PortfolioResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PortfolioResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			v, err := d.Str()
			s.TrackingId = string(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SandboxAccount) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"brokerAccountType\"" + ":")
		s.BrokerAccountType.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"brokerAccountId\"" + ":")
		e.Str(s.BrokerAccountId)
	}
	e.ObjEnd()
}

// Decode decodes SandboxAccount from json.
func (s *SandboxAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SandboxAccount to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "brokerAccountType":
			if err := s.BrokerAccountType.Decode(d); err != nil {
				return err
			}
		case "brokerAccountId":
			v, err := d.Str()
			s.BrokerAccountId = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SandboxCurrency as json.
func (s SandboxCurrency) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes SandboxCurrency from json.
func (s *SandboxCurrency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SandboxCurrency to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SandboxCurrency(v) {
	case SandboxCurrencyRUB:
		*s = SandboxCurrencyRUB
	case SandboxCurrencyUSD:
		*s = SandboxCurrencyUSD
	case SandboxCurrencyEUR:
		*s = SandboxCurrencyEUR
	case SandboxCurrencyGBP:
		*s = SandboxCurrencyGBP
	case SandboxCurrencyHKD:
		*s = SandboxCurrencyHKD
	case SandboxCurrencyCHF:
		*s = SandboxCurrencyCHF
	case SandboxCurrencyJPY:
		*s = SandboxCurrencyJPY
	case SandboxCurrencyCNY:
		*s = SandboxCurrencyCNY
	case SandboxCurrencyTRY:
		*s = SandboxCurrencyTRY
	default:
		*s = SandboxCurrency(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s SandboxRegisterRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.BrokerAccountType.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.BrokerAccountType.Set {
			e.RawStr("\"brokerAccountType\"" + ":")
			s.BrokerAccountType.Encode(e)
		}
	}
	e.ObjEnd()
}

// Decode decodes SandboxRegisterRequest from json.
func (s *SandboxRegisterRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SandboxRegisterRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "brokerAccountType":
			s.BrokerAccountType.Reset()
			if err := s.BrokerAccountType.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SandboxRegisterResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SandboxRegisterResponse from json.
func (s *SandboxRegisterResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SandboxRegisterResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			v, err := d.Str()
			s.TrackingId = string(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SandboxSetCurrencyBalanceRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"currency\"" + ":")
		s.Currency.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"balance\"" + ":")
		e.Float64(s.Balance)
	}
	e.ObjEnd()
}

// Decode decodes SandboxSetCurrencyBalanceRequest from json.
func (s *SandboxSetCurrencyBalanceRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SandboxSetCurrencyBalanceRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			if err := s.Currency.Decode(d); err != nil {
				return err
			}
		case "balance":
			v, err := d.Float64()
			s.Balance = float64(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SandboxSetPositionBalanceRequest) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if s.Figi.Set {
			if !first {
				e.Comma()
			}
			first = false
		}
		if s.Figi.Set {
			e.RawStr("\"figi\"" + ":")
			s.Figi.Encode(e)
		}
	}
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"balance\"" + ":")
		e.Float64(s.Balance)
	}
	e.ObjEnd()
}

// Decode decodes SandboxSetPositionBalanceRequest from json.
func (s *SandboxSetPositionBalanceRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SandboxSetPositionBalanceRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			s.Figi.Reset()
			if err := s.Figi.Decode(d); err != nil {
				return err
			}
		case "balance":
			v, err := d.Float64()
			s.Balance = float64(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SearchMarketInstrument) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"figi\"" + ":")
		e.Str(s.Figi)
	}
	{
		e.Comma()

		e.RawStr("\"ticker\"" + ":")
		e.Str(s.Ticker)
	}
	{
		if s.Isin.Set {
			e.Comma()
		}
		if s.Isin.Set {
			e.RawStr("\"isin\"" + ":")
			s.Isin.Encode(e)
		}
	}
	{
		if s.MinPriceIncrement.Set {
			e.Comma()
		}
		if s.MinPriceIncrement.Set {
			e.RawStr("\"minPriceIncrement\"" + ":")
			s.MinPriceIncrement.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"lot\"" + ":")
		e.Int32(s.Lot)
	}
	{
		if s.Currency.Set {
			e.Comma()
		}
		if s.Currency.Set {
			e.RawStr("\"currency\"" + ":")
			s.Currency.Encode(e)
		}
	}
	{
		e.Comma()

		e.RawStr("\"name\"" + ":")
		e.Str(s.Name)
	}
	{
		e.Comma()

		e.RawStr("\"type\"" + ":")
		s.Type.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SearchMarketInstrument from json.
func (s *SearchMarketInstrument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchMarketInstrument to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			v, err := d.Str()
			s.Figi = string(v)
			if err != nil {
				return err
			}
		case "ticker":
			v, err := d.Str()
			s.Ticker = string(v)
			if err != nil {
				return err
			}
		case "isin":
			s.Isin.Reset()
			if err := s.Isin.Decode(d); err != nil {
				return err
			}
		case "minPriceIncrement":
			s.MinPriceIncrement.Reset()
			if err := s.MinPriceIncrement.Decode(d); err != nil {
				return err
			}
		case "lot":
			v, err := d.Int32()
			s.Lot = int32(v)
			if err != nil {
				return err
			}
		case "currency":
			s.Currency.Reset()
			if err := s.Currency.Decode(d); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "type":
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SearchMarketInstrumentResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SearchMarketInstrumentResponse from json.
func (s *SearchMarketInstrumentResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchMarketInstrumentResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			v, err := d.Str()
			s.TrackingId = string(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TradeStatus as json.
func (s TradeStatus) Encode(e *jx.Writer) {
	e.Str(string(s))
}

// Decode decodes TradeStatus from json.
func (s *TradeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TradeStatus to nil`)
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TradeStatus(v) {
	case TradeStatusNormalTrading:
		*s = TradeStatusNormalTrading
	case TradeStatusNotAvailableForTrading:
		*s = TradeStatusNotAvailableForTrading
	default:
		*s = TradeStatus(v)
	}

	return nil
}

// Encode implements json.Marshaler.
func (s UserAccount) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"brokerAccountType\"" + ":")
		s.BrokerAccountType.Encode(e)
	}
	{
		e.Comma()

		e.RawStr("\"brokerAccountId\"" + ":")
		e.Str(s.BrokerAccountId)
	}
	e.ObjEnd()
}

// Decode decodes UserAccount from json.
func (s *UserAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UserAccount to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "brokerAccountType":
			if err := s.BrokerAccountType.Decode(d); err != nil {
				return err
			}
		case "brokerAccountId":
			v, err := d.Str()
			s.BrokerAccountId = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UserAccounts) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"accounts\"" + ":")
		e.ArrStart()
		if len(s.Accounts) >= 1 {
			// Encode first element without comma.
			{
				elem := s.Accounts[0]
				elem.Encode(e)
			}
			for _, elem := range s.Accounts[1:] {
				e.Comma()
				elem.Encode(e)
			}
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes UserAccounts from json.
func (s *UserAccounts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UserAccounts to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accounts":
			s.Accounts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem UserAccount
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Accounts = append(s.Accounts, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UserAccountsResponse) Encode(e *jx.Writer) {
	e.ObjStart()
	var (
		first = true
		_     = first
	)
	{
		if !first {
			e.Comma()
		}
		first = false

		e.RawStr("\"trackingId\"" + ":")
		e.Str(s.TrackingId)
	}
	{
		e.Comma()

		e.RawStr("\"status\"" + ":")
		e.Str(s.Status)
	}
	{
		e.Comma()

		e.RawStr("\"payload\"" + ":")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes UserAccountsResponse from json.
func (s *UserAccountsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UserAccountsResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trackingId":
			v, err := d.Str()
			s.TrackingId = string(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}
