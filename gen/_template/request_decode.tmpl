{{ define "request_decoders" }}
{{- /*gotype: github.com/ogen-go/ogen/gen.TemplateConfig*/ -}}
{{ $pkg := $.Package }}
{{ template "header" $ }}

{{- range $op := $.Operations }}
{{- if $op.Request }}
func (s *Server) decode{{ $op.Name }}Request(r *http.Request, span trace.Span) (
	req {{ $op.Request.Type.Go }},
	close func() error,
	rerr error,
) {
	var closers []io.Closer
	close = func() error {
		var merr error
		for _, c := range closers {
			merr = multierr.Append(merr, c.Close())
		}
		return merr
	}
	defer func() {
		if rerr != nil {
			rerr = multierr.Append(rerr, close())
		}
	}()

	{{- if not $op.Request.Spec.Required }}
	if _, ok := r.Header["Content-Type"]; !ok && r.ContentLength == 0 {
		return req, close, nil
	}
	{{- end }}

	ct, _, err := mime.ParseMediaType(r.Header.Get("Content-Type"))
	if err != nil {
		return req, close, errors.Wrap(err, "parse media type")
	}
	switch ct {
{{- range $contentType, $t := $op.Request.Contents }}
	case {{ quote $contentType }}:
	{{- if $t.IsStream }}
		return {{ $op.Request.Type.Go }}{Data: r.Body}, close, nil
	{{- else if $contentType.JSON }}
		if r.ContentLength == 0 {
		{{- if not $op.Request.Spec.Required }}
			return req, close, nil
		{{- else }}
			return req, close, validate.ErrBodyRequired
		{{- end }}
		}

		var request {{ $t.Go }}
		buf, err := io.ReadAll(r.Body)
		if err != nil {
			return req, close, err
		}

		if len(buf) == 0 {
		{{- if not $op.Request.Spec.Required }}
			return req, close, nil
		{{- else }}
			return req, close, validate.ErrBodyRequired
		{{- end }}
		}

		d := jx.DecodeBytes(buf)
		if err := func() error {
			{{- template "json/dec" elem $t "request" }}
			return nil
		}(); err != nil {
			return req, close, errors.Wrap(err, {{ printf "decode %q" $contentType | quote }})
		}

		{{- if $t.NeedValidation }}
		if err := func() error {
			{{- template "validate" elem $t "request" }}
		}(); err != nil {
			return req, close, errors.Wrap(err, "validate")
		}
		{{- end }}

		return {{ if ($op.Request.Type.IsInterface) }}&{{ end }}request, close, nil
    {{- else if or $contentType.FormURLEncoded $contentType.MultipartForm  }}
		var request {{ $t.Go }}

		if r.ContentLength == 0 {
		{{- if not $op.Request.Spec.Required }}
			return req, close, nil
		{{- else }}
			return req, close, validate.ErrBodyRequired
		{{- end }}
		}

		{{- if $contentType.FormURLEncoded }}
		if err := r.ParseForm(); err != nil {
			return req, close, errors.Wrap(err, "parse form")
		}
		form := r.PostForm
		{{- else }}
		if err := r.ParseMultipartForm(s.cfg.MaxMultipartMemory); err != nil {
			return req, close, errors.Wrap(err, "parse multipart form")
		}
		form := url.Values(r.MultipartForm.Value)
        {{- end }}

		q := uri.NewQueryDecoder(form)
		{{- range $p := $op.Request.FormParameters $contentType }}
		{
        	{{- $el := elem $p.Type (printf "request.%s" $p.Name) }}
			cfg := uri.QueryParameterDecodingConfig{
				Name:    {{ quote $p.Spec.Name }},
				Style:   uri.QueryStyle{{ capitalize $p.Spec.Style.String }},
				Explode: {{ if $p.Spec.Explode }}true{{ else }}false{{ end }},
				{{- if isObjectParam $p }}
				Fields: {{ paramObjectFields $p.Type }},
				{{- end }}
			}

			if err := q.HasParam(cfg); err == nil {
				if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
					{{- template "uri/decode" $el }}
				}); err != nil {
					return req, close, errors.Wrap(err, {{ printf "decode %q" $p.Spec.Name | quote }})
				}

				{{- if $p.Type.NeedValidation }}
				if err := func() error {
					{{- template "validate" $el }}
				}(); err != nil {
					return req, close, errors.Wrap(err, "validate")
				}
				{{- end }}
			} {{- if $p.Spec.Required }} else {
				return req, close, errors.Wrap(err, "query")
			} {{- end }}
		}
		{{- end }}
		{{- if $contentType.MultipartForm }}
        {{- range $param := $op.Request.FileParameters $contentType }}
		if err := func() error {
			{{- template "decode_multipart_file_param" $param }}
		}(); err != nil {
			return req, close, errors.Wrap(err, {{ printf "decode %q" $param.Spec.Name | quote }})
		}
		{{- end }}
		{{- end }}

		return {{ if ($op.Request.Type.IsInterface) }}&{{ end }}request, close, nil
	{{- else }}
		{{- errorf "%s decoder not implemented" $contentType }}
	{{- end }}
{{- end }}
	default:
		return req, close, validate.InvalidContentType(ct)
	}
}
{{- end }}
{{ end }}
{{ end }}

{{- define "decode_multipart_file_param" }}
{{- /*gotype: github.com/ogen-go/ogen/gen/ir.Parameter*/ -}}
{{- $name := quote $.Spec.Name }}
{{- $t := $.Type }}
	files, ok := r.MultipartForm.File[{{ $name }}]
	{{- if or $t.IsPrimitive $t.IsGeneric }}
	if !ok || len(files) < 1  {
		{{- if $t.IsPrimitive }}
		return validate.ErrFieldRequired
		{{- else }}
		return nil
		{{- end }}
	}
	fh := files[0]

	f, err := fh.Open()
	if err != nil {
		return errors.Wrap(err, "open")
	}
	closers = append(closers, f)

    {{- if $t.IsPrimitive }}
	{{ printf "request.%s" $.Name }} = ht.MultipartFile{
		Name:   fh.Filename,
		File:   f,
		Header: fh.Header,
	}
	{{- else }}
	{{ printf "request.%s" $.Name }}.SetTo(ht.MultipartFile{
		Name:   fh.Filename,
		File:   f,
		Header: fh.Header,
	})
	{{- end }}
	{{- else if $t.IsArray }}
	_ = ok
	request.Files = make({{ $t.Go }}, 0, len(files))
	for _, fh := range files {
		f, err := fh.Open()
		if err != nil {
			return errors.Wrap(err, "open")
		}
		closers = append(closers, f)

		{{ printf "request.%s" $.Name }} = append({{ printf "request.%s" $.Name }}, ht.MultipartFile{
			Name:   fh.Filename,
			File:   f,
			Header: fh.Header,
		})
	}
	{{- else }}
		{{ errorf "unexpected kind %s" $t.Kind }}
	{{- end }}

	{{- if $t.NeedValidation }}
	if err := func() error {
		{{- template "validate" elem $t (printf "request.%s" $.Name) }}
	}(); err != nil {
		return errors.Wrap(err, "validate")
	}
	{{- end }}
	return nil
{{- end }}
