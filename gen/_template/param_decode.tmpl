{{- /*gotype: github.com/ogen-go/ogen/gen.TemplateConfig*/ -}}

{{ define "param_dec" }}
{{ $pkg := $.Package }}
{{ template "header" $ }}

{{- range $op := $.Operations }}{{/* Range over methods */}}
{{ if $op.Params }}{{/* Check parameters existence */}}

func decode{{ $op.Name }}Params(args [{{ $op.PathParamsCount }}]string, r *http.Request) (params {{ $op.Name }}Params, _ error) {
	{{- if $op.HasQueryParams }}
	q := uri.NewQueryDecoder(r.URL.Query())
	{{- end }}
	{{- if $op.HasHeaderParams }}
	h := uri.NewHeaderDecoder(r.Header)
	{{- end }}

	{{- range $p := $op.Params }}{{/* Range params */}}
    {{- $loc             := printf "%s: %s" $p.Spec.In $p.Spec.Name }}
    {{- $errParse        := printf "%s: parse"         $loc }}
    {{- $errInvalid      := printf "%s: invalid"       $loc }}
    {{- $errNotSpecified := printf "%s: not specified" $loc }}
    {{- $el              := elem $p.Type (printf "params.%s" $p.Name) }}
	{{- $default 		 := $p.Default }}
	{{- if $default.Set }}
	// Set default value for {{ $loc }}.
	{
    {{- template "defaults/set" default_elem $p.Type (printf "params.%s" $p.Name) $default }}
	}
	{{- end }}
	// Decode {{ $loc }}.
	{{- if $p.Spec.In.Query }}{{/* Switch location */}}
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    {{ quote $p.Spec.Name }},
			Style:   uri.QueryStyle{{ capitalize $p.Spec.Style.String }},
			Explode: {{ if $p.Spec.Explode }}true{{ else }}false{{ end }},
			{{- if isObjectParam $p }}
			Fields: {{ paramObjectFields $p.Type }},
			{{- end }}
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				{{- template "uri/decode" $el }}
			}); err != nil {
				return params, errors.Wrap(err, {{ quote $errParse }})
			}

			{{- if $p.Type.NeedValidation }}
			if err := func() error {
				{{- template "validate" $el }}
			}(); err != nil {
				return params, errors.Wrap(err, {{ quote $errInvalid }})
			}
			{{- end }}
		} {{- if $p.Spec.Required }} else {
			return params, errors.Wrap(err, "query")
		} {{- end }}
	}
	{{- else if $p.Spec.In.Path }}
	{{- /* If we cannot find such path parameter, defined path parameter is not used */ -}}
	{{- $idx := $op.PathParamIndex $p.Spec.Name }}
	{{- if ge $idx 0 }}
	{
		param := args[{{ $idx }}]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param: {{ quote $p.Spec.Name}},
				Value: param,
				Style: uri.PathStyle{{ capitalize $p.Spec.Style.String }},
				Explode: {{ if $p.Spec.Explode }}true{{ else }}false{{ end }},
			})

			if err := func() error {
				{{- template "uri/decode" $el }}
			}(); err != nil {
				return params, err
			}
		} {{ if $p.Spec.Required }} else {
			return params, errors.New({{ quote $errNotSpecified }})
		} {{ end }}
	}
	{{- else }}
	// Not used.
	{{- end }}
	{{- else if $p.Spec.In.Header }}
	{
		cfg := uri.HeaderParameterDecodingConfig{
			Name:   {{ quote $p.Spec.Name }},
			Explode:{{ if $p.Spec.Explode }}true{{ else }}false{{ end }},
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				{{- template "uri/decode" $el }}
			}); err != nil {
				return params, errors.Wrap(err, {{ quote $errParse }})
			}
		} {{ if $p.Spec.Required }} else {
			return params, errors.New({{ quote $errNotSpecified }})
		} {{ end }}
	}
	{{- else if $p.Spec.In.Cookie }}
	{
		c, err := r.Cookie({{ quote $p.Spec.Name }})
		if err != nil {
			return params, errors.Wrap(err, {{ printf "%s: get %s" $loc $p.Spec.Name | quote }})
		}

		param := c.Value
		if len(param) > 0 {
			v, err := conv.{{ $p.Type.FromString }}(param)
			if err != nil {
				return params, errors.Wrap(err, {{ quote $errParse }})
			}

			params.{{ $p.Name }} = v
		} {{ if $p.Spec.Required }} else {
			return params, errors.New({{ quote $errNotSpecified }})
		} {{ end }}
	}
	{{- else }}
	{{ errorf "unsupported location %s" $p.Spec.In }}
	{{- end }}{{/* Switch location */}}
	{{- end }}{{/* Range params */}}
	return params, nil
}

{{- end }}{{/* Check parameters existence */}}
{{- end }}{{/* Range over methods */}}
{{ end }}
